"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/chat/page",{

/***/ "(app-pages-browser)/./components/chat/ChatBubble.tsx":
/*!****************************************!*\
  !*** ./components/chat/ChatBubble.tsx ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _barrel_optimize_names_Box_Typography_mui_material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=Box,Typography!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/esm/Box/Box.js\");\n/* harmony import */ var _barrel_optimize_names_Box_Typography_mui_material__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=Box,Typography!=!@mui/material */ \"(app-pages-browser)/./node_modules/@mui/material/esm/Typography/Typography.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react_markdown__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-markdown */ \"(app-pages-browser)/./node_modules/react-markdown/lib/index.js\");\n/* harmony import */ var remark_math__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! remark-math */ \"(app-pages-browser)/./node_modules/remark-math/lib/index.js\");\n/* harmony import */ var remark_gfm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! remark-gfm */ \"(app-pages-browser)/./node_modules/remark-gfm/lib/index.js\");\n/* harmony import */ var rehype_katex__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rehype-katex */ \"(app-pages-browser)/./node_modules/rehype-katex/lib/index.js\");\n/* harmony import */ var katex_dist_katex_min_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! katex/dist/katex.min.css */ \"(app-pages-browser)/./node_modules/katex/dist/katex.min.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\nconst ChatBubble = (param)=>{\n    let { message, isLoading = false } = param;\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const isUser = message.role === 'user';\n    const isAI = message.role === 'ai';\n    const handleClick = ()=>{\n        if (isAI && message.apiResponse) {\n            router.push(\"/details/\".concat(message.id));\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Box_Typography_mui_material__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n        display: \"flex\",\n        justifyContent: isUser ? 'flex-end' : 'flex-start',\n        mb: 3,\n        sx: {\n            width: '100%'\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Box_Typography_mui_material__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n            onClick: handleClick,\n            sx: {\n                maxWidth: {\n                    xs: '85%',\n                    sm: '80%'\n                },\n                px: {\n                    xs: 2.5,\n                    md: 3\n                },\n                py: {\n                    xs: 1.5,\n                    md: 2\n                },\n                borderRadius: '1.5rem',\n                bgcolor: isUser ? '#6D5CFF' : '#1E0C34',\n                color: '#F2ECF8',\n                fontSize: {\n                    xs: '0.95rem',\n                    md: '1rem'\n                },\n                lineHeight: 1.6,\n                boxShadow: '0 2px 5px rgba(0,0,0,0.2)',\n                border: isAI ? '1px solid' : 'none',\n                borderColor: isAI ? '#2B1348' : 'transparent',\n                cursor: isAI && !isLoading && message.apiResponse ? 'pointer' : 'default',\n                transition: 'all 0.2s ease',\n                '&:hover': isAI && !isLoading && message.apiResponse ? {\n                    bgcolor: '#2B1348',\n                    transform: 'translateY(-1px)'\n                } : {}\n            },\n            children: [\n                isAI ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Box_Typography_mui_material__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                    sx: {\n                        color: '#F2ECF8',\n                        '& p': {\n                            margin: '0 0 0.75rem 0',\n                            '&:last-child': {\n                                marginBottom: 0\n                            }\n                        },\n                        '& h1, & h2, & h3, & h4, & h5, & h6': {\n                            margin: '0.5rem 0 0.75rem 0',\n                            color: '#F2ECF8',\n                            fontWeight: 600,\n                            '&:first-of-type': {\n                                marginTop: 0\n                            }\n                        },\n                        '& h1': {\n                            fontSize: '1.5rem'\n                        },\n                        '& h2': {\n                            fontSize: '1.3rem'\n                        },\n                        '& h3': {\n                            fontSize: '1.1rem'\n                        },\n                        '& ul, & ol': {\n                            margin: '0.5rem 0',\n                            paddingLeft: '1.5rem'\n                        },\n                        '& li': {\n                            margin: '0.25rem 0'\n                        },\n                        '& code': {\n                            backgroundColor: 'rgba(0, 0, 0, 0.3)',\n                            padding: '0.2rem 0.4rem',\n                            borderRadius: '0.25rem',\n                            fontSize: '0.9em',\n                            fontFamily: 'monospace'\n                        },\n                        '& pre': {\n                            backgroundColor: 'rgba(0, 0, 0, 0.3)',\n                            padding: '1rem',\n                            borderRadius: '0.5rem',\n                            overflow: 'auto',\n                            margin: '0.75rem 0',\n                            '& code': {\n                                backgroundColor: 'transparent',\n                                padding: 0\n                            }\n                        },\n                        '& blockquote': {\n                            borderLeft: '3px solid #6D5CFF',\n                            paddingLeft: '1rem',\n                            margin: '0.75rem 0',\n                            fontStyle: 'italic',\n                            opacity: 0.9\n                        },\n                        '& a': {\n                            color: '#6D5CFF',\n                            textDecoration: 'underline'\n                        },\n                        '& table': {\n                            borderCollapse: 'collapse',\n                            width: '100%',\n                            margin: '0.75rem 0'\n                        },\n                        '& th, & td': {\n                            border: '1px solid rgba(255, 255, 255, 0.2)',\n                            padding: '0.5rem'\n                        },\n                        '& th': {\n                            backgroundColor: 'rgba(0, 0, 0, 0.2)'\n                        }\n                    },\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_markdown__WEBPACK_IMPORTED_MODULE_5__.Markdown, {\n                        remarkPlugins: [\n                            remark_gfm__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n                            remark_math__WEBPACK_IMPORTED_MODULE_7__[\"default\"]\n                        ],\n                        rehypePlugins: [\n                            rehype_katex__WEBPACK_IMPORTED_MODULE_8__[\"default\"]\n                        ],\n                        children: message.content || ''\n                    }, void 0, false, {\n                        fileName: \"/Users/apzzo/client/demo-app/components/chat/ChatBubble.tsx\",\n                        lineNumber: 129,\n                        columnNumber: 25\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"/Users/apzzo/client/demo-app/components/chat/ChatBubble.tsx\",\n                    lineNumber: 59,\n                    columnNumber: 21\n                }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Box_Typography_mui_material__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                    variant: \"body1\",\n                    sx: {\n                        whiteSpace: 'pre-wrap',\n                        wordBreak: 'break-word',\n                        color: '#F2ECF8'\n                    },\n                    children: message.content\n                }, void 0, false, {\n                    fileName: \"/Users/apzzo/client/demo-app/components/chat/ChatBubble.tsx\",\n                    lineNumber: 137,\n                    columnNumber: 21\n                }, undefined),\n                isAI && !isLoading && message.apiResponse && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Box_Typography_mui_material__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                    variant: \"caption\",\n                    display: \"block\",\n                    sx: {\n                        mt: 1.5,\n                        color: '#A090B0',\n                        fontSize: '0.75rem',\n                        fontStyle: 'italic'\n                    },\n                    children: \"\\uD83D\\uDCA1 Click to view SQL details\"\n                }, void 0, false, {\n                    fileName: \"/Users/apzzo/client/demo-app/components/chat/ChatBubble.tsx\",\n                    lineNumber: 149,\n                    columnNumber: 21\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/apzzo/client/demo-app/components/chat/ChatBubble.tsx\",\n            lineNumber: 36,\n            columnNumber: 13\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/apzzo/client/demo-app/components/chat/ChatBubble.tsx\",\n        lineNumber: 30,\n        columnNumber: 9\n    }, undefined);\n};\n_s(ChatBubble, \"fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = ChatBubble;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChatBubble);\nvar _c;\n$RefreshReg$(_c, \"ChatBubble\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvY2hhdC9DaGF0QnViYmxlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUUwQjtBQUNzQjtBQUNKO0FBQ0Q7QUFDTjtBQUNGO0FBQ0k7QUFDTDtBQVFsQyxNQUFNUSxhQUF3QztRQUFDLEVBQUVDLE9BQU8sRUFBRUMsWUFBWSxLQUFLLEVBQUU7O0lBQ3pFLE1BQU1DLFNBQVNSLDBEQUFTQTtJQUN4QixNQUFNUyxTQUFTSCxRQUFRSSxJQUFJLEtBQUs7SUFDaEMsTUFBTUMsT0FBT0wsUUFBUUksSUFBSSxLQUFLO0lBRTlCLE1BQU1FLGNBQWM7UUFDaEIsSUFBSUQsUUFBUUwsUUFBUU8sV0FBVyxFQUFFO1lBQzdCTCxPQUFPTSxJQUFJLENBQUMsWUFBdUIsT0FBWFIsUUFBUVMsRUFBRTtRQUN0QztJQUNKO0lBRUEscUJBQ0ksOERBQUNqQiwwRkFBR0E7UUFDQWtCLFNBQVE7UUFDUkMsZ0JBQWdCUixTQUFTLGFBQWE7UUFDdENTLElBQUk7UUFDSkMsSUFBSTtZQUFFQyxPQUFPO1FBQU87a0JBRXBCLDRFQUFDdEIsMEZBQUdBO1lBQ0F1QixTQUFTVDtZQUNUTyxJQUFJO2dCQUNBRyxVQUFVO29CQUFFQyxJQUFJO29CQUFPQyxJQUFJO2dCQUFNO2dCQUNqQ0MsSUFBSTtvQkFBRUYsSUFBSTtvQkFBS0csSUFBSTtnQkFBRTtnQkFDckJDLElBQUk7b0JBQUVKLElBQUk7b0JBQUtHLElBQUk7Z0JBQUU7Z0JBQ3JCRSxjQUFjO2dCQUNkQyxTQUFTcEIsU0FBUyxZQUFZO2dCQUM5QnFCLE9BQU87Z0JBQ1BDLFVBQVU7b0JBQUVSLElBQUk7b0JBQVdHLElBQUk7Z0JBQU87Z0JBQ3RDTSxZQUFZO2dCQUNaQyxXQUFXO2dCQUNYQyxRQUFRdkIsT0FBTyxjQUFjO2dCQUM3QndCLGFBQWF4QixPQUFPLFlBQVk7Z0JBQ2hDeUIsUUFBUXpCLFFBQVEsQ0FBQ0osYUFBYUQsUUFBUU8sV0FBVyxHQUFHLFlBQVk7Z0JBQ2hFd0IsWUFBWTtnQkFDWixXQUFXMUIsUUFBUSxDQUFDSixhQUFhRCxRQUFRTyxXQUFXLEdBQUc7b0JBQ25EZ0IsU0FBUztvQkFDVFMsV0FBVztnQkFDZixJQUFJLENBQUM7WUFDVDs7Z0JBRUMzQixxQkFDRyw4REFBQ2IsMEZBQUdBO29CQUNBcUIsSUFBSTt3QkFDQVcsT0FBTzt3QkFDUCxPQUFPOzRCQUNIUyxRQUFROzRCQUNSLGdCQUFnQjtnQ0FDWkMsY0FBYzs0QkFDbEI7d0JBQ0o7d0JBQ0Esc0NBQXNDOzRCQUNsQ0QsUUFBUTs0QkFDUlQsT0FBTzs0QkFDUFcsWUFBWTs0QkFDWixtQkFBbUI7Z0NBQ2ZDLFdBQVc7NEJBQ2Y7d0JBQ0o7d0JBQ0EsUUFBUTs0QkFBRVgsVUFBVTt3QkFBUzt3QkFDN0IsUUFBUTs0QkFBRUEsVUFBVTt3QkFBUzt3QkFDN0IsUUFBUTs0QkFBRUEsVUFBVTt3QkFBUzt3QkFDN0IsY0FBYzs0QkFDVlEsUUFBUTs0QkFDUkksYUFBYTt3QkFDakI7d0JBQ0EsUUFBUTs0QkFDSkosUUFBUTt3QkFDWjt3QkFDQSxVQUFVOzRCQUNOSyxpQkFBaUI7NEJBQ2pCQyxTQUFTOzRCQUNUakIsY0FBYzs0QkFDZEcsVUFBVTs0QkFDVmUsWUFBWTt3QkFDaEI7d0JBQ0EsU0FBUzs0QkFDTEYsaUJBQWlCOzRCQUNqQkMsU0FBUzs0QkFDVGpCLGNBQWM7NEJBQ2RtQixVQUFVOzRCQUNWUixRQUFROzRCQUNSLFVBQVU7Z0NBQ05LLGlCQUFpQjtnQ0FDakJDLFNBQVM7NEJBQ2I7d0JBQ0o7d0JBQ0EsZ0JBQWdCOzRCQUNaRyxZQUFZOzRCQUNaTCxhQUFhOzRCQUNiSixRQUFROzRCQUNSVSxXQUFXOzRCQUNYQyxTQUFTO3dCQUNiO3dCQUNBLE9BQU87NEJBQ0hwQixPQUFPOzRCQUNQcUIsZ0JBQWdCO3dCQUNwQjt3QkFDQSxXQUFXOzRCQUNQQyxnQkFBZ0I7NEJBQ2hCaEMsT0FBTzs0QkFDUG1CLFFBQVE7d0JBQ1o7d0JBQ0EsY0FBYzs0QkFDVkwsUUFBUTs0QkFDUlcsU0FBUzt3QkFDYjt3QkFDQSxRQUFROzRCQUNKRCxpQkFBaUI7d0JBQ3JCO29CQUNKOzhCQUVBLDRFQUFDM0Msb0RBQWFBO3dCQUNWb0QsZUFBZTs0QkFBQ2xELGtEQUFTQTs0QkFBRUQsbURBQVVBO3lCQUFDO3dCQUN0Q29ELGVBQWU7NEJBQUNsRCxvREFBV0E7eUJBQUM7a0NBRTNCRSxRQUFRaUQsT0FBTyxJQUFJOzs7Ozs7Ozs7OzhDQUk1Qiw4REFBQ3hELDBGQUFVQTtvQkFDUHlELFNBQVE7b0JBQ1JyQyxJQUFJO3dCQUNBc0MsWUFBWTt3QkFDWkMsV0FBVzt3QkFDWDVCLE9BQU87b0JBQ1g7OEJBRUN4QixRQUFRaUQsT0FBTzs7Ozs7O2dCQUd2QjVDLFFBQVEsQ0FBQ0osYUFBYUQsUUFBUU8sV0FBVyxrQkFDdEMsOERBQUNkLDBGQUFVQTtvQkFDUHlELFNBQVE7b0JBQ1J4QyxTQUFRO29CQUNSRyxJQUFJO3dCQUNBd0MsSUFBSTt3QkFDSjdCLE9BQU87d0JBQ1BDLFVBQVU7d0JBQ1ZrQixXQUFXO29CQUNmOzhCQUNIOzs7Ozs7Ozs7Ozs7Ozs7OztBQU9yQjtHQW5KTTVDOztRQUNhTCxzREFBU0E7OztLQUR0Qks7QUFxSk4saUVBQWVBLFVBQVVBLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvY29tcG9uZW50cy9jaGF0L0NoYXRCdWJibGUudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEJveCwgVHlwb2dyYXBoeSB9IGZyb20gJ0BtdWkvbWF0ZXJpYWwnO1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJztcbmltcG9ydCBSZWFjdE1hcmtkb3duIGZyb20gJ3JlYWN0LW1hcmtkb3duJztcbmltcG9ydCByZW1hcmtNYXRoIGZyb20gJ3JlbWFyay1tYXRoJztcbmltcG9ydCByZW1hcmtHZm0gZnJvbSAncmVtYXJrLWdmbSc7XG5pbXBvcnQgcmVoeXBlS2F0ZXggZnJvbSAncmVoeXBlLWthdGV4JztcbmltcG9ydCAna2F0ZXgvZGlzdC9rYXRleC5taW4uY3NzJztcbmltcG9ydCB0eXBlIHsgTWVzc2FnZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcblxuaW50ZXJmYWNlIENoYXRCdWJibGVQcm9wcyB7XG4gICAgbWVzc2FnZTogTWVzc2FnZTtcbiAgICBpc0xvYWRpbmc/OiBib29sZWFuO1xufVxuXG5jb25zdCBDaGF0QnViYmxlOiBSZWFjdC5GQzxDaGF0QnViYmxlUHJvcHM+ID0gKHsgbWVzc2FnZSwgaXNMb2FkaW5nID0gZmFsc2UgfSkgPT4ge1xuICAgIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICAgIGNvbnN0IGlzVXNlciA9IG1lc3NhZ2Uucm9sZSA9PT0gJ3VzZXInO1xuICAgIGNvbnN0IGlzQUkgPSBtZXNzYWdlLnJvbGUgPT09ICdhaSc7XG5cbiAgICBjb25zdCBoYW5kbGVDbGljayA9ICgpID0+IHtcbiAgICAgICAgaWYgKGlzQUkgJiYgbWVzc2FnZS5hcGlSZXNwb25zZSkge1xuICAgICAgICAgICAgcm91dGVyLnB1c2goYC9kZXRhaWxzLyR7bWVzc2FnZS5pZH1gKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8Qm94XG4gICAgICAgICAgICBkaXNwbGF5PVwiZmxleFwiXG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudD17aXNVc2VyID8gJ2ZsZXgtZW5kJyA6ICdmbGV4LXN0YXJ0J31cbiAgICAgICAgICAgIG1iPXszfVxuICAgICAgICAgICAgc3g9e3sgd2lkdGg6ICcxMDAlJyB9fVxuICAgICAgICA+XG4gICAgICAgICAgICA8Qm94XG4gICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XG4gICAgICAgICAgICAgICAgc3g9e3tcbiAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6IHsgeHM6ICc4NSUnLCBzbTogJzgwJScgfSxcbiAgICAgICAgICAgICAgICAgICAgcHg6IHsgeHM6IDIuNSwgbWQ6IDMgfSxcbiAgICAgICAgICAgICAgICAgICAgcHk6IHsgeHM6IDEuNSwgbWQ6IDIgfSxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnMS41cmVtJyxcbiAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogaXNVc2VyID8gJyM2RDVDRkYnIDogJyMxRTBDMzQnLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyNGMkVDRjgnLFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogeyB4czogJzAuOTVyZW0nLCBtZDogJzFyZW0nIH0sXG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDEuNixcbiAgICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiAnMCAycHggNXB4IHJnYmEoMCwwLDAsMC4yKScsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlcjogaXNBSSA/ICcxcHggc29saWQnIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogaXNBSSA/ICcjMkIxMzQ4JyA6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcjogaXNBSSAmJiAhaXNMb2FkaW5nICYmIG1lc3NhZ2UuYXBpUmVzcG9uc2UgPyAncG9pbnRlcicgOiAnZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICdhbGwgMC4ycyBlYXNlJyxcbiAgICAgICAgICAgICAgICAgICAgJyY6aG92ZXInOiBpc0FJICYmICFpc0xvYWRpbmcgJiYgbWVzc2FnZS5hcGlSZXNwb25zZSA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJnY29sb3I6ICcjMkIxMzQ4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoLTFweCknLFxuICAgICAgICAgICAgICAgICAgICB9IDoge30sXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7aXNBSSA/IChcbiAgICAgICAgICAgICAgICAgICAgPEJveFxuICAgICAgICAgICAgICAgICAgICAgICAgc3g9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyNGMkVDRjgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmIHAnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAwLjc1cmVtIDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJjpsYXN0LWNoaWxkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYgaDEsICYgaDIsICYgaDMsICYgaDQsICYgaDUsICYgaDYnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogJzAuNXJlbSAwIDAuNzVyZW0gMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI0YyRUNGOCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDYwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyY6Zmlyc3Qtb2YtdHlwZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmIGgxJzogeyBmb250U2l6ZTogJzEuNXJlbScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJiBoMic6IHsgZm9udFNpemU6ICcxLjNyZW0nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYgaDMnOiB7IGZvbnRTaXplOiAnMS4xcmVtJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmIHVsLCAmIG9sJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46ICcwLjVyZW0gMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAnMS41cmVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmIGxpJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46ICcwLjI1cmVtIDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYgY29kZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjMpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzAuMnJlbSAwLjRyZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICcwLjI1cmVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjllbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdtb25vc3BhY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYgcHJlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMyknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMXJlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzAuNXJlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnYXV0bycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogJzAuNzVyZW0gMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmIGNvZGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYgYmxvY2txdW90ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyTGVmdDogJzNweCBzb2xpZCAjNkQ1Q0ZGJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6ICcxcmVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAnMC43NXJlbSAwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFN0eWxlOiAnaXRhbGljJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMC45LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYgYSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjNkQ1Q0ZGJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dERlY29yYXRpb246ICd1bmRlcmxpbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYgdGFibGUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbGxhcHNlOiAnY29sbGFwc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46ICcwLjc1cmVtIDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYgdGgsICYgdGQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMC41cmVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmIHRoJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMiknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8UmVhY3RNYXJrZG93blxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFya1BsdWdpbnM9e1tyZW1hcmtHZm0sIHJlbWFya01hdGhdfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlaHlwZVBsdWdpbnM9e1tyZWh5cGVLYXRleF19XG4gICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge21lc3NhZ2UuY29udGVudCB8fCAnJ31cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvUmVhY3RNYXJrZG93bj5cbiAgICAgICAgICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAgICAgPFR5cG9ncmFwaHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJib2R5MVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBzeD17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdwcmUtd3JhcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZEJyZWFrOiAnYnJlYWstd29yZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjRjJFQ0Y4J1xuICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAge21lc3NhZ2UuY29udGVudH1cbiAgICAgICAgICAgICAgICAgICAgPC9UeXBvZ3JhcGh5PlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAge2lzQUkgJiYgIWlzTG9hZGluZyAmJiBtZXNzYWdlLmFwaVJlc3BvbnNlICYmIChcbiAgICAgICAgICAgICAgICAgICAgPFR5cG9ncmFwaHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJjYXB0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk9XCJibG9ja1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBzeD17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG10OiAxLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjQTA5MEIwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzAuNzVyZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTdHlsZTogJ2l0YWxpYycsXG4gICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICDwn5KhIENsaWNrIHRvIHZpZXcgU1FMIGRldGFpbHNcbiAgICAgICAgICAgICAgICAgICAgPC9UeXBvZ3JhcGh5PlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L0JveD5cbiAgICAgICAgPC9Cb3g+XG4gICAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENoYXRCdWJibGU7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJCb3giLCJUeXBvZ3JhcGh5IiwidXNlUm91dGVyIiwiUmVhY3RNYXJrZG93biIsInJlbWFya01hdGgiLCJyZW1hcmtHZm0iLCJyZWh5cGVLYXRleCIsIkNoYXRCdWJibGUiLCJtZXNzYWdlIiwiaXNMb2FkaW5nIiwicm91dGVyIiwiaXNVc2VyIiwicm9sZSIsImlzQUkiLCJoYW5kbGVDbGljayIsImFwaVJlc3BvbnNlIiwicHVzaCIsImlkIiwiZGlzcGxheSIsImp1c3RpZnlDb250ZW50IiwibWIiLCJzeCIsIndpZHRoIiwib25DbGljayIsIm1heFdpZHRoIiwieHMiLCJzbSIsInB4IiwibWQiLCJweSIsImJvcmRlclJhZGl1cyIsImJnY29sb3IiLCJjb2xvciIsImZvbnRTaXplIiwibGluZUhlaWdodCIsImJveFNoYWRvdyIsImJvcmRlciIsImJvcmRlckNvbG9yIiwiY3Vyc29yIiwidHJhbnNpdGlvbiIsInRyYW5zZm9ybSIsIm1hcmdpbiIsIm1hcmdpbkJvdHRvbSIsImZvbnRXZWlnaHQiLCJtYXJnaW5Ub3AiLCJwYWRkaW5nTGVmdCIsImJhY2tncm91bmRDb2xvciIsInBhZGRpbmciLCJmb250RmFtaWx5Iiwib3ZlcmZsb3ciLCJib3JkZXJMZWZ0IiwiZm9udFN0eWxlIiwib3BhY2l0eSIsInRleHREZWNvcmF0aW9uIiwiYm9yZGVyQ29sbGFwc2UiLCJyZW1hcmtQbHVnaW5zIiwicmVoeXBlUGx1Z2lucyIsImNvbnRlbnQiLCJ2YXJpYW50Iiwid2hpdGVTcGFjZSIsIndvcmRCcmVhayIsIm10Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/chat/ChatBubble.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ccount/index.js":
/*!**************************************!*\
  !*** ./node_modules/ccount/index.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ccount: () => (/* binding */ ccount)\n/* harmony export */ });\n/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nfunction ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jY291bnQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9jY291bnQvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3VudCBob3cgb2Z0ZW4gYSBjaGFyYWN0ZXIgKG9yIHN1YnN0cmluZykgaXMgdXNlZCBpbiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqICAgVmFsdWUgdG8gc2VhcmNoIGluLlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJhY3RlclxuICogICBDaGFyYWN0ZXIgKG9yIHN1YnN0cmluZykgdG8gbG9vayBmb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiAgIE51bWJlciBvZiB0aW1lcyBgY2hhcmFjdGVyYCBvY2N1cnJlZCBpbiBgdmFsdWVgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2NvdW50KHZhbHVlLCBjaGFyYWN0ZXIpIHtcbiAgY29uc3Qgc291cmNlID0gU3RyaW5nKHZhbHVlKVxuXG4gIGlmICh0eXBlb2YgY2hhcmFjdGVyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGNoYXJhY3RlcicpXG4gIH1cblxuICBsZXQgY291bnQgPSAwXG4gIGxldCBpbmRleCA9IHNvdXJjZS5pbmRleE9mKGNoYXJhY3RlcilcblxuICB3aGlsZSAoaW5kZXggIT09IC0xKSB7XG4gICAgY291bnQrK1xuICAgIGluZGV4ID0gc291cmNlLmluZGV4T2YoY2hhcmFjdGVyLCBpbmRleCArIGNoYXJhY3Rlci5sZW5ndGgpXG4gIH1cblxuICByZXR1cm4gY291bnRcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ccount/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/hast-util-from-dom/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/hast-util-from-dom/lib/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromDom: () => (/* binding */ fromDom)\n/* harmony export */ });\n/* harmony import */ var hastscript__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hastscript */ \"(app-pages-browser)/./node_modules/hastscript/lib/index.js\");\n/* harmony import */ var web_namespaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! web-namespaces */ \"(app-pages-browser)/./node_modules/web-namespaces/index.js\");\n/**\n * @import {\n *   Comment as HastComment,\n *   Doctype as HastDoctype,\n *   Element as HastElement,\n *   Nodes as HastNodes,\n *   RootContent as HastRootContent,\n *   Root as HastRoot,\n *   Text as HastText,\n * } from 'hast'\n */\n\n/**\n * @callback AfterTransform\n *   Callback called when each node is transformed.\n * @param {Node} domNode\n *   DOM node that was handled.\n * @param {HastNodes} hastNode\n *   Corresponding hast node.\n * @returns {undefined | void}\n *   Nothing.\n *\n *   Note: `void` included until TS infers `undefined` nicely.\n *\n * @typedef Options\n *   Configuration.\n * @property {AfterTransform | null | undefined} [afterTransform]\n *   Callback called when each node is transformed (optional).\n */\n\n\n\n\n/**\n * Transform a DOM tree to a hast tree.\n *\n * @param {Node} tree\n *   DOM tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {HastNodes}\n *   Equivalent hast node.\n */\nfunction fromDom(tree, options) {\n  return transform(tree, options || {}) || {type: 'root', children: []}\n}\n\n/**\n * @param {Node} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastNodes | undefined}\n *   Equivalent hast node.\n *\n *   Note that certain legacy DOM nodes (i.e., Attr nodes (2),  CDATA, processing instructions)\n */\nfunction transform(node, options) {\n  const transformed = one(node, options)\n  if (transformed && options.afterTransform)\n    options.afterTransform(node, transformed)\n  return transformed\n}\n\n/**\n * @param {Node} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastNodes | undefined}\n *   Equivalent hast node.\n */\nfunction one(node, options) {\n  switch (node.nodeType) {\n    case 1 /* Element */: {\n      const domNode = /** @type {Element} */ (node)\n      return element(domNode, options)\n    }\n\n    // Ignore: Attr (2).\n\n    case 3 /* Text */: {\n      const domNode = /** @type {Text} */ (node)\n      return text(domNode)\n    }\n\n    // Ignore: CDATA (4).\n    // Removed: Entity reference (5)\n    // Removed: Entity (6)\n    // Ignore: Processing instruction (7).\n\n    case 8 /* Comment */: {\n      const domNode = /** @type {Comment} */ (node)\n      return comment(domNode)\n    }\n\n    case 9 /* Document */: {\n      const domNode = /** @type {Document} */ (node)\n      return root(domNode, options)\n    }\n\n    case 10 /* Document type */: {\n      return doctype()\n    }\n\n    case 11 /* Document fragment */: {\n      const domNode = /** @type {DocumentFragment} */ (node)\n      return root(domNode, options)\n    }\n\n    default: {\n      return undefined\n    }\n  }\n}\n\n/**\n * Transform a document.\n *\n * @param {Document | DocumentFragment} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastRoot}\n *   Equivalent hast node.\n */\nfunction root(node, options) {\n  return {type: 'root', children: all(node, options)}\n}\n\n/**\n * Transform a doctype.\n *\n * @returns {HastDoctype}\n *   Equivalent hast node.\n */\nfunction doctype() {\n  return {type: 'doctype'}\n}\n\n/**\n * Transform a text.\n *\n * @param {Text} node\n *   DOM node to transform.\n * @returns {HastText}\n *   Equivalent hast node.\n */\nfunction text(node) {\n  return {type: 'text', value: node.nodeValue || ''}\n}\n\n/**\n * Transform a comment.\n *\n * @param {Comment} node\n *   DOM node to transform.\n * @returns {HastComment}\n *   Equivalent hast node.\n */\nfunction comment(node) {\n  return {type: 'comment', value: node.nodeValue || ''}\n}\n\n/**\n * Transform an element.\n *\n * @param {Element} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {HastElement}\n *   Equivalent hast node.\n */\nfunction element(node, options) {\n  const space = node.namespaceURI\n  const x = space === web_namespaces__WEBPACK_IMPORTED_MODULE_0__.webNamespaces.svg ? hastscript__WEBPACK_IMPORTED_MODULE_1__.s : hastscript__WEBPACK_IMPORTED_MODULE_1__.h\n  const tagName =\n    space === web_namespaces__WEBPACK_IMPORTED_MODULE_0__.webNamespaces.html ? node.tagName.toLowerCase() : node.tagName\n  /** @type {DocumentFragment | Element} */\n  const content =\n    // @ts-expect-error: DOM types are wrong, content can exist.\n    space === web_namespaces__WEBPACK_IMPORTED_MODULE_0__.webNamespaces.html && tagName === 'template' ? node.content : node\n  const attributes = node.getAttributeNames()\n  /** @type {Record<string, string>} */\n  const properties = {}\n  let index = -1\n\n  while (++index < attributes.length) {\n    properties[attributes[index]] = node.getAttribute(attributes[index]) || ''\n  }\n\n  return x(tagName, properties, all(content, options))\n}\n\n/**\n * Transform child nodes in a parent.\n *\n * @param {Document | DocumentFragment | Element} node\n *   DOM node to transform.\n * @param {Options} options\n *   Configuration.\n * @returns {Array<HastRootContent>}\n *   Equivalent hast nodes.\n */\nfunction all(node, options) {\n  const nodes = node.childNodes\n  /** @type {Array<HastRootContent>} */\n  const children = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    const child = transform(nodes[index], options)\n\n    if (child !== undefined) {\n      // @ts-expect-error Assume no document inside document.\n      children.push(child)\n    }\n  }\n\n  return children\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtZnJvbS1kb20vbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQ0FBbUM7QUFDakQ7QUFDQTs7QUFFK0I7QUFDYTs7QUFFNUM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1Asc0NBQXNDLE1BQU07QUFDNUM7O0FBRUE7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEM7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5REFBYSxPQUFPLHlDQUFDLEdBQUcseUNBQUM7QUFDL0M7QUFDQSxjQUFjLHlEQUFhO0FBQzNCLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQSxjQUFjLHlEQUFhO0FBQzNCO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVDQUF1QztBQUNsRDtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC1mcm9tLWRvbS9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtcbiAqICAgQ29tbWVudCBhcyBIYXN0Q29tbWVudCxcbiAqICAgRG9jdHlwZSBhcyBIYXN0RG9jdHlwZSxcbiAqICAgRWxlbWVudCBhcyBIYXN0RWxlbWVudCxcbiAqICAgTm9kZXMgYXMgSGFzdE5vZGVzLFxuICogICBSb290Q29udGVudCBhcyBIYXN0Um9vdENvbnRlbnQsXG4gKiAgIFJvb3QgYXMgSGFzdFJvb3QsXG4gKiAgIFRleHQgYXMgSGFzdFRleHQsXG4gKiB9IGZyb20gJ2hhc3QnXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgQWZ0ZXJUcmFuc2Zvcm1cbiAqICAgQ2FsbGJhY2sgY2FsbGVkIHdoZW4gZWFjaCBub2RlIGlzIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHtOb2RlfSBkb21Ob2RlXG4gKiAgIERPTSBub2RlIHRoYXQgd2FzIGhhbmRsZWQuXG4gKiBAcGFyYW0ge0hhc3ROb2Rlc30gaGFzdE5vZGVcbiAqICAgQ29ycmVzcG9uZGluZyBoYXN0IG5vZGUuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkIHwgdm9pZH1cbiAqICAgTm90aGluZy5cbiAqXG4gKiAgIE5vdGU6IGB2b2lkYCBpbmNsdWRlZCB1bnRpbCBUUyBpbmZlcnMgYHVuZGVmaW5lZGAgbmljZWx5LlxuICpcbiAqIEB0eXBlZGVmIE9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7QWZ0ZXJUcmFuc2Zvcm0gfCBudWxsIHwgdW5kZWZpbmVkfSBbYWZ0ZXJUcmFuc2Zvcm1dXG4gKiAgIENhbGxiYWNrIGNhbGxlZCB3aGVuIGVhY2ggbm9kZSBpcyB0cmFuc2Zvcm1lZCAob3B0aW9uYWwpLlxuICovXG5cbmltcG9ydCB7aCwgc30gZnJvbSAnaGFzdHNjcmlwdCdcbmltcG9ydCB7d2ViTmFtZXNwYWNlc30gZnJvbSAnd2ViLW5hbWVzcGFjZXMnXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgRE9NIHRyZWUgdG8gYSBoYXN0IHRyZWUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSB0cmVlXG4gKiAgIERPTSB0cmVlIHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7T3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zXVxuICogICBDb25maWd1cmF0aW9uIChvcHRpb25hbCkuXG4gKiBAcmV0dXJucyB7SGFzdE5vZGVzfVxuICogICBFcXVpdmFsZW50IGhhc3Qgbm9kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Eb20odHJlZSwgb3B0aW9ucykge1xuICByZXR1cm4gdHJhbnNmb3JtKHRyZWUsIG9wdGlvbnMgfHwge30pIHx8IHt0eXBlOiAncm9vdCcsIGNoaWxkcmVuOiBbXX1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqICAgRE9NIG5vZGUgdG8gdHJhbnNmb3JtLlxuICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcmV0dXJucyB7SGFzdE5vZGVzIHwgdW5kZWZpbmVkfVxuICogICBFcXVpdmFsZW50IGhhc3Qgbm9kZS5cbiAqXG4gKiAgIE5vdGUgdGhhdCBjZXJ0YWluIGxlZ2FjeSBET00gbm9kZXMgKGkuZS4sIEF0dHIgbm9kZXMgKDIpLCAgQ0RBVEEsIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb25zKVxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgb3B0aW9ucykge1xuICBjb25zdCB0cmFuc2Zvcm1lZCA9IG9uZShub2RlLCBvcHRpb25zKVxuICBpZiAodHJhbnNmb3JtZWQgJiYgb3B0aW9ucy5hZnRlclRyYW5zZm9ybSlcbiAgICBvcHRpb25zLmFmdGVyVHJhbnNmb3JtKG5vZGUsIHRyYW5zZm9ybWVkKVxuICByZXR1cm4gdHJhbnNmb3JtZWRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqICAgRE9NIG5vZGUgdG8gdHJhbnNmb3JtLlxuICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcmV0dXJucyB7SGFzdE5vZGVzIHwgdW5kZWZpbmVkfVxuICogICBFcXVpdmFsZW50IGhhc3Qgbm9kZS5cbiAqL1xuZnVuY3Rpb24gb25lKG5vZGUsIG9wdGlvbnMpIHtcbiAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgY2FzZSAxIC8qIEVsZW1lbnQgKi86IHtcbiAgICAgIGNvbnN0IGRvbU5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlKVxuICAgICAgcmV0dXJuIGVsZW1lbnQoZG9tTm9kZSwgb3B0aW9ucylcbiAgICB9XG5cbiAgICAvLyBJZ25vcmU6IEF0dHIgKDIpLlxuXG4gICAgY2FzZSAzIC8qIFRleHQgKi86IHtcbiAgICAgIGNvbnN0IGRvbU5vZGUgPSAvKiogQHR5cGUge1RleHR9ICovIChub2RlKVxuICAgICAgcmV0dXJuIHRleHQoZG9tTm9kZSlcbiAgICB9XG5cbiAgICAvLyBJZ25vcmU6IENEQVRBICg0KS5cbiAgICAvLyBSZW1vdmVkOiBFbnRpdHkgcmVmZXJlbmNlICg1KVxuICAgIC8vIFJlbW92ZWQ6IEVudGl0eSAoNilcbiAgICAvLyBJZ25vcmU6IFByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gKDcpLlxuXG4gICAgY2FzZSA4IC8qIENvbW1lbnQgKi86IHtcbiAgICAgIGNvbnN0IGRvbU5vZGUgPSAvKiogQHR5cGUge0NvbW1lbnR9ICovIChub2RlKVxuICAgICAgcmV0dXJuIGNvbW1lbnQoZG9tTm9kZSlcbiAgICB9XG5cbiAgICBjYXNlIDkgLyogRG9jdW1lbnQgKi86IHtcbiAgICAgIGNvbnN0IGRvbU5vZGUgPSAvKiogQHR5cGUge0RvY3VtZW50fSAqLyAobm9kZSlcbiAgICAgIHJldHVybiByb290KGRvbU5vZGUsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgY2FzZSAxMCAvKiBEb2N1bWVudCB0eXBlICovOiB7XG4gICAgICByZXR1cm4gZG9jdHlwZSgpXG4gICAgfVxuXG4gICAgY2FzZSAxMSAvKiBEb2N1bWVudCBmcmFnbWVudCAqLzoge1xuICAgICAgY29uc3QgZG9tTm9kZSA9IC8qKiBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudH0gKi8gKG5vZGUpXG4gICAgICByZXR1cm4gcm9vdChkb21Ob2RlLCBvcHRpb25zKVxuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge0RvY3VtZW50IHwgRG9jdW1lbnRGcmFnbWVudH0gbm9kZVxuICogICBET00gbm9kZSB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm5zIHtIYXN0Um9vdH1cbiAqICAgRXF1aXZhbGVudCBoYXN0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIHJvb3Qobm9kZSwgb3B0aW9ucykge1xuICByZXR1cm4ge3R5cGU6ICdyb290JywgY2hpbGRyZW46IGFsbChub2RlLCBvcHRpb25zKX1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBkb2N0eXBlLlxuICpcbiAqIEByZXR1cm5zIHtIYXN0RG9jdHlwZX1cbiAqICAgRXF1aXZhbGVudCBoYXN0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGRvY3R5cGUoKSB7XG4gIHJldHVybiB7dHlwZTogJ2RvY3R5cGUnfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHRleHQuXG4gKlxuICogQHBhcmFtIHtUZXh0fSBub2RlXG4gKiAgIERPTSBub2RlIHRvIHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtIYXN0VGV4dH1cbiAqICAgRXF1aXZhbGVudCBoYXN0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIHRleHQobm9kZSkge1xuICByZXR1cm4ge3R5cGU6ICd0ZXh0JywgdmFsdWU6IG5vZGUubm9kZVZhbHVlIHx8ICcnfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGNvbW1lbnQuXG4gKlxuICogQHBhcmFtIHtDb21tZW50fSBub2RlXG4gKiAgIERPTSBub2RlIHRvIHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtIYXN0Q29tbWVudH1cbiAqICAgRXF1aXZhbGVudCBoYXN0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNvbW1lbnQobm9kZSkge1xuICByZXR1cm4ge3R5cGU6ICdjb21tZW50JywgdmFsdWU6IG5vZGUubm9kZVZhbHVlIHx8ICcnfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogICBET00gbm9kZSB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm5zIHtIYXN0RWxlbWVudH1cbiAqICAgRXF1aXZhbGVudCBoYXN0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnQobm9kZSwgb3B0aW9ucykge1xuICBjb25zdCBzcGFjZSA9IG5vZGUubmFtZXNwYWNlVVJJXG4gIGNvbnN0IHggPSBzcGFjZSA9PT0gd2ViTmFtZXNwYWNlcy5zdmcgPyBzIDogaFxuICBjb25zdCB0YWdOYW1lID1cbiAgICBzcGFjZSA9PT0gd2ViTmFtZXNwYWNlcy5odG1sID8gbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgOiBub2RlLnRhZ05hbWVcbiAgLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50IHwgRWxlbWVudH0gKi9cbiAgY29uc3QgY29udGVudCA9XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogRE9NIHR5cGVzIGFyZSB3cm9uZywgY29udGVudCBjYW4gZXhpc3QuXG4gICAgc3BhY2UgPT09IHdlYk5hbWVzcGFjZXMuaHRtbCAmJiB0YWdOYW1lID09PSAndGVtcGxhdGUnID8gbm9kZS5jb250ZW50IDogbm9kZVxuICBjb25zdCBhdHRyaWJ1dGVzID0gbm9kZS5nZXRBdHRyaWJ1dGVOYW1lcygpXG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgY29uc3QgcHJvcGVydGllcyA9IHt9XG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgIHByb3BlcnRpZXNbYXR0cmlidXRlc1tpbmRleF1dID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlc1tpbmRleF0pIHx8ICcnXG4gIH1cblxuICByZXR1cm4geCh0YWdOYW1lLCBwcm9wZXJ0aWVzLCBhbGwoY29udGVudCwgb3B0aW9ucykpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGNoaWxkIG5vZGVzIGluIGEgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnQgfCBEb2N1bWVudEZyYWdtZW50IHwgRWxlbWVudH0gbm9kZVxuICogICBET00gbm9kZSB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheTxIYXN0Um9vdENvbnRlbnQ+fVxuICogICBFcXVpdmFsZW50IGhhc3Qgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGFsbChub2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzXG4gIC8qKiBAdHlwZSB7QXJyYXk8SGFzdFJvb3RDb250ZW50Pn0gKi9cbiAgY29uc3QgY2hpbGRyZW4gPSBbXVxuICBsZXQgaW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK2luZGV4IDwgbm9kZXMubGVuZ3RoKSB7XG4gICAgY29uc3QgY2hpbGQgPSB0cmFuc2Zvcm0obm9kZXNbaW5kZXhdLCBvcHRpb25zKVxuXG4gICAgaWYgKGNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQXNzdW1lIG5vIGRvY3VtZW50IGluc2lkZSBkb2N1bWVudC5cbiAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/hast-util-from-dom/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/hast-util-from-html-isomorphic/lib/browser.js":
/*!********************************************************************!*\
  !*** ./node_modules/hast-util-from-html-isomorphic/lib/browser.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromHtmlIsomorphic: () => (/* binding */ fromHtmlIsomorphic)\n/* harmony export */ });\n/* harmony import */ var hast_util_from_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-from-dom */ \"(app-pages-browser)/./node_modules/hast-util-from-dom/lib/index.js\");\n/**\n * @typedef {import('hast').Root} Root\n *\n * @typedef {typeof import('./index.js').fromHtmlIsomorphic} FromHtmlIsomorphic\n */\n\n\n\nconst parser = new DOMParser()\n\n/** @type {FromHtmlIsomorphic} */\nfunction fromHtmlIsomorphic(value, options) {\n  const node = options?.fragment\n    ? parseFragment(value)\n    : parser.parseFromString(value, 'text/html')\n\n  return /** @type {Root} */ ((0,hast_util_from_dom__WEBPACK_IMPORTED_MODULE_0__.fromDom)(node))\n}\n\n/**\n * Parse as a fragment.\n *\n * @param {string} value\n * @returns {DocumentFragment}\n */\nfunction parseFragment(value) {\n  const template = document.createElement('template')\n  template.innerHTML = value\n  return template.content\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtZnJvbS1odG1sLWlzb21vcnBoaWMvbGliL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0EsYUFBYSxnREFBZ0Q7QUFDN0Q7O0FBRTBDOztBQUUxQzs7QUFFQSxXQUFXLG9CQUFvQjtBQUN4QjtBQUNQO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsTUFBTSxJQUFJLDJEQUFPO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtZnJvbS1odG1sLWlzb21vcnBoaWMvbGliL2Jyb3dzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuUm9vdH0gUm9vdFxuICpcbiAqIEB0eXBlZGVmIHt0eXBlb2YgaW1wb3J0KCcuL2luZGV4LmpzJykuZnJvbUh0bWxJc29tb3JwaGljfSBGcm9tSHRtbElzb21vcnBoaWNcbiAqL1xuXG5pbXBvcnQge2Zyb21Eb219IGZyb20gJ2hhc3QtdXRpbC1mcm9tLWRvbSdcblxuY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpXG5cbi8qKiBAdHlwZSB7RnJvbUh0bWxJc29tb3JwaGljfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21IdG1sSXNvbW9ycGhpYyh2YWx1ZSwgb3B0aW9ucykge1xuICBjb25zdCBub2RlID0gb3B0aW9ucz8uZnJhZ21lbnRcbiAgICA/IHBhcnNlRnJhZ21lbnQodmFsdWUpXG4gICAgOiBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHZhbHVlLCAndGV4dC9odG1sJylcblxuICByZXR1cm4gLyoqIEB0eXBlIHtSb290fSAqLyAoZnJvbURvbShub2RlKSlcbn1cblxuLyoqXG4gKiBQYXJzZSBhcyBhIGZyYWdtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge0RvY3VtZW50RnJhZ21lbnR9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlRnJhZ21lbnQodmFsdWUpIHtcbiAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpXG4gIHRlbXBsYXRlLmlubmVySFRNTCA9IHZhbHVlXG4gIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/hast-util-from-html-isomorphic/lib/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/hast-util-is-element/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/hast-util-is-element/lib/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertElement: () => (/* binding */ convertElement),\n/* harmony export */   isElement: () => (/* binding */ isElement)\n/* harmony export */ });\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Parents} Parents\n */\n\n/**\n * @template Fn\n * @template Fallback\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\n */\n\n/**\n * @callback Check\n *   Check that an arbitrary value is an element.\n * @param {unknown} this\n *   Context object (`this`) to call `test` with\n * @param {unknown} [element]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   Position of `element` in its parent.\n * @param {Parents | null | undefined} [parent]\n *   Parent of `element`.\n * @returns {boolean}\n *   Whether this is an element and passes a test.\n *\n * @typedef {Array<TestFunction | string> | TestFunction | string | null | undefined} Test\n *   Check for an arbitrary element.\n *\n *   * when `string`, checks that the element has that tag name\n *   * when `function`, see `TestFunction`\n *   * when `Array`, checks if one of the subtests pass\n *\n * @callback TestFunction\n *   Check if an element passes a test.\n * @param {unknown} this\n *   The given context.\n * @param {Element} element\n *   An element.\n * @param {number | undefined} [index]\n *   Position of `element` in its parent.\n * @param {Parents | undefined} [parent]\n *   Parent of `element`.\n * @returns {boolean | undefined | void}\n *   Whether this element passes the test.\n *\n *   Note: `void` is included until TS sees no return as `undefined`.\n */\n\n/**\n * Check if `element` is an `Element` and whether it passes the given test.\n *\n * @param element\n *   Thing to check, typically `element`.\n * @param test\n *   Check for a specific element.\n * @param index\n *   Position of `element` in its parent.\n * @param parent\n *   Parent of `element`.\n * @param context\n *   Context object (`this`) to call `test` with.\n * @returns\n *   Whether `element` is an `Element` and passes a test.\n * @throws\n *   When an incorrect `test`, `index`, or `parent` is given; there is no error\n *   thrown when `element` is not a node or not an element.\n */\nconst isElement =\n  // Note: overloads in JSDoc cant yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends TestFunction>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &\n   *   (<Condition extends string>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &\n   *   ((element?: null | undefined) => false) &\n   *   ((element: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &\n   *   ((element: unknown, test?: Test, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [element]\n     * @param {Test | undefined} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parents | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function (element, test, index, parent, context) {\n      const check = convertElement(test)\n\n      if (\n        index !== null &&\n        index !== undefined &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite `index`')\n      }\n\n      if (\n        parent !== null &&\n        parent !== undefined &&\n        (!parent.type || !parent.children)\n      ) {\n        throw new Error('Expected valid `parent`')\n      }\n\n      if (\n        (index === null || index === undefined) !==\n        (parent === null || parent === undefined)\n      ) {\n        throw new Error('Expected both `index` and `parent`')\n      }\n\n      return looksLikeAnElement(element)\n        ? check.call(context, element, index, parent)\n        : false\n    }\n  )\n\n/**\n * Generate a check from a test.\n *\n * Useful if youre going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * an `element`, `index`, and `parent`.\n *\n * @param test\n *   A test for a specific element.\n * @returns\n *   A check.\n */\nconst convertElement =\n  // Note: overloads in JSDoc cant yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &\n   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &\n   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  (\n    /**\n     * @param {Test | null | undefined} [test]\n     * @returns {Check}\n     */\n    function (test) {\n      if (test === null || test === undefined) {\n        return element\n      }\n\n      if (typeof test === 'string') {\n        return tagNameFactory(test)\n      }\n\n      // Assume array.\n      if (typeof test === 'object') {\n        return anyFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or array as `test`')\n    }\n  )\n\n/**\n * Handle multiple tests.\n *\n * @param {Array<TestFunction | string>} tests\n * @returns {Check}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convertElement(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @type {TestFunction}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn a string into a test for an element with a certain type.\n *\n * @param {string} check\n * @returns {Check}\n */\nfunction tagNameFactory(check) {\n  return castFactory(tagName)\n\n  /**\n   * @param {Element} element\n   * @returns {boolean}\n   */\n  function tagName(element) {\n    return element.tagName === check\n  }\n}\n\n/**\n * Turn a custom test into a test for an element that passes that test.\n *\n * @param {TestFunction} testFunction\n * @returns {Check}\n */\nfunction castFactory(testFunction) {\n  return check\n\n  /**\n   * @this {unknown}\n   * @type {Check}\n   */\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeAnElement(value) &&\n        testFunction.call(\n          this,\n          value,\n          typeof index === 'number' ? index : undefined,\n          parent || undefined\n        )\n    )\n  }\n}\n\n/**\n * Make sure something is an element.\n *\n * @param {unknown} element\n * @returns {element is Element}\n */\nfunction element(element) {\n  return Boolean(\n    element &&\n      typeof element === 'object' &&\n      'type' in element &&\n      element.type === 'element' &&\n      'tagName' in element &&\n      typeof element.tagName === 'string'\n  )\n}\n\n/**\n * @param {unknown} value\n * @returns {value is Element}\n */\nfunction looksLikeAnElement(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    'type' in value &&\n    'tagName' in value\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtaXMtZWxlbWVudC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0VBQW9FO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWEseUVBQXlFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSwwTEFBMEwsbUJBQW1CO0FBQzdNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsa0JBQWtCO0FBQ2pDLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsNEJBQTRCO0FBQzNDLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSw4TEFBOEwsbUJBQW1CO0FBQ2pOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQThCO0FBQ3pDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC1pcy1lbGVtZW50L2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5FbGVtZW50fSBFbGVtZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuUGFyZW50c30gUGFyZW50c1xuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIEZuXG4gKiBAdGVtcGxhdGUgRmFsbGJhY2tcbiAqIEB0eXBlZGVmIHtGbiBleHRlbmRzICh2YWx1ZTogYW55KSA9PiB2YWx1ZSBpcyBpbmZlciBUaGluZyA/IFRoaW5nIDogRmFsbGJhY2t9IFByZWRpY2F0ZVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIENoZWNrXG4gKiAgIENoZWNrIHRoYXQgYW4gYXJiaXRyYXJ5IHZhbHVlIGlzIGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge3Vua25vd259IHRoaXNcbiAqICAgQ29udGV4dCBvYmplY3QgKGB0aGlzYCkgdG8gY2FsbCBgdGVzdGAgd2l0aFxuICogQHBhcmFtIHt1bmtub3dufSBbZWxlbWVudF1cbiAqICAgQW55dGhpbmcgKHR5cGljYWxseSBhIG5vZGUpLlxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSBbaW5kZXhdXG4gKiAgIFBvc2l0aW9uIG9mIGBlbGVtZW50YCBpbiBpdHMgcGFyZW50LlxuICogQHBhcmFtIHtQYXJlbnRzIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3BhcmVudF1cbiAqICAgUGFyZW50IG9mIGBlbGVtZW50YC5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogICBXaGV0aGVyIHRoaXMgaXMgYW4gZWxlbWVudCBhbmQgcGFzc2VzIGEgdGVzdC5cbiAqXG4gKiBAdHlwZWRlZiB7QXJyYXk8VGVzdEZ1bmN0aW9uIHwgc3RyaW5nPiB8IFRlc3RGdW5jdGlvbiB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFRlc3RcbiAqICAgQ2hlY2sgZm9yIGFuIGFyYml0cmFyeSBlbGVtZW50LlxuICpcbiAqICAgKiB3aGVuIGBzdHJpbmdgLCBjaGVja3MgdGhhdCB0aGUgZWxlbWVudCBoYXMgdGhhdCB0YWcgbmFtZVxuICogICAqIHdoZW4gYGZ1bmN0aW9uYCwgc2VlIGBUZXN0RnVuY3Rpb25gXG4gKiAgICogd2hlbiBgQXJyYXlgLCBjaGVja3MgaWYgb25lIG9mIHRoZSBzdWJ0ZXN0cyBwYXNzXG4gKlxuICogQGNhbGxiYWNrIFRlc3RGdW5jdGlvblxuICogICBDaGVjayBpZiBhbiBlbGVtZW50IHBhc3NlcyBhIHRlc3QuXG4gKiBAcGFyYW0ge3Vua25vd259IHRoaXNcbiAqICAgVGhlIGdpdmVuIGNvbnRleHQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqICAgQW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBbaW5kZXhdXG4gKiAgIFBvc2l0aW9uIG9mIGBlbGVtZW50YCBpbiBpdHMgcGFyZW50LlxuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBbcGFyZW50XVxuICogICBQYXJlbnQgb2YgYGVsZW1lbnRgLlxuICogQHJldHVybnMge2Jvb2xlYW4gfCB1bmRlZmluZWQgfCB2b2lkfVxuICogICBXaGV0aGVyIHRoaXMgZWxlbWVudCBwYXNzZXMgdGhlIHRlc3QuXG4gKlxuICogICBOb3RlOiBgdm9pZGAgaXMgaW5jbHVkZWQgdW50aWwgVFMgc2VlcyBubyByZXR1cm4gYXMgYHVuZGVmaW5lZGAuXG4gKi9cblxuLyoqXG4gKiBDaGVjayBpZiBgZWxlbWVudGAgaXMgYW4gYEVsZW1lbnRgIGFuZCB3aGV0aGVyIGl0IHBhc3NlcyB0aGUgZ2l2ZW4gdGVzdC5cbiAqXG4gKiBAcGFyYW0gZWxlbWVudFxuICogICBUaGluZyB0byBjaGVjaywgdHlwaWNhbGx5IGBlbGVtZW50YC5cbiAqIEBwYXJhbSB0ZXN0XG4gKiAgIENoZWNrIGZvciBhIHNwZWNpZmljIGVsZW1lbnQuXG4gKiBAcGFyYW0gaW5kZXhcbiAqICAgUG9zaXRpb24gb2YgYGVsZW1lbnRgIGluIGl0cyBwYXJlbnQuXG4gKiBAcGFyYW0gcGFyZW50XG4gKiAgIFBhcmVudCBvZiBgZWxlbWVudGAuXG4gKiBAcGFyYW0gY29udGV4dFxuICogICBDb250ZXh0IG9iamVjdCAoYHRoaXNgKSB0byBjYWxsIGB0ZXN0YCB3aXRoLlxuICogQHJldHVybnNcbiAqICAgV2hldGhlciBgZWxlbWVudGAgaXMgYW4gYEVsZW1lbnRgIGFuZCBwYXNzZXMgYSB0ZXN0LlxuICogQHRocm93c1xuICogICBXaGVuIGFuIGluY29ycmVjdCBgdGVzdGAsIGBpbmRleGAsIG9yIGBwYXJlbnRgIGlzIGdpdmVuOyB0aGVyZSBpcyBubyBlcnJvclxuICogICB0aHJvd24gd2hlbiBgZWxlbWVudGAgaXMgbm90IGEgbm9kZSBvciBub3QgYW4gZWxlbWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzRWxlbWVudCA9XG4gIC8vIE5vdGU6IG92ZXJsb2FkcyBpbiBKU0RvYyBjYW7igJl0IHlldCB1c2UgZGlmZmVyZW50IGBAdGVtcGxhdGVgcy5cbiAgLyoqXG4gICAqIEB0eXBlIHsoXG4gICAqICAgKDxDb25kaXRpb24gZXh0ZW5kcyBUZXN0RnVuY3Rpb24+KGVsZW1lbnQ6IHVua25vd24sIHRlc3Q6IENvbmRpdGlvbiwgaW5kZXg/OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkLCBwYXJlbnQ/OiBQYXJlbnRzIHwgbnVsbCB8IHVuZGVmaW5lZCwgY29udGV4dD86IHVua25vd24pID0+IGVsZW1lbnQgaXMgRWxlbWVudCAmIFByZWRpY2F0ZTxDb25kaXRpb24sIEVsZW1lbnQ+KSAmXG4gICAqICAgKDxDb25kaXRpb24gZXh0ZW5kcyBzdHJpbmc+KGVsZW1lbnQ6IHVua25vd24sIHRlc3Q6IENvbmRpdGlvbiwgaW5kZXg/OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkLCBwYXJlbnQ/OiBQYXJlbnRzIHwgbnVsbCB8IHVuZGVmaW5lZCwgY29udGV4dD86IHVua25vd24pID0+IGVsZW1lbnQgaXMgRWxlbWVudCAmIHt0YWdOYW1lOiBDb25kaXRpb259KSAmXG4gICAqICAgKChlbGVtZW50PzogbnVsbCB8IHVuZGVmaW5lZCkgPT4gZmFsc2UpICZcbiAgICogICAoKGVsZW1lbnQ6IHVua25vd24sIHRlc3Q/OiBudWxsIHwgdW5kZWZpbmVkLCBpbmRleD86IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQsIHBhcmVudD86IFBhcmVudHMgfCBudWxsIHwgdW5kZWZpbmVkLCBjb250ZXh0PzogdW5rbm93bikgPT4gZWxlbWVudCBpcyBFbGVtZW50KSAmXG4gICAqICAgKChlbGVtZW50OiB1bmtub3duLCB0ZXN0PzogVGVzdCwgaW5kZXg/OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkLCBwYXJlbnQ/OiBQYXJlbnRzIHwgbnVsbCB8IHVuZGVmaW5lZCwgY29udGV4dD86IHVua25vd24pID0+IGJvb2xlYW4pXG4gICAqICl9XG4gICAqL1xuICAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHt1bmtub3dufSBbZWxlbWVudF1cbiAgICAgKiBAcGFyYW0ge1Rlc3QgfCB1bmRlZmluZWR9IFt0ZXN0XVxuICAgICAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2luZGV4XVxuICAgICAqIEBwYXJhbSB7UGFyZW50cyB8IG51bGwgfCB1bmRlZmluZWR9IFtwYXJlbnRdXG4gICAgICogQHBhcmFtIHt1bmtub3dufSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuICAgIGZ1bmN0aW9uIChlbGVtZW50LCB0ZXN0LCBpbmRleCwgcGFyZW50LCBjb250ZXh0KSB7XG4gICAgICBjb25zdCBjaGVjayA9IGNvbnZlcnRFbGVtZW50KHRlc3QpXG5cbiAgICAgIGlmIChcbiAgICAgICAgaW5kZXggIT09IG51bGwgJiZcbiAgICAgICAgaW5kZXggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgIGluZGV4IDwgMCB8fFxuICAgICAgICAgIGluZGV4ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3NpdGl2ZSBmaW5pdGUgYGluZGV4YCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgcGFyZW50ICE9PSBudWxsICYmXG4gICAgICAgIHBhcmVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICghcGFyZW50LnR5cGUgfHwgIXBhcmVudC5jaGlsZHJlbilcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhbGlkIGBwYXJlbnRgJylcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICAoaW5kZXggPT09IG51bGwgfHwgaW5kZXggPT09IHVuZGVmaW5lZCkgIT09XG4gICAgICAgIChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB1bmRlZmluZWQpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBib3RoIGBpbmRleGAgYW5kIGBwYXJlbnRgJylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxvb2tzTGlrZUFuRWxlbWVudChlbGVtZW50KVxuICAgICAgICA/IGNoZWNrLmNhbGwoY29udGV4dCwgZWxlbWVudCwgaW5kZXgsIHBhcmVudClcbiAgICAgICAgOiBmYWxzZVxuICAgIH1cbiAgKVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgY2hlY2sgZnJvbSBhIHRlc3QuXG4gKlxuICogVXNlZnVsIGlmIHlvdeKAmXJlIGdvaW5nIHRvIHRlc3QgbWFueSBub2RlcywgZm9yIGV4YW1wbGUgd2hlbiBjcmVhdGluZyBhXG4gKiB1dGlsaXR5IHdoZXJlIHNvbWV0aGluZyBlbHNlIHBhc3NlcyBhIGNvbXBhdGlibGUgdGVzdC5cbiAqXG4gKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBhIGJpdCBmYXN0ZXIgYmVjYXVzZSBpdCBleHBlY3RzIHZhbGlkIGlucHV0IG9ubHk6XG4gKiBhbiBgZWxlbWVudGAsIGBpbmRleGAsIGFuZCBgcGFyZW50YC5cbiAqXG4gKiBAcGFyYW0gdGVzdFxuICogICBBIHRlc3QgZm9yIGEgc3BlY2lmaWMgZWxlbWVudC5cbiAqIEByZXR1cm5zXG4gKiAgIEEgY2hlY2suXG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0RWxlbWVudCA9XG4gIC8vIE5vdGU6IG92ZXJsb2FkcyBpbiBKU0RvYyBjYW7igJl0IHlldCB1c2UgZGlmZmVyZW50IGBAdGVtcGxhdGVgcy5cbiAgLyoqXG4gICAqIEB0eXBlIHsoXG4gICAqICAgKDxDb25kaXRpb24gZXh0ZW5kcyBUZXN0RnVuY3Rpb24+KHRlc3Q6IENvbmRpdGlvbikgPT4gKGVsZW1lbnQ6IHVua25vd24sIGluZGV4PzogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCwgcGFyZW50PzogUGFyZW50cyB8IG51bGwgfCB1bmRlZmluZWQsIGNvbnRleHQ/OiB1bmtub3duKSA9PiBlbGVtZW50IGlzIEVsZW1lbnQgJiBQcmVkaWNhdGU8Q29uZGl0aW9uLCBFbGVtZW50PikgJlxuICAgKiAgICg8Q29uZGl0aW9uIGV4dGVuZHMgc3RyaW5nPih0ZXN0OiBDb25kaXRpb24pID0+IChlbGVtZW50OiB1bmtub3duLCBpbmRleD86IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQsIHBhcmVudD86IFBhcmVudHMgfCBudWxsIHwgdW5kZWZpbmVkLCBjb250ZXh0PzogdW5rbm93bikgPT4gZWxlbWVudCBpcyBFbGVtZW50ICYge3RhZ05hbWU6IENvbmRpdGlvbn0pICZcbiAgICogICAoKHRlc3Q/OiBudWxsIHwgdW5kZWZpbmVkKSA9PiAoZWxlbWVudD86IHVua25vd24sIGluZGV4PzogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCwgcGFyZW50PzogUGFyZW50cyB8IG51bGwgfCB1bmRlZmluZWQsIGNvbnRleHQ/OiB1bmtub3duKSA9PiBlbGVtZW50IGlzIEVsZW1lbnQpICZcbiAgICogICAoKHRlc3Q/OiBUZXN0KSA9PiBDaGVjaylcbiAgICogKX1cbiAgICovXG4gIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1Rlc3QgfCBudWxsIHwgdW5kZWZpbmVkfSBbdGVzdF1cbiAgICAgKiBAcmV0dXJucyB7Q2hlY2t9XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRlc3QpIHtcbiAgICAgIGlmICh0ZXN0ID09PSBudWxsIHx8IHRlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudFxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lRmFjdG9yeSh0ZXN0KVxuICAgICAgfVxuXG4gICAgICAvLyBBc3N1bWUgYXJyYXkuXG4gICAgICBpZiAodHlwZW9mIHRlc3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBhbnlGYWN0b3J5KHRlc3QpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGVzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY2FzdEZhY3RvcnkodGVzdClcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBmdW5jdGlvbiwgc3RyaW5nLCBvciBhcnJheSBhcyBgdGVzdGAnKVxuICAgIH1cbiAgKVxuXG4vKipcbiAqIEhhbmRsZSBtdWx0aXBsZSB0ZXN0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFRlc3RGdW5jdGlvbiB8IHN0cmluZz59IHRlc3RzXG4gKiBAcmV0dXJucyB7Q2hlY2t9XG4gKi9cbmZ1bmN0aW9uIGFueUZhY3RvcnkodGVzdHMpIHtcbiAgLyoqIEB0eXBlIHtBcnJheTxDaGVjaz59ICovXG4gIGNvbnN0IGNoZWNrcyA9IFtdXG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCB0ZXN0cy5sZW5ndGgpIHtcbiAgICBjaGVja3NbaW5kZXhdID0gY29udmVydEVsZW1lbnQodGVzdHNbaW5kZXhdKVxuICB9XG5cbiAgcmV0dXJuIGNhc3RGYWN0b3J5KGFueSlcblxuICAvKipcbiAgICogQHRoaXMge3Vua25vd259XG4gICAqIEB0eXBlIHtUZXN0RnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBhbnkoLi4ucGFyYW1ldGVycykge1xuICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGNoZWNrcy5sZW5ndGgpIHtcbiAgICAgIGlmIChjaGVja3NbaW5kZXhdLmFwcGx5KHRoaXMsIHBhcmFtZXRlcnMpKSByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogVHVybiBhIHN0cmluZyBpbnRvIGEgdGVzdCBmb3IgYW4gZWxlbWVudCB3aXRoIGEgY2VydGFpbiB0eXBlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaGVja1xuICogQHJldHVybnMge0NoZWNrfVxuICovXG5mdW5jdGlvbiB0YWdOYW1lRmFjdG9yeShjaGVjaykge1xuICByZXR1cm4gY2FzdEZhY3RvcnkodGFnTmFtZSlcblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gdGFnTmFtZShlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZSA9PT0gY2hlY2tcbiAgfVxufVxuXG4vKipcbiAqIFR1cm4gYSBjdXN0b20gdGVzdCBpbnRvIGEgdGVzdCBmb3IgYW4gZWxlbWVudCB0aGF0IHBhc3NlcyB0aGF0IHRlc3QuXG4gKlxuICogQHBhcmFtIHtUZXN0RnVuY3Rpb259IHRlc3RGdW5jdGlvblxuICogQHJldHVybnMge0NoZWNrfVxuICovXG5mdW5jdGlvbiBjYXN0RmFjdG9yeSh0ZXN0RnVuY3Rpb24pIHtcbiAgcmV0dXJuIGNoZWNrXG5cbiAgLyoqXG4gICAqIEB0aGlzIHt1bmtub3dufVxuICAgKiBAdHlwZSB7Q2hlY2t9XG4gICAqL1xuICBmdW5jdGlvbiBjaGVjayh2YWx1ZSwgaW5kZXgsIHBhcmVudCkge1xuICAgIHJldHVybiBCb29sZWFuKFxuICAgICAgbG9va3NMaWtlQW5FbGVtZW50KHZhbHVlKSAmJlxuICAgICAgICB0ZXN0RnVuY3Rpb24uY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicgPyBpbmRleCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBwYXJlbnQgfHwgdW5kZWZpbmVkXG4gICAgICAgIClcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBNYWtlIHN1cmUgc29tZXRoaW5nIGlzIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSBlbGVtZW50XG4gKiBAcmV0dXJucyB7ZWxlbWVudCBpcyBFbGVtZW50fVxuICovXG5mdW5jdGlvbiBlbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgZWxlbWVudCAmJlxuICAgICAgdHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmXG4gICAgICAndHlwZScgaW4gZWxlbWVudCAmJlxuICAgICAgZWxlbWVudC50eXBlID09PSAnZWxlbWVudCcgJiZcbiAgICAgICd0YWdOYW1lJyBpbiBlbGVtZW50ICYmXG4gICAgICB0eXBlb2YgZWxlbWVudC50YWdOYW1lID09PSAnc3RyaW5nJ1xuICApXG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIEVsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGxvb2tzTGlrZUFuRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICd0eXBlJyBpbiB2YWx1ZSAmJlxuICAgICd0YWdOYW1lJyBpbiB2YWx1ZVxuICApXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/hast-util-is-element/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/hast-util-parse-selector/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/hast-util-parse-selector/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseSelector: () => (/* binding */ parseSelector)\n/* harmony export */ });\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n */\n\n/**\n * @template {string} SimpleSelector\n *   Selector type.\n * @template {string} DefaultTagName\n *   Default tag name.\n * @typedef {(\n *   SimpleSelector extends ''\n *     ? DefaultTagName\n *     : SimpleSelector extends `${infer TagName}.${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends `${infer TagName}#${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends string\n *     ? SimpleSelector\n *     : DefaultTagName\n * )} ExtractTagName\n *   Extract tag name from a simple selector.\n */\n\nconst search = /[#.]/g\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @template {string} Selector\n *   Type of selector.\n * @template {string} [DefaultTagName='div']\n *   Type of default tag name (default: `'div'`).\n * @param {Selector | null | undefined} [selector]\n *   Simple CSS selector (optional).\n *\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\n * @returns {Element & {tagName: ExtractTagName<Selector, DefaultTagName>}}\n *   Built element.\n */\nfunction parseSelector(selector, defaultTagName) {\n  const value = selector || ''\n  /** @type {Properties} */\n  const props = {}\n  let start = 0\n  /** @type {string | undefined} */\n  let previous\n  /** @type {string | undefined} */\n  let tagName\n\n  while (start < value.length) {\n    search.lastIndex = start\n    const match = search.exec(value)\n    const subvalue = value.slice(start, match ? match.index : value.length)\n\n    if (subvalue) {\n      if (!previous) {\n        tagName = subvalue\n      } else if (previous === '#') {\n        props.id = subvalue\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue)\n      } else {\n        props.className = [subvalue]\n      }\n\n      start += subvalue.length\n    }\n\n    if (match) {\n      previous = match[0]\n      start++\n    }\n  }\n\n  return {\n    type: 'element',\n    // @ts-expect-error: tag name is parsed.\n    tagName: tagName || defaultTagName || 'div',\n    properties: props,\n    children: []\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtcGFyc2Utc2VsZWN0b3IvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsMkJBQTJCO0FBQ3hDOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYyxHQUFHLFdBQVc7QUFDL0Q7QUFDQSxtQ0FBbUMsY0FBYyxHQUFHLFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUM7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNPO0FBQ1A7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC1wYXJzZS1zZWxlY3Rvci9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuRWxlbWVudH0gRWxlbWVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnaGFzdCcpLlByb3BlcnRpZXN9IFByb3BlcnRpZXNcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBTaW1wbGVTZWxlY3RvclxuICogICBTZWxlY3RvciB0eXBlLlxuICogQHRlbXBsYXRlIHtzdHJpbmd9IERlZmF1bHRUYWdOYW1lXG4gKiAgIERlZmF1bHQgdGFnIG5hbWUuXG4gKiBAdHlwZWRlZiB7KFxuICogICBTaW1wbGVTZWxlY3RvciBleHRlbmRzICcnXG4gKiAgICAgPyBEZWZhdWx0VGFnTmFtZVxuICogICAgIDogU2ltcGxlU2VsZWN0b3IgZXh0ZW5kcyBgJHtpbmZlciBUYWdOYW1lfS4ke2luZmVyIFJlc3R9YFxuICogICAgID8gRXh0cmFjdFRhZ05hbWU8VGFnTmFtZSwgRGVmYXVsdFRhZ05hbWU+XG4gKiAgICAgOiBTaW1wbGVTZWxlY3RvciBleHRlbmRzIGAke2luZmVyIFRhZ05hbWV9IyR7aW5mZXIgUmVzdH1gXG4gKiAgICAgPyBFeHRyYWN0VGFnTmFtZTxUYWdOYW1lLCBEZWZhdWx0VGFnTmFtZT5cbiAqICAgICA6IFNpbXBsZVNlbGVjdG9yIGV4dGVuZHMgc3RyaW5nXG4gKiAgICAgPyBTaW1wbGVTZWxlY3RvclxuICogICAgIDogRGVmYXVsdFRhZ05hbWVcbiAqICl9IEV4dHJhY3RUYWdOYW1lXG4gKiAgIEV4dHJhY3QgdGFnIG5hbWUgZnJvbSBhIHNpbXBsZSBzZWxlY3Rvci5cbiAqL1xuXG5jb25zdCBzZWFyY2ggPSAvWyMuXS9nXG5cbi8qKlxuICogQ3JlYXRlIGEgaGFzdCBlbGVtZW50IGZyb20gYSBzaW1wbGUgQ1NTIHNlbGVjdG9yLlxuICpcbiAqIEB0ZW1wbGF0ZSB7c3RyaW5nfSBTZWxlY3RvclxuICogICBUeXBlIG9mIHNlbGVjdG9yLlxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFtEZWZhdWx0VGFnTmFtZT0nZGl2J11cbiAqICAgVHlwZSBvZiBkZWZhdWx0IHRhZyBuYW1lIChkZWZhdWx0OiBgJ2RpdidgKS5cbiAqIEBwYXJhbSB7U2VsZWN0b3IgfCBudWxsIHwgdW5kZWZpbmVkfSBbc2VsZWN0b3JdXG4gKiAgIFNpbXBsZSBDU1Mgc2VsZWN0b3IgKG9wdGlvbmFsKS5cbiAqXG4gKiAgIENhbiBjb250YWluIGEgdGFnIG5hbWUgKGBmb29gKSwgY2xhc3NlcyAoYC5iYXJgKSwgYW5kIGFuIElEIChgI2JhemApLlxuICogICBNdWx0aXBsZSBjbGFzc2VzIGFyZSBhbGxvd2VkLlxuICogICBVc2VzIHRoZSBsYXN0IElEIGlmIG11bHRpcGxlIElEcyBhcmUgZm91bmQuXG4gKiBAcGFyYW0ge0RlZmF1bHRUYWdOYW1lIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2RlZmF1bHRUYWdOYW1lPSdkaXYnXVxuICogICBUYWcgbmFtZSB0byB1c2UgaWYgYHNlbGVjdG9yYCBkb2VzIG5vdCBzcGVjaWZ5IG9uZSAoZGVmYXVsdDogYCdkaXYnYCkuXG4gKiBAcmV0dXJucyB7RWxlbWVudCAmIHt0YWdOYW1lOiBFeHRyYWN0VGFnTmFtZTxTZWxlY3RvciwgRGVmYXVsdFRhZ05hbWU+fX1cbiAqICAgQnVpbHQgZWxlbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2VsZWN0b3Ioc2VsZWN0b3IsIGRlZmF1bHRUYWdOYW1lKSB7XG4gIGNvbnN0IHZhbHVlID0gc2VsZWN0b3IgfHwgJydcbiAgLyoqIEB0eXBlIHtQcm9wZXJ0aWVzfSAqL1xuICBjb25zdCBwcm9wcyA9IHt9XG4gIGxldCBzdGFydCA9IDBcbiAgLyoqIEB0eXBlIHtzdHJpbmcgfCB1bmRlZmluZWR9ICovXG4gIGxldCBwcmV2aW91c1xuICAvKiogQHR5cGUge3N0cmluZyB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IHRhZ05hbWVcblxuICB3aGlsZSAoc3RhcnQgPCB2YWx1ZS5sZW5ndGgpIHtcbiAgICBzZWFyY2gubGFzdEluZGV4ID0gc3RhcnRcbiAgICBjb25zdCBtYXRjaCA9IHNlYXJjaC5leGVjKHZhbHVlKVxuICAgIGNvbnN0IHN1YnZhbHVlID0gdmFsdWUuc2xpY2Uoc3RhcnQsIG1hdGNoID8gbWF0Y2guaW5kZXggOiB2YWx1ZS5sZW5ndGgpXG5cbiAgICBpZiAoc3VidmFsdWUpIHtcbiAgICAgIGlmICghcHJldmlvdXMpIHtcbiAgICAgICAgdGFnTmFtZSA9IHN1YnZhbHVlXG4gICAgICB9IGVsc2UgaWYgKHByZXZpb3VzID09PSAnIycpIHtcbiAgICAgICAgcHJvcHMuaWQgPSBzdWJ2YWx1ZVxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHByb3BzLmNsYXNzTmFtZSkpIHtcbiAgICAgICAgcHJvcHMuY2xhc3NOYW1lLnB1c2goc3VidmFsdWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wcy5jbGFzc05hbWUgPSBbc3VidmFsdWVdXG4gICAgICB9XG5cbiAgICAgIHN0YXJ0ICs9IHN1YnZhbHVlLmxlbmd0aFxuICAgIH1cblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgcHJldmlvdXMgPSBtYXRjaFswXVxuICAgICAgc3RhcnQrK1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ2VsZW1lbnQnLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHRhZyBuYW1lIGlzIHBhcnNlZC5cbiAgICB0YWdOYW1lOiB0YWdOYW1lIHx8IGRlZmF1bHRUYWdOYW1lIHx8ICdkaXYnLFxuICAgIHByb3BlcnRpZXM6IHByb3BzLFxuICAgIGNoaWxkcmVuOiBbXVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/hast-util-parse-selector/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/hast-util-to-text/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/hast-util-to-text/lib/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toText: () => (/* binding */ toText)\n/* harmony export */ });\n/* harmony import */ var unist_util_find_after__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unist-util-find-after */ \"(app-pages-browser)/./node_modules/unist-util-find-after/lib/index.js\");\n/* harmony import */ var hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-is-element */ \"(app-pages-browser)/./node_modules/hast-util-is-element/lib/index.js\");\n/**\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Parents} Parents\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast-util-is-element').TestFunction} TestFunction\n */\n\n/**\n * @typedef {'normal' | 'nowrap' | 'pre' | 'pre-wrap'} Whitespace\n *   Valid and useful whitespace values (from CSS).\n *\n * @typedef {0 | 1 | 2} BreakNumber\n *   Specific break:\n *\n *   *   `0`  space\n *   *   `1`  line ending\n *   *   `2`  blank line\n *\n * @typedef {'\\n'} BreakForce\n *   Forced break.\n *\n * @typedef {boolean} BreakValue\n *   Whether there was a break.\n *\n * @typedef {BreakNumber | BreakValue | undefined} BreakBefore\n *   Any value for a break before.\n *\n * @typedef {BreakForce | BreakNumber | BreakValue | undefined} BreakAfter\n *   Any value for a break after.\n *\n * @typedef CollectionInfo\n *   Info on current collection.\n * @property {BreakAfter} breakAfter\n *   Whether there was a break after.\n * @property {BreakBefore} breakBefore\n *   Whether there was a break before.\n * @property {Whitespace} whitespace\n *   Current whitespace setting.\n *\n * @typedef Options\n *   Configuration.\n * @property {Whitespace | null | undefined} [whitespace='normal']\n *   Initial CSS whitespace setting to use (default: `'normal'`).\n */\n\n\n\n\nconst searchLineFeeds = /\\n/g\nconst searchTabOrSpaces = /[\\t ]+/g\n\nconst br = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('br')\nconst cell = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)(isCell)\nconst p = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('p')\nconst row = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)('tr')\n\n// Note that we dont need to include void elements here as they dont have text.\n// See: <https://github.com/wooorm/html-void-elements>\nconst notRendered = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)([\n  // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>\n  'datalist',\n  'head',\n  'noembed',\n  'noframes',\n  'noscript', // Act as if we support scripting.\n  'rp',\n  'script',\n  'style',\n  'template',\n  'title',\n  // Hidden attribute.\n  hidden,\n  // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>\n  closedDialog\n])\n\n// See: <https://html.spec.whatwg.org/multipage/rendering.html#the-css-user-agent-style-sheet-and-presentational-hints>\nconst blockOrCaption = (0,hast_util_is_element__WEBPACK_IMPORTED_MODULE_0__.convertElement)([\n  'address', // Flow content\n  'article', // Sections and headings\n  'aside', // Sections and headings\n  'blockquote', // Flow content\n  'body', // Page\n  'caption', // `table-caption`\n  'center', // Flow content (legacy)\n  'dd', // Lists\n  'dialog', // Flow content\n  'dir', // Lists (legacy)\n  'dl', // Lists\n  'dt', // Lists\n  'div', // Flow content\n  'figure', // Flow content\n  'figcaption', // Flow content\n  'footer', // Flow content\n  'form,', // Flow content\n  'h1', // Sections and headings\n  'h2', // Sections and headings\n  'h3', // Sections and headings\n  'h4', // Sections and headings\n  'h5', // Sections and headings\n  'h6', // Sections and headings\n  'header', // Flow content\n  'hgroup', // Sections and headings\n  'hr', // Flow content\n  'html', // Page\n  'legend', // Flow content\n  'li', // Lists (as `display: list-item`)\n  'listing', // Flow content (legacy)\n  'main', // Flow content\n  'menu', // Lists\n  'nav', // Sections and headings\n  'ol', // Lists\n  'p', // Flow content\n  'plaintext', // Flow content (legacy)\n  'pre', // Flow content\n  'section', // Sections and headings\n  'ul', // Lists\n  'xmp' // Flow content (legacy)\n])\n\n/**\n * Get the plain-text value of a node.\n *\n * ###### Algorithm\n *\n * *   if `tree` is a comment, returns its `value`\n * *   if `tree` is a text, applies normal whitespace collapsing to its\n *     `value`, as defined by the CSS Text spec\n * *   if `tree` is a root or element, applies an algorithm similar to the\n *     `innerText` getter as defined by HTML\n *\n * ###### Notes\n *\n * >  **Note**: the algorithm acts as if `tree` is being rendered, and as if\n * > were a CSS-supporting user agent, with scripting enabled.\n *\n * *   if `tree` is an element that is not displayed (such as a `head`), well\n *     still use the `innerText` algorithm instead of switching to `textContent`\n * *   if descendants of `tree` are elements that are not displayed, they are\n *     ignored\n * *   CSS is not considered, except for the default user agent style sheet\n * *   a line feed is collapsed instead of ignored in cases where Fullwidth, Wide,\n *     or Halfwidth East Asian Width characters are used, the same goes for a case\n *     with Chinese, Japanese, or Yi writing systems\n * *   replaced elements (such as `audio`) are treated like non-replaced elements\n *\n * @param {Nodes} tree\n *   Tree to turn into text.\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `tree`.\n */\nfunction toText(tree, options) {\n  const options_ = options || {}\n  const children = 'children' in tree ? tree.children : []\n  const block = blockOrCaption(tree)\n  const whitespace = inferWhitespace(tree, {\n    whitespace: options_.whitespace || 'normal',\n    breakBefore: false,\n    breakAfter: false\n  })\n\n  /** @type {Array<BreakNumber | string>} */\n  const results = []\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the nodes `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (tree.type === 'text' || tree.type === 'comment') {\n    results.push(\n      ...collectText(tree, {\n        whitespace,\n        breakBefore: true,\n        breakAfter: true\n      })\n    )\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: were not supporting stylesheets so were acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: well have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  let index = -1\n\n  // 3.  For each child node node of this element:\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results.push(\n      ...renderedTextCollection(\n        children[index],\n        // @ts-expect-error: `tree` is a parent if were here.\n        tree,\n        {\n          whitespace,\n          breakBefore: index ? undefined : block,\n          breakAfter:\n            index < children.length - 1 ? br(children[index + 1]) : block\n        }\n      )\n    )\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {number | undefined} */\n  let count\n\n  index = -1\n\n  while (++index < results.length) {\n    const value = results[index]\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value\n    } else if (value) {\n      if (count !== undefined && count > -1) {\n        result.push('\\n'.repeat(count) || ' ')\n      }\n\n      count = -1\n      result.push(value)\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('')\n}\n\n/**\n * <https://html.spec.whatwg.org/multipage/dom.html#rendered-text-collection-steps>\n *\n * @param {Nodes} node\n * @param {Parents} parent\n * @param {CollectionInfo} info\n * @returns {Array<BreakNumber | string>}\n */\nfunction renderedTextCollection(node, parent, info) {\n  if (node.type === 'element') {\n    return collectElement(node, parent, info)\n  }\n\n  if (node.type === 'text') {\n    return info.whitespace === 'normal'\n      ? collectText(node, info)\n      : collectPreText(node)\n  }\n\n  return []\n}\n\n/**\n * Collect an element.\n *\n * @param {Element} node\n *   Element node.\n * @param {Parents} parent\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Array<BreakNumber | string>}\n */\nfunction collectElement(node, parent, info) {\n  // First we infer the `white-space` property.\n  const whitespace = inferWhitespace(node, info)\n  const children = node.children || []\n  let index = -1\n  /** @type {Array<BreakNumber | string>} */\n  let items = []\n\n  // Were ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items\n  }\n\n  /** @type {BreakNumber | undefined} */\n  let prefix\n  /** @type {BreakForce | BreakNumber | undefined} */\n  let suffix\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If nodes computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (br(node)) {\n    suffix = '\\n'\n  }\n\n  // 7.  If nodes computed value of `display` is `table-row`, and nodes CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/multipage/rendering.html#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (\n    row(node) &&\n    // @ts-expect-error: something up with types of parents.\n    (0,unist_util_find_after__WEBPACK_IMPORTED_MODULE_1__.findAfter)(parent, node, row)\n  ) {\n    suffix = '\\n'\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2\n    suffix = 2\n  }\n\n  // 9.  If nodes used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1\n    suffix = 1\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++index < children.length) {\n    items = items.concat(\n      renderedTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? undefined : prefix,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : suffix\n      })\n    )\n  }\n\n  // 6.  If nodes computed value of `display` is `table-cell`, and nodes CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/multipage/rendering.html#tables-2>\n  if (\n    cell(node) &&\n    // @ts-expect-error: something up with types of parents.\n    (0,unist_util_find_after__WEBPACK_IMPORTED_MODULE_1__.findAfter)(parent, node, cell)\n  ) {\n    items.push('\\t')\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) items.unshift(prefix)\n  if (suffix) items.push(suffix)\n\n  return items\n}\n\n/**\n * 4.  If node is a Text node, then for each CSS text box produced by node,\n *     in content order, compute the text of the box after application of the\n *     CSS `white-space` processing rules and `text-transform` rules, set\n *     items to the list of the resulting strings, and return items.\n *     The CSS `white-space` processing rules are slightly modified:\n *     collapsible spaces at the end of lines are always collapsed, but they\n *     are only removed if the line is the last line of the block, or it ends\n *     with a br element.\n *     Soft hyphens should be preserved.\n *\n *     Note: See `collectText` and `collectPreText`.\n *     Note: we dont deal with `text-transform`, no element has that by\n *     default.\n *\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\n *\n * @param {Comment | Text} node\n *   Text node.\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Array<BreakNumber | string>}\n *   Result.\n */\nfunction collectText(node, info) {\n  const value = String(node.value)\n  /** @type {Array<string>} */\n  const lines = []\n  /** @type {Array<BreakNumber | string>} */\n  const result = []\n  let start = 0\n\n  while (start <= value.length) {\n    searchLineFeeds.lastIndex = start\n\n    const match = searchLineFeeds.exec(value)\n    const end = match && 'index' in match ? match.index : value.length\n\n    lines.push(\n      // Any sequence of collapsible spaces and tabs immediately preceding or\n      // following a segment break is removed.\n      trimAndCollapseSpacesAndTabs(\n        // [] ignoring bidi formatting characters (characters with the\n        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n        // they were not there.\n        value\n          .slice(start, end)\n          .replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''),\n        start === 0 ? info.breakBefore : true,\n        end === value.length ? info.breakAfter : true\n      )\n    )\n\n    start = end + 1\n  }\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  let index = -1\n  /** @type {BreakNumber | undefined} */\n  let join\n\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (\n      lines[index].charCodeAt(lines[index].length - 1) === 0x20_0b /* ZWSP */ ||\n      (index < lines.length - 1 &&\n        lines[index + 1].charCodeAt(0) === 0x20_0b) /* ZWSP */\n    ) {\n      result.push(lines[index])\n      join = undefined\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (typeof join === 'number') result.push(join)\n      result.push(lines[index])\n      join = 0\n    } else if (index === 0 || index === lines.length - 1) {\n      // If this line is empty, and its the first or last, add a space.\n      // Note that this function is only called in normal whitespace, so we\n      // dont worry about `pre`.\n      result.push(0)\n    }\n  }\n\n  return result\n}\n\n/**\n * Collect a text node as pre whitespace.\n *\n * @param {Text} node\n *   Text node.\n * @returns {Array<BreakNumber | string>}\n *   Result.\n */\nfunction collectPreText(node) {\n  return [String(node.value)]\n}\n\n/**\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n * 4.  Any collapsible space immediately following another collapsible\n *     spaceeven one outside the boundary of the inline containing that\n *     space, provided both spaces are within the same inline formatting\n *     contextis collapsed to have zero advance width. (It is invisible,\n *     but retains its soft wrap opportunity, if any.)\n *\n * @param {string} value\n *   Value to collapse.\n * @param {BreakBefore} breakBefore\n *   Whether there was a break before.\n * @param {BreakAfter} breakAfter\n *   Whether there was a break after.\n * @returns {string}\n *   Result.\n */\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  /** @type {number | undefined} */\n  let end\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start\n    const match = searchTabOrSpaces.exec(value)\n    end = match ? match.index : value.length\n\n    // If were not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n    if (!start && !end && match && !breakBefore) {\n      result.push('')\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end))\n    }\n\n    start = match ? end + match[0].length : end\n  }\n\n  // If we reached the end, there was trailing white space, and theres no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n  if (start !== end && !breakAfter) {\n    result.push('')\n  }\n\n  return result.join(' ')\n}\n\n/**\n * Figure out the whitespace of a node.\n *\n * We dont support void elements here (so `nobr wbr` -> `normal` is ignored).\n *\n * @param {Nodes} node\n *   Node (typically `Element`).\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Whitespace}\n *   Applied whitespace.\n */\nfunction inferWhitespace(node, info) {\n  if (node.type === 'element') {\n    const properties = node.properties || {}\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp': {\n        return 'pre'\n      }\n\n      case 'nobr': {\n        return 'nowrap'\n      }\n\n      case 'pre': {\n        return properties.wrap ? 'pre-wrap' : 'pre'\n      }\n\n      case 'td':\n      case 'th': {\n        return properties.noWrap ? 'nowrap' : info.whitespace\n      }\n\n      case 'textarea': {\n        return 'pre-wrap'\n      }\n\n      default:\n    }\n  }\n\n  return info.whitespace\n}\n\n/**\n * @type {TestFunction}\n * @param {Element} node\n * @returns {node is {properties: {hidden: true}}}\n */\nfunction hidden(node) {\n  return Boolean((node.properties || {}).hidden)\n}\n\n/**\n * @type {TestFunction}\n * @param {Element} node\n * @returns {node is {tagName: 'td' | 'th'}}\n */\nfunction isCell(node) {\n  return node.tagName === 'td' || node.tagName === 'th'\n}\n\n/**\n * @type {TestFunction}\n */\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtdG8tdGV4dC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQyxhQUFhLHdCQUF3QjtBQUNyQyxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHdCQUF3QjtBQUNyQyxhQUFhLHFCQUFxQjtBQUNsQyxhQUFhLDZDQUE2QztBQUMxRDs7QUFFQTtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZEO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGFBQWEsc0NBQXNDO0FBQ25EO0FBQ0E7QUFDQSxhQUFhLG1EQUFtRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0JBQStCO0FBQzdDO0FBQ0E7O0FBRStDO0FBQ0k7O0FBRW5EO0FBQ0E7O0FBRUEsV0FBVyxvRUFBYztBQUN6QixhQUFhLG9FQUFjO0FBQzNCLFVBQVUsb0VBQWM7QUFDeEIsWUFBWSxvRUFBYzs7QUFFMUI7QUFDQTtBQUNBLG9CQUFvQixvRUFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixvRUFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLHNDQUFzQztBQUNqRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsYUFBYSw2QkFBNkI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0EsYUFBYSxzQ0FBc0M7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdFQUFTO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0VBQVM7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTLGFBQWE7QUFDbkM7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBLFVBQVU7QUFDVixXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by10ZXh0L2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5Db21tZW50fSBDb21tZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuRWxlbWVudH0gRWxlbWVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnaGFzdCcpLk5vZGVzfSBOb2Rlc1xuICogQHR5cGVkZWYge2ltcG9ydCgnaGFzdCcpLlBhcmVudHN9IFBhcmVudHNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5UZXh0fSBUZXh0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0LXV0aWwtaXMtZWxlbWVudCcpLlRlc3RGdW5jdGlvbn0gVGVzdEZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7J25vcm1hbCcgfCAnbm93cmFwJyB8ICdwcmUnIHwgJ3ByZS13cmFwJ30gV2hpdGVzcGFjZVxuICogICBWYWxpZCBhbmQgdXNlZnVsIHdoaXRlc3BhY2UgdmFsdWVzIChmcm9tIENTUykuXG4gKlxuICogQHR5cGVkZWYgezAgfCAxIHwgMn0gQnJlYWtOdW1iZXJcbiAqICAgU3BlY2lmaWMgYnJlYWs6XG4gKlxuICogICAqICAgYDBgIOKAlCBzcGFjZVxuICogICAqICAgYDFgIOKAlCBsaW5lIGVuZGluZ1xuICogICAqICAgYDJgIOKAlCBibGFuayBsaW5lXG4gKlxuICogQHR5cGVkZWYgeydcXG4nfSBCcmVha0ZvcmNlXG4gKiAgIEZvcmNlZCBicmVhay5cbiAqXG4gKiBAdHlwZWRlZiB7Ym9vbGVhbn0gQnJlYWtWYWx1ZVxuICogICBXaGV0aGVyIHRoZXJlIHdhcyBhIGJyZWFrLlxuICpcbiAqIEB0eXBlZGVmIHtCcmVha051bWJlciB8IEJyZWFrVmFsdWUgfCB1bmRlZmluZWR9IEJyZWFrQmVmb3JlXG4gKiAgIEFueSB2YWx1ZSBmb3IgYSBicmVhayBiZWZvcmUuXG4gKlxuICogQHR5cGVkZWYge0JyZWFrRm9yY2UgfCBCcmVha051bWJlciB8IEJyZWFrVmFsdWUgfCB1bmRlZmluZWR9IEJyZWFrQWZ0ZXJcbiAqICAgQW55IHZhbHVlIGZvciBhIGJyZWFrIGFmdGVyLlxuICpcbiAqIEB0eXBlZGVmIENvbGxlY3Rpb25JbmZvXG4gKiAgIEluZm8gb24gY3VycmVudCBjb2xsZWN0aW9uLlxuICogQHByb3BlcnR5IHtCcmVha0FmdGVyfSBicmVha0FmdGVyXG4gKiAgIFdoZXRoZXIgdGhlcmUgd2FzIGEgYnJlYWsgYWZ0ZXIuXG4gKiBAcHJvcGVydHkge0JyZWFrQmVmb3JlfSBicmVha0JlZm9yZVxuICogICBXaGV0aGVyIHRoZXJlIHdhcyBhIGJyZWFrIGJlZm9yZS5cbiAqIEBwcm9wZXJ0eSB7V2hpdGVzcGFjZX0gd2hpdGVzcGFjZVxuICogICBDdXJyZW50IHdoaXRlc3BhY2Ugc2V0dGluZy5cbiAqXG4gKiBAdHlwZWRlZiBPcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcHJvcGVydHkge1doaXRlc3BhY2UgfCBudWxsIHwgdW5kZWZpbmVkfSBbd2hpdGVzcGFjZT0nbm9ybWFsJ11cbiAqICAgSW5pdGlhbCBDU1Mgd2hpdGVzcGFjZSBzZXR0aW5nIHRvIHVzZSAoZGVmYXVsdDogYCdub3JtYWwnYCkuXG4gKi9cblxuaW1wb3J0IHtmaW5kQWZ0ZXJ9IGZyb20gJ3VuaXN0LXV0aWwtZmluZC1hZnRlcidcbmltcG9ydCB7Y29udmVydEVsZW1lbnR9IGZyb20gJ2hhc3QtdXRpbC1pcy1lbGVtZW50J1xuXG5jb25zdCBzZWFyY2hMaW5lRmVlZHMgPSAvXFxuL2dcbmNvbnN0IHNlYXJjaFRhYk9yU3BhY2VzID0gL1tcXHQgXSsvZ1xuXG5jb25zdCBiciA9IGNvbnZlcnRFbGVtZW50KCdicicpXG5jb25zdCBjZWxsID0gY29udmVydEVsZW1lbnQoaXNDZWxsKVxuY29uc3QgcCA9IGNvbnZlcnRFbGVtZW50KCdwJylcbmNvbnN0IHJvdyA9IGNvbnZlcnRFbGVtZW50KCd0cicpXG5cbi8vIE5vdGUgdGhhdCB3ZSBkb27igJl0IG5lZWQgdG8gaW5jbHVkZSB2b2lkIGVsZW1lbnRzIGhlcmUgYXMgdGhleSBkb27igJl0IGhhdmUgdGV4dC5cbi8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS93b29vcm0vaHRtbC12b2lkLWVsZW1lbnRzPlxuY29uc3Qgbm90UmVuZGVyZWQgPSBjb252ZXJ0RWxlbWVudChbXG4gIC8vIExpc3QgZnJvbTogPGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3JlbmRlcmluZy5odG1sI2hpZGRlbi1lbGVtZW50cz5cbiAgJ2RhdGFsaXN0JyxcbiAgJ2hlYWQnLFxuICAnbm9lbWJlZCcsXG4gICdub2ZyYW1lcycsXG4gICdub3NjcmlwdCcsIC8vIEFjdCBhcyBpZiB3ZSBzdXBwb3J0IHNjcmlwdGluZy5cbiAgJ3JwJyxcbiAgJ3NjcmlwdCcsXG4gICdzdHlsZScsXG4gICd0ZW1wbGF0ZScsXG4gICd0aXRsZScsXG4gIC8vIEhpZGRlbiBhdHRyaWJ1dGUuXG4gIGhpZGRlbixcbiAgLy8gRnJvbTogPGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3JlbmRlcmluZy5odG1sI2Zsb3ctY29udGVudC0zPlxuICBjbG9zZWREaWFsb2dcbl0pXG5cbi8vIFNlZTogPGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3JlbmRlcmluZy5odG1sI3RoZS1jc3MtdXNlci1hZ2VudC1zdHlsZS1zaGVldC1hbmQtcHJlc2VudGF0aW9uYWwtaGludHM+XG5jb25zdCBibG9ja09yQ2FwdGlvbiA9IGNvbnZlcnRFbGVtZW50KFtcbiAgJ2FkZHJlc3MnLCAvLyBGbG93IGNvbnRlbnRcbiAgJ2FydGljbGUnLCAvLyBTZWN0aW9ucyBhbmQgaGVhZGluZ3NcbiAgJ2FzaWRlJywgLy8gU2VjdGlvbnMgYW5kIGhlYWRpbmdzXG4gICdibG9ja3F1b3RlJywgLy8gRmxvdyBjb250ZW50XG4gICdib2R5JywgLy8gUGFnZVxuICAnY2FwdGlvbicsIC8vIGB0YWJsZS1jYXB0aW9uYFxuICAnY2VudGVyJywgLy8gRmxvdyBjb250ZW50IChsZWdhY3kpXG4gICdkZCcsIC8vIExpc3RzXG4gICdkaWFsb2cnLCAvLyBGbG93IGNvbnRlbnRcbiAgJ2RpcicsIC8vIExpc3RzIChsZWdhY3kpXG4gICdkbCcsIC8vIExpc3RzXG4gICdkdCcsIC8vIExpc3RzXG4gICdkaXYnLCAvLyBGbG93IGNvbnRlbnRcbiAgJ2ZpZ3VyZScsIC8vIEZsb3cgY29udGVudFxuICAnZmlnY2FwdGlvbicsIC8vIEZsb3cgY29udGVudFxuICAnZm9vdGVyJywgLy8gRmxvdyBjb250ZW50XG4gICdmb3JtLCcsIC8vIEZsb3cgY29udGVudFxuICAnaDEnLCAvLyBTZWN0aW9ucyBhbmQgaGVhZGluZ3NcbiAgJ2gyJywgLy8gU2VjdGlvbnMgYW5kIGhlYWRpbmdzXG4gICdoMycsIC8vIFNlY3Rpb25zIGFuZCBoZWFkaW5nc1xuICAnaDQnLCAvLyBTZWN0aW9ucyBhbmQgaGVhZGluZ3NcbiAgJ2g1JywgLy8gU2VjdGlvbnMgYW5kIGhlYWRpbmdzXG4gICdoNicsIC8vIFNlY3Rpb25zIGFuZCBoZWFkaW5nc1xuICAnaGVhZGVyJywgLy8gRmxvdyBjb250ZW50XG4gICdoZ3JvdXAnLCAvLyBTZWN0aW9ucyBhbmQgaGVhZGluZ3NcbiAgJ2hyJywgLy8gRmxvdyBjb250ZW50XG4gICdodG1sJywgLy8gUGFnZVxuICAnbGVnZW5kJywgLy8gRmxvdyBjb250ZW50XG4gICdsaScsIC8vIExpc3RzIChhcyBgZGlzcGxheTogbGlzdC1pdGVtYClcbiAgJ2xpc3RpbmcnLCAvLyBGbG93IGNvbnRlbnQgKGxlZ2FjeSlcbiAgJ21haW4nLCAvLyBGbG93IGNvbnRlbnRcbiAgJ21lbnUnLCAvLyBMaXN0c1xuICAnbmF2JywgLy8gU2VjdGlvbnMgYW5kIGhlYWRpbmdzXG4gICdvbCcsIC8vIExpc3RzXG4gICdwJywgLy8gRmxvdyBjb250ZW50XG4gICdwbGFpbnRleHQnLCAvLyBGbG93IGNvbnRlbnQgKGxlZ2FjeSlcbiAgJ3ByZScsIC8vIEZsb3cgY29udGVudFxuICAnc2VjdGlvbicsIC8vIFNlY3Rpb25zIGFuZCBoZWFkaW5nc1xuICAndWwnLCAvLyBMaXN0c1xuICAneG1wJyAvLyBGbG93IGNvbnRlbnQgKGxlZ2FjeSlcbl0pXG5cbi8qKlxuICogR2V0IHRoZSBwbGFpbi10ZXh0IHZhbHVlIG9mIGEgbm9kZS5cbiAqXG4gKiAjIyMjIyMgQWxnb3JpdGhtXG4gKlxuICogKiAgIGlmIGB0cmVlYCBpcyBhIGNvbW1lbnQsIHJldHVybnMgaXRzIGB2YWx1ZWBcbiAqICogICBpZiBgdHJlZWAgaXMgYSB0ZXh0LCBhcHBsaWVzIG5vcm1hbCB3aGl0ZXNwYWNlIGNvbGxhcHNpbmcgdG8gaXRzXG4gKiAgICAgYHZhbHVlYCwgYXMgZGVmaW5lZCBieSB0aGUgQ1NTIFRleHQgc3BlY1xuICogKiAgIGlmIGB0cmVlYCBpcyBhIHJvb3Qgb3IgZWxlbWVudCwgYXBwbGllcyBhbiBhbGdvcml0aG0gc2ltaWxhciB0byB0aGVcbiAqICAgICBgaW5uZXJUZXh0YCBnZXR0ZXIgYXMgZGVmaW5lZCBieSBIVE1MXG4gKlxuICogIyMjIyMjIE5vdGVzXG4gKlxuICogPiDwn5GJICoqTm90ZSoqOiB0aGUgYWxnb3JpdGhtIGFjdHMgYXMgaWYgYHRyZWVgIGlzIGJlaW5nIHJlbmRlcmVkLCBhbmQgYXMgaWZcbiAqID4gd2XigJlyZSBhIENTUy1zdXBwb3J0aW5nIHVzZXIgYWdlbnQsIHdpdGggc2NyaXB0aW5nIGVuYWJsZWQuXG4gKlxuICogKiAgIGlmIGB0cmVlYCBpcyBhbiBlbGVtZW50IHRoYXQgaXMgbm90IGRpc3BsYXllZCAoc3VjaCBhcyBhIGBoZWFkYCksIHdl4oCZbGxcbiAqICAgICBzdGlsbCB1c2UgdGhlIGBpbm5lclRleHRgIGFsZ29yaXRobSBpbnN0ZWFkIG9mIHN3aXRjaGluZyB0byBgdGV4dENvbnRlbnRgXG4gKiAqICAgaWYgZGVzY2VuZGFudHMgb2YgYHRyZWVgIGFyZSBlbGVtZW50cyB0aGF0IGFyZSBub3QgZGlzcGxheWVkLCB0aGV5IGFyZVxuICogICAgIGlnbm9yZWRcbiAqICogICBDU1MgaXMgbm90IGNvbnNpZGVyZWQsIGV4Y2VwdCBmb3IgdGhlIGRlZmF1bHQgdXNlciBhZ2VudCBzdHlsZSBzaGVldFxuICogKiAgIGEgbGluZSBmZWVkIGlzIGNvbGxhcHNlZCBpbnN0ZWFkIG9mIGlnbm9yZWQgaW4gY2FzZXMgd2hlcmUgRnVsbHdpZHRoLCBXaWRlLFxuICogICAgIG9yIEhhbGZ3aWR0aCBFYXN0IEFzaWFuIFdpZHRoIGNoYXJhY3RlcnMgYXJlIHVzZWQsIHRoZSBzYW1lIGdvZXMgZm9yIGEgY2FzZVxuICogICAgIHdpdGggQ2hpbmVzZSwgSmFwYW5lc2UsIG9yIFlpIHdyaXRpbmcgc3lzdGVtc1xuICogKiAgIHJlcGxhY2VkIGVsZW1lbnRzIChzdWNoIGFzIGBhdWRpb2ApIGFyZSB0cmVhdGVkIGxpa2Ugbm9uLXJlcGxhY2VkIGVsZW1lbnRzXG4gKlxuICogQHBhcmFtIHtOb2Rlc30gdHJlZVxuICogICBUcmVlIHRvIHR1cm4gaW50byB0ZXh0LlxuICogQHBhcmFtIHtSZWFkb25seTxPcHRpb25zPiB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zXVxuICogICBDb25maWd1cmF0aW9uIChvcHRpb25hbCkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogICBTZXJpYWxpemVkIGB0cmVlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVGV4dCh0cmVlLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnNfID0gb3B0aW9ucyB8fCB7fVxuICBjb25zdCBjaGlsZHJlbiA9ICdjaGlsZHJlbicgaW4gdHJlZSA/IHRyZWUuY2hpbGRyZW4gOiBbXVxuICBjb25zdCBibG9jayA9IGJsb2NrT3JDYXB0aW9uKHRyZWUpXG4gIGNvbnN0IHdoaXRlc3BhY2UgPSBpbmZlcldoaXRlc3BhY2UodHJlZSwge1xuICAgIHdoaXRlc3BhY2U6IG9wdGlvbnNfLndoaXRlc3BhY2UgfHwgJ25vcm1hbCcsXG4gICAgYnJlYWtCZWZvcmU6IGZhbHNlLFxuICAgIGJyZWFrQWZ0ZXI6IGZhbHNlXG4gIH0pXG5cbiAgLyoqIEB0eXBlIHtBcnJheTxCcmVha051bWJlciB8IHN0cmluZz59ICovXG4gIGNvbnN0IHJlc3VsdHMgPSBbXVxuXG4gIC8vIFRyZWF0IGB0ZXh0YCBhbmQgYGNvbW1lbnRgIGFzIGhhdmluZyBub3JtYWwgd2hpdGUtc3BhY2UuXG4gIC8vIFRoaXMgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhcyBpbiB0aGUgRE9NIHRoZSBub2Rl4oCZcyBgLmRhdGFgIGhhcyB0byBiZVxuICAvLyByZXR1cm5lZC5cbiAgLy8gSWYgeW91IHdhbnQgdGhhdCBiZWhhdmlvciB1c2UgYGhhc3QtdXRpbC10by1zdHJpbmdgLlxuICAvLyBBbGwgb3RoZXIgbm9kZXMgYXJlIGxhdGVyIGhhbmRsZWQgYXMgaWYgdGhleSBhcmUgYGVsZW1lbnRgcyAoc28gdGhlXG4gIC8vIGFsZ29yaXRobSBhbHNvIHdvcmtzIG9uIGEgYHJvb3RgKS5cbiAgLy8gTm9kZXMgd2l0aG91dCBjaGlsZHJlbiBhcmUgdHJlYXRlZCBhcyBhIHZvaWQgZWxlbWVudCwgc28gYGRvY3R5cGVgIGlzIHRodXNcbiAgLy8gaWdub3JlZC5cbiAgaWYgKHRyZWUudHlwZSA9PT0gJ3RleHQnIHx8IHRyZWUudHlwZSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgcmVzdWx0cy5wdXNoKFxuICAgICAgLi4uY29sbGVjdFRleHQodHJlZSwge1xuICAgICAgICB3aGl0ZXNwYWNlLFxuICAgICAgICBicmVha0JlZm9yZTogdHJ1ZSxcbiAgICAgICAgYnJlYWtBZnRlcjogdHJ1ZVxuICAgICAgfSlcbiAgICApXG4gIH1cblxuICAvLyAxLiAgSWYgdGhpcyBlbGVtZW50IGlzIG5vdCBiZWluZyByZW5kZXJlZCwgb3IgaWYgdGhlIHVzZXIgYWdlbnQgaXMgYVxuICAvLyAgICAgbm9uLUNTUyB1c2VyIGFnZW50LCB0aGVuIHJldHVybiB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgdGV4dENvbnRlbnQgSURMXG4gIC8vICAgICBhdHRyaWJ1dGUgb24gdGhpcyBlbGVtZW50LlxuICAvL1xuICAvLyAgICAgTm90ZTogd2XigJlyZSBub3Qgc3VwcG9ydGluZyBzdHlsZXNoZWV0cyBzbyB3ZeKAmXJlIGFjdGluZyBhcyBpZiB0aGUgbm9kZVxuICAvLyAgICAgaXMgcmVuZGVyZWQuXG4gIC8vXG4gIC8vICAgICBJZiB5b3Ugd2FudCB0aGF0IGJlaGF2aW9yIHVzZSBgaGFzdC11dGlsLXRvLXN0cmluZ2AuXG4gIC8vICAgICBJbXBvcnRhbnQ6IHdl4oCZbGwgaGF2ZSB0byBhY2NvdW50IGZvciB0aGlzIGxhdGVyIHRob3VnaC5cblxuICAvLyAyLiAgTGV0IHJlc3VsdHMgYmUgYSBuZXcgZW1wdHkgbGlzdC5cbiAgbGV0IGluZGV4ID0gLTFcblxuICAvLyAzLiAgRm9yIGVhY2ggY2hpbGQgbm9kZSBub2RlIG9mIHRoaXMgZWxlbWVudDpcbiAgd2hpbGUgKCsraW5kZXggPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAvLyAzLjEuIExldCBjdXJyZW50IGJlIHRoZSBsaXN0IHJlc3VsdGluZyBpbiBydW5uaW5nIHRoZSBpbm5lciB0ZXh0XG4gICAgLy8gICAgICBjb2xsZWN0aW9uIHN0ZXBzIHdpdGggbm9kZS5cbiAgICAvLyAgICAgIEVhY2ggaXRlbSBpbiByZXN1bHRzIHdpbGwgZWl0aGVyIGJlIGEgSmF2YVNjcmlwdCBzdHJpbmcgb3IgYVxuICAgIC8vICAgICAgcG9zaXRpdmUgaW50ZWdlciAoYSByZXF1aXJlZCBsaW5lIGJyZWFrIGNvdW50KS5cbiAgICAvLyAzLjIuIEZvciBlYWNoIGl0ZW0gaXRlbSBpbiBjdXJyZW50LCBhcHBlbmQgaXRlbSB0byByZXN1bHRzLlxuICAgIHJlc3VsdHMucHVzaChcbiAgICAgIC4uLnJlbmRlcmVkVGV4dENvbGxlY3Rpb24oXG4gICAgICAgIGNoaWxkcmVuW2luZGV4XSxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYHRyZWVgIGlzIGEgcGFyZW50IGlmIHdl4oCZcmUgaGVyZS5cbiAgICAgICAgdHJlZSxcbiAgICAgICAge1xuICAgICAgICAgIHdoaXRlc3BhY2UsXG4gICAgICAgICAgYnJlYWtCZWZvcmU6IGluZGV4ID8gdW5kZWZpbmVkIDogYmxvY2ssXG4gICAgICAgICAgYnJlYWtBZnRlcjpcbiAgICAgICAgICAgIGluZGV4IDwgY2hpbGRyZW4ubGVuZ3RoIC0gMSA/IGJyKGNoaWxkcmVuW2luZGV4ICsgMV0pIDogYmxvY2tcbiAgICAgICAgfVxuICAgICAgKVxuICAgIClcbiAgfVxuXG4gIC8vIDQuICBSZW1vdmUgYW55IGl0ZW1zIGZyb20gcmVzdWx0cyB0aGF0IGFyZSB0aGUgZW1wdHkgc3RyaW5nLlxuICAvLyA1LiAgUmVtb3ZlIGFueSBydW5zIG9mIGNvbnNlY3V0aXZlIHJlcXVpcmVkIGxpbmUgYnJlYWsgY291bnQgaXRlbXMgYXQgdGhlXG4gIC8vICAgICBzdGFydCBvciBlbmQgb2YgcmVzdWx0cy5cbiAgLy8gNi4gIFJlcGxhY2UgZWFjaCByZW1haW5pbmcgcnVuIG9mIGNvbnNlY3V0aXZlIHJlcXVpcmVkIGxpbmUgYnJlYWsgY291bnRcbiAgLy8gICAgIGl0ZW1zIHdpdGggYSBzdHJpbmcgY29uc2lzdGluZyBvZiBhcyBtYW55IFUrMDAwQSBMSU5FIEZFRUQgKExGKVxuICAvLyAgICAgY2hhcmFjdGVycyBhcyB0aGUgbWF4aW11bSBvZiB0aGUgdmFsdWVzIGluIHRoZSByZXF1aXJlZCBsaW5lIGJyZWFrXG4gIC8vICAgICBjb3VudCBpdGVtcy5cbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuICAvKiogQHR5cGUge251bWJlciB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IGNvdW50XG5cbiAgaW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK2luZGV4IDwgcmVzdWx0cy5sZW5ndGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHJlc3VsdHNbaW5kZXhdXG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGNvdW50ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPiBjb3VudCkgY291bnQgPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIGlmIChjb3VudCAhPT0gdW5kZWZpbmVkICYmIGNvdW50ID4gLTEpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goJ1xcbicucmVwZWF0KGNvdW50KSB8fCAnICcpXG4gICAgICB9XG5cbiAgICAgIGNvdW50ID0gLTFcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIC8vIDcuICBSZXR1cm4gdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIHN0cmluZyBpdGVtcyBpbiByZXN1bHRzLlxuICByZXR1cm4gcmVzdWx0LmpvaW4oJycpXG59XG5cbi8qKlxuICogPGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3JlbmRlcmVkLXRleHQtY29sbGVjdGlvbi1zdGVwcz5cbiAqXG4gKiBAcGFyYW0ge05vZGVzfSBub2RlXG4gKiBAcGFyYW0ge1BhcmVudHN9IHBhcmVudFxuICogQHBhcmFtIHtDb2xsZWN0aW9uSW5mb30gaW5mb1xuICogQHJldHVybnMge0FycmF5PEJyZWFrTnVtYmVyIHwgc3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gcmVuZGVyZWRUZXh0Q29sbGVjdGlvbihub2RlLCBwYXJlbnQsIGluZm8pIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgcmV0dXJuIGNvbGxlY3RFbGVtZW50KG5vZGUsIHBhcmVudCwgaW5mbylcbiAgfVxuXG4gIGlmIChub2RlLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIHJldHVybiBpbmZvLndoaXRlc3BhY2UgPT09ICdub3JtYWwnXG4gICAgICA/IGNvbGxlY3RUZXh0KG5vZGUsIGluZm8pXG4gICAgICA6IGNvbGxlY3RQcmVUZXh0KG5vZGUpXG4gIH1cblxuICByZXR1cm4gW11cbn1cblxuLyoqXG4gKiBDb2xsZWN0IGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiAgIEVsZW1lbnQgbm9kZS5cbiAqIEBwYXJhbSB7UGFyZW50c30gcGFyZW50XG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25JbmZvfSBpbmZvXG4gKiAgIEluZm8gb24gY3VycmVudCBjb2xsZWN0aW9uLlxuICogQHJldHVybnMge0FycmF5PEJyZWFrTnVtYmVyIHwgc3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gY29sbGVjdEVsZW1lbnQobm9kZSwgcGFyZW50LCBpbmZvKSB7XG4gIC8vIEZpcnN0IHdlIGluZmVyIHRoZSBgd2hpdGUtc3BhY2VgIHByb3BlcnR5LlxuICBjb25zdCB3aGl0ZXNwYWNlID0gaW5mZXJXaGl0ZXNwYWNlKG5vZGUsIGluZm8pXG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiB8fCBbXVxuICBsZXQgaW5kZXggPSAtMVxuICAvKiogQHR5cGUge0FycmF5PEJyZWFrTnVtYmVyIHwgc3RyaW5nPn0gKi9cbiAgbGV0IGl0ZW1zID0gW11cblxuICAvLyBXZeKAmXJlIGlnbm9yaW5nIHBvaW50IDMsIGFuZCBleGl0aW5nIHdpdGhvdXQgYW55IGNvbnRlbnQgaGVyZSwgYmVjYXVzZSB3ZVxuICAvLyBkZXZpYXRlZCBmcm9tIHRoZSBzcGVjIGluIGB0b1RleHRgIGF0IHN0ZXAgMy5cbiAgaWYgKG5vdFJlbmRlcmVkKG5vZGUpKSB7XG4gICAgcmV0dXJuIGl0ZW1zXG4gIH1cblxuICAvKiogQHR5cGUge0JyZWFrTnVtYmVyIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgcHJlZml4XG4gIC8qKiBAdHlwZSB7QnJlYWtGb3JjZSB8IEJyZWFrTnVtYmVyIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgc3VmZml4XG4gIC8vIE5vdGU6IHdlIGZpcnN0IGRldGVjdCBpZiB0aGVyZSBpcyBnb2luZyB0byBiZSBhIGJyZWFrIGJlZm9yZSBvciBhZnRlciB0aGVcbiAgLy8gY29udGVudHMsIGFzIHRoYXQgY2hhbmdlcyB0aGUgd2hpdGUtc3BhY2UgaGFuZGxpbmcuXG5cbiAgLy8gMi4gIElmIG5vZGXigJlzIGNvbXB1dGVkIHZhbHVlIG9mIGB2aXNpYmlsaXR5YCBpcyBub3QgYHZpc2libGVgLCB0aGVuIHJldHVyblxuICAvLyAgICAgaXRlbXMuXG4gIC8vXG4gIC8vICAgICBOb3RlOiBJZ25vcmVkLCBhcyBldmVyeXRoaW5nIGlzIHZpc2libGUgYnkgZGVmYXVsdCB1c2VyIGFnZW50IHN0eWxlcy5cblxuICAvLyAzLiAgSWYgbm9kZSBpcyBub3QgYmVpbmcgcmVuZGVyZWQsIHRoZW4gcmV0dXJuIGl0ZW1zLiBbLi4uXVxuICAvL1xuICAvLyAgICAgTm90ZTogV2UgYWxyZWFkeSBkaWQgdGhpcyBhYm92ZS5cblxuICAvLyBTZWUgYGNvbGxlY3RUZXh0YCBmb3Igc3RlcCA0LlxuXG4gIC8vIDUuICBJZiBub2RlIGlzIGEgYDxicj5gIGVsZW1lbnQsIHRoZW4gYXBwZW5kIGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBzaW5nbGVcbiAgLy8gICAgIFUrMDAwQSBMSU5FIEZFRUQgKExGKSBjaGFyYWN0ZXIgdG8gaXRlbXMuXG4gIGlmIChicihub2RlKSkge1xuICAgIHN1ZmZpeCA9ICdcXG4nXG4gIH1cblxuICAvLyA3LiAgSWYgbm9kZeKAmXMgY29tcHV0ZWQgdmFsdWUgb2YgYGRpc3BsYXlgIGlzIGB0YWJsZS1yb3dgLCBhbmQgbm9kZeKAmXMgQ1NTXG4gIC8vICAgICBib3ggaXMgbm90IHRoZSBsYXN0IGB0YWJsZS1yb3dgIGJveCBvZiB0aGUgbmVhcmVzdCBhbmNlc3RvciBgdGFibGVgXG4gIC8vICAgICBib3gsIHRoZW4gYXBwZW5kIGEgc3RyaW5nIGNvbnRhaW5pbmcgYSBzaW5nbGUgVSswMDBBIExJTkUgRkVFRCAoTEYpXG4gIC8vICAgICBjaGFyYWN0ZXIgdG8gaXRlbXMuXG4gIC8vXG4gIC8vICAgICBTZWU6IDxodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9yZW5kZXJpbmcuaHRtbCN0YWJsZXMtMj5cbiAgLy8gICAgIE5vdGU6IG5lZWRzIGZ1cnRoZXIgaW52ZXN0aWdhdGlvbiBhcyB0aGlzIGRvZXMgbm90IGFjY291bnQgZm9yIGltcGxpY2l0XG4gIC8vICAgICByb3dzLlxuICBlbHNlIGlmIChcbiAgICByb3cobm9kZSkgJiZcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBzb21ldGhpbmcgdXAgd2l0aCB0eXBlcyBvZiBwYXJlbnRzLlxuICAgIGZpbmRBZnRlcihwYXJlbnQsIG5vZGUsIHJvdylcbiAgKSB7XG4gICAgc3VmZml4ID0gJ1xcbidcbiAgfVxuXG4gIC8vIDguICBJZiBub2RlIGlzIGEgYDxwPmAgZWxlbWVudCwgdGhlbiBhcHBlbmQgMiAoYSByZXF1aXJlZCBsaW5lIGJyZWFrIGNvdW50KVxuICAvLyAgICAgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGl0ZW1zLlxuICBlbHNlIGlmIChwKG5vZGUpKSB7XG4gICAgcHJlZml4ID0gMlxuICAgIHN1ZmZpeCA9IDJcbiAgfVxuXG4gIC8vIDkuICBJZiBub2Rl4oCZcyB1c2VkIHZhbHVlIG9mIGBkaXNwbGF5YCBpcyBibG9jay1sZXZlbCBvciBgdGFibGUtY2FwdGlvbmAsXG4gIC8vICAgICB0aGVuIGFwcGVuZCAxIChhIHJlcXVpcmVkIGxpbmUgYnJlYWsgY291bnQpIGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZlxuICAvLyAgICAgaXRlbXMuXG4gIGVsc2UgaWYgKGJsb2NrT3JDYXB0aW9uKG5vZGUpKSB7XG4gICAgcHJlZml4ID0gMVxuICAgIHN1ZmZpeCA9IDFcbiAgfVxuXG4gIC8vIDEuICBMZXQgaXRlbXMgYmUgdGhlIHJlc3VsdCBvZiBydW5uaW5nIHRoZSBpbm5lciB0ZXh0IGNvbGxlY3Rpb24gc3RlcHMgd2l0aFxuICAvLyAgICAgZWFjaCBjaGlsZCBub2RlIG9mIG5vZGUgaW4gdHJlZSBvcmRlciwgYW5kIHRoZW4gY29uY2F0ZW5hdGluZyB0aGVcbiAgLy8gICAgIHJlc3VsdHMgdG8gYSBzaW5nbGUgbGlzdC5cbiAgd2hpbGUgKCsraW5kZXggPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChcbiAgICAgIHJlbmRlcmVkVGV4dENvbGxlY3Rpb24oY2hpbGRyZW5baW5kZXhdLCBub2RlLCB7XG4gICAgICAgIHdoaXRlc3BhY2UsXG4gICAgICAgIGJyZWFrQmVmb3JlOiBpbmRleCA/IHVuZGVmaW5lZCA6IHByZWZpeCxcbiAgICAgICAgYnJlYWtBZnRlcjpcbiAgICAgICAgICBpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCAtIDEgPyBicihjaGlsZHJlbltpbmRleCArIDFdKSA6IHN1ZmZpeFxuICAgICAgfSlcbiAgICApXG4gIH1cblxuICAvLyA2LiAgSWYgbm9kZeKAmXMgY29tcHV0ZWQgdmFsdWUgb2YgYGRpc3BsYXlgIGlzIGB0YWJsZS1jZWxsYCwgYW5kIG5vZGXigJlzIENTU1xuICAvLyAgICAgYm94IGlzIG5vdCB0aGUgbGFzdCBgdGFibGUtY2VsbGAgYm94IG9mIGl0cyBlbmNsb3NpbmcgYHRhYmxlLXJvd2AgYm94LFxuICAvLyAgICAgdGhlbiBhcHBlbmQgYSBzdHJpbmcgY29udGFpbmluZyBhIHNpbmdsZSBVKzAwMDkgQ0hBUkFDVEVSIFRBQlVMQVRJT05cbiAgLy8gICAgICh0YWIpIGNoYXJhY3RlciB0byBpdGVtcy5cbiAgLy9cbiAgLy8gICAgIFNlZTogPGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3JlbmRlcmluZy5odG1sI3RhYmxlcy0yPlxuICBpZiAoXG4gICAgY2VsbChub2RlKSAmJlxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHNvbWV0aGluZyB1cCB3aXRoIHR5cGVzIG9mIHBhcmVudHMuXG4gICAgZmluZEFmdGVyKHBhcmVudCwgbm9kZSwgY2VsbClcbiAgKSB7XG4gICAgaXRlbXMucHVzaCgnXFx0JylcbiAgfVxuXG4gIC8vIEFkZCB0aGUgcHJlLSBhbmQgc3VmZml4LlxuICBpZiAocHJlZml4KSBpdGVtcy51bnNoaWZ0KHByZWZpeClcbiAgaWYgKHN1ZmZpeCkgaXRlbXMucHVzaChzdWZmaXgpXG5cbiAgcmV0dXJuIGl0ZW1zXG59XG5cbi8qKlxuICogNC4gIElmIG5vZGUgaXMgYSBUZXh0IG5vZGUsIHRoZW4gZm9yIGVhY2ggQ1NTIHRleHQgYm94IHByb2R1Y2VkIGJ5IG5vZGUsXG4gKiAgICAgaW4gY29udGVudCBvcmRlciwgY29tcHV0ZSB0aGUgdGV4dCBvZiB0aGUgYm94IGFmdGVyIGFwcGxpY2F0aW9uIG9mIHRoZVxuICogICAgIENTUyBgd2hpdGUtc3BhY2VgIHByb2Nlc3NpbmcgcnVsZXMgYW5kIGB0ZXh0LXRyYW5zZm9ybWAgcnVsZXMsIHNldFxuICogICAgIGl0ZW1zIHRvIHRoZSBsaXN0IG9mIHRoZSByZXN1bHRpbmcgc3RyaW5ncywgYW5kIHJldHVybiBpdGVtcy5cbiAqICAgICBUaGUgQ1NTIGB3aGl0ZS1zcGFjZWAgcHJvY2Vzc2luZyBydWxlcyBhcmUgc2xpZ2h0bHkgbW9kaWZpZWQ6XG4gKiAgICAgY29sbGFwc2libGUgc3BhY2VzIGF0IHRoZSBlbmQgb2YgbGluZXMgYXJlIGFsd2F5cyBjb2xsYXBzZWQsIGJ1dCB0aGV5XG4gKiAgICAgYXJlIG9ubHkgcmVtb3ZlZCBpZiB0aGUgbGluZSBpcyB0aGUgbGFzdCBsaW5lIG9mIHRoZSBibG9jaywgb3IgaXQgZW5kc1xuICogICAgIHdpdGggYSBiciBlbGVtZW50LlxuICogICAgIFNvZnQgaHlwaGVucyBzaG91bGQgYmUgcHJlc2VydmVkLlxuICpcbiAqICAgICBOb3RlOiBTZWUgYGNvbGxlY3RUZXh0YCBhbmQgYGNvbGxlY3RQcmVUZXh0YC5cbiAqICAgICBOb3RlOiB3ZSBkb27igJl0IGRlYWwgd2l0aCBgdGV4dC10cmFuc2Zvcm1gLCBubyBlbGVtZW50IGhhcyB0aGF0IGJ5XG4gKiAgICAgZGVmYXVsdC5cbiAqXG4gKiBTZWU6IDxodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXRleHQvI3doaXRlLXNwYWNlLXBoYXNlLTE+XG4gKlxuICogQHBhcmFtIHtDb21tZW50IHwgVGV4dH0gbm9kZVxuICogICBUZXh0IG5vZGUuXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25JbmZvfSBpbmZvXG4gKiAgIEluZm8gb24gY3VycmVudCBjb2xsZWN0aW9uLlxuICogQHJldHVybnMge0FycmF5PEJyZWFrTnVtYmVyIHwgc3RyaW5nPn1cbiAqICAgUmVzdWx0LlxuICovXG5mdW5jdGlvbiBjb2xsZWN0VGV4dChub2RlLCBpbmZvKSB7XG4gIGNvbnN0IHZhbHVlID0gU3RyaW5nKG5vZGUudmFsdWUpXG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3QgbGluZXMgPSBbXVxuICAvKiogQHR5cGUge0FycmF5PEJyZWFrTnVtYmVyIHwgc3RyaW5nPn0gKi9cbiAgY29uc3QgcmVzdWx0ID0gW11cbiAgbGV0IHN0YXJ0ID0gMFxuXG4gIHdoaWxlIChzdGFydCA8PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICBzZWFyY2hMaW5lRmVlZHMubGFzdEluZGV4ID0gc3RhcnRcblxuICAgIGNvbnN0IG1hdGNoID0gc2VhcmNoTGluZUZlZWRzLmV4ZWModmFsdWUpXG4gICAgY29uc3QgZW5kID0gbWF0Y2ggJiYgJ2luZGV4JyBpbiBtYXRjaCA/IG1hdGNoLmluZGV4IDogdmFsdWUubGVuZ3RoXG5cbiAgICBsaW5lcy5wdXNoKFxuICAgICAgLy8gQW55IHNlcXVlbmNlIG9mIGNvbGxhcHNpYmxlIHNwYWNlcyBhbmQgdGFicyBpbW1lZGlhdGVseSBwcmVjZWRpbmcgb3JcbiAgICAgIC8vIGZvbGxvd2luZyBhIHNlZ21lbnQgYnJlYWsgaXMgcmVtb3ZlZC5cbiAgICAgIHRyaW1BbmRDb2xsYXBzZVNwYWNlc0FuZFRhYnMoXG4gICAgICAgIC8vIFvigKZdIGlnbm9yaW5nIGJpZGkgZm9ybWF0dGluZyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggdGhlXG4gICAgICAgIC8vIEJpZGlfQ29udHJvbCBwcm9wZXJ0eSBbVUFYOV06IEFMTSwgTFRSLCBSVEwsIExSRS1STE8sIExSSS1QREkpIGFzIGlmXG4gICAgICAgIC8vIHRoZXkgd2VyZSBub3QgdGhlcmUuXG4gICAgICAgIHZhbHVlXG4gICAgICAgICAgLnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgICAgICAgLnJlcGxhY2UoL1tcXHUwNjFDXFx1MjAwRVxcdTIwMEZcXHUyMDJBLVxcdTIwMkVcXHUyMDY2LVxcdTIwNjldL2csICcnKSxcbiAgICAgICAgc3RhcnQgPT09IDAgPyBpbmZvLmJyZWFrQmVmb3JlIDogdHJ1ZSxcbiAgICAgICAgZW5kID09PSB2YWx1ZS5sZW5ndGggPyBpbmZvLmJyZWFrQWZ0ZXIgOiB0cnVlXG4gICAgICApXG4gICAgKVxuXG4gICAgc3RhcnQgPSBlbmQgKyAxXG4gIH1cblxuICAvLyBDb2xsYXBzaWJsZSBzZWdtZW50IGJyZWFrcyBhcmUgdHJhbnNmb3JtZWQgZm9yIHJlbmRlcmluZyBhY2NvcmRpbmcgdG8gdGhlXG4gIC8vIHNlZ21lbnQgYnJlYWsgdHJhbnNmb3JtYXRpb24gcnVsZXMuXG4gIC8vIFNvIGhlcmUgd2UganVtcCB0byA0LjEuMiBvZiBbQ1NTVEVYVF06XG4gIC8vIEFueSBjb2xsYXBzaWJsZSBzZWdtZW50IGJyZWFrIGltbWVkaWF0ZWx5IGZvbGxvd2luZyBhbm90aGVyIGNvbGxhcHNpYmxlXG4gIC8vIHNlZ21lbnQgYnJlYWsgaXMgcmVtb3ZlZFxuICBsZXQgaW5kZXggPSAtMVxuICAvKiogQHR5cGUge0JyZWFrTnVtYmVyIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgam9pblxuXG4gIHdoaWxlICgrK2luZGV4IDwgbGluZXMubGVuZ3RoKSB7XG4gICAgLy8gKiAgIElmIHRoZSBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIG9yIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBzZWdtZW50XG4gICAgLy8gICAgIGJyZWFrIGlzIHRoZSB6ZXJvLXdpZHRoIHNwYWNlIGNoYXJhY3RlciAoVSsyMDBCKSwgdGhlbiB0aGUgYnJlYWsgaXNcbiAgICAvLyAgICAgcmVtb3ZlZCwgbGVhdmluZyBiZWhpbmQgdGhlIHplcm8td2lkdGggc3BhY2UuXG4gICAgaWYgKFxuICAgICAgbGluZXNbaW5kZXhdLmNoYXJDb2RlQXQobGluZXNbaW5kZXhdLmxlbmd0aCAtIDEpID09PSAweDIwXzBiIC8qIFpXU1AgKi8gfHxcbiAgICAgIChpbmRleCA8IGxpbmVzLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgbGluZXNbaW5kZXggKyAxXS5jaGFyQ29kZUF0KDApID09PSAweDIwXzBiKSAvKiBaV1NQICovXG4gICAgKSB7XG4gICAgICByZXN1bHQucHVzaChsaW5lc1tpbmRleF0pXG4gICAgICBqb2luID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgLy8gKiAgIE90aGVyd2lzZSwgaWYgdGhlIEVhc3QgQXNpYW4gV2lkdGggcHJvcGVydHkgW1VBWDExXSBvZiBib3RoIHRoZVxuICAgIC8vICAgICBjaGFyYWN0ZXIgYmVmb3JlIGFuZCBhZnRlciB0aGUgc2VnbWVudCBicmVhayBpcyBGdWxsd2lkdGgsIFdpZGUsIG9yXG4gICAgLy8gICAgIEhhbGZ3aWR0aCAobm90IEFtYmlndW91cyksIGFuZCBuZWl0aGVyIHNpZGUgaXMgSGFuZ3VsLCB0aGVuIHRoZVxuICAgIC8vICAgICBzZWdtZW50IGJyZWFrIGlzIHJlbW92ZWQuXG4gICAgLy9cbiAgICAvLyAgICAgTm90ZTogaWdub3JlZC5cbiAgICAvLyAqICAgT3RoZXJ3aXNlLCBpZiB0aGUgd3JpdGluZyBzeXN0ZW0gb2YgdGhlIHNlZ21lbnQgYnJlYWsgaXMgQ2hpbmVzZSxcbiAgICAvLyAgICAgSmFwYW5lc2UsIG9yIFlpLCBhbmQgdGhlIGNoYXJhY3RlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlIHNlZ21lbnQgYnJlYWtcbiAgICAvLyAgICAgaXMgcHVuY3R1YXRpb24gb3IgYSBzeW1ib2wgKFVuaWNvZGUgZ2VuZXJhbCBjYXRlZ29yeSBQKiBvciBTKikgYW5kXG4gICAgLy8gICAgIGhhcyBhbiBFYXN0IEFzaWFuIFdpZHRoIHByb3BlcnR5IG9mIEFtYmlndW91cywgYW5kIHRoZSBjaGFyYWN0ZXIgb25cbiAgICAvLyAgICAgdGhlIG90aGVyIHNpZGUgb2YgdGhlIHNlZ21lbnQgYnJlYWsgaXMgRnVsbHdpZHRoLCBXaWRlLCBvciBIYWxmd2lkdGgsXG4gICAgLy8gICAgIGFuZCBub3QgSGFuZ3VsLCB0aGVuIHRoZSBzZWdtZW50IGJyZWFrIGlzIHJlbW92ZWQuXG4gICAgLy9cbiAgICAvLyAgICAgTm90ZTogaWdub3JlZC5cblxuICAgIC8vICogICBPdGhlcndpc2UsIHRoZSBzZWdtZW50IGJyZWFrIGlzIGNvbnZlcnRlZCB0byBhIHNwYWNlIChVKzAwMjApLlxuICAgIGVsc2UgaWYgKGxpbmVzW2luZGV4XSkge1xuICAgICAgaWYgKHR5cGVvZiBqb2luID09PSAnbnVtYmVyJykgcmVzdWx0LnB1c2goam9pbilcbiAgICAgIHJlc3VsdC5wdXNoKGxpbmVzW2luZGV4XSlcbiAgICAgIGpvaW4gPSAwXG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCB8fCBpbmRleCA9PT0gbGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgLy8gSWYgdGhpcyBsaW5lIGlzIGVtcHR5LCBhbmQgaXTigJlzIHRoZSBmaXJzdCBvciBsYXN0LCBhZGQgYSBzcGFjZS5cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGluIG5vcm1hbCB3aGl0ZXNwYWNlLCBzbyB3ZVxuICAgICAgLy8gZG9u4oCZdCB3b3JyeSBhYm91dCBgcHJlYC5cbiAgICAgIHJlc3VsdC5wdXNoKDApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIENvbGxlY3QgYSB0ZXh0IG5vZGUgYXMg4oCccHJl4oCdIHdoaXRlc3BhY2UuXG4gKlxuICogQHBhcmFtIHtUZXh0fSBub2RlXG4gKiAgIFRleHQgbm9kZS5cbiAqIEByZXR1cm5zIHtBcnJheTxCcmVha051bWJlciB8IHN0cmluZz59XG4gKiAgIFJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gY29sbGVjdFByZVRleHQobm9kZSkge1xuICByZXR1cm4gW1N0cmluZyhub2RlLnZhbHVlKV1cbn1cblxuLyoqXG4gKiAzLiAgRXZlcnkgY29sbGFwc2libGUgdGFiIGlzIGNvbnZlcnRlZCB0byBhIGNvbGxhcHNpYmxlIHNwYWNlIChVKzAwMjApLlxuICogNC4gIEFueSBjb2xsYXBzaWJsZSBzcGFjZSBpbW1lZGlhdGVseSBmb2xsb3dpbmcgYW5vdGhlciBjb2xsYXBzaWJsZVxuICogICAgIHNwYWNl4oCUZXZlbiBvbmUgb3V0c2lkZSB0aGUgYm91bmRhcnkgb2YgdGhlIGlubGluZSBjb250YWluaW5nIHRoYXRcbiAqICAgICBzcGFjZSwgcHJvdmlkZWQgYm90aCBzcGFjZXMgYXJlIHdpdGhpbiB0aGUgc2FtZSBpbmxpbmUgZm9ybWF0dGluZ1xuICogICAgIGNvbnRleHTigJRpcyBjb2xsYXBzZWQgdG8gaGF2ZSB6ZXJvIGFkdmFuY2Ugd2lkdGguIChJdCBpcyBpbnZpc2libGUsXG4gKiAgICAgYnV0IHJldGFpbnMgaXRzIHNvZnQgd3JhcCBvcHBvcnR1bml0eSwgaWYgYW55LilcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqICAgVmFsdWUgdG8gY29sbGFwc2UuXG4gKiBAcGFyYW0ge0JyZWFrQmVmb3JlfSBicmVha0JlZm9yZVxuICogICBXaGV0aGVyIHRoZXJlIHdhcyBhIGJyZWFrIGJlZm9yZS5cbiAqIEBwYXJhbSB7QnJlYWtBZnRlcn0gYnJlYWtBZnRlclxuICogICBXaGV0aGVyIHRoZXJlIHdhcyBhIGJyZWFrIGFmdGVyLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqICAgUmVzdWx0LlxuICovXG5mdW5jdGlvbiB0cmltQW5kQ29sbGFwc2VTcGFjZXNBbmRUYWJzKHZhbHVlLCBicmVha0JlZm9yZSwgYnJlYWtBZnRlcikge1xuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gIGNvbnN0IHJlc3VsdCA9IFtdXG4gIGxldCBzdGFydCA9IDBcbiAgLyoqIEB0eXBlIHtudW1iZXIgfCB1bmRlZmluZWR9ICovXG4gIGxldCBlbmRcblxuICB3aGlsZSAoc3RhcnQgPCB2YWx1ZS5sZW5ndGgpIHtcbiAgICBzZWFyY2hUYWJPclNwYWNlcy5sYXN0SW5kZXggPSBzdGFydFxuICAgIGNvbnN0IG1hdGNoID0gc2VhcmNoVGFiT3JTcGFjZXMuZXhlYyh2YWx1ZSlcbiAgICBlbmQgPSBtYXRjaCA/IG1hdGNoLmluZGV4IDogdmFsdWUubGVuZ3RoXG5cbiAgICAvLyBJZiB3ZeKAmXJlIG5vdCBkaXJlY3RseSBhZnRlciBhIHNlZ21lbnQgYnJlYWssIGJ1dCB0aGVyZSB3YXMgd2hpdGUgc3BhY2UsXG4gICAgLy8gYWRkIGFuIGVtcHR5IHZhbHVlIHRoYXQgd2lsbCBiZSB0dXJuZWQgaW50byBhIHNwYWNlLlxuICAgIGlmICghc3RhcnQgJiYgIWVuZCAmJiBtYXRjaCAmJiAhYnJlYWtCZWZvcmUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKCcnKVxuICAgIH1cblxuICAgIGlmIChzdGFydCAhPT0gZW5kKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZS5zbGljZShzdGFydCwgZW5kKSlcbiAgICB9XG5cbiAgICBzdGFydCA9IG1hdGNoID8gZW5kICsgbWF0Y2hbMF0ubGVuZ3RoIDogZW5kXG4gIH1cblxuICAvLyBJZiB3ZSByZWFjaGVkIHRoZSBlbmQsIHRoZXJlIHdhcyB0cmFpbGluZyB3aGl0ZSBzcGFjZSwgYW5kIHRoZXJl4oCZcyBub1xuICAvLyBzZWdtZW50IGJyZWFrIGFmdGVyIHRoaXMgbm9kZSwgYWRkIGFuIGVtcHR5IHZhbHVlIHRoYXQgd2lsbCBiZSB0dXJuZWRcbiAgLy8gaW50byBhIHNwYWNlLlxuICBpZiAoc3RhcnQgIT09IGVuZCAmJiAhYnJlYWtBZnRlcikge1xuICAgIHJlc3VsdC5wdXNoKCcnKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5qb2luKCcgJylcbn1cblxuLyoqXG4gKiBGaWd1cmUgb3V0IHRoZSB3aGl0ZXNwYWNlIG9mIGEgbm9kZS5cbiAqXG4gKiBXZSBkb27igJl0IHN1cHBvcnQgdm9pZCBlbGVtZW50cyBoZXJlIChzbyBgbm9iciB3YnJgIC0+IGBub3JtYWxgIGlzIGlnbm9yZWQpLlxuICpcbiAqIEBwYXJhbSB7Tm9kZXN9IG5vZGVcbiAqICAgTm9kZSAodHlwaWNhbGx5IGBFbGVtZW50YCkuXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25JbmZvfSBpbmZvXG4gKiAgIEluZm8gb24gY3VycmVudCBjb2xsZWN0aW9uLlxuICogQHJldHVybnMge1doaXRlc3BhY2V9XG4gKiAgIEFwcGxpZWQgd2hpdGVzcGFjZS5cbiAqL1xuZnVuY3Rpb24gaW5mZXJXaGl0ZXNwYWNlKG5vZGUsIGluZm8pIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IG5vZGUucHJvcGVydGllcyB8fCB7fVxuICAgIHN3aXRjaCAobm9kZS50YWdOYW1lKSB7XG4gICAgICBjYXNlICdsaXN0aW5nJzpcbiAgICAgIGNhc2UgJ3BsYWludGV4dCc6XG4gICAgICBjYXNlICd4bXAnOiB7XG4gICAgICAgIHJldHVybiAncHJlJ1xuICAgICAgfVxuXG4gICAgICBjYXNlICdub2JyJzoge1xuICAgICAgICByZXR1cm4gJ25vd3JhcCdcbiAgICAgIH1cblxuICAgICAgY2FzZSAncHJlJzoge1xuICAgICAgICByZXR1cm4gcHJvcGVydGllcy53cmFwID8gJ3ByZS13cmFwJyA6ICdwcmUnXG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ3RkJzpcbiAgICAgIGNhc2UgJ3RoJzoge1xuICAgICAgICByZXR1cm4gcHJvcGVydGllcy5ub1dyYXAgPyAnbm93cmFwJyA6IGluZm8ud2hpdGVzcGFjZVxuICAgICAgfVxuXG4gICAgICBjYXNlICd0ZXh0YXJlYSc6IHtcbiAgICAgICAgcmV0dXJuICdwcmUtd3JhcCdcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5mby53aGl0ZXNwYWNlXG59XG5cbi8qKlxuICogQHR5cGUge1Rlc3RGdW5jdGlvbn1cbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge25vZGUgaXMge3Byb3BlcnRpZXM6IHtoaWRkZW46IHRydWV9fX1cbiAqL1xuZnVuY3Rpb24gaGlkZGVuKG5vZGUpIHtcbiAgcmV0dXJuIEJvb2xlYW4oKG5vZGUucHJvcGVydGllcyB8fCB7fSkuaGlkZGVuKVxufVxuXG4vKipcbiAqIEB0eXBlIHtUZXN0RnVuY3Rpb259XG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtub2RlIGlzIHt0YWdOYW1lOiAndGQnIHwgJ3RoJ319XG4gKi9cbmZ1bmN0aW9uIGlzQ2VsbChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUgPT09ICd0ZCcgfHwgbm9kZS50YWdOYW1lID09PSAndGgnXG59XG5cbi8qKlxuICogQHR5cGUge1Rlc3RGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gY2xvc2VkRGlhbG9nKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ2RpYWxvZycgJiYgIShub2RlLnByb3BlcnRpZXMgfHwge30pLm9wZW5cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/hast-util-to-text/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/hastscript/lib/create-h.js":
/*!*************************************************!*\
  !*** ./node_modules/hastscript/lib/create-h.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createH: () => (/* binding */ createH)\n/* harmony export */ });\n/* harmony import */ var comma_separated_tokens__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! comma-separated-tokens */ \"(app-pages-browser)/./node_modules/comma-separated-tokens/index.js\");\n/* harmony import */ var hast_util_parse_selector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hast-util-parse-selector */ \"(app-pages-browser)/./node_modules/hast-util-parse-selector/lib/index.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! property-information */ \"(app-pages-browser)/./node_modules/property-information/lib/find.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! property-information */ \"(app-pages-browser)/./node_modules/property-information/lib/normalize.js\");\n/* harmony import */ var space_separated_tokens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! space-separated-tokens */ \"(app-pages-browser)/./node_modules/space-separated-tokens/index.js\");\n/**\n * @import {Element, Nodes, RootContent, Root} from 'hast'\n * @import {Info, Schema} from 'property-information'\n */\n\n/**\n * @typedef {Array<Nodes | PrimitiveChild>} ArrayChildNested\n *   List of children (deep).\n */\n\n/**\n * @typedef {Array<ArrayChildNested | Nodes | PrimitiveChild>} ArrayChild\n *   List of children.\n */\n\n/**\n * @typedef {Array<number | string>} ArrayValue\n *   List of property values for space- or comma separated values (such as `className`).\n */\n\n/**\n * @typedef {ArrayChild | Nodes | PrimitiveChild} Child\n *   Acceptable child value.\n */\n\n/**\n * @typedef {number | string | null | undefined} PrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n */\n\n/**\n * @typedef {boolean | number | string | null | undefined} PrimitiveValue\n *   Primitive property value.\n */\n\n/**\n * @typedef {Record<string, PropertyValue | Style>} Properties\n *   Acceptable value for element properties.\n */\n\n/**\n * @typedef {ArrayValue | PrimitiveValue} PropertyValue\n *   Primitive value or list value.\n */\n\n/**\n * @typedef {Element | Root} Result\n *   Result from a `h` (or `s`) call.\n */\n\n/**\n * @typedef {number | string} StyleValue\n *   Value for a CSS style field.\n */\n\n/**\n * @typedef {Record<string, StyleValue>} Style\n *   Supported value of a `style` prop.\n */\n\n\n\n\n\n\n/**\n * @param {Schema} schema\n *   Schema to use.\n * @param {string} defaultTagName\n *   Default tag name.\n * @param {ReadonlyArray<string> | undefined} [caseSensitive]\n *   Case-sensitive tag names (default: `undefined`).\n * @returns\n *   `h`.\n */\nfunction createH(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive ? createAdjustMap(caseSensitive) : undefined\n\n  /**\n   * Hyperscript compatible DSL for creating virtual hast trees.\n   *\n   * @overload\n   * @param {null | undefined} [selector]\n   * @param {...Child} children\n   * @returns {Root}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {Properties} properties\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @param {string | null | undefined} [selector]\n   *   Selector.\n   * @param {Child | Properties | null | undefined} [properties]\n   *   Properties (or first child) (default: `undefined`).\n   * @param {...Child} children\n   *   Children.\n   * @returns {Result}\n   *   Result.\n   */\n  function h(selector, properties, ...children) {\n    /** @type {Result} */\n    let node\n\n    if (selector === null || selector === undefined) {\n      node = {type: 'root', children: []}\n      // Properties are not supported for roots.\n      const child = /** @type {Child} */ (properties)\n      children.unshift(child)\n    } else {\n      node = (0,hast_util_parse_selector__WEBPACK_IMPORTED_MODULE_0__.parseSelector)(selector, defaultTagName)\n      // Normalize the name.\n      const lower = node.tagName.toLowerCase()\n      const adjusted = adjust ? adjust.get(lower) : undefined\n      node.tagName = adjusted || lower\n\n      // Handle properties.\n      if (isChild(properties)) {\n        children.unshift(properties)\n      } else {\n        for (const [key, value] of Object.entries(properties)) {\n          addProperty(schema, node.properties, key, value)\n        }\n      }\n    }\n\n    // Handle children.\n    for (const child of children) {\n      addChild(node.children, child)\n    }\n\n    if (node.type === 'element' && node.tagName === 'template') {\n      node.content = {type: 'root', children: node.children}\n      node.children = []\n    }\n\n    return node\n  }\n\n  return h\n}\n\n/**\n * Check if something is properties or a child.\n *\n * @param {Child | Properties} value\n *   Value to check.\n * @returns {value is Child}\n *   Whether `value` is definitely a child.\n */\nfunction isChild(value) {\n  // Never properties if not an object.\n  if (value === null || typeof value !== 'object' || Array.isArray(value)) {\n    return true\n  }\n\n  // Never node without `type`; thats the main discriminator.\n  if (typeof value.type !== 'string') return false\n\n  // Slower check: never property value if object or array with\n  // non-number/strings.\n  const record = /** @type {Record<string, unknown>} */ (value)\n  const keys = Object.keys(value)\n\n  for (const key of keys) {\n    const value = record[key]\n\n    if (value && typeof value === 'object') {\n      if (!Array.isArray(value)) return true\n\n      const list = /** @type {ReadonlyArray<unknown>} */ (value)\n\n      for (const item of list) {\n        if (typeof item !== 'number' && typeof item !== 'string') {\n          return true\n        }\n      }\n    }\n  }\n\n  // Also see empty `children` as a node.\n  if ('children' in value && Array.isArray(value.children)) {\n    return true\n  }\n\n  // Default to properties, someone can always pass an empty object,\n  // put `data: {}` in a node,\n  // or wrap it in an array.\n  return false\n}\n\n/**\n * @param {Schema} schema\n *   Schema.\n * @param {Properties} properties\n *   Properties object.\n * @param {string} key\n *   Property name.\n * @param {PropertyValue | Style} value\n *   Property value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = (0,property_information__WEBPACK_IMPORTED_MODULE_1__.find)(schema, key)\n  /** @type {PropertyValue} */\n  let result\n\n  // Ignore nullish and NaN values.\n  if (value === null || value === undefined) return\n\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return\n\n    result = value\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = (0,space_separated_tokens__WEBPACK_IMPORTED_MODULE_2__.parse)(value)\n    } else if (info.commaSeparated) {\n      result = (0,comma_separated_tokens__WEBPACK_IMPORTED_MODULE_3__.parse)(value)\n    } else if (info.commaOrSpaceSeparated) {\n      result = (0,space_separated_tokens__WEBPACK_IMPORTED_MODULE_2__.parse)((0,comma_separated_tokens__WEBPACK_IMPORTED_MODULE_3__.parse)(value).join(' '))\n    } else {\n      result = parsePrimitive(info, info.property, value)\n    }\n  } else if (Array.isArray(value)) {\n    result = [...value]\n  } else {\n    result = info.property === 'style' ? style(value) : String(value)\n  }\n\n  if (Array.isArray(result)) {\n    /** @type {Array<number | string>} */\n    const finalResult = []\n\n    for (const item of result) {\n      // Assume no booleans in array.\n      finalResult.push(\n        /** @type {number | string} */ (\n          parsePrimitive(info, info.property, item)\n        )\n      )\n    }\n\n    result = finalResult\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // Assume no booleans in `className`.\n    result = properties.className.concat(\n      /** @type {Array<number | string> | number | string} */ (result)\n    )\n  }\n\n  properties[info.property] = result\n}\n\n/**\n * @param {Array<RootContent>} nodes\n *   Children.\n * @param {Child} value\n *   Child.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChild(nodes, value) {\n  if (value === null || value === undefined) {\n    // Empty.\n  } else if (typeof value === 'number' || typeof value === 'string') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    for (const child of value) {\n      addChild(nodes, child)\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`')\n  }\n}\n\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n *   Property information.\n * @param {string} name\n *   Property name.\n * @param {PrimitiveValue} value\n *   Property value.\n * @returns {PrimitiveValue}\n *   Property value.\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value)\n    }\n\n    if (\n      (info.boolean || info.overloadedBoolean) &&\n      (value === '' || (0,property_information__WEBPACK_IMPORTED_MODULE_4__.normalize)(value) === (0,property_information__WEBPACK_IMPORTED_MODULE_4__.normalize)(name))\n    ) {\n      return true\n    }\n  }\n\n  return value\n}\n\n/**\n * Serialize a `style` object as a string.\n *\n * @param {Style} styles\n *   Style object.\n * @returns {string}\n *   CSS string.\n */\nfunction style(styles) {\n  /** @type {Array<string>} */\n  const result = []\n\n  for (const [key, value] of Object.entries(styles)) {\n    result.push([key, value].join(': '))\n  }\n\n  return result.join('; ')\n}\n\n/**\n * Create a map to adjust casing.\n *\n * @param {ReadonlyArray<string>} values\n *   List of properly cased keys.\n * @returns {Map<string, string>}\n *   Map of lowercase keys to uppercase keys.\n */\nfunction createAdjustMap(values) {\n  /** @type {Map<string, string>} */\n  const result = new Map()\n\n  for (const value of values) {\n    result.set(value.toLowerCase(), value)\n  }\n\n  return result\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9oYXN0c2NyaXB0L2xpYi9jcmVhdGUtaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBLFlBQVksbUNBQW1DO0FBQy9DLFlBQVksY0FBYztBQUMxQjs7QUFFQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtEQUFrRDtBQUMvRDtBQUNBOztBQUVBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG9DQUFvQztBQUNqRDtBQUNBOztBQUVBO0FBQ0EsYUFBYSw4Q0FBOEM7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBLGFBQWEsdUNBQXVDO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQztBQUNBOztBQUVBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTs7QUFFQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDRCQUE0QjtBQUN6QztBQUNBOztBQUUyRDtBQUNMO0FBQ0Y7QUFDTzs7QUFFM0Q7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLG1DQUFtQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsVUFBVTtBQUN2QixlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0EsYUFBYSwyQkFBMkI7QUFDeEM7QUFDQSxhQUFhLHVDQUF1QztBQUNwRDtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBLE1BQU07QUFDTixhQUFhLHVFQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCLHdCQUF3Qjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBSTtBQUNuQixhQUFhLGVBQWU7QUFDNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2REFBVztBQUMxQixNQUFNO0FBQ04sZUFBZSw2REFBVztBQUMxQixNQUFNO0FBQ04sZUFBZSw2REFBVyxDQUFDLDZEQUFXO0FBQ3RDLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHdCQUF3QjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMENBQTBDO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0JBQWdCLG1DQUFtQztBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QiwrREFBUyxZQUFZLCtEQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9oYXN0c2NyaXB0L2xpYi9jcmVhdGUtaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge0VsZW1lbnQsIE5vZGVzLCBSb290Q29udGVudCwgUm9vdH0gZnJvbSAnaGFzdCdcbiAqIEBpbXBvcnQge0luZm8sIFNjaGVtYX0gZnJvbSAncHJvcGVydHktaW5mb3JtYXRpb24nXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7QXJyYXk8Tm9kZXMgfCBQcmltaXRpdmVDaGlsZD59IEFycmF5Q2hpbGROZXN0ZWRcbiAqICAgTGlzdCBvZiBjaGlsZHJlbiAoZGVlcCkuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7QXJyYXk8QXJyYXlDaGlsZE5lc3RlZCB8IE5vZGVzIHwgUHJpbWl0aXZlQ2hpbGQ+fSBBcnJheUNoaWxkXG4gKiAgIExpc3Qgb2YgY2hpbGRyZW4uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7QXJyYXk8bnVtYmVyIHwgc3RyaW5nPn0gQXJyYXlWYWx1ZVxuICogICBMaXN0IG9mIHByb3BlcnR5IHZhbHVlcyBmb3Igc3BhY2UtIG9yIGNvbW1hIHNlcGFyYXRlZCB2YWx1ZXMgKHN1Y2ggYXMgYGNsYXNzTmFtZWApLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0FycmF5Q2hpbGQgfCBOb2RlcyB8IFByaW1pdGl2ZUNoaWxkfSBDaGlsZFxuICogICBBY2NlcHRhYmxlIGNoaWxkIHZhbHVlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge251bWJlciB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFByaW1pdGl2ZUNoaWxkXG4gKiAgIFByaW1pdGl2ZSBjaGlsZHJlbiwgZWl0aGVyIGlnbm9yZWQgKG51bGxpc2gpLCBvciB0dXJuZWQgaW50byB0ZXh0IG5vZGVzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2Jvb2xlYW4gfCBudW1iZXIgfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBQcmltaXRpdmVWYWx1ZVxuICogICBQcmltaXRpdmUgcHJvcGVydHkgdmFsdWUuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7UmVjb3JkPHN0cmluZywgUHJvcGVydHlWYWx1ZSB8IFN0eWxlPn0gUHJvcGVydGllc1xuICogICBBY2NlcHRhYmxlIHZhbHVlIGZvciBlbGVtZW50IHByb3BlcnRpZXMuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7QXJyYXlWYWx1ZSB8IFByaW1pdGl2ZVZhbHVlfSBQcm9wZXJ0eVZhbHVlXG4gKiAgIFByaW1pdGl2ZSB2YWx1ZSBvciBsaXN0IHZhbHVlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0VsZW1lbnQgfCBSb290fSBSZXN1bHRcbiAqICAgUmVzdWx0IGZyb20gYSBgaGAgKG9yIGBzYCkgY2FsbC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtudW1iZXIgfCBzdHJpbmd9IFN0eWxlVmFsdWVcbiAqICAgVmFsdWUgZm9yIGEgQ1NTIHN0eWxlIGZpZWxkLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1JlY29yZDxzdHJpbmcsIFN0eWxlVmFsdWU+fSBTdHlsZVxuICogICBTdXBwb3J0ZWQgdmFsdWUgb2YgYSBgc3R5bGVgIHByb3AuXG4gKi9cblxuaW1wb3J0IHtwYXJzZSBhcyBwYXJzZUNvbW1hc30gZnJvbSAnY29tbWEtc2VwYXJhdGVkLXRva2VucydcbmltcG9ydCB7cGFyc2VTZWxlY3Rvcn0gZnJvbSAnaGFzdC11dGlsLXBhcnNlLXNlbGVjdG9yJ1xuaW1wb3J0IHtmaW5kLCBub3JtYWxpemV9IGZyb20gJ3Byb3BlcnR5LWluZm9ybWF0aW9uJ1xuaW1wb3J0IHtwYXJzZSBhcyBwYXJzZVNwYWNlc30gZnJvbSAnc3BhY2Utc2VwYXJhdGVkLXRva2VucydcblxuLyoqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiAgIFNjaGVtYSB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdFRhZ05hbWVcbiAqICAgRGVmYXVsdCB0YWcgbmFtZS5cbiAqIEBwYXJhbSB7UmVhZG9ubHlBcnJheTxzdHJpbmc+IHwgdW5kZWZpbmVkfSBbY2FzZVNlbnNpdGl2ZV1cbiAqICAgQ2FzZS1zZW5zaXRpdmUgdGFnIG5hbWVzIChkZWZhdWx0OiBgdW5kZWZpbmVkYCkuXG4gKiBAcmV0dXJuc1xuICogICBgaGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIKHNjaGVtYSwgZGVmYXVsdFRhZ05hbWUsIGNhc2VTZW5zaXRpdmUpIHtcbiAgY29uc3QgYWRqdXN0ID0gY2FzZVNlbnNpdGl2ZSA/IGNyZWF0ZUFkanVzdE1hcChjYXNlU2Vuc2l0aXZlKSA6IHVuZGVmaW5lZFxuXG4gIC8qKlxuICAgKiBIeXBlcnNjcmlwdCBjb21wYXRpYmxlIERTTCBmb3IgY3JlYXRpbmcgdmlydHVhbCBoYXN0IHRyZWVzLlxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtudWxsIHwgdW5kZWZpbmVkfSBbc2VsZWN0b3JdXG4gICAqIEBwYXJhbSB7Li4uQ2hpbGR9IGNoaWxkcmVuXG4gICAqIEByZXR1cm5zIHtSb290fVxuICAgKlxuICAgKiBAb3ZlcmxvYWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7UHJvcGVydGllc30gcHJvcGVydGllc1xuICAgKiBAcGFyYW0gey4uLkNoaWxkfSBjaGlsZHJlblxuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICpcbiAgICogQG92ZXJsb2FkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICAgKiBAcGFyYW0gey4uLkNoaWxkfSBjaGlsZHJlblxuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbc2VsZWN0b3JdXG4gICAqICAgU2VsZWN0b3IuXG4gICAqIEBwYXJhbSB7Q2hpbGQgfCBQcm9wZXJ0aWVzIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Byb3BlcnRpZXNdXG4gICAqICAgUHJvcGVydGllcyAob3IgZmlyc3QgY2hpbGQpIChkZWZhdWx0OiBgdW5kZWZpbmVkYCkuXG4gICAqIEBwYXJhbSB7Li4uQ2hpbGR9IGNoaWxkcmVuXG4gICAqICAgQ2hpbGRyZW4uXG4gICAqIEByZXR1cm5zIHtSZXN1bHR9XG4gICAqICAgUmVzdWx0LlxuICAgKi9cbiAgZnVuY3Rpb24gaChzZWxlY3RvciwgcHJvcGVydGllcywgLi4uY2hpbGRyZW4pIHtcbiAgICAvKiogQHR5cGUge1Jlc3VsdH0gKi9cbiAgICBsZXQgbm9kZVxuXG4gICAgaWYgKHNlbGVjdG9yID09PSBudWxsIHx8IHNlbGVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vZGUgPSB7dHlwZTogJ3Jvb3QnLCBjaGlsZHJlbjogW119XG4gICAgICAvLyBQcm9wZXJ0aWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciByb290cy5cbiAgICAgIGNvbnN0IGNoaWxkID0gLyoqIEB0eXBlIHtDaGlsZH0gKi8gKHByb3BlcnRpZXMpXG4gICAgICBjaGlsZHJlbi51bnNoaWZ0KGNoaWxkKVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gcGFyc2VTZWxlY3RvcihzZWxlY3RvciwgZGVmYXVsdFRhZ05hbWUpXG4gICAgICAvLyBOb3JtYWxpemUgdGhlIG5hbWUuXG4gICAgICBjb25zdCBsb3dlciA9IG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICBjb25zdCBhZGp1c3RlZCA9IGFkanVzdCA/IGFkanVzdC5nZXQobG93ZXIpIDogdW5kZWZpbmVkXG4gICAgICBub2RlLnRhZ05hbWUgPSBhZGp1c3RlZCB8fCBsb3dlclxuXG4gICAgICAvLyBIYW5kbGUgcHJvcGVydGllcy5cbiAgICAgIGlmIChpc0NoaWxkKHByb3BlcnRpZXMpKSB7XG4gICAgICAgIGNoaWxkcmVuLnVuc2hpZnQocHJvcGVydGllcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgYWRkUHJvcGVydHkoc2NoZW1hLCBub2RlLnByb3BlcnRpZXMsIGtleSwgdmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY2hpbGRyZW4uXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgYWRkQ2hpbGQobm9kZS5jaGlsZHJlbiwgY2hpbGQpXG4gICAgfVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2VsZW1lbnQnICYmIG5vZGUudGFnTmFtZSA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgbm9kZS5jb250ZW50ID0ge3R5cGU6ICdyb290JywgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW59XG4gICAgICBub2RlLmNoaWxkcmVuID0gW11cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgcmV0dXJuIGhcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBzb21ldGhpbmcgaXMgcHJvcGVydGllcyBvciBhIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Q2hpbGQgfCBQcm9wZXJ0aWVzfSB2YWx1ZVxuICogICBWYWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHt2YWx1ZSBpcyBDaGlsZH1cbiAqICAgV2hldGhlciBgdmFsdWVgIGlzIGRlZmluaXRlbHkgYSBjaGlsZC5cbiAqL1xuZnVuY3Rpb24gaXNDaGlsZCh2YWx1ZSkge1xuICAvLyBOZXZlciBwcm9wZXJ0aWVzIGlmIG5vdCBhbiBvYmplY3QuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIE5ldmVyIG5vZGUgd2l0aG91dCBgdHlwZWA7IHRoYXTigJlzIHRoZSBtYWluIGRpc2NyaW1pbmF0b3IuXG4gIGlmICh0eXBlb2YgdmFsdWUudHlwZSAhPT0gJ3N0cmluZycpIHJldHVybiBmYWxzZVxuXG4gIC8vIFNsb3dlciBjaGVjazogbmV2ZXIgcHJvcGVydHkgdmFsdWUgaWYgb2JqZWN0IG9yIGFycmF5IHdpdGhcbiAgLy8gbm9uLW51bWJlci9zdHJpbmdzLlxuICBjb25zdCByZWNvcmQgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSAqLyAodmFsdWUpXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSlcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3QgdmFsdWUgPSByZWNvcmRba2V5XVxuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB0cnVlXG5cbiAgICAgIGNvbnN0IGxpc3QgPSAvKiogQHR5cGUge1JlYWRvbmx5QXJyYXk8dW5rbm93bj59ICovICh2YWx1ZSlcblxuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGxpc3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgaXRlbSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQWxzbyBzZWUgZW1wdHkgYGNoaWxkcmVuYCBhcyBhIG5vZGUuXG4gIGlmICgnY2hpbGRyZW4nIGluIHZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUuY2hpbGRyZW4pKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIERlZmF1bHQgdG8gcHJvcGVydGllcywgc29tZW9uZSBjYW4gYWx3YXlzIHBhc3MgYW4gZW1wdHkgb2JqZWN0LFxuICAvLyBwdXQgYGRhdGE6IHt9YCBpbiBhIG5vZGUsXG4gIC8vIG9yIHdyYXAgaXQgaW4gYW4gYXJyYXkuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqICAgU2NoZW1hLlxuICogQHBhcmFtIHtQcm9wZXJ0aWVzfSBwcm9wZXJ0aWVzXG4gKiAgIFByb3BlcnRpZXMgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogICBQcm9wZXJ0eSBuYW1lLlxuICogQHBhcmFtIHtQcm9wZXJ0eVZhbHVlIHwgU3R5bGV9IHZhbHVlXG4gKiAgIFByb3BlcnR5IHZhbHVlLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gYWRkUHJvcGVydHkoc2NoZW1hLCBwcm9wZXJ0aWVzLCBrZXksIHZhbHVlKSB7XG4gIGNvbnN0IGluZm8gPSBmaW5kKHNjaGVtYSwga2V5KVxuICAvKiogQHR5cGUge1Byb3BlcnR5VmFsdWV9ICovXG4gIGxldCByZXN1bHRcblxuICAvLyBJZ25vcmUgbnVsbGlzaCBhbmQgTmFOIHZhbHVlcy5cbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVyblxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgLy8gSWdub3JlIE5hTi5cbiAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbHVlKSkgcmV0dXJuXG5cbiAgICByZXN1bHQgPSB2YWx1ZVxuICB9XG4gIC8vIEJvb2xlYW5zLlxuICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgIHJlc3VsdCA9IHZhbHVlXG4gIH1cbiAgLy8gSGFuZGxlIGxpc3QgdmFsdWVzLlxuICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGluZm8uc3BhY2VTZXBhcmF0ZWQpIHtcbiAgICAgIHJlc3VsdCA9IHBhcnNlU3BhY2VzKHZhbHVlKVxuICAgIH0gZWxzZSBpZiAoaW5mby5jb21tYVNlcGFyYXRlZCkge1xuICAgICAgcmVzdWx0ID0gcGFyc2VDb21tYXModmFsdWUpXG4gICAgfSBlbHNlIGlmIChpbmZvLmNvbW1hT3JTcGFjZVNlcGFyYXRlZCkge1xuICAgICAgcmVzdWx0ID0gcGFyc2VTcGFjZXMocGFyc2VDb21tYXModmFsdWUpLmpvaW4oJyAnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gcGFyc2VQcmltaXRpdmUoaW5mbywgaW5mby5wcm9wZXJ0eSwgdmFsdWUpXG4gICAgfVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmVzdWx0ID0gWy4uLnZhbHVlXVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IGluZm8ucHJvcGVydHkgPT09ICdzdHlsZScgPyBzdHlsZSh2YWx1ZSkgOiBTdHJpbmcodmFsdWUpXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXIgfCBzdHJpbmc+fSAqL1xuICAgIGNvbnN0IGZpbmFsUmVzdWx0ID0gW11cblxuICAgIGZvciAoY29uc3QgaXRlbSBvZiByZXN1bHQpIHtcbiAgICAgIC8vIEFzc3VtZSBubyBib29sZWFucyBpbiBhcnJheS5cbiAgICAgIGZpbmFsUmVzdWx0LnB1c2goXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyIHwgc3RyaW5nfSAqLyAoXG4gICAgICAgICAgcGFyc2VQcmltaXRpdmUoaW5mbywgaW5mby5wcm9wZXJ0eSwgaXRlbSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH1cblxuICAgIHJlc3VsdCA9IGZpbmFsUmVzdWx0XG4gIH1cblxuICAvLyBDbGFzcyBuYW1lcyAod2hpY2ggY2FuIGJlIGFkZGVkIGJvdGggb24gdGhlIGBzZWxlY3RvcmAgYW5kIGhlcmUpLlxuICBpZiAoaW5mby5wcm9wZXJ0eSA9PT0gJ2NsYXNzTmFtZScgJiYgQXJyYXkuaXNBcnJheShwcm9wZXJ0aWVzLmNsYXNzTmFtZSkpIHtcbiAgICAvLyBBc3N1bWUgbm8gYm9vbGVhbnMgaW4gYGNsYXNzTmFtZWAuXG4gICAgcmVzdWx0ID0gcHJvcGVydGllcy5jbGFzc05hbWUuY29uY2F0KFxuICAgICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXIgfCBzdHJpbmc+IHwgbnVtYmVyIHwgc3RyaW5nfSAqLyAocmVzdWx0KVxuICAgIClcbiAgfVxuXG4gIHByb3BlcnRpZXNbaW5mby5wcm9wZXJ0eV0gPSByZXN1bHRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFJvb3RDb250ZW50Pn0gbm9kZXNcbiAqICAgQ2hpbGRyZW4uXG4gKiBAcGFyYW0ge0NoaWxkfSB2YWx1ZVxuICogICBDaGlsZC5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIGFkZENoaWxkKG5vZGVzLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIEVtcHR5LlxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIG5vZGVzLnB1c2goe3R5cGU6ICd0ZXh0JywgdmFsdWU6IFN0cmluZyh2YWx1ZSl9KVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB2YWx1ZSkge1xuICAgICAgYWRkQ2hpbGQobm9kZXMsIGNoaWxkKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICd0eXBlJyBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS50eXBlID09PSAncm9vdCcpIHtcbiAgICAgIGFkZENoaWxkKG5vZGVzLCB2YWx1ZS5jaGlsZHJlbilcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZXMucHVzaCh2YWx1ZSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBub2RlLCBub2Rlcywgb3Igc3RyaW5nLCBnb3QgYCcgKyB2YWx1ZSArICdgJylcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgc2luZ2xlIHByaW1pdGl2ZXMuXG4gKlxuICogQHBhcmFtIHtJbmZvfSBpbmZvXG4gKiAgIFByb3BlcnR5IGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqICAgUHJvcGVydHkgbmFtZS5cbiAqIEBwYXJhbSB7UHJpbWl0aXZlVmFsdWV9IHZhbHVlXG4gKiAgIFByb3BlcnR5IHZhbHVlLlxuICogQHJldHVybnMge1ByaW1pdGl2ZVZhbHVlfVxuICogICBQcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VQcmltaXRpdmUoaW5mbywgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoaW5mby5udW1iZXIgJiYgdmFsdWUgJiYgIU51bWJlci5pc05hTihOdW1iZXIodmFsdWUpKSkge1xuICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSlcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAoaW5mby5ib29sZWFuIHx8IGluZm8ub3ZlcmxvYWRlZEJvb2xlYW4pICYmXG4gICAgICAodmFsdWUgPT09ICcnIHx8IG5vcm1hbGl6ZSh2YWx1ZSkgPT09IG5vcm1hbGl6ZShuYW1lKSlcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogU2VyaWFsaXplIGEgYHN0eWxlYCBvYmplY3QgYXMgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHlsZX0gc3R5bGVzXG4gKiAgIFN0eWxlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiAgIENTUyBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHN0eWxlKHN0eWxlcykge1xuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gIGNvbnN0IHJlc3VsdCA9IFtdXG5cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc3R5bGVzKSkge1xuICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlXS5qb2luKCc6ICcpKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5qb2luKCc7ICcpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbWFwIHRvIGFkanVzdCBjYXNpbmcuXG4gKlxuICogQHBhcmFtIHtSZWFkb25seUFycmF5PHN0cmluZz59IHZhbHVlc1xuICogICBMaXN0IG9mIHByb3Blcmx5IGNhc2VkIGtleXMuXG4gKiBAcmV0dXJucyB7TWFwPHN0cmluZywgc3RyaW5nPn1cbiAqICAgTWFwIG9mIGxvd2VyY2FzZSBrZXlzIHRvIHVwcGVyY2FzZSBrZXlzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBZGp1c3RNYXAodmFsdWVzKSB7XG4gIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpXG5cbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICByZXN1bHQuc2V0KHZhbHVlLnRvTG93ZXJDYXNlKCksIHZhbHVlKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/hastscript/lib/create-h.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/hastscript/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/hastscript/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   h: () => (/* binding */ h),\n/* harmony export */   s: () => (/* binding */ s)\n/* harmony export */ });\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! property-information */ \"(app-pages-browser)/./node_modules/property-information/index.js\");\n/* harmony import */ var _create_h_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create-h.js */ \"(app-pages-browser)/./node_modules/hastscript/lib/create-h.js\");\n/* harmony import */ var _svg_case_sensitive_tag_names_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./svg-case-sensitive-tag-names.js */ \"(app-pages-browser)/./node_modules/hastscript/lib/svg-case-sensitive-tag-names.js\");\n// Register the JSX namespace on `h`.\n/**\n * @typedef {import('./jsx-classic.js').Element} h.JSX.Element\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} h.JSX.ElementChildrenAttribute\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} h.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} h.JSX.IntrinsicElements\n */\n\n// Register the JSX namespace on `s`.\n/**\n * @typedef {import('./jsx-classic.js').Element} s.JSX.Element\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} s.JSX.ElementChildrenAttribute\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} s.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} s.JSX.IntrinsicElements\n */\n\n\n\n\n\n// Note: this explicit type is needed, otherwise TS creates broken types.\n/** @type {ReturnType<createH>} */\nconst h = (0,_create_h_js__WEBPACK_IMPORTED_MODULE_0__.createH)(property_information__WEBPACK_IMPORTED_MODULE_1__.html, 'div')\n\n// Note: this explicit type is needed, otherwise TS creates broken types.\n/** @type {ReturnType<createH>} */\nconst s = (0,_create_h_js__WEBPACK_IMPORTED_MODULE_0__.createH)(property_information__WEBPACK_IMPORTED_MODULE_1__.svg, 'g', _svg_case_sensitive_tag_names_js__WEBPACK_IMPORTED_MODULE_2__.svgCaseSensitiveTagNames)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9oYXN0c2NyaXB0L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxhQUFhLG9DQUFvQztBQUNqRCxhQUFhLHFEQUFxRDtBQUNsRSxhQUFhLGdEQUFnRDtBQUM3RCxhQUFhLDhDQUE4QztBQUMzRDs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxvQ0FBb0M7QUFDakQsYUFBYSxxREFBcUQ7QUFDbEUsYUFBYSxnREFBZ0Q7QUFDN0QsYUFBYSw4Q0FBOEM7QUFDM0Q7O0FBRThDO0FBQ1Q7QUFDcUM7O0FBRTFFO0FBQ0EsV0FBVyxxQkFBcUI7QUFDekIsVUFBVSxxREFBTyxDQUFDLHNEQUFJOztBQUU3QjtBQUNBLFdBQVcscUJBQXFCO0FBQ3pCLFVBQVUscURBQU8sQ0FBQyxxREFBRyxPQUFPLHNGQUF3QiIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvaGFzdHNjcmlwdC9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUmVnaXN0ZXIgdGhlIEpTWCBuYW1lc3BhY2Ugb24gYGhgLlxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2pzeC1jbGFzc2ljLmpzJykuRWxlbWVudH0gaC5KU1guRWxlbWVudFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9qc3gtY2xhc3NpYy5qcycpLkVsZW1lbnRDaGlsZHJlbkF0dHJpYnV0ZX0gaC5KU1guRWxlbWVudENoaWxkcmVuQXR0cmlidXRlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2pzeC1jbGFzc2ljLmpzJykuSW50cmluc2ljQXR0cmlidXRlc30gaC5KU1guSW50cmluc2ljQXR0cmlidXRlc1xuICogQHR5cGVkZWYge2ltcG9ydCgnLi9qc3gtY2xhc3NpYy5qcycpLkludHJpbnNpY0VsZW1lbnRzfSBoLkpTWC5JbnRyaW5zaWNFbGVtZW50c1xuICovXG5cbi8vIFJlZ2lzdGVyIHRoZSBKU1ggbmFtZXNwYWNlIG9uIGBzYC5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9qc3gtY2xhc3NpYy5qcycpLkVsZW1lbnR9IHMuSlNYLkVsZW1lbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vanN4LWNsYXNzaWMuanMnKS5FbGVtZW50Q2hpbGRyZW5BdHRyaWJ1dGV9IHMuSlNYLkVsZW1lbnRDaGlsZHJlbkF0dHJpYnV0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnLi9qc3gtY2xhc3NpYy5qcycpLkludHJpbnNpY0F0dHJpYnV0ZXN9IHMuSlNYLkludHJpbnNpY0F0dHJpYnV0ZXNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vanN4LWNsYXNzaWMuanMnKS5JbnRyaW5zaWNFbGVtZW50c30gcy5KU1guSW50cmluc2ljRWxlbWVudHNcbiAqL1xuXG5pbXBvcnQge2h0bWwsIHN2Z30gZnJvbSAncHJvcGVydHktaW5mb3JtYXRpb24nXG5pbXBvcnQge2NyZWF0ZUh9IGZyb20gJy4vY3JlYXRlLWguanMnXG5pbXBvcnQge3N2Z0Nhc2VTZW5zaXRpdmVUYWdOYW1lc30gZnJvbSAnLi9zdmctY2FzZS1zZW5zaXRpdmUtdGFnLW5hbWVzLmpzJ1xuXG4vLyBOb3RlOiB0aGlzIGV4cGxpY2l0IHR5cGUgaXMgbmVlZGVkLCBvdGhlcndpc2UgVFMgY3JlYXRlcyBicm9rZW4gdHlwZXMuXG4vKiogQHR5cGUge1JldHVyblR5cGU8Y3JlYXRlSD59ICovXG5leHBvcnQgY29uc3QgaCA9IGNyZWF0ZUgoaHRtbCwgJ2RpdicpXG5cbi8vIE5vdGU6IHRoaXMgZXhwbGljaXQgdHlwZSBpcyBuZWVkZWQsIG90aGVyd2lzZSBUUyBjcmVhdGVzIGJyb2tlbiB0eXBlcy5cbi8qKiBAdHlwZSB7UmV0dXJuVHlwZTxjcmVhdGVIPn0gKi9cbmV4cG9ydCBjb25zdCBzID0gY3JlYXRlSChzdmcsICdnJywgc3ZnQ2FzZVNlbnNpdGl2ZVRhZ05hbWVzKVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/hastscript/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/hastscript/lib/svg-case-sensitive-tag-names.js":
/*!*********************************************************************!*\
  !*** ./node_modules/hastscript/lib/svg-case-sensitive-tag-names.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   svgCaseSensitiveTagNames: () => (/* binding */ svgCaseSensitiveTagNames)\n/* harmony export */ });\n/**\n * List of case-sensitive SVG tag names.\n *\n * @type {ReadonlyArray<string>}\n */\nconst svgCaseSensitiveTagNames = [\n  'altGlyph',\n  'altGlyphDef',\n  'altGlyphItem',\n  'animateColor',\n  'animateMotion',\n  'animateTransform',\n  'clipPath',\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n  'foreignObject',\n  'glyphRef',\n  'linearGradient',\n  'radialGradient',\n  'solidColor',\n  'textArea',\n  'textPath'\n]\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9oYXN0c2NyaXB0L2xpYi9zdmctY2FzZS1zZW5zaXRpdmUtdGFnLW5hbWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9oYXN0c2NyaXB0L2xpYi9zdmctY2FzZS1zZW5zaXRpdmUtdGFnLW5hbWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTGlzdCBvZiBjYXNlLXNlbnNpdGl2ZSBTVkcgdGFnIG5hbWVzLlxuICpcbiAqIEB0eXBlIHtSZWFkb25seUFycmF5PHN0cmluZz59XG4gKi9cbmV4cG9ydCBjb25zdCBzdmdDYXNlU2Vuc2l0aXZlVGFnTmFtZXMgPSBbXG4gICdhbHRHbHlwaCcsXG4gICdhbHRHbHlwaERlZicsXG4gICdhbHRHbHlwaEl0ZW0nLFxuICAnYW5pbWF0ZUNvbG9yJyxcbiAgJ2FuaW1hdGVNb3Rpb24nLFxuICAnYW5pbWF0ZVRyYW5zZm9ybScsXG4gICdjbGlwUGF0aCcsXG4gICdmZUJsZW5kJyxcbiAgJ2ZlQ29sb3JNYXRyaXgnLFxuICAnZmVDb21wb25lbnRUcmFuc2ZlcicsXG4gICdmZUNvbXBvc2l0ZScsXG4gICdmZUNvbnZvbHZlTWF0cml4JyxcbiAgJ2ZlRGlmZnVzZUxpZ2h0aW5nJyxcbiAgJ2ZlRGlzcGxhY2VtZW50TWFwJyxcbiAgJ2ZlRGlzdGFudExpZ2h0JyxcbiAgJ2ZlRHJvcFNoYWRvdycsXG4gICdmZUZsb29kJyxcbiAgJ2ZlRnVuY0EnLFxuICAnZmVGdW5jQicsXG4gICdmZUZ1bmNHJyxcbiAgJ2ZlRnVuY1InLFxuICAnZmVHYXVzc2lhbkJsdXInLFxuICAnZmVJbWFnZScsXG4gICdmZU1lcmdlJyxcbiAgJ2ZlTWVyZ2VOb2RlJyxcbiAgJ2ZlTW9ycGhvbG9neScsXG4gICdmZU9mZnNldCcsXG4gICdmZVBvaW50TGlnaHQnLFxuICAnZmVTcGVjdWxhckxpZ2h0aW5nJyxcbiAgJ2ZlU3BvdExpZ2h0JyxcbiAgJ2ZlVGlsZScsXG4gICdmZVR1cmJ1bGVuY2UnLFxuICAnZm9yZWlnbk9iamVjdCcsXG4gICdnbHlwaFJlZicsXG4gICdsaW5lYXJHcmFkaWVudCcsXG4gICdyYWRpYWxHcmFkaWVudCcsXG4gICdzb2xpZENvbG9yJyxcbiAgJ3RleHRBcmVhJyxcbiAgJ3RleHRQYXRoJ1xuXVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/hastscript/lib/svg-case-sensitive-tag-names.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/katex/dist/katex.mjs":
/*!*******************************************!*\
  !*** ./node_modules/katex/dist/katex.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ParseError: () => (/* binding */ ParseError),\n/* harmony export */   SETTINGS_SCHEMA: () => (/* binding */ SETTINGS_SCHEMA),\n/* harmony export */   __defineFunction: () => (/* binding */ defineFunction),\n/* harmony export */   __defineMacro: () => (/* binding */ defineMacro),\n/* harmony export */   __defineSymbol: () => (/* binding */ defineSymbol),\n/* harmony export */   __domTree: () => (/* binding */ __domTree),\n/* harmony export */   __parse: () => (/* binding */ generateParseTree),\n/* harmony export */   __renderToDomTree: () => (/* binding */ renderToDomTree),\n/* harmony export */   __renderToHTMLTree: () => (/* binding */ renderToHTMLTree),\n/* harmony export */   __setFontMetrics: () => (/* binding */ setFontMetrics),\n/* harmony export */   \"default\": () => (/* binding */ katex),\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   renderToString: () => (/* binding */ renderToString),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/**\n * Lexing or parsing positional information for error reporting.\n * This object is immutable.\n */\nclass SourceLocation {\n  // The + prefix indicates that these fields aren't writeable\n  // Lexer holding the input string.\n  // Start offset, zero-based inclusive.\n  // End offset, zero-based exclusive.\n  constructor(lexer, start, end) {\n    this.lexer = void 0;\n    this.start = void 0;\n    this.end = void 0;\n    this.lexer = lexer;\n    this.start = start;\n    this.end = end;\n  }\n  /**\n   * Merges two `SourceLocation`s from location providers, given they are\n   * provided in order of appearance.\n   * - Returns the first one's location if only the first is provided.\n   * - Returns a merged range of the first and the last if both are provided\n   *   and their lexers match.\n   * - Otherwise, returns null.\n   */\n\n\n  static range(first, second) {\n    if (!second) {\n      return first && first.loc;\n    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {\n      return null;\n    } else {\n      return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);\n    }\n  }\n\n}\n\n/**\n * Interface required to break circular dependency between Token, Lexer, and\n * ParseError.\n */\n\n/**\n * The resulting token returned from `lex`.\n *\n * It consists of the token text plus some position information.\n * The position information is essentially a range in an input string,\n * but instead of referencing the bare input string, we refer to the lexer.\n * That way it is possible to attach extra metadata to the input string,\n * like for example a file name or similar.\n *\n * The position information is optional, so it is OK to construct synthetic\n * tokens if appropriate. Not providing available position information may\n * lead to degraded error reporting, though.\n */\nclass Token {\n  // don't expand the token\n  // used in \\noexpand\n  constructor(text, // the text of this token\n  loc) {\n    this.text = void 0;\n    this.loc = void 0;\n    this.noexpand = void 0;\n    this.treatAsRelax = void 0;\n    this.text = text;\n    this.loc = loc;\n  }\n  /**\n   * Given a pair of tokens (this and endToken), compute a `Token` encompassing\n   * the whole input range enclosed by these two.\n   */\n\n\n  range(endToken, // last token of the range, inclusive\n  text // the text of the newly constructed token\n  ) {\n    return new Token(text, SourceLocation.range(this, endToken));\n  }\n\n}\n\n/**\n * This is the ParseError class, which is the main error thrown by KaTeX\n * functions when something has gone wrong. This is used to distinguish internal\n * errors from errors in the expression that the user provided.\n *\n * If possible, a caller should provide a Token or ParseNode with information\n * about where in the source string the problem occurred.\n */\nclass ParseError {\n  // Error start position based on passed-in Token or ParseNode.\n  // Length of affected text based on passed-in Token or ParseNode.\n  // The underlying error message without any context added.\n  constructor(message, // The error message\n  token // An object providing position information\n  ) {\n    this.name = void 0;\n    this.position = void 0;\n    this.length = void 0;\n    this.rawMessage = void 0;\n    var error = \"KaTeX parse error: \" + message;\n    var start;\n    var end;\n    var loc = token && token.loc;\n\n    if (loc && loc.start <= loc.end) {\n      // If we have the input and a position, make the error a bit fancier\n      // Get the input\n      var input = loc.lexer.input; // Prepend some information\n\n      start = loc.start;\n      end = loc.end;\n\n      if (start === input.length) {\n        error += \" at end of input: \";\n      } else {\n        error += \" at position \" + (start + 1) + \": \";\n      } // Underline token in question using combining underscores\n\n\n      var underlined = input.slice(start, end).replace(/[^]/g, \"$&\\u0332\"); // Extract some context from the input and add it to the error\n\n      var left;\n\n      if (start > 15) {\n        left = \"\" + input.slice(start - 15, start);\n      } else {\n        left = input.slice(0, start);\n      }\n\n      var right;\n\n      if (end + 15 < input.length) {\n        right = input.slice(end, end + 15) + \"\";\n      } else {\n        right = input.slice(end);\n      }\n\n      error += left + underlined + right;\n    } // Some hackery to make ParseError a prototype of Error\n    // See http://stackoverflow.com/a/8460753\n    // $FlowFixMe\n\n\n    var self = new Error(error);\n    self.name = \"ParseError\"; // $FlowFixMe\n\n    self.__proto__ = ParseError.prototype;\n    self.position = start;\n\n    if (start != null && end != null) {\n      self.length = end - start;\n    }\n\n    self.rawMessage = message;\n    return self;\n  }\n\n} // $FlowFixMe More hackery\n\n\nParseError.prototype.__proto__ = Error.prototype;\n\n/**\n * This file contains a list of utility functions which are useful in other\n * files.\n */\n\n/**\n * Provide a default value if a setting is undefined\n * NOTE: Couldn't use `T` as the output type due to facebook/flow#5022.\n */\nvar deflt = function deflt(setting, defaultIfUndefined) {\n  return setting === undefined ? defaultIfUndefined : setting;\n}; // hyphenate and escape adapted from Facebook's React under Apache 2 license\n\n\nvar uppercase = /([A-Z])/g;\n\nvar hyphenate = function hyphenate(str) {\n  return str.replace(uppercase, \"-$1\").toLowerCase();\n};\n\nvar ESCAPE_LOOKUP = {\n  \"&\": \"&amp;\",\n  \">\": \"&gt;\",\n  \"<\": \"&lt;\",\n  \"\\\"\": \"&quot;\",\n  \"'\": \"&#x27;\"\n};\nvar ESCAPE_REGEX = /[&><\"']/g;\n/**\n * Escapes text to prevent scripting attacks.\n */\n\nfunction escape(text) {\n  return String(text).replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);\n}\n/**\n * Sometimes we want to pull out the innermost element of a group. In most\n * cases, this will just be the group itself, but when ordgroups and colors have\n * a single element, we want to pull that out.\n */\n\n\nvar getBaseElem = function getBaseElem(group) {\n  if (group.type === \"ordgroup\") {\n    if (group.body.length === 1) {\n      return getBaseElem(group.body[0]);\n    } else {\n      return group;\n    }\n  } else if (group.type === \"color\") {\n    if (group.body.length === 1) {\n      return getBaseElem(group.body[0]);\n    } else {\n      return group;\n    }\n  } else if (group.type === \"font\") {\n    return getBaseElem(group.body);\n  } else {\n    return group;\n  }\n};\n/**\n * TeXbook algorithms often reference \"character boxes\", which are simply groups\n * with a single character in them. To decide if something is a character box,\n * we find its innermost group, and see if it is a single character.\n */\n\n\nvar isCharacterBox = function isCharacterBox(group) {\n  var baseElem = getBaseElem(group); // These are all they types of groups which hold single characters\n\n  return baseElem.type === \"mathord\" || baseElem.type === \"textord\" || baseElem.type === \"atom\";\n};\n\nvar assert = function assert(value) {\n  if (!value) {\n    throw new Error('Expected non-null, but got ' + String(value));\n  }\n\n  return value;\n};\n/**\n * Return the protocol of a URL, or \"_relative\" if the URL does not specify a\n * protocol (and thus is relative), or `null` if URL has invalid protocol\n * (so should be outright rejected).\n */\n\nvar protocolFromUrl = function protocolFromUrl(url) {\n  // Check for possible leading protocol.\n  // https://url.spec.whatwg.org/#url-parsing strips leading whitespace\n  // (U+20) or C0 control (U+00-U+1F) characters.\n  // eslint-disable-next-line no-control-regex\n  var protocol = /^[\\x00-\\x20]*([^\\\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);\n\n  if (!protocol) {\n    return \"_relative\";\n  } // Reject weird colons\n\n\n  if (protocol[2] !== \":\") {\n    return null;\n  } // Reject invalid characters in scheme according to\n  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.1\n\n\n  if (!/^[a-zA-Z][a-zA-Z0-9+\\-.]*$/.test(protocol[1])) {\n    return null;\n  } // Lowercase the protocol\n\n\n  return protocol[1].toLowerCase();\n};\nvar utils = {\n  deflt,\n  escape,\n  hyphenate,\n  getBaseElem,\n  isCharacterBox,\n  protocolFromUrl\n};\n\n/* eslint no-console:0 */\n// TODO: automatically generate documentation\n// TODO: check all properties on Settings exist\n// TODO: check the type of a property on Settings matches\nvar SETTINGS_SCHEMA = {\n  displayMode: {\n    type: \"boolean\",\n    description: \"Render math in display mode, which puts the math in \" + \"display style (so \\\\int and \\\\sum are large, for example), and \" + \"centers the math on the page on its own line.\",\n    cli: \"-d, --display-mode\"\n  },\n  output: {\n    type: {\n      enum: [\"htmlAndMathml\", \"html\", \"mathml\"]\n    },\n    description: \"Determines the markup language of the output.\",\n    cli: \"-F, --format <type>\"\n  },\n  leqno: {\n    type: \"boolean\",\n    description: \"Render display math in leqno style (left-justified tags).\"\n  },\n  fleqn: {\n    type: \"boolean\",\n    description: \"Render display math flush left.\"\n  },\n  throwOnError: {\n    type: \"boolean\",\n    default: true,\n    cli: \"-t, --no-throw-on-error\",\n    cliDescription: \"Render errors (in the color given by --error-color) ins\" + \"tead of throwing a ParseError exception when encountering an error.\"\n  },\n  errorColor: {\n    type: \"string\",\n    default: \"#cc0000\",\n    cli: \"-c, --error-color <color>\",\n    cliDescription: \"A color string given in the format 'rgb' or 'rrggbb' \" + \"(no #). This option determines the color of errors rendered by the \" + \"-t option.\",\n    cliProcessor: color => \"#\" + color\n  },\n  macros: {\n    type: \"object\",\n    cli: \"-m, --macro <def>\",\n    cliDescription: \"Define custom macro of the form '\\\\foo:expansion' (use \" + \"multiple -m arguments for multiple macros).\",\n    cliDefault: [],\n    cliProcessor: (def, defs) => {\n      defs.push(def);\n      return defs;\n    }\n  },\n  minRuleThickness: {\n    type: \"number\",\n    description: \"Specifies a minimum thickness, in ems, for fraction lines,\" + \" `\\\\sqrt` top lines, `{array}` vertical lines, `\\\\hline`, \" + \"`\\\\hdashline`, `\\\\underline`, `\\\\overline`, and the borders of \" + \"`\\\\fbox`, `\\\\boxed`, and `\\\\fcolorbox`.\",\n    processor: t => Math.max(0, t),\n    cli: \"--min-rule-thickness <size>\",\n    cliProcessor: parseFloat\n  },\n  colorIsTextColor: {\n    type: \"boolean\",\n    description: \"Makes \\\\color behave like LaTeX's 2-argument \\\\textcolor, \" + \"instead of LaTeX's one-argument \\\\color mode change.\",\n    cli: \"-b, --color-is-text-color\"\n  },\n  strict: {\n    type: [{\n      enum: [\"warn\", \"ignore\", \"error\"]\n    }, \"boolean\", \"function\"],\n    description: \"Turn on strict / LaTeX faithfulness mode, which throws an \" + \"error if the input uses features that are not supported by LaTeX.\",\n    cli: \"-S, --strict\",\n    cliDefault: false\n  },\n  trust: {\n    type: [\"boolean\", \"function\"],\n    description: \"Trust the input, enabling all HTML features such as \\\\url.\",\n    cli: \"-T, --trust\"\n  },\n  maxSize: {\n    type: \"number\",\n    default: Infinity,\n    description: \"If non-zero, all user-specified sizes, e.g. in \" + \"\\\\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, \" + \"elements and spaces can be arbitrarily large\",\n    processor: s => Math.max(0, s),\n    cli: \"-s, --max-size <n>\",\n    cliProcessor: parseInt\n  },\n  maxExpand: {\n    type: \"number\",\n    default: 1000,\n    description: \"Limit the number of macro expansions to the specified \" + \"number, to prevent e.g. infinite macro loops. If set to Infinity, \" + \"the macro expander will try to fully expand as in LaTeX.\",\n    processor: n => Math.max(0, n),\n    cli: \"-e, --max-expand <n>\",\n    cliProcessor: n => n === \"Infinity\" ? Infinity : parseInt(n)\n  },\n  globalGroup: {\n    type: \"boolean\",\n    cli: false\n  }\n};\n\nfunction getDefaultValue(schema) {\n  if (schema.default) {\n    return schema.default;\n  }\n\n  var type = schema.type;\n  var defaultType = Array.isArray(type) ? type[0] : type;\n\n  if (typeof defaultType !== 'string') {\n    return defaultType.enum[0];\n  }\n\n  switch (defaultType) {\n    case 'boolean':\n      return false;\n\n    case 'string':\n      return '';\n\n    case 'number':\n      return 0;\n\n    case 'object':\n      return {};\n  }\n}\n/**\n * The main Settings object\n *\n * The current options stored are:\n *  - displayMode: Whether the expression should be typeset as inline math\n *                 (false, the default), meaning that the math starts in\n *                 \\textstyle and is placed in an inline-block); or as display\n *                 math (true), meaning that the math starts in \\displaystyle\n *                 and is placed in a block with vertical margin.\n */\n\n\nclass Settings {\n  constructor(options) {\n    this.displayMode = void 0;\n    this.output = void 0;\n    this.leqno = void 0;\n    this.fleqn = void 0;\n    this.throwOnError = void 0;\n    this.errorColor = void 0;\n    this.macros = void 0;\n    this.minRuleThickness = void 0;\n    this.colorIsTextColor = void 0;\n    this.strict = void 0;\n    this.trust = void 0;\n    this.maxSize = void 0;\n    this.maxExpand = void 0;\n    this.globalGroup = void 0;\n    // allow null options\n    options = options || {};\n\n    for (var prop in SETTINGS_SCHEMA) {\n      if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {\n        // $FlowFixMe\n        var schema = SETTINGS_SCHEMA[prop]; // TODO: validate options\n        // $FlowFixMe\n\n        this[prop] = options[prop] !== undefined ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);\n      }\n    }\n  }\n  /**\n   * Report nonstrict (non-LaTeX-compatible) input.\n   * Can safely not be called if `this.strict` is false in JavaScript.\n   */\n\n\n  reportNonstrict(errorCode, errorMsg, token) {\n    var strict = this.strict;\n\n    if (typeof strict === \"function\") {\n      // Allow return value of strict function to be boolean or string\n      // (or null/undefined, meaning no further processing).\n      strict = strict(errorCode, errorMsg, token);\n    }\n\n    if (!strict || strict === \"ignore\") {\n      return;\n    } else if (strict === true || strict === \"error\") {\n      throw new ParseError(\"LaTeX-incompatible input and strict mode is set to 'error': \" + (errorMsg + \" [\" + errorCode + \"]\"), token);\n    } else if (strict === \"warn\") {\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to 'warn': \" + (errorMsg + \" [\" + errorCode + \"]\"));\n    } else {\n      // won't happen in type-safe code\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to \" + (\"unrecognized '\" + strict + \"': \" + errorMsg + \" [\" + errorCode + \"]\"));\n    }\n  }\n  /**\n   * Check whether to apply strict (LaTeX-adhering) behavior for unusual\n   * input (like `\\\\`).  Unlike `nonstrict`, will not throw an error;\n   * instead, \"error\" translates to a return value of `true`, while \"ignore\"\n   * translates to a return value of `false`.  May still print a warning:\n   * \"warn\" prints a warning and returns `false`.\n   * This is for the second category of `errorCode`s listed in the README.\n   */\n\n\n  useStrictBehavior(errorCode, errorMsg, token) {\n    var strict = this.strict;\n\n    if (typeof strict === \"function\") {\n      // Allow return value of strict function to be boolean or string\n      // (or null/undefined, meaning no further processing).\n      // But catch any exceptions thrown by function, treating them\n      // like \"error\".\n      try {\n        strict = strict(errorCode, errorMsg, token);\n      } catch (error) {\n        strict = \"error\";\n      }\n    }\n\n    if (!strict || strict === \"ignore\") {\n      return false;\n    } else if (strict === true || strict === \"error\") {\n      return true;\n    } else if (strict === \"warn\") {\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to 'warn': \" + (errorMsg + \" [\" + errorCode + \"]\"));\n      return false;\n    } else {\n      // won't happen in type-safe code\n      typeof console !== \"undefined\" && console.warn(\"LaTeX-incompatible input and strict mode is set to \" + (\"unrecognized '\" + strict + \"': \" + errorMsg + \" [\" + errorCode + \"]\"));\n      return false;\n    }\n  }\n  /**\n   * Check whether to test potentially dangerous input, and return\n   * `true` (trusted) or `false` (untrusted).  The sole argument `context`\n   * should be an object with `command` field specifying the relevant LaTeX\n   * command (as a string starting with `\\`), and any other arguments, etc.\n   * If `context` has a `url` field, a `protocol` field will automatically\n   * get added by this function (changing the specified object).\n   */\n\n\n  isTrusted(context) {\n    if (context.url && !context.protocol) {\n      var protocol = utils.protocolFromUrl(context.url);\n\n      if (protocol == null) {\n        return false;\n      }\n\n      context.protocol = protocol;\n    }\n\n    var trust = typeof this.trust === \"function\" ? this.trust(context) : this.trust;\n    return Boolean(trust);\n  }\n\n}\n\n/**\n * This file contains information and classes for the various kinds of styles\n * used in TeX. It provides a generic `Style` class, which holds information\n * about a specific style. It then provides instances of all the different kinds\n * of styles possible, and provides functions to move between them and get\n * information about them.\n */\n\n/**\n * The main style class. Contains a unique id for the style, a size (which is\n * the same for cramped and uncramped version of a style), and a cramped flag.\n */\nclass Style {\n  constructor(id, size, cramped) {\n    this.id = void 0;\n    this.size = void 0;\n    this.cramped = void 0;\n    this.id = id;\n    this.size = size;\n    this.cramped = cramped;\n  }\n  /**\n   * Get the style of a superscript given a base in the current style.\n   */\n\n\n  sup() {\n    return styles[sup[this.id]];\n  }\n  /**\n   * Get the style of a subscript given a base in the current style.\n   */\n\n\n  sub() {\n    return styles[sub[this.id]];\n  }\n  /**\n   * Get the style of a fraction numerator given the fraction in the current\n   * style.\n   */\n\n\n  fracNum() {\n    return styles[fracNum[this.id]];\n  }\n  /**\n   * Get the style of a fraction denominator given the fraction in the current\n   * style.\n   */\n\n\n  fracDen() {\n    return styles[fracDen[this.id]];\n  }\n  /**\n   * Get the cramped version of a style (in particular, cramping a cramped style\n   * doesn't change the style).\n   */\n\n\n  cramp() {\n    return styles[cramp[this.id]];\n  }\n  /**\n   * Get a text or display version of this style.\n   */\n\n\n  text() {\n    return styles[text$1[this.id]];\n  }\n  /**\n   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)\n   */\n\n\n  isTight() {\n    return this.size >= 2;\n  }\n\n} // Export an interface for type checking, but don't expose the implementation.\n// This way, no more styles can be generated.\n\n\n// IDs of the different styles\nvar D = 0;\nvar Dc = 1;\nvar T = 2;\nvar Tc = 3;\nvar S = 4;\nvar Sc = 5;\nvar SS = 6;\nvar SSc = 7; // Instances of the different styles\n\nvar styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)]; // Lookup tables for switching from one style to another\n\nvar sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];\nvar sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];\nvar fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];\nvar fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];\nvar cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];\nvar text$1 = [D, Dc, T, Tc, T, Tc, T, Tc]; // We only export some of the styles.\n\nvar Style$1 = {\n  DISPLAY: styles[D],\n  TEXT: styles[T],\n  SCRIPT: styles[S],\n  SCRIPTSCRIPT: styles[SS]\n};\n\n/*\n * This file defines the Unicode scripts and script families that we\n * support. To add new scripts or families, just add a new entry to the\n * scriptData array below. Adding scripts to the scriptData array allows\n * characters from that script to appear in \\text{} environments.\n */\n\n/**\n * Each script or script family has a name and an array of blocks.\n * Each block is an array of two numbers which specify the start and\n * end points (inclusive) of a block of Unicode codepoints.\n */\n\n/**\n * Unicode block data for the families of scripts we support in \\text{}.\n * Scripts only need to appear here if they do not have font metrics.\n */\nvar scriptData = [{\n  // Latin characters beyond the Latin-1 characters we have metrics for.\n  // Needed for Czech, Hungarian and Turkish text, for example.\n  name: 'latin',\n  blocks: [[0x0100, 0x024f], // Latin Extended-A and Latin Extended-B\n  [0x0300, 0x036f] // Combining Diacritical marks\n  ]\n}, {\n  // The Cyrillic script used by Russian and related languages.\n  // A Cyrillic subset used to be supported as explicitly defined\n  // symbols in symbols.js\n  name: 'cyrillic',\n  blocks: [[0x0400, 0x04ff]]\n}, {\n  // Armenian\n  name: 'armenian',\n  blocks: [[0x0530, 0x058F]]\n}, {\n  // The Brahmic scripts of South and Southeast Asia\n  // Devanagari (0900097F)\n  // Bengali (098009FF)\n  // Gurmukhi (0A000A7F)\n  // Gujarati (0A800AFF)\n  // Oriya (0B000B7F)\n  // Tamil (0B800BFF)\n  // Telugu (0C000C7F)\n  // Kannada (0C800CFF)\n  // Malayalam (0D000D7F)\n  // Sinhala (0D800DFF)\n  // Thai (0E000E7F)\n  // Lao (0E800EFF)\n  // Tibetan (0F000FFF)\n  // Myanmar (1000109F)\n  name: 'brahmic',\n  blocks: [[0x0900, 0x109F]]\n}, {\n  name: 'georgian',\n  blocks: [[0x10A0, 0x10ff]]\n}, {\n  // Chinese and Japanese.\n  // The \"k\" in cjk is for Korean, but we've separated Korean out\n  name: \"cjk\",\n  blocks: [[0x3000, 0x30FF], // CJK symbols and punctuation, Hiragana, Katakana\n  [0x4E00, 0x9FAF], // CJK ideograms\n  [0xFF00, 0xFF60] // Fullwidth punctuation\n  // TODO: add halfwidth Katakana and Romanji glyphs\n  ]\n}, {\n  // Korean\n  name: 'hangul',\n  blocks: [[0xAC00, 0xD7AF]]\n}];\n/**\n * Given a codepoint, return the name of the script or script family\n * it is from, or null if it is not part of a known block\n */\n\nfunction scriptFromCodepoint(codepoint) {\n  for (var i = 0; i < scriptData.length; i++) {\n    var script = scriptData[i];\n\n    for (var _i = 0; _i < script.blocks.length; _i++) {\n      var block = script.blocks[_i];\n\n      if (codepoint >= block[0] && codepoint <= block[1]) {\n        return script.name;\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * A flattened version of all the supported blocks in a single array.\n * This is an optimization to make supportedCodepoint() fast.\n */\n\nvar allBlocks = [];\nscriptData.forEach(s => s.blocks.forEach(b => allBlocks.push(...b)));\n/**\n * Given a codepoint, return true if it falls within one of the\n * scripts or script families defined above and false otherwise.\n *\n * Micro benchmarks shows that this is faster than\n * /[\\u3000-\\u30FF\\u4E00-\\u9FAF\\uFF00-\\uFF60\\uAC00-\\uD7AF\\u0900-\\u109F]/.test()\n * in Firefox, Chrome and Node.\n */\n\nfunction supportedCodepoint(codepoint) {\n  for (var i = 0; i < allBlocks.length; i += 2) {\n    if (codepoint >= allBlocks[i] && codepoint <= allBlocks[i + 1]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * This file provides support to domTree.js and delimiter.js.\n * It's a storehouse of path geometry for SVG images.\n */\n// In all paths below, the viewBox-to-em scale is 1000:1.\nvar hLinePad = 80; // padding above a sqrt vinculum. Prevents image cropping.\n// The vinculum of a \\sqrt can be made thicker by a KaTeX rendering option.\n// Think of variable extraVinculum as two detours in the SVG path.\n// The detour begins at the lower left of the area labeled extraVinculum below.\n// The detour proceeds one extraVinculum distance up and slightly to the right,\n// displacing the radiused corner between surd and vinculum. The radius is\n// traversed as usual, then the detour resumes. It goes right, to the end of\n// the very long vinculum, then down one extraVinculum distance,\n// after which it resumes regular path geometry for the radical.\n\n/*                                                  vinculum\n                                                   /\n         /extraVinculum\n        / 0.04em (40 unit) std vinculum thickness\n       / /\n      / /\n     / /\\\n    / / surd\n*/\n\nvar sqrtMain = function sqrtMain(extraVinculum, hLinePad) {\n  // sqrtMain path geometry is from glyph U221A in the font KaTeX Main\n  return \"M95,\" + (622 + extraVinculum + hLinePad) + \"\\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\\nc69,-144,104.5,-217.7,106.5,-221\\nl\" + extraVinculum / 2.075 + \" -\" + extraVinculum + \"\\nc5.3,-9.3,12,-14,20,-14\\nH400000v\" + (40 + extraVinculum) + \"H845.2724\\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\\nM\" + (834 + extraVinculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraVinculum) + \"h-400000z\";\n};\n\nvar sqrtSize1 = function sqrtSize1(extraVinculum, hLinePad) {\n  // size1 is from glyph U221A in the font KaTeX_Size1-Regular\n  return \"M263,\" + (601 + extraVinculum + hLinePad) + \"c0.7,0,18,39.7,52,119\\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\\nc340,-704.7,510.7,-1060.3,512,-1067\\nl\" + extraVinculum / 2.084 + \" -\" + extraVinculum + \"\\nc4.7,-7.3,11,-11,19,-11\\nH40000v\" + (40 + extraVinculum) + \"H1012.3\\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\\nM\" + (1001 + extraVinculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraVinculum) + \"h-400000z\";\n};\n\nvar sqrtSize2 = function sqrtSize2(extraVinculum, hLinePad) {\n  // size2 is from glyph U221A in the font KaTeX_Size2-Regular\n  return \"M983 \" + (10 + extraVinculum + hLinePad) + \"\\nl\" + extraVinculum / 3.13 + \" -\" + extraVinculum + \"\\nc4,-6.7,10,-10,18,-10 H400000v\" + (40 + extraVinculum) + \"\\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\\nM\" + (1001 + extraVinculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraVinculum) + \"h-400000z\";\n};\n\nvar sqrtSize3 = function sqrtSize3(extraVinculum, hLinePad) {\n  // size3 is from glyph U221A in the font KaTeX_Size3-Regular\n  return \"M424,\" + (2398 + extraVinculum + hLinePad) + \"\\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\\nl\" + extraVinculum / 4.223 + \" -\" + extraVinculum + \"c4,-6.7,10,-10,18,-10 H400000\\nv\" + (40 + extraVinculum) + \"H1014.6\\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\\nc-2,6,-10,9,-24,9\\nc-8,0,-12,-0.7,-12,-2z M\" + (1001 + extraVinculum) + \" \" + hLinePad + \"\\nh400000v\" + (40 + extraVinculum) + \"h-400000z\";\n};\n\nvar sqrtSize4 = function sqrtSize4(extraVinculum, hLinePad) {\n  // size4 is from glyph U221A in the font KaTeX_Size4-Regular\n  return \"M473,\" + (2713 + extraVinculum + hLinePad) + \"\\nc339.3,-1799.3,509.3,-2700,510,-2702 l\" + extraVinculum / 5.298 + \" -\" + extraVinculum + \"\\nc3.3,-7.3,9.3,-11,18,-11 H400000v\" + (40 + extraVinculum) + \"H1017.7\\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\\n606zM\" + (1001 + extraVinculum) + \" \" + hLinePad + \"h400000v\" + (40 + extraVinculum) + \"H1017.7z\";\n};\n\nvar phasePath = function phasePath(y) {\n  var x = y / 2; // x coordinate at top of angle\n\n  return \"M400000 \" + y + \" H0 L\" + x + \" 0 l65 45 L145 \" + (y - 80) + \" H400000z\";\n};\n\nvar sqrtTall = function sqrtTall(extraVinculum, hLinePad, viewBoxHeight) {\n  // sqrtTall is from glyph U23B7 in the font KaTeX_Size4-Regular\n  // One path edge has a variable length. It runs vertically from the vinculum\n  // to a point near (14 units) the bottom of the surd. The vinculum\n  // is normally 40 units thick. So the length of the line in question is:\n  var vertSegment = viewBoxHeight - 54 - hLinePad - extraVinculum;\n  return \"M702 \" + (extraVinculum + hLinePad) + \"H400000\" + (40 + extraVinculum) + \"\\nH742v\" + vertSegment + \"l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\\n219 661 l218 661zM702 \" + hLinePad + \"H400000v\" + (40 + extraVinculum) + \"H742z\";\n};\n\nvar sqrtPath = function sqrtPath(size, extraVinculum, viewBoxHeight) {\n  extraVinculum = 1000 * extraVinculum; // Convert from document ems to viewBox.\n\n  var path = \"\";\n\n  switch (size) {\n    case \"sqrtMain\":\n      path = sqrtMain(extraVinculum, hLinePad);\n      break;\n\n    case \"sqrtSize1\":\n      path = sqrtSize1(extraVinculum, hLinePad);\n      break;\n\n    case \"sqrtSize2\":\n      path = sqrtSize2(extraVinculum, hLinePad);\n      break;\n\n    case \"sqrtSize3\":\n      path = sqrtSize3(extraVinculum, hLinePad);\n      break;\n\n    case \"sqrtSize4\":\n      path = sqrtSize4(extraVinculum, hLinePad);\n      break;\n\n    case \"sqrtTall\":\n      path = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);\n  }\n\n  return path;\n};\nvar innerPath = function innerPath(name, height) {\n  // The inner part of stretchy tall delimiters\n  switch (name) {\n    case \"\\u239c\":\n      return \"M291 0 H417 V\" + height + \" H291z M291 0 H417 V\" + height + \" H291z\";\n\n    case \"\\u2223\":\n      return \"M145 0 H188 V\" + height + \" H145z M145 0 H188 V\" + height + \" H145z\";\n\n    case \"\\u2225\":\n      return \"M145 0 H188 V\" + height + \" H145z M145 0 H188 V\" + height + \" H145z\" + (\"M367 0 H410 V\" + height + \" H367z M367 0 H410 V\" + height + \" H367z\");\n\n    case \"\\u239f\":\n      return \"M457 0 H583 V\" + height + \" H457z M457 0 H583 V\" + height + \" H457z\";\n\n    case \"\\u23a2\":\n      return \"M319 0 H403 V\" + height + \" H319z M319 0 H403 V\" + height + \" H319z\";\n\n    case \"\\u23a5\":\n      return \"M263 0 H347 V\" + height + \" H263z M263 0 H347 V\" + height + \" H263z\";\n\n    case \"\\u23aa\":\n      return \"M384 0 H504 V\" + height + \" H384z M384 0 H504 V\" + height + \" H384z\";\n\n    case \"\\u23d0\":\n      return \"M312 0 H355 V\" + height + \" H312z M312 0 H355 V\" + height + \" H312z\";\n\n    case \"\\u2016\":\n      return \"M257 0 H300 V\" + height + \" H257z M257 0 H300 V\" + height + \" H257z\" + (\"M478 0 H521 V\" + height + \" H478z M478 0 H521 V\" + height + \" H478z\");\n\n    default:\n      return \"\";\n  }\n};\nvar path = {\n  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main\n  doubleleftarrow: \"M262 157\\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\\nm8 0v40h399730v-40zm0 194v40h399730v-40z\",\n  // doublerightarrow is from glyph U+21D2 in font KaTeX Main\n  doublerightarrow: \"M399738 392l\\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z\",\n  // leftarrow is from glyph U+2190 in font KaTeX Main\n  leftarrow: \"M400000 241H110l3-3c68.7-52.7 113.7-120\\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\\n l-3-3h399890zM100 241v40h399900v-40z\",\n  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular\n  leftbrace: \"M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z\",\n  leftbraceunder: \"M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z\",\n  // overgroup is from the MnSymbol package (public domain)\n  leftgroup: \"M400000 80\\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\\n 435 0h399565z\",\n  leftgroupunder: \"M400000 262\\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\\n 435 219h399565z\",\n  // Harpoons are from glyph U+21BD in font KaTeX Main\n  leftharpoon: \"M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z\",\n  leftharpoonplus: \"M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\\nm0 0v40h400000v-40z\",\n  leftharpoondown: \"M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z\",\n  leftharpoondownplus: \"M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z\",\n  // hook is from glyph U+21A9 in font KaTeX Main\n  lefthook: \"M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\\n 71.5 23h399859zM103 281v-40h399897v40z\",\n  leftlinesegment: \"M40 281 V428 H0 V94 H40 V241 H400000 v40z\\nM40 281 V428 H0 V94 H40 V241 H400000 v40z\",\n  leftmapsto: \"M40 281 V448H0V74H40V241H400000v40z\\nM40 281 V448H0V74H40V241H400000v40z\",\n  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular\n  leftToFrom: \"M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z\",\n  longequal: \"M0 50 h400000 v40H0z m0 194h40000v40H0z\\nM0 50 h400000 v40H0z m0 194h40000v40H0z\",\n  midbrace: \"M200428 334\\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z\",\n  midbraceunder: \"M199572 214\\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z\",\n  oiintSize1: \"M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z\",\n  oiintSize2: \"M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\\nc0 110 84 276 504 276s502.4-166 502.4-276z\",\n  oiiintSize1: \"M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z\",\n  oiiintSize2: \"M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z\",\n  rightarrow: \"M0 241v40h399891c-47.3 35.3-84 78-110 128\\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\\n 151.7 139 205zm0 0v40h399900v-40z\",\n  rightbrace: \"M400000 542l\\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z\",\n  rightbraceunder: \"M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z\",\n  rightgroup: \"M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\\n 3-1 3-3v-38c-76-158-257-219-435-219H0z\",\n  rightgroupunder: \"M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z\",\n  rightharpoon: \"M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\\n 69.2 92 94.5zm0 0v40h399900v-40z\",\n  rightharpoonplus: \"M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z\",\n  rightharpoondown: \"M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z\",\n  rightharpoondownplus: \"M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\\nm0-194v40h400000v-40zm0 0v40h400000v-40z\",\n  righthook: \"M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z\",\n  rightlinesegment: \"M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z\",\n  rightToFrom: \"M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z\",\n  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular\n  twoheadleftarrow: \"M0 167c68 40\\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z\",\n  twoheadrightarrow: \"M400000 167\\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z\",\n  // tilde1 is a modified version of a glyph from the MnSymbol package\n  tilde1: \"M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\\n-68.267.847-113-73.952-191-73.952z\",\n  // ditto tilde2, tilde3, & tilde4\n  tilde2: \"M344 55.266c-142 0-300.638 81.316-311.5 86.418\\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z\",\n  tilde3: \"M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\\n -338 0-409-156.573-744-156.573z\",\n  tilde4: \"M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\\n -175.236-744-175.236z\",\n  // vec is from glyph U+20D7 in font KaTeX Main\n  vec: \"M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\\nc-16-25.333-24-45-24-59z\",\n  // widehat1 is a modified version of a glyph from the MnSymbol package\n  widehat1: \"M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z\",\n  // ditto widehat2, widehat3, & widehat4\n  widehat2: \"M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z\",\n  widehat3: \"M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z\",\n  widehat4: \"M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z\",\n  // widecheck paths are all inverted versions of widehat\n  widecheck1: \"M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z\",\n  widecheck2: \"M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z\",\n  widecheck3: \"M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z\",\n  widecheck4: \"M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z\",\n  // The next ten paths support reaction arrows from the mhchem package.\n  // Arrows for \\ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX\n  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main\n  baraboveleftarrow: \"M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z\",\n  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main\n  rightarrowabovebar: \"M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z\",\n  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.\n  // Ref from mhchem.sty: \\rlap{\\raisebox{-.22ex}{$\\kern0.5em\n  baraboveshortleftharpoon: \"M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z\",\n  rightharpoonaboveshortbar: \"M0,241 l0,40c399126,0,399993,0,399993,0\\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z\",\n  shortbaraboveleftharpoon: \"M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z\",\n  shortrightharpoonabovebar: \"M53,241l0,40c398570,0,399437,0,399437,0\\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z\"\n};\nvar tallDelim = function tallDelim(label, midHeight) {\n  switch (label) {\n    case \"lbrack\":\n      return \"M403 1759 V84 H666 V0 H319 V1759 v\" + midHeight + \" v1759 h347 v-84\\nH403z M403 1759 V0 H319 V1759 v\" + midHeight + \" v1759 h84z\";\n\n    case \"rbrack\":\n      return \"M347 1759 V0 H0 V84 H263 V1759 v\" + midHeight + \" v1759 H0 v84 H347z\\nM347 1759 V0 H263 V1759 v\" + midHeight + \" v1759 h84z\";\n\n    case \"vert\":\n      return \"M145 15 v585 v\" + midHeight + \" v585 c2.667,10,9.667,15,21,15\\nc10,0,16.667,-5,20,-15 v-585 v\" + -midHeight + \" v-585 c-2.667,-10,-9.667,-15,-21,-15\\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v\" + midHeight + \" v585 h43z\";\n\n    case \"doublevert\":\n      return \"M145 15 v585 v\" + midHeight + \" v585 c2.667,10,9.667,15,21,15\\nc10,0,16.667,-5,20,-15 v-585 v\" + -midHeight + \" v-585 c-2.667,-10,-9.667,-15,-21,-15\\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v\" + midHeight + \" v585 h43z\\nM367 15 v585 v\" + midHeight + \" v585 c2.667,10,9.667,15,21,15\\nc10,0,16.667,-5,20,-15 v-585 v\" + -midHeight + \" v-585 c-2.667,-10,-9.667,-15,-21,-15\\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v\" + midHeight + \" v585 h43z\";\n\n    case \"lfloor\":\n      return \"M319 602 V0 H403 V602 v\" + midHeight + \" v1715 h263 v84 H319z\\nMM319 602 V0 H403 V602 v\" + midHeight + \" v1715 H319z\";\n\n    case \"rfloor\":\n      return \"M319 602 V0 H403 V602 v\" + midHeight + \" v1799 H0 v-84 H319z\\nMM319 602 V0 H403 V602 v\" + midHeight + \" v1715 H319z\";\n\n    case \"lceil\":\n      return \"M403 1759 V84 H666 V0 H319 V1759 v\" + midHeight + \" v602 h84z\\nM403 1759 V0 H319 V1759 v\" + midHeight + \" v602 h84z\";\n\n    case \"rceil\":\n      return \"M347 1759 V0 H0 V84 H263 V1759 v\" + midHeight + \" v602 h84z\\nM347 1759 V0 h-84 V1759 v\" + midHeight + \" v602 h84z\";\n\n    case \"lparen\":\n      return \"M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\\n-36,557 l0,\" + (midHeight + 84) + \"c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\\nl0,-\" + (midHeight + 92) + \"c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z\";\n\n    case \"rparen\":\n      return \"M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,\" + (midHeight + 9) + \"\\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\\nl0,-\" + (midHeight + 144) + \"c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z\";\n\n    default:\n      // We should not ever get here.\n      throw new Error(\"Unknown stretchy delimiter.\");\n  }\n};\n\n// To ensure that all nodes have compatible signatures for these methods.\n\n/**\n * This node represents a document fragment, which contains elements, but when\n * placed into the DOM doesn't have any representation itself. It only contains\n * children and doesn't have any DOM node properties.\n */\nclass DocumentFragment {\n  // Never used; needed for satisfying interface.\n  constructor(children) {\n    this.children = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    this.children = children;\n    this.classes = [];\n    this.height = 0;\n    this.depth = 0;\n    this.maxFontSize = 0;\n    this.style = {};\n  }\n\n  hasClass(className) {\n    return this.classes.includes(className);\n  }\n  /** Convert the fragment into a node. */\n\n\n  toNode() {\n    var frag = document.createDocumentFragment();\n\n    for (var i = 0; i < this.children.length; i++) {\n      frag.appendChild(this.children[i].toNode());\n    }\n\n    return frag;\n  }\n  /** Convert the fragment into HTML markup. */\n\n\n  toMarkup() {\n    var markup = \"\"; // Simply concatenate the markup for the children together.\n\n    for (var i = 0; i < this.children.length; i++) {\n      markup += this.children[i].toMarkup();\n    }\n\n    return markup;\n  }\n  /**\n   * Converts the math node into a string, similar to innerText. Applies to\n   * MathDomNode's only.\n   */\n\n\n  toText() {\n    // To avoid this, we would subclass documentFragment separately for\n    // MathML, but polyfills for subclassing is expensive per PR 1469.\n    // $FlowFixMe: Only works for ChildType = MathDomNode.\n    var toText = child => child.toText();\n\n    return this.children.map(toText).join(\"\");\n  }\n\n}\n\n// This file is GENERATED by buildMetrics.sh. DO NOT MODIFY.\nvar fontMetricsData = {\n  \"AMS-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"65\": [0, 0.68889, 0, 0, 0.72222],\n    \"66\": [0, 0.68889, 0, 0, 0.66667],\n    \"67\": [0, 0.68889, 0, 0, 0.72222],\n    \"68\": [0, 0.68889, 0, 0, 0.72222],\n    \"69\": [0, 0.68889, 0, 0, 0.66667],\n    \"70\": [0, 0.68889, 0, 0, 0.61111],\n    \"71\": [0, 0.68889, 0, 0, 0.77778],\n    \"72\": [0, 0.68889, 0, 0, 0.77778],\n    \"73\": [0, 0.68889, 0, 0, 0.38889],\n    \"74\": [0.16667, 0.68889, 0, 0, 0.5],\n    \"75\": [0, 0.68889, 0, 0, 0.77778],\n    \"76\": [0, 0.68889, 0, 0, 0.66667],\n    \"77\": [0, 0.68889, 0, 0, 0.94445],\n    \"78\": [0, 0.68889, 0, 0, 0.72222],\n    \"79\": [0.16667, 0.68889, 0, 0, 0.77778],\n    \"80\": [0, 0.68889, 0, 0, 0.61111],\n    \"81\": [0.16667, 0.68889, 0, 0, 0.77778],\n    \"82\": [0, 0.68889, 0, 0, 0.72222],\n    \"83\": [0, 0.68889, 0, 0, 0.55556],\n    \"84\": [0, 0.68889, 0, 0, 0.66667],\n    \"85\": [0, 0.68889, 0, 0, 0.72222],\n    \"86\": [0, 0.68889, 0, 0, 0.72222],\n    \"87\": [0, 0.68889, 0, 0, 1.0],\n    \"88\": [0, 0.68889, 0, 0, 0.72222],\n    \"89\": [0, 0.68889, 0, 0, 0.72222],\n    \"90\": [0, 0.68889, 0, 0, 0.66667],\n    \"107\": [0, 0.68889, 0, 0, 0.55556],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"165\": [0, 0.675, 0.025, 0, 0.75],\n    \"174\": [0.15559, 0.69224, 0, 0, 0.94666],\n    \"240\": [0, 0.68889, 0, 0, 0.55556],\n    \"295\": [0, 0.68889, 0, 0, 0.54028],\n    \"710\": [0, 0.825, 0, 0, 2.33334],\n    \"732\": [0, 0.9, 0, 0, 2.33334],\n    \"770\": [0, 0.825, 0, 0, 2.33334],\n    \"771\": [0, 0.9, 0, 0, 2.33334],\n    \"989\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"1008\": [0, 0.43056, 0.04028, 0, 0.66667],\n    \"8245\": [0, 0.54986, 0, 0, 0.275],\n    \"8463\": [0, 0.68889, 0, 0, 0.54028],\n    \"8487\": [0, 0.68889, 0, 0, 0.72222],\n    \"8498\": [0, 0.68889, 0, 0, 0.55556],\n    \"8502\": [0, 0.68889, 0, 0, 0.66667],\n    \"8503\": [0, 0.68889, 0, 0, 0.44445],\n    \"8504\": [0, 0.68889, 0, 0, 0.66667],\n    \"8513\": [0, 0.68889, 0, 0, 0.63889],\n    \"8592\": [-0.03598, 0.46402, 0, 0, 0.5],\n    \"8594\": [-0.03598, 0.46402, 0, 0, 0.5],\n    \"8602\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8603\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8606\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8608\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8610\": [0.01354, 0.52239, 0, 0, 1.11111],\n    \"8611\": [0.01354, 0.52239, 0, 0, 1.11111],\n    \"8619\": [0, 0.54986, 0, 0, 1.0],\n    \"8620\": [0, 0.54986, 0, 0, 1.0],\n    \"8621\": [-0.13313, 0.37788, 0, 0, 1.38889],\n    \"8622\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8624\": [0, 0.69224, 0, 0, 0.5],\n    \"8625\": [0, 0.69224, 0, 0, 0.5],\n    \"8630\": [0, 0.43056, 0, 0, 1.0],\n    \"8631\": [0, 0.43056, 0, 0, 1.0],\n    \"8634\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8635\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8638\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8639\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8642\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8643\": [0.19444, 0.69224, 0, 0, 0.41667],\n    \"8644\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8646\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8647\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8648\": [0.19444, 0.69224, 0, 0, 0.83334],\n    \"8649\": [0.1808, 0.675, 0, 0, 1.0],\n    \"8650\": [0.19444, 0.69224, 0, 0, 0.83334],\n    \"8651\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8652\": [0.01354, 0.52239, 0, 0, 1.0],\n    \"8653\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8654\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8655\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8666\": [0.13667, 0.63667, 0, 0, 1.0],\n    \"8667\": [0.13667, 0.63667, 0, 0, 1.0],\n    \"8669\": [-0.13313, 0.37788, 0, 0, 1.0],\n    \"8672\": [-0.064, 0.437, 0, 0, 1.334],\n    \"8674\": [-0.064, 0.437, 0, 0, 1.334],\n    \"8705\": [0, 0.825, 0, 0, 0.5],\n    \"8708\": [0, 0.68889, 0, 0, 0.55556],\n    \"8709\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8717\": [0, 0.43056, 0, 0, 0.42917],\n    \"8722\": [-0.03598, 0.46402, 0, 0, 0.5],\n    \"8724\": [0.08198, 0.69224, 0, 0, 0.77778],\n    \"8726\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8733\": [0, 0.69224, 0, 0, 0.77778],\n    \"8736\": [0, 0.69224, 0, 0, 0.72222],\n    \"8737\": [0, 0.69224, 0, 0, 0.72222],\n    \"8738\": [0.03517, 0.52239, 0, 0, 0.72222],\n    \"8739\": [0.08167, 0.58167, 0, 0, 0.22222],\n    \"8740\": [0.25142, 0.74111, 0, 0, 0.27778],\n    \"8741\": [0.08167, 0.58167, 0, 0, 0.38889],\n    \"8742\": [0.25142, 0.74111, 0, 0, 0.5],\n    \"8756\": [0, 0.69224, 0, 0, 0.66667],\n    \"8757\": [0, 0.69224, 0, 0, 0.66667],\n    \"8764\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"8765\": [-0.13313, 0.37788, 0, 0, 0.77778],\n    \"8769\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"8770\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8774\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8776\": [-0.01688, 0.48312, 0, 0, 0.77778],\n    \"8778\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8782\": [0.06062, 0.54986, 0, 0, 0.77778],\n    \"8783\": [0.06062, 0.54986, 0, 0, 0.77778],\n    \"8785\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8786\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8787\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8790\": [0, 0.69224, 0, 0, 0.77778],\n    \"8791\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8796\": [0.08198, 0.91667, 0, 0, 0.77778],\n    \"8806\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"8807\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"8808\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"8809\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"8812\": [0.25583, 0.75583, 0, 0, 0.5],\n    \"8814\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8815\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8816\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8817\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8818\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8819\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8822\": [0.1808, 0.675, 0, 0, 0.77778],\n    \"8823\": [0.1808, 0.675, 0, 0, 0.77778],\n    \"8828\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8829\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8830\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8831\": [0.22958, 0.72958, 0, 0, 0.77778],\n    \"8832\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8833\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8840\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8841\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8842\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8843\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8847\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8848\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8858\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8859\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8861\": [0.08198, 0.58198, 0, 0, 0.77778],\n    \"8862\": [0, 0.675, 0, 0, 0.77778],\n    \"8863\": [0, 0.675, 0, 0, 0.77778],\n    \"8864\": [0, 0.675, 0, 0, 0.77778],\n    \"8865\": [0, 0.675, 0, 0, 0.77778],\n    \"8872\": [0, 0.69224, 0, 0, 0.61111],\n    \"8873\": [0, 0.69224, 0, 0, 0.72222],\n    \"8874\": [0, 0.69224, 0, 0, 0.88889],\n    \"8876\": [0, 0.68889, 0, 0, 0.61111],\n    \"8877\": [0, 0.68889, 0, 0, 0.61111],\n    \"8878\": [0, 0.68889, 0, 0, 0.72222],\n    \"8879\": [0, 0.68889, 0, 0, 0.72222],\n    \"8882\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8883\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8884\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8885\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8888\": [0, 0.54986, 0, 0, 1.11111],\n    \"8890\": [0.19444, 0.43056, 0, 0, 0.55556],\n    \"8891\": [0.19444, 0.69224, 0, 0, 0.61111],\n    \"8892\": [0.19444, 0.69224, 0, 0, 0.61111],\n    \"8901\": [0, 0.54986, 0, 0, 0.27778],\n    \"8903\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8905\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8906\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"8907\": [0, 0.69224, 0, 0, 0.77778],\n    \"8908\": [0, 0.69224, 0, 0, 0.77778],\n    \"8909\": [-0.03598, 0.46402, 0, 0, 0.77778],\n    \"8910\": [0, 0.54986, 0, 0, 0.76042],\n    \"8911\": [0, 0.54986, 0, 0, 0.76042],\n    \"8912\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8913\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"8914\": [0, 0.54986, 0, 0, 0.66667],\n    \"8915\": [0, 0.54986, 0, 0, 0.66667],\n    \"8916\": [0, 0.69224, 0, 0, 0.66667],\n    \"8918\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8919\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8920\": [0.03517, 0.54986, 0, 0, 1.33334],\n    \"8921\": [0.03517, 0.54986, 0, 0, 1.33334],\n    \"8922\": [0.38569, 0.88569, 0, 0, 0.77778],\n    \"8923\": [0.38569, 0.88569, 0, 0, 0.77778],\n    \"8926\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8927\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"8928\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8929\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8934\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8935\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8936\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8937\": [0.23222, 0.74111, 0, 0, 0.77778],\n    \"8938\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8939\": [0.20576, 0.70576, 0, 0, 0.77778],\n    \"8940\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8941\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"8994\": [0.19444, 0.69224, 0, 0, 0.77778],\n    \"8995\": [0.19444, 0.69224, 0, 0, 0.77778],\n    \"9416\": [0.15559, 0.69224, 0, 0, 0.90222],\n    \"9484\": [0, 0.69224, 0, 0, 0.5],\n    \"9488\": [0, 0.69224, 0, 0, 0.5],\n    \"9492\": [0, 0.37788, 0, 0, 0.5],\n    \"9496\": [0, 0.37788, 0, 0, 0.5],\n    \"9585\": [0.19444, 0.68889, 0, 0, 0.88889],\n    \"9586\": [0.19444, 0.74111, 0, 0, 0.88889],\n    \"9632\": [0, 0.675, 0, 0, 0.77778],\n    \"9633\": [0, 0.675, 0, 0, 0.77778],\n    \"9650\": [0, 0.54986, 0, 0, 0.72222],\n    \"9651\": [0, 0.54986, 0, 0, 0.72222],\n    \"9654\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"9660\": [0, 0.54986, 0, 0, 0.72222],\n    \"9661\": [0, 0.54986, 0, 0, 0.72222],\n    \"9664\": [0.03517, 0.54986, 0, 0, 0.77778],\n    \"9674\": [0.11111, 0.69224, 0, 0, 0.66667],\n    \"9733\": [0.19444, 0.69224, 0, 0, 0.94445],\n    \"10003\": [0, 0.69224, 0, 0, 0.83334],\n    \"10016\": [0, 0.69224, 0, 0, 0.83334],\n    \"10731\": [0.11111, 0.69224, 0, 0, 0.66667],\n    \"10846\": [0.19444, 0.75583, 0, 0, 0.61111],\n    \"10877\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10878\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10885\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10886\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10887\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"10888\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"10889\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10890\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10891\": [0.48256, 0.98256, 0, 0, 0.77778],\n    \"10892\": [0.48256, 0.98256, 0, 0, 0.77778],\n    \"10901\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10902\": [0.13667, 0.63667, 0, 0, 0.77778],\n    \"10933\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"10934\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"10935\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10936\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10937\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10938\": [0.26167, 0.75726, 0, 0, 0.77778],\n    \"10949\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10950\": [0.25583, 0.75583, 0, 0, 0.77778],\n    \"10955\": [0.28481, 0.79383, 0, 0, 0.77778],\n    \"10956\": [0.28481, 0.79383, 0, 0, 0.77778],\n    \"57350\": [0.08167, 0.58167, 0, 0, 0.22222],\n    \"57351\": [0.08167, 0.58167, 0, 0, 0.38889],\n    \"57352\": [0.08167, 0.58167, 0, 0, 0.77778],\n    \"57353\": [0, 0.43056, 0.04028, 0, 0.66667],\n    \"57356\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57357\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57358\": [0.41951, 0.91951, 0, 0, 0.77778],\n    \"57359\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"57360\": [0.30274, 0.79383, 0, 0, 0.77778],\n    \"57361\": [0.41951, 0.91951, 0, 0, 0.77778],\n    \"57366\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57367\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57368\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57369\": [0.25142, 0.75726, 0, 0, 0.77778],\n    \"57370\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"57371\": [0.13597, 0.63597, 0, 0, 0.77778]\n  },\n  \"Caligraphic-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"65\": [0, 0.68333, 0, 0.19445, 0.79847],\n    \"66\": [0, 0.68333, 0.03041, 0.13889, 0.65681],\n    \"67\": [0, 0.68333, 0.05834, 0.13889, 0.52653],\n    \"68\": [0, 0.68333, 0.02778, 0.08334, 0.77139],\n    \"69\": [0, 0.68333, 0.08944, 0.11111, 0.52778],\n    \"70\": [0, 0.68333, 0.09931, 0.11111, 0.71875],\n    \"71\": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],\n    \"72\": [0, 0.68333, 0.00965, 0.11111, 0.84452],\n    \"73\": [0, 0.68333, 0.07382, 0, 0.54452],\n    \"74\": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],\n    \"75\": [0, 0.68333, 0.01445, 0.05556, 0.76195],\n    \"76\": [0, 0.68333, 0, 0.13889, 0.68972],\n    \"77\": [0, 0.68333, 0, 0.13889, 1.2009],\n    \"78\": [0, 0.68333, 0.14736, 0.08334, 0.82049],\n    \"79\": [0, 0.68333, 0.02778, 0.11111, 0.79611],\n    \"80\": [0, 0.68333, 0.08222, 0.08334, 0.69556],\n    \"81\": [0.09722, 0.68333, 0, 0.11111, 0.81667],\n    \"82\": [0, 0.68333, 0, 0.08334, 0.8475],\n    \"83\": [0, 0.68333, 0.075, 0.13889, 0.60556],\n    \"84\": [0, 0.68333, 0.25417, 0, 0.54464],\n    \"85\": [0, 0.68333, 0.09931, 0.08334, 0.62583],\n    \"86\": [0, 0.68333, 0.08222, 0, 0.61278],\n    \"87\": [0, 0.68333, 0.08222, 0.08334, 0.98778],\n    \"88\": [0, 0.68333, 0.14643, 0.13889, 0.7133],\n    \"89\": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],\n    \"90\": [0, 0.68333, 0.07944, 0.13889, 0.72473],\n    \"160\": [0, 0, 0, 0, 0.25]\n  },\n  \"Fraktur-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69141, 0, 0, 0.29574],\n    \"34\": [0, 0.69141, 0, 0, 0.21471],\n    \"38\": [0, 0.69141, 0, 0, 0.73786],\n    \"39\": [0, 0.69141, 0, 0, 0.21201],\n    \"40\": [0.24982, 0.74947, 0, 0, 0.38865],\n    \"41\": [0.24982, 0.74947, 0, 0, 0.38865],\n    \"42\": [0, 0.62119, 0, 0, 0.27764],\n    \"43\": [0.08319, 0.58283, 0, 0, 0.75623],\n    \"44\": [0, 0.10803, 0, 0, 0.27764],\n    \"45\": [0.08319, 0.58283, 0, 0, 0.75623],\n    \"46\": [0, 0.10803, 0, 0, 0.27764],\n    \"47\": [0.24982, 0.74947, 0, 0, 0.50181],\n    \"48\": [0, 0.47534, 0, 0, 0.50181],\n    \"49\": [0, 0.47534, 0, 0, 0.50181],\n    \"50\": [0, 0.47534, 0, 0, 0.50181],\n    \"51\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"52\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"53\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"54\": [0, 0.69141, 0, 0, 0.50181],\n    \"55\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"56\": [0, 0.69141, 0, 0, 0.50181],\n    \"57\": [0.18906, 0.47534, 0, 0, 0.50181],\n    \"58\": [0, 0.47534, 0, 0, 0.21606],\n    \"59\": [0.12604, 0.47534, 0, 0, 0.21606],\n    \"61\": [-0.13099, 0.36866, 0, 0, 0.75623],\n    \"63\": [0, 0.69141, 0, 0, 0.36245],\n    \"65\": [0, 0.69141, 0, 0, 0.7176],\n    \"66\": [0, 0.69141, 0, 0, 0.88397],\n    \"67\": [0, 0.69141, 0, 0, 0.61254],\n    \"68\": [0, 0.69141, 0, 0, 0.83158],\n    \"69\": [0, 0.69141, 0, 0, 0.66278],\n    \"70\": [0.12604, 0.69141, 0, 0, 0.61119],\n    \"71\": [0, 0.69141, 0, 0, 0.78539],\n    \"72\": [0.06302, 0.69141, 0, 0, 0.7203],\n    \"73\": [0, 0.69141, 0, 0, 0.55448],\n    \"74\": [0.12604, 0.69141, 0, 0, 0.55231],\n    \"75\": [0, 0.69141, 0, 0, 0.66845],\n    \"76\": [0, 0.69141, 0, 0, 0.66602],\n    \"77\": [0, 0.69141, 0, 0, 1.04953],\n    \"78\": [0, 0.69141, 0, 0, 0.83212],\n    \"79\": [0, 0.69141, 0, 0, 0.82699],\n    \"80\": [0.18906, 0.69141, 0, 0, 0.82753],\n    \"81\": [0.03781, 0.69141, 0, 0, 0.82699],\n    \"82\": [0, 0.69141, 0, 0, 0.82807],\n    \"83\": [0, 0.69141, 0, 0, 0.82861],\n    \"84\": [0, 0.69141, 0, 0, 0.66899],\n    \"85\": [0, 0.69141, 0, 0, 0.64576],\n    \"86\": [0, 0.69141, 0, 0, 0.83131],\n    \"87\": [0, 0.69141, 0, 0, 1.04602],\n    \"88\": [0, 0.69141, 0, 0, 0.71922],\n    \"89\": [0.18906, 0.69141, 0, 0, 0.83293],\n    \"90\": [0.12604, 0.69141, 0, 0, 0.60201],\n    \"91\": [0.24982, 0.74947, 0, 0, 0.27764],\n    \"93\": [0.24982, 0.74947, 0, 0, 0.27764],\n    \"94\": [0, 0.69141, 0, 0, 0.49965],\n    \"97\": [0, 0.47534, 0, 0, 0.50046],\n    \"98\": [0, 0.69141, 0, 0, 0.51315],\n    \"99\": [0, 0.47534, 0, 0, 0.38946],\n    \"100\": [0, 0.62119, 0, 0, 0.49857],\n    \"101\": [0, 0.47534, 0, 0, 0.40053],\n    \"102\": [0.18906, 0.69141, 0, 0, 0.32626],\n    \"103\": [0.18906, 0.47534, 0, 0, 0.5037],\n    \"104\": [0.18906, 0.69141, 0, 0, 0.52126],\n    \"105\": [0, 0.69141, 0, 0, 0.27899],\n    \"106\": [0, 0.69141, 0, 0, 0.28088],\n    \"107\": [0, 0.69141, 0, 0, 0.38946],\n    \"108\": [0, 0.69141, 0, 0, 0.27953],\n    \"109\": [0, 0.47534, 0, 0, 0.76676],\n    \"110\": [0, 0.47534, 0, 0, 0.52666],\n    \"111\": [0, 0.47534, 0, 0, 0.48885],\n    \"112\": [0.18906, 0.52396, 0, 0, 0.50046],\n    \"113\": [0.18906, 0.47534, 0, 0, 0.48912],\n    \"114\": [0, 0.47534, 0, 0, 0.38919],\n    \"115\": [0, 0.47534, 0, 0, 0.44266],\n    \"116\": [0, 0.62119, 0, 0, 0.33301],\n    \"117\": [0, 0.47534, 0, 0, 0.5172],\n    \"118\": [0, 0.52396, 0, 0, 0.5118],\n    \"119\": [0, 0.52396, 0, 0, 0.77351],\n    \"120\": [0.18906, 0.47534, 0, 0, 0.38865],\n    \"121\": [0.18906, 0.47534, 0, 0, 0.49884],\n    \"122\": [0.18906, 0.47534, 0, 0, 0.39054],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"8216\": [0, 0.69141, 0, 0, 0.21471],\n    \"8217\": [0, 0.69141, 0, 0, 0.21471],\n    \"58112\": [0, 0.62119, 0, 0, 0.49749],\n    \"58113\": [0, 0.62119, 0, 0, 0.4983],\n    \"58114\": [0.18906, 0.69141, 0, 0, 0.33328],\n    \"58115\": [0.18906, 0.69141, 0, 0, 0.32923],\n    \"58116\": [0.18906, 0.47534, 0, 0, 0.50343],\n    \"58117\": [0, 0.69141, 0, 0, 0.33301],\n    \"58118\": [0, 0.62119, 0, 0, 0.33409],\n    \"58119\": [0, 0.47534, 0, 0, 0.50073]\n  },\n  \"Main-Bold\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0, 0, 0.35],\n    \"34\": [0, 0.69444, 0, 0, 0.60278],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.95833],\n    \"36\": [0.05556, 0.75, 0, 0, 0.575],\n    \"37\": [0.05556, 0.75, 0, 0, 0.95833],\n    \"38\": [0, 0.69444, 0, 0, 0.89444],\n    \"39\": [0, 0.69444, 0, 0, 0.31944],\n    \"40\": [0.25, 0.75, 0, 0, 0.44722],\n    \"41\": [0.25, 0.75, 0, 0, 0.44722],\n    \"42\": [0, 0.75, 0, 0, 0.575],\n    \"43\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"44\": [0.19444, 0.15556, 0, 0, 0.31944],\n    \"45\": [0, 0.44444, 0, 0, 0.38333],\n    \"46\": [0, 0.15556, 0, 0, 0.31944],\n    \"47\": [0.25, 0.75, 0, 0, 0.575],\n    \"48\": [0, 0.64444, 0, 0, 0.575],\n    \"49\": [0, 0.64444, 0, 0, 0.575],\n    \"50\": [0, 0.64444, 0, 0, 0.575],\n    \"51\": [0, 0.64444, 0, 0, 0.575],\n    \"52\": [0, 0.64444, 0, 0, 0.575],\n    \"53\": [0, 0.64444, 0, 0, 0.575],\n    \"54\": [0, 0.64444, 0, 0, 0.575],\n    \"55\": [0, 0.64444, 0, 0, 0.575],\n    \"56\": [0, 0.64444, 0, 0, 0.575],\n    \"57\": [0, 0.64444, 0, 0, 0.575],\n    \"58\": [0, 0.44444, 0, 0, 0.31944],\n    \"59\": [0.19444, 0.44444, 0, 0, 0.31944],\n    \"60\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"61\": [-0.10889, 0.39111, 0, 0, 0.89444],\n    \"62\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"63\": [0, 0.69444, 0, 0, 0.54305],\n    \"64\": [0, 0.69444, 0, 0, 0.89444],\n    \"65\": [0, 0.68611, 0, 0, 0.86944],\n    \"66\": [0, 0.68611, 0, 0, 0.81805],\n    \"67\": [0, 0.68611, 0, 0, 0.83055],\n    \"68\": [0, 0.68611, 0, 0, 0.88194],\n    \"69\": [0, 0.68611, 0, 0, 0.75555],\n    \"70\": [0, 0.68611, 0, 0, 0.72361],\n    \"71\": [0, 0.68611, 0, 0, 0.90416],\n    \"72\": [0, 0.68611, 0, 0, 0.9],\n    \"73\": [0, 0.68611, 0, 0, 0.43611],\n    \"74\": [0, 0.68611, 0, 0, 0.59444],\n    \"75\": [0, 0.68611, 0, 0, 0.90138],\n    \"76\": [0, 0.68611, 0, 0, 0.69166],\n    \"77\": [0, 0.68611, 0, 0, 1.09166],\n    \"78\": [0, 0.68611, 0, 0, 0.9],\n    \"79\": [0, 0.68611, 0, 0, 0.86388],\n    \"80\": [0, 0.68611, 0, 0, 0.78611],\n    \"81\": [0.19444, 0.68611, 0, 0, 0.86388],\n    \"82\": [0, 0.68611, 0, 0, 0.8625],\n    \"83\": [0, 0.68611, 0, 0, 0.63889],\n    \"84\": [0, 0.68611, 0, 0, 0.8],\n    \"85\": [0, 0.68611, 0, 0, 0.88472],\n    \"86\": [0, 0.68611, 0.01597, 0, 0.86944],\n    \"87\": [0, 0.68611, 0.01597, 0, 1.18888],\n    \"88\": [0, 0.68611, 0, 0, 0.86944],\n    \"89\": [0, 0.68611, 0.02875, 0, 0.86944],\n    \"90\": [0, 0.68611, 0, 0, 0.70277],\n    \"91\": [0.25, 0.75, 0, 0, 0.31944],\n    \"92\": [0.25, 0.75, 0, 0, 0.575],\n    \"93\": [0.25, 0.75, 0, 0, 0.31944],\n    \"94\": [0, 0.69444, 0, 0, 0.575],\n    \"95\": [0.31, 0.13444, 0.03194, 0, 0.575],\n    \"97\": [0, 0.44444, 0, 0, 0.55902],\n    \"98\": [0, 0.69444, 0, 0, 0.63889],\n    \"99\": [0, 0.44444, 0, 0, 0.51111],\n    \"100\": [0, 0.69444, 0, 0, 0.63889],\n    \"101\": [0, 0.44444, 0, 0, 0.52708],\n    \"102\": [0, 0.69444, 0.10903, 0, 0.35139],\n    \"103\": [0.19444, 0.44444, 0.01597, 0, 0.575],\n    \"104\": [0, 0.69444, 0, 0, 0.63889],\n    \"105\": [0, 0.69444, 0, 0, 0.31944],\n    \"106\": [0.19444, 0.69444, 0, 0, 0.35139],\n    \"107\": [0, 0.69444, 0, 0, 0.60694],\n    \"108\": [0, 0.69444, 0, 0, 0.31944],\n    \"109\": [0, 0.44444, 0, 0, 0.95833],\n    \"110\": [0, 0.44444, 0, 0, 0.63889],\n    \"111\": [0, 0.44444, 0, 0, 0.575],\n    \"112\": [0.19444, 0.44444, 0, 0, 0.63889],\n    \"113\": [0.19444, 0.44444, 0, 0, 0.60694],\n    \"114\": [0, 0.44444, 0, 0, 0.47361],\n    \"115\": [0, 0.44444, 0, 0, 0.45361],\n    \"116\": [0, 0.63492, 0, 0, 0.44722],\n    \"117\": [0, 0.44444, 0, 0, 0.63889],\n    \"118\": [0, 0.44444, 0.01597, 0, 0.60694],\n    \"119\": [0, 0.44444, 0.01597, 0, 0.83055],\n    \"120\": [0, 0.44444, 0, 0, 0.60694],\n    \"121\": [0.19444, 0.44444, 0.01597, 0, 0.60694],\n    \"122\": [0, 0.44444, 0, 0, 0.51111],\n    \"123\": [0.25, 0.75, 0, 0, 0.575],\n    \"124\": [0.25, 0.75, 0, 0, 0.31944],\n    \"125\": [0.25, 0.75, 0, 0, 0.575],\n    \"126\": [0.35, 0.34444, 0, 0, 0.575],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"163\": [0, 0.69444, 0, 0, 0.86853],\n    \"168\": [0, 0.69444, 0, 0, 0.575],\n    \"172\": [0, 0.44444, 0, 0, 0.76666],\n    \"176\": [0, 0.69444, 0, 0, 0.86944],\n    \"177\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"184\": [0.17014, 0, 0, 0, 0.51111],\n    \"198\": [0, 0.68611, 0, 0, 1.04166],\n    \"215\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"216\": [0.04861, 0.73472, 0, 0, 0.89444],\n    \"223\": [0, 0.69444, 0, 0, 0.59722],\n    \"230\": [0, 0.44444, 0, 0, 0.83055],\n    \"247\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"248\": [0.09722, 0.54167, 0, 0, 0.575],\n    \"305\": [0, 0.44444, 0, 0, 0.31944],\n    \"338\": [0, 0.68611, 0, 0, 1.16944],\n    \"339\": [0, 0.44444, 0, 0, 0.89444],\n    \"567\": [0.19444, 0.44444, 0, 0, 0.35139],\n    \"710\": [0, 0.69444, 0, 0, 0.575],\n    \"711\": [0, 0.63194, 0, 0, 0.575],\n    \"713\": [0, 0.59611, 0, 0, 0.575],\n    \"714\": [0, 0.69444, 0, 0, 0.575],\n    \"715\": [0, 0.69444, 0, 0, 0.575],\n    \"728\": [0, 0.69444, 0, 0, 0.575],\n    \"729\": [0, 0.69444, 0, 0, 0.31944],\n    \"730\": [0, 0.69444, 0, 0, 0.86944],\n    \"732\": [0, 0.69444, 0, 0, 0.575],\n    \"733\": [0, 0.69444, 0, 0, 0.575],\n    \"915\": [0, 0.68611, 0, 0, 0.69166],\n    \"916\": [0, 0.68611, 0, 0, 0.95833],\n    \"920\": [0, 0.68611, 0, 0, 0.89444],\n    \"923\": [0, 0.68611, 0, 0, 0.80555],\n    \"926\": [0, 0.68611, 0, 0, 0.76666],\n    \"928\": [0, 0.68611, 0, 0, 0.9],\n    \"931\": [0, 0.68611, 0, 0, 0.83055],\n    \"933\": [0, 0.68611, 0, 0, 0.89444],\n    \"934\": [0, 0.68611, 0, 0, 0.83055],\n    \"936\": [0, 0.68611, 0, 0, 0.89444],\n    \"937\": [0, 0.68611, 0, 0, 0.83055],\n    \"8211\": [0, 0.44444, 0.03194, 0, 0.575],\n    \"8212\": [0, 0.44444, 0.03194, 0, 1.14999],\n    \"8216\": [0, 0.69444, 0, 0, 0.31944],\n    \"8217\": [0, 0.69444, 0, 0, 0.31944],\n    \"8220\": [0, 0.69444, 0, 0, 0.60278],\n    \"8221\": [0, 0.69444, 0, 0, 0.60278],\n    \"8224\": [0.19444, 0.69444, 0, 0, 0.51111],\n    \"8225\": [0.19444, 0.69444, 0, 0, 0.51111],\n    \"8242\": [0, 0.55556, 0, 0, 0.34444],\n    \"8407\": [0, 0.72444, 0.15486, 0, 0.575],\n    \"8463\": [0, 0.69444, 0, 0, 0.66759],\n    \"8465\": [0, 0.69444, 0, 0, 0.83055],\n    \"8467\": [0, 0.69444, 0, 0, 0.47361],\n    \"8472\": [0.19444, 0.44444, 0, 0, 0.74027],\n    \"8476\": [0, 0.69444, 0, 0, 0.83055],\n    \"8501\": [0, 0.69444, 0, 0, 0.70277],\n    \"8592\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8593\": [0.19444, 0.69444, 0, 0, 0.575],\n    \"8594\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8595\": [0.19444, 0.69444, 0, 0, 0.575],\n    \"8596\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8597\": [0.25, 0.75, 0, 0, 0.575],\n    \"8598\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8599\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8600\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8601\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"8636\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8637\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8640\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8641\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8656\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8657\": [0.19444, 0.69444, 0, 0, 0.70277],\n    \"8658\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8659\": [0.19444, 0.69444, 0, 0, 0.70277],\n    \"8660\": [-0.10889, 0.39111, 0, 0, 1.14999],\n    \"8661\": [0.25, 0.75, 0, 0, 0.70277],\n    \"8704\": [0, 0.69444, 0, 0, 0.63889],\n    \"8706\": [0, 0.69444, 0.06389, 0, 0.62847],\n    \"8707\": [0, 0.69444, 0, 0, 0.63889],\n    \"8709\": [0.05556, 0.75, 0, 0, 0.575],\n    \"8711\": [0, 0.68611, 0, 0, 0.95833],\n    \"8712\": [0.08556, 0.58556, 0, 0, 0.76666],\n    \"8715\": [0.08556, 0.58556, 0, 0, 0.76666],\n    \"8722\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8723\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8725\": [0.25, 0.75, 0, 0, 0.575],\n    \"8726\": [0.25, 0.75, 0, 0, 0.575],\n    \"8727\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"8728\": [-0.02639, 0.47361, 0, 0, 0.575],\n    \"8729\": [-0.02639, 0.47361, 0, 0, 0.575],\n    \"8730\": [0.18, 0.82, 0, 0, 0.95833],\n    \"8733\": [0, 0.44444, 0, 0, 0.89444],\n    \"8734\": [0, 0.44444, 0, 0, 1.14999],\n    \"8736\": [0, 0.69224, 0, 0, 0.72222],\n    \"8739\": [0.25, 0.75, 0, 0, 0.31944],\n    \"8741\": [0.25, 0.75, 0, 0, 0.575],\n    \"8743\": [0, 0.55556, 0, 0, 0.76666],\n    \"8744\": [0, 0.55556, 0, 0, 0.76666],\n    \"8745\": [0, 0.55556, 0, 0, 0.76666],\n    \"8746\": [0, 0.55556, 0, 0, 0.76666],\n    \"8747\": [0.19444, 0.69444, 0.12778, 0, 0.56875],\n    \"8764\": [-0.10889, 0.39111, 0, 0, 0.89444],\n    \"8768\": [0.19444, 0.69444, 0, 0, 0.31944],\n    \"8771\": [0.00222, 0.50222, 0, 0, 0.89444],\n    \"8773\": [0.027, 0.638, 0, 0, 0.894],\n    \"8776\": [0.02444, 0.52444, 0, 0, 0.89444],\n    \"8781\": [0.00222, 0.50222, 0, 0, 0.89444],\n    \"8801\": [0.00222, 0.50222, 0, 0, 0.89444],\n    \"8804\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8805\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8810\": [0.08556, 0.58556, 0, 0, 1.14999],\n    \"8811\": [0.08556, 0.58556, 0, 0, 1.14999],\n    \"8826\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8827\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8834\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8835\": [0.08556, 0.58556, 0, 0, 0.89444],\n    \"8838\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8839\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8846\": [0, 0.55556, 0, 0, 0.76666],\n    \"8849\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8850\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"8851\": [0, 0.55556, 0, 0, 0.76666],\n    \"8852\": [0, 0.55556, 0, 0, 0.76666],\n    \"8853\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8854\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8855\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8856\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8857\": [0.13333, 0.63333, 0, 0, 0.89444],\n    \"8866\": [0, 0.69444, 0, 0, 0.70277],\n    \"8867\": [0, 0.69444, 0, 0, 0.70277],\n    \"8868\": [0, 0.69444, 0, 0, 0.89444],\n    \"8869\": [0, 0.69444, 0, 0, 0.89444],\n    \"8900\": [-0.02639, 0.47361, 0, 0, 0.575],\n    \"8901\": [-0.02639, 0.47361, 0, 0, 0.31944],\n    \"8902\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"8968\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8969\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8970\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8971\": [0.25, 0.75, 0, 0, 0.51111],\n    \"8994\": [-0.13889, 0.36111, 0, 0, 1.14999],\n    \"8995\": [-0.13889, 0.36111, 0, 0, 1.14999],\n    \"9651\": [0.19444, 0.69444, 0, 0, 1.02222],\n    \"9657\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"9661\": [0.19444, 0.69444, 0, 0, 1.02222],\n    \"9667\": [-0.02778, 0.47222, 0, 0, 0.575],\n    \"9711\": [0.19444, 0.69444, 0, 0, 1.14999],\n    \"9824\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9825\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9826\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9827\": [0.12963, 0.69444, 0, 0, 0.89444],\n    \"9837\": [0, 0.75, 0, 0, 0.44722],\n    \"9838\": [0.19444, 0.69444, 0, 0, 0.44722],\n    \"9839\": [0.19444, 0.69444, 0, 0, 0.44722],\n    \"10216\": [0.25, 0.75, 0, 0, 0.44722],\n    \"10217\": [0.25, 0.75, 0, 0, 0.44722],\n    \"10815\": [0, 0.68611, 0, 0, 0.9],\n    \"10927\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"10928\": [0.19667, 0.69667, 0, 0, 0.89444],\n    \"57376\": [0.19444, 0.69444, 0, 0, 0]\n  },\n  \"Main-BoldItalic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0.11417, 0, 0.38611],\n    \"34\": [0, 0.69444, 0.07939, 0, 0.62055],\n    \"35\": [0.19444, 0.69444, 0.06833, 0, 0.94444],\n    \"37\": [0.05556, 0.75, 0.12861, 0, 0.94444],\n    \"38\": [0, 0.69444, 0.08528, 0, 0.88555],\n    \"39\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"40\": [0.25, 0.75, 0.15806, 0, 0.47333],\n    \"41\": [0.25, 0.75, 0.03306, 0, 0.47333],\n    \"42\": [0, 0.75, 0.14333, 0, 0.59111],\n    \"43\": [0.10333, 0.60333, 0.03306, 0, 0.88555],\n    \"44\": [0.19444, 0.14722, 0, 0, 0.35555],\n    \"45\": [0, 0.44444, 0.02611, 0, 0.41444],\n    \"46\": [0, 0.14722, 0, 0, 0.35555],\n    \"47\": [0.25, 0.75, 0.15806, 0, 0.59111],\n    \"48\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"49\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"50\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"51\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"52\": [0.19444, 0.64444, 0.13167, 0, 0.59111],\n    \"53\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"54\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"55\": [0.19444, 0.64444, 0.13167, 0, 0.59111],\n    \"56\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"57\": [0, 0.64444, 0.13167, 0, 0.59111],\n    \"58\": [0, 0.44444, 0.06695, 0, 0.35555],\n    \"59\": [0.19444, 0.44444, 0.06695, 0, 0.35555],\n    \"61\": [-0.10889, 0.39111, 0.06833, 0, 0.88555],\n    \"63\": [0, 0.69444, 0.11472, 0, 0.59111],\n    \"64\": [0, 0.69444, 0.09208, 0, 0.88555],\n    \"65\": [0, 0.68611, 0, 0, 0.86555],\n    \"66\": [0, 0.68611, 0.0992, 0, 0.81666],\n    \"67\": [0, 0.68611, 0.14208, 0, 0.82666],\n    \"68\": [0, 0.68611, 0.09062, 0, 0.87555],\n    \"69\": [0, 0.68611, 0.11431, 0, 0.75666],\n    \"70\": [0, 0.68611, 0.12903, 0, 0.72722],\n    \"71\": [0, 0.68611, 0.07347, 0, 0.89527],\n    \"72\": [0, 0.68611, 0.17208, 0, 0.8961],\n    \"73\": [0, 0.68611, 0.15681, 0, 0.47166],\n    \"74\": [0, 0.68611, 0.145, 0, 0.61055],\n    \"75\": [0, 0.68611, 0.14208, 0, 0.89499],\n    \"76\": [0, 0.68611, 0, 0, 0.69777],\n    \"77\": [0, 0.68611, 0.17208, 0, 1.07277],\n    \"78\": [0, 0.68611, 0.17208, 0, 0.8961],\n    \"79\": [0, 0.68611, 0.09062, 0, 0.85499],\n    \"80\": [0, 0.68611, 0.0992, 0, 0.78721],\n    \"81\": [0.19444, 0.68611, 0.09062, 0, 0.85499],\n    \"82\": [0, 0.68611, 0.02559, 0, 0.85944],\n    \"83\": [0, 0.68611, 0.11264, 0, 0.64999],\n    \"84\": [0, 0.68611, 0.12903, 0, 0.7961],\n    \"85\": [0, 0.68611, 0.17208, 0, 0.88083],\n    \"86\": [0, 0.68611, 0.18625, 0, 0.86555],\n    \"87\": [0, 0.68611, 0.18625, 0, 1.15999],\n    \"88\": [0, 0.68611, 0.15681, 0, 0.86555],\n    \"89\": [0, 0.68611, 0.19803, 0, 0.86555],\n    \"90\": [0, 0.68611, 0.14208, 0, 0.70888],\n    \"91\": [0.25, 0.75, 0.1875, 0, 0.35611],\n    \"93\": [0.25, 0.75, 0.09972, 0, 0.35611],\n    \"94\": [0, 0.69444, 0.06709, 0, 0.59111],\n    \"95\": [0.31, 0.13444, 0.09811, 0, 0.59111],\n    \"97\": [0, 0.44444, 0.09426, 0, 0.59111],\n    \"98\": [0, 0.69444, 0.07861, 0, 0.53222],\n    \"99\": [0, 0.44444, 0.05222, 0, 0.53222],\n    \"100\": [0, 0.69444, 0.10861, 0, 0.59111],\n    \"101\": [0, 0.44444, 0.085, 0, 0.53222],\n    \"102\": [0.19444, 0.69444, 0.21778, 0, 0.4],\n    \"103\": [0.19444, 0.44444, 0.105, 0, 0.53222],\n    \"104\": [0, 0.69444, 0.09426, 0, 0.59111],\n    \"105\": [0, 0.69326, 0.11387, 0, 0.35555],\n    \"106\": [0.19444, 0.69326, 0.1672, 0, 0.35555],\n    \"107\": [0, 0.69444, 0.11111, 0, 0.53222],\n    \"108\": [0, 0.69444, 0.10861, 0, 0.29666],\n    \"109\": [0, 0.44444, 0.09426, 0, 0.94444],\n    \"110\": [0, 0.44444, 0.09426, 0, 0.64999],\n    \"111\": [0, 0.44444, 0.07861, 0, 0.59111],\n    \"112\": [0.19444, 0.44444, 0.07861, 0, 0.59111],\n    \"113\": [0.19444, 0.44444, 0.105, 0, 0.53222],\n    \"114\": [0, 0.44444, 0.11111, 0, 0.50167],\n    \"115\": [0, 0.44444, 0.08167, 0, 0.48694],\n    \"116\": [0, 0.63492, 0.09639, 0, 0.385],\n    \"117\": [0, 0.44444, 0.09426, 0, 0.62055],\n    \"118\": [0, 0.44444, 0.11111, 0, 0.53222],\n    \"119\": [0, 0.44444, 0.11111, 0, 0.76777],\n    \"120\": [0, 0.44444, 0.12583, 0, 0.56055],\n    \"121\": [0.19444, 0.44444, 0.105, 0, 0.56166],\n    \"122\": [0, 0.44444, 0.13889, 0, 0.49055],\n    \"126\": [0.35, 0.34444, 0.11472, 0, 0.59111],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.69444, 0.11473, 0, 0.59111],\n    \"176\": [0, 0.69444, 0, 0, 0.94888],\n    \"184\": [0.17014, 0, 0, 0, 0.53222],\n    \"198\": [0, 0.68611, 0.11431, 0, 1.02277],\n    \"216\": [0.04861, 0.73472, 0.09062, 0, 0.88555],\n    \"223\": [0.19444, 0.69444, 0.09736, 0, 0.665],\n    \"230\": [0, 0.44444, 0.085, 0, 0.82666],\n    \"248\": [0.09722, 0.54167, 0.09458, 0, 0.59111],\n    \"305\": [0, 0.44444, 0.09426, 0, 0.35555],\n    \"338\": [0, 0.68611, 0.11431, 0, 1.14054],\n    \"339\": [0, 0.44444, 0.085, 0, 0.82666],\n    \"567\": [0.19444, 0.44444, 0.04611, 0, 0.385],\n    \"710\": [0, 0.69444, 0.06709, 0, 0.59111],\n    \"711\": [0, 0.63194, 0.08271, 0, 0.59111],\n    \"713\": [0, 0.59444, 0.10444, 0, 0.59111],\n    \"714\": [0, 0.69444, 0.08528, 0, 0.59111],\n    \"715\": [0, 0.69444, 0, 0, 0.59111],\n    \"728\": [0, 0.69444, 0.10333, 0, 0.59111],\n    \"729\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"730\": [0, 0.69444, 0, 0, 0.94888],\n    \"732\": [0, 0.69444, 0.11472, 0, 0.59111],\n    \"733\": [0, 0.69444, 0.11472, 0, 0.59111],\n    \"915\": [0, 0.68611, 0.12903, 0, 0.69777],\n    \"916\": [0, 0.68611, 0, 0, 0.94444],\n    \"920\": [0, 0.68611, 0.09062, 0, 0.88555],\n    \"923\": [0, 0.68611, 0, 0, 0.80666],\n    \"926\": [0, 0.68611, 0.15092, 0, 0.76777],\n    \"928\": [0, 0.68611, 0.17208, 0, 0.8961],\n    \"931\": [0, 0.68611, 0.11431, 0, 0.82666],\n    \"933\": [0, 0.68611, 0.10778, 0, 0.88555],\n    \"934\": [0, 0.68611, 0.05632, 0, 0.82666],\n    \"936\": [0, 0.68611, 0.10778, 0, 0.88555],\n    \"937\": [0, 0.68611, 0.0992, 0, 0.82666],\n    \"8211\": [0, 0.44444, 0.09811, 0, 0.59111],\n    \"8212\": [0, 0.44444, 0.09811, 0, 1.18221],\n    \"8216\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"8217\": [0, 0.69444, 0.12945, 0, 0.35555],\n    \"8220\": [0, 0.69444, 0.16772, 0, 0.62055],\n    \"8221\": [0, 0.69444, 0.07939, 0, 0.62055]\n  },\n  \"Main-Italic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"34\": [0, 0.69444, 0.06961, 0, 0.51444],\n    \"35\": [0.19444, 0.69444, 0.06616, 0, 0.81777],\n    \"37\": [0.05556, 0.75, 0.13639, 0, 0.81777],\n    \"38\": [0, 0.69444, 0.09694, 0, 0.76666],\n    \"39\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"40\": [0.25, 0.75, 0.16194, 0, 0.40889],\n    \"41\": [0.25, 0.75, 0.03694, 0, 0.40889],\n    \"42\": [0, 0.75, 0.14917, 0, 0.51111],\n    \"43\": [0.05667, 0.56167, 0.03694, 0, 0.76666],\n    \"44\": [0.19444, 0.10556, 0, 0, 0.30667],\n    \"45\": [0, 0.43056, 0.02826, 0, 0.35778],\n    \"46\": [0, 0.10556, 0, 0, 0.30667],\n    \"47\": [0.25, 0.75, 0.16194, 0, 0.51111],\n    \"48\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"49\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"50\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"51\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"52\": [0.19444, 0.64444, 0.13556, 0, 0.51111],\n    \"53\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"54\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"55\": [0.19444, 0.64444, 0.13556, 0, 0.51111],\n    \"56\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"57\": [0, 0.64444, 0.13556, 0, 0.51111],\n    \"58\": [0, 0.43056, 0.0582, 0, 0.30667],\n    \"59\": [0.19444, 0.43056, 0.0582, 0, 0.30667],\n    \"61\": [-0.13313, 0.36687, 0.06616, 0, 0.76666],\n    \"63\": [0, 0.69444, 0.1225, 0, 0.51111],\n    \"64\": [0, 0.69444, 0.09597, 0, 0.76666],\n    \"65\": [0, 0.68333, 0, 0, 0.74333],\n    \"66\": [0, 0.68333, 0.10257, 0, 0.70389],\n    \"67\": [0, 0.68333, 0.14528, 0, 0.71555],\n    \"68\": [0, 0.68333, 0.09403, 0, 0.755],\n    \"69\": [0, 0.68333, 0.12028, 0, 0.67833],\n    \"70\": [0, 0.68333, 0.13305, 0, 0.65277],\n    \"71\": [0, 0.68333, 0.08722, 0, 0.77361],\n    \"72\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"73\": [0, 0.68333, 0.15806, 0, 0.38555],\n    \"74\": [0, 0.68333, 0.14028, 0, 0.525],\n    \"75\": [0, 0.68333, 0.14528, 0, 0.76888],\n    \"76\": [0, 0.68333, 0, 0, 0.62722],\n    \"77\": [0, 0.68333, 0.16389, 0, 0.89666],\n    \"78\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"79\": [0, 0.68333, 0.09403, 0, 0.76666],\n    \"80\": [0, 0.68333, 0.10257, 0, 0.67833],\n    \"81\": [0.19444, 0.68333, 0.09403, 0, 0.76666],\n    \"82\": [0, 0.68333, 0.03868, 0, 0.72944],\n    \"83\": [0, 0.68333, 0.11972, 0, 0.56222],\n    \"84\": [0, 0.68333, 0.13305, 0, 0.71555],\n    \"85\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"86\": [0, 0.68333, 0.18361, 0, 0.74333],\n    \"87\": [0, 0.68333, 0.18361, 0, 0.99888],\n    \"88\": [0, 0.68333, 0.15806, 0, 0.74333],\n    \"89\": [0, 0.68333, 0.19383, 0, 0.74333],\n    \"90\": [0, 0.68333, 0.14528, 0, 0.61333],\n    \"91\": [0.25, 0.75, 0.1875, 0, 0.30667],\n    \"93\": [0.25, 0.75, 0.10528, 0, 0.30667],\n    \"94\": [0, 0.69444, 0.06646, 0, 0.51111],\n    \"95\": [0.31, 0.12056, 0.09208, 0, 0.51111],\n    \"97\": [0, 0.43056, 0.07671, 0, 0.51111],\n    \"98\": [0, 0.69444, 0.06312, 0, 0.46],\n    \"99\": [0, 0.43056, 0.05653, 0, 0.46],\n    \"100\": [0, 0.69444, 0.10333, 0, 0.51111],\n    \"101\": [0, 0.43056, 0.07514, 0, 0.46],\n    \"102\": [0.19444, 0.69444, 0.21194, 0, 0.30667],\n    \"103\": [0.19444, 0.43056, 0.08847, 0, 0.46],\n    \"104\": [0, 0.69444, 0.07671, 0, 0.51111],\n    \"105\": [0, 0.65536, 0.1019, 0, 0.30667],\n    \"106\": [0.19444, 0.65536, 0.14467, 0, 0.30667],\n    \"107\": [0, 0.69444, 0.10764, 0, 0.46],\n    \"108\": [0, 0.69444, 0.10333, 0, 0.25555],\n    \"109\": [0, 0.43056, 0.07671, 0, 0.81777],\n    \"110\": [0, 0.43056, 0.07671, 0, 0.56222],\n    \"111\": [0, 0.43056, 0.06312, 0, 0.51111],\n    \"112\": [0.19444, 0.43056, 0.06312, 0, 0.51111],\n    \"113\": [0.19444, 0.43056, 0.08847, 0, 0.46],\n    \"114\": [0, 0.43056, 0.10764, 0, 0.42166],\n    \"115\": [0, 0.43056, 0.08208, 0, 0.40889],\n    \"116\": [0, 0.61508, 0.09486, 0, 0.33222],\n    \"117\": [0, 0.43056, 0.07671, 0, 0.53666],\n    \"118\": [0, 0.43056, 0.10764, 0, 0.46],\n    \"119\": [0, 0.43056, 0.10764, 0, 0.66444],\n    \"120\": [0, 0.43056, 0.12042, 0, 0.46389],\n    \"121\": [0.19444, 0.43056, 0.08847, 0, 0.48555],\n    \"122\": [0, 0.43056, 0.12292, 0, 0.40889],\n    \"126\": [0.35, 0.31786, 0.11585, 0, 0.51111],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.66786, 0.10474, 0, 0.51111],\n    \"176\": [0, 0.69444, 0, 0, 0.83129],\n    \"184\": [0.17014, 0, 0, 0, 0.46],\n    \"198\": [0, 0.68333, 0.12028, 0, 0.88277],\n    \"216\": [0.04861, 0.73194, 0.09403, 0, 0.76666],\n    \"223\": [0.19444, 0.69444, 0.10514, 0, 0.53666],\n    \"230\": [0, 0.43056, 0.07514, 0, 0.71555],\n    \"248\": [0.09722, 0.52778, 0.09194, 0, 0.51111],\n    \"338\": [0, 0.68333, 0.12028, 0, 0.98499],\n    \"339\": [0, 0.43056, 0.07514, 0, 0.71555],\n    \"710\": [0, 0.69444, 0.06646, 0, 0.51111],\n    \"711\": [0, 0.62847, 0.08295, 0, 0.51111],\n    \"713\": [0, 0.56167, 0.10333, 0, 0.51111],\n    \"714\": [0, 0.69444, 0.09694, 0, 0.51111],\n    \"715\": [0, 0.69444, 0, 0, 0.51111],\n    \"728\": [0, 0.69444, 0.10806, 0, 0.51111],\n    \"729\": [0, 0.66786, 0.11752, 0, 0.30667],\n    \"730\": [0, 0.69444, 0, 0, 0.83129],\n    \"732\": [0, 0.66786, 0.11585, 0, 0.51111],\n    \"733\": [0, 0.69444, 0.1225, 0, 0.51111],\n    \"915\": [0, 0.68333, 0.13305, 0, 0.62722],\n    \"916\": [0, 0.68333, 0, 0, 0.81777],\n    \"920\": [0, 0.68333, 0.09403, 0, 0.76666],\n    \"923\": [0, 0.68333, 0, 0, 0.69222],\n    \"926\": [0, 0.68333, 0.15294, 0, 0.66444],\n    \"928\": [0, 0.68333, 0.16389, 0, 0.74333],\n    \"931\": [0, 0.68333, 0.12028, 0, 0.71555],\n    \"933\": [0, 0.68333, 0.11111, 0, 0.76666],\n    \"934\": [0, 0.68333, 0.05986, 0, 0.71555],\n    \"936\": [0, 0.68333, 0.11111, 0, 0.76666],\n    \"937\": [0, 0.68333, 0.10257, 0, 0.71555],\n    \"8211\": [0, 0.43056, 0.09208, 0, 0.51111],\n    \"8212\": [0, 0.43056, 0.09208, 0, 1.02222],\n    \"8216\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"8217\": [0, 0.69444, 0.12417, 0, 0.30667],\n    \"8220\": [0, 0.69444, 0.1685, 0, 0.51444],\n    \"8221\": [0, 0.69444, 0.06961, 0, 0.51444],\n    \"8463\": [0, 0.68889, 0, 0, 0.54028]\n  },\n  \"Main-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0, 0, 0.27778],\n    \"34\": [0, 0.69444, 0, 0, 0.5],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.83334],\n    \"36\": [0.05556, 0.75, 0, 0, 0.5],\n    \"37\": [0.05556, 0.75, 0, 0, 0.83334],\n    \"38\": [0, 0.69444, 0, 0, 0.77778],\n    \"39\": [0, 0.69444, 0, 0, 0.27778],\n    \"40\": [0.25, 0.75, 0, 0, 0.38889],\n    \"41\": [0.25, 0.75, 0, 0, 0.38889],\n    \"42\": [0, 0.75, 0, 0, 0.5],\n    \"43\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"44\": [0.19444, 0.10556, 0, 0, 0.27778],\n    \"45\": [0, 0.43056, 0, 0, 0.33333],\n    \"46\": [0, 0.10556, 0, 0, 0.27778],\n    \"47\": [0.25, 0.75, 0, 0, 0.5],\n    \"48\": [0, 0.64444, 0, 0, 0.5],\n    \"49\": [0, 0.64444, 0, 0, 0.5],\n    \"50\": [0, 0.64444, 0, 0, 0.5],\n    \"51\": [0, 0.64444, 0, 0, 0.5],\n    \"52\": [0, 0.64444, 0, 0, 0.5],\n    \"53\": [0, 0.64444, 0, 0, 0.5],\n    \"54\": [0, 0.64444, 0, 0, 0.5],\n    \"55\": [0, 0.64444, 0, 0, 0.5],\n    \"56\": [0, 0.64444, 0, 0, 0.5],\n    \"57\": [0, 0.64444, 0, 0, 0.5],\n    \"58\": [0, 0.43056, 0, 0, 0.27778],\n    \"59\": [0.19444, 0.43056, 0, 0, 0.27778],\n    \"60\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"61\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"62\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"63\": [0, 0.69444, 0, 0, 0.47222],\n    \"64\": [0, 0.69444, 0, 0, 0.77778],\n    \"65\": [0, 0.68333, 0, 0, 0.75],\n    \"66\": [0, 0.68333, 0, 0, 0.70834],\n    \"67\": [0, 0.68333, 0, 0, 0.72222],\n    \"68\": [0, 0.68333, 0, 0, 0.76389],\n    \"69\": [0, 0.68333, 0, 0, 0.68056],\n    \"70\": [0, 0.68333, 0, 0, 0.65278],\n    \"71\": [0, 0.68333, 0, 0, 0.78472],\n    \"72\": [0, 0.68333, 0, 0, 0.75],\n    \"73\": [0, 0.68333, 0, 0, 0.36111],\n    \"74\": [0, 0.68333, 0, 0, 0.51389],\n    \"75\": [0, 0.68333, 0, 0, 0.77778],\n    \"76\": [0, 0.68333, 0, 0, 0.625],\n    \"77\": [0, 0.68333, 0, 0, 0.91667],\n    \"78\": [0, 0.68333, 0, 0, 0.75],\n    \"79\": [0, 0.68333, 0, 0, 0.77778],\n    \"80\": [0, 0.68333, 0, 0, 0.68056],\n    \"81\": [0.19444, 0.68333, 0, 0, 0.77778],\n    \"82\": [0, 0.68333, 0, 0, 0.73611],\n    \"83\": [0, 0.68333, 0, 0, 0.55556],\n    \"84\": [0, 0.68333, 0, 0, 0.72222],\n    \"85\": [0, 0.68333, 0, 0, 0.75],\n    \"86\": [0, 0.68333, 0.01389, 0, 0.75],\n    \"87\": [0, 0.68333, 0.01389, 0, 1.02778],\n    \"88\": [0, 0.68333, 0, 0, 0.75],\n    \"89\": [0, 0.68333, 0.025, 0, 0.75],\n    \"90\": [0, 0.68333, 0, 0, 0.61111],\n    \"91\": [0.25, 0.75, 0, 0, 0.27778],\n    \"92\": [0.25, 0.75, 0, 0, 0.5],\n    \"93\": [0.25, 0.75, 0, 0, 0.27778],\n    \"94\": [0, 0.69444, 0, 0, 0.5],\n    \"95\": [0.31, 0.12056, 0.02778, 0, 0.5],\n    \"97\": [0, 0.43056, 0, 0, 0.5],\n    \"98\": [0, 0.69444, 0, 0, 0.55556],\n    \"99\": [0, 0.43056, 0, 0, 0.44445],\n    \"100\": [0, 0.69444, 0, 0, 0.55556],\n    \"101\": [0, 0.43056, 0, 0, 0.44445],\n    \"102\": [0, 0.69444, 0.07778, 0, 0.30556],\n    \"103\": [0.19444, 0.43056, 0.01389, 0, 0.5],\n    \"104\": [0, 0.69444, 0, 0, 0.55556],\n    \"105\": [0, 0.66786, 0, 0, 0.27778],\n    \"106\": [0.19444, 0.66786, 0, 0, 0.30556],\n    \"107\": [0, 0.69444, 0, 0, 0.52778],\n    \"108\": [0, 0.69444, 0, 0, 0.27778],\n    \"109\": [0, 0.43056, 0, 0, 0.83334],\n    \"110\": [0, 0.43056, 0, 0, 0.55556],\n    \"111\": [0, 0.43056, 0, 0, 0.5],\n    \"112\": [0.19444, 0.43056, 0, 0, 0.55556],\n    \"113\": [0.19444, 0.43056, 0, 0, 0.52778],\n    \"114\": [0, 0.43056, 0, 0, 0.39167],\n    \"115\": [0, 0.43056, 0, 0, 0.39445],\n    \"116\": [0, 0.61508, 0, 0, 0.38889],\n    \"117\": [0, 0.43056, 0, 0, 0.55556],\n    \"118\": [0, 0.43056, 0.01389, 0, 0.52778],\n    \"119\": [0, 0.43056, 0.01389, 0, 0.72222],\n    \"120\": [0, 0.43056, 0, 0, 0.52778],\n    \"121\": [0.19444, 0.43056, 0.01389, 0, 0.52778],\n    \"122\": [0, 0.43056, 0, 0, 0.44445],\n    \"123\": [0.25, 0.75, 0, 0, 0.5],\n    \"124\": [0.25, 0.75, 0, 0, 0.27778],\n    \"125\": [0.25, 0.75, 0, 0, 0.5],\n    \"126\": [0.35, 0.31786, 0, 0, 0.5],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"163\": [0, 0.69444, 0, 0, 0.76909],\n    \"167\": [0.19444, 0.69444, 0, 0, 0.44445],\n    \"168\": [0, 0.66786, 0, 0, 0.5],\n    \"172\": [0, 0.43056, 0, 0, 0.66667],\n    \"176\": [0, 0.69444, 0, 0, 0.75],\n    \"177\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"182\": [0.19444, 0.69444, 0, 0, 0.61111],\n    \"184\": [0.17014, 0, 0, 0, 0.44445],\n    \"198\": [0, 0.68333, 0, 0, 0.90278],\n    \"215\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"216\": [0.04861, 0.73194, 0, 0, 0.77778],\n    \"223\": [0, 0.69444, 0, 0, 0.5],\n    \"230\": [0, 0.43056, 0, 0, 0.72222],\n    \"247\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"248\": [0.09722, 0.52778, 0, 0, 0.5],\n    \"305\": [0, 0.43056, 0, 0, 0.27778],\n    \"338\": [0, 0.68333, 0, 0, 1.01389],\n    \"339\": [0, 0.43056, 0, 0, 0.77778],\n    \"567\": [0.19444, 0.43056, 0, 0, 0.30556],\n    \"710\": [0, 0.69444, 0, 0, 0.5],\n    \"711\": [0, 0.62847, 0, 0, 0.5],\n    \"713\": [0, 0.56778, 0, 0, 0.5],\n    \"714\": [0, 0.69444, 0, 0, 0.5],\n    \"715\": [0, 0.69444, 0, 0, 0.5],\n    \"728\": [0, 0.69444, 0, 0, 0.5],\n    \"729\": [0, 0.66786, 0, 0, 0.27778],\n    \"730\": [0, 0.69444, 0, 0, 0.75],\n    \"732\": [0, 0.66786, 0, 0, 0.5],\n    \"733\": [0, 0.69444, 0, 0, 0.5],\n    \"915\": [0, 0.68333, 0, 0, 0.625],\n    \"916\": [0, 0.68333, 0, 0, 0.83334],\n    \"920\": [0, 0.68333, 0, 0, 0.77778],\n    \"923\": [0, 0.68333, 0, 0, 0.69445],\n    \"926\": [0, 0.68333, 0, 0, 0.66667],\n    \"928\": [0, 0.68333, 0, 0, 0.75],\n    \"931\": [0, 0.68333, 0, 0, 0.72222],\n    \"933\": [0, 0.68333, 0, 0, 0.77778],\n    \"934\": [0, 0.68333, 0, 0, 0.72222],\n    \"936\": [0, 0.68333, 0, 0, 0.77778],\n    \"937\": [0, 0.68333, 0, 0, 0.72222],\n    \"8211\": [0, 0.43056, 0.02778, 0, 0.5],\n    \"8212\": [0, 0.43056, 0.02778, 0, 1.0],\n    \"8216\": [0, 0.69444, 0, 0, 0.27778],\n    \"8217\": [0, 0.69444, 0, 0, 0.27778],\n    \"8220\": [0, 0.69444, 0, 0, 0.5],\n    \"8221\": [0, 0.69444, 0, 0, 0.5],\n    \"8224\": [0.19444, 0.69444, 0, 0, 0.44445],\n    \"8225\": [0.19444, 0.69444, 0, 0, 0.44445],\n    \"8230\": [0, 0.123, 0, 0, 1.172],\n    \"8242\": [0, 0.55556, 0, 0, 0.275],\n    \"8407\": [0, 0.71444, 0.15382, 0, 0.5],\n    \"8463\": [0, 0.68889, 0, 0, 0.54028],\n    \"8465\": [0, 0.69444, 0, 0, 0.72222],\n    \"8467\": [0, 0.69444, 0, 0.11111, 0.41667],\n    \"8472\": [0.19444, 0.43056, 0, 0.11111, 0.63646],\n    \"8476\": [0, 0.69444, 0, 0, 0.72222],\n    \"8501\": [0, 0.69444, 0, 0, 0.61111],\n    \"8592\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8593\": [0.19444, 0.69444, 0, 0, 0.5],\n    \"8594\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8595\": [0.19444, 0.69444, 0, 0, 0.5],\n    \"8596\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8597\": [0.25, 0.75, 0, 0, 0.5],\n    \"8598\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8599\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8600\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8601\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"8614\": [0.011, 0.511, 0, 0, 1.0],\n    \"8617\": [0.011, 0.511, 0, 0, 1.126],\n    \"8618\": [0.011, 0.511, 0, 0, 1.126],\n    \"8636\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8637\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8640\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8641\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8652\": [0.011, 0.671, 0, 0, 1.0],\n    \"8656\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8657\": [0.19444, 0.69444, 0, 0, 0.61111],\n    \"8658\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8659\": [0.19444, 0.69444, 0, 0, 0.61111],\n    \"8660\": [-0.13313, 0.36687, 0, 0, 1.0],\n    \"8661\": [0.25, 0.75, 0, 0, 0.61111],\n    \"8704\": [0, 0.69444, 0, 0, 0.55556],\n    \"8706\": [0, 0.69444, 0.05556, 0.08334, 0.5309],\n    \"8707\": [0, 0.69444, 0, 0, 0.55556],\n    \"8709\": [0.05556, 0.75, 0, 0, 0.5],\n    \"8711\": [0, 0.68333, 0, 0, 0.83334],\n    \"8712\": [0.0391, 0.5391, 0, 0, 0.66667],\n    \"8715\": [0.0391, 0.5391, 0, 0, 0.66667],\n    \"8722\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8723\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8725\": [0.25, 0.75, 0, 0, 0.5],\n    \"8726\": [0.25, 0.75, 0, 0, 0.5],\n    \"8727\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"8728\": [-0.05555, 0.44445, 0, 0, 0.5],\n    \"8729\": [-0.05555, 0.44445, 0, 0, 0.5],\n    \"8730\": [0.2, 0.8, 0, 0, 0.83334],\n    \"8733\": [0, 0.43056, 0, 0, 0.77778],\n    \"8734\": [0, 0.43056, 0, 0, 1.0],\n    \"8736\": [0, 0.69224, 0, 0, 0.72222],\n    \"8739\": [0.25, 0.75, 0, 0, 0.27778],\n    \"8741\": [0.25, 0.75, 0, 0, 0.5],\n    \"8743\": [0, 0.55556, 0, 0, 0.66667],\n    \"8744\": [0, 0.55556, 0, 0, 0.66667],\n    \"8745\": [0, 0.55556, 0, 0, 0.66667],\n    \"8746\": [0, 0.55556, 0, 0, 0.66667],\n    \"8747\": [0.19444, 0.69444, 0.11111, 0, 0.41667],\n    \"8764\": [-0.13313, 0.36687, 0, 0, 0.77778],\n    \"8768\": [0.19444, 0.69444, 0, 0, 0.27778],\n    \"8771\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8773\": [-0.022, 0.589, 0, 0, 0.778],\n    \"8776\": [-0.01688, 0.48312, 0, 0, 0.77778],\n    \"8781\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8784\": [-0.133, 0.673, 0, 0, 0.778],\n    \"8801\": [-0.03625, 0.46375, 0, 0, 0.77778],\n    \"8804\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8805\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8810\": [0.0391, 0.5391, 0, 0, 1.0],\n    \"8811\": [0.0391, 0.5391, 0, 0, 1.0],\n    \"8826\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8827\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8834\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8835\": [0.0391, 0.5391, 0, 0, 0.77778],\n    \"8838\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8839\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8846\": [0, 0.55556, 0, 0, 0.66667],\n    \"8849\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8850\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"8851\": [0, 0.55556, 0, 0, 0.66667],\n    \"8852\": [0, 0.55556, 0, 0, 0.66667],\n    \"8853\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8854\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8855\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8856\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8857\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"8866\": [0, 0.69444, 0, 0, 0.61111],\n    \"8867\": [0, 0.69444, 0, 0, 0.61111],\n    \"8868\": [0, 0.69444, 0, 0, 0.77778],\n    \"8869\": [0, 0.69444, 0, 0, 0.77778],\n    \"8872\": [0.249, 0.75, 0, 0, 0.867],\n    \"8900\": [-0.05555, 0.44445, 0, 0, 0.5],\n    \"8901\": [-0.05555, 0.44445, 0, 0, 0.27778],\n    \"8902\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"8904\": [0.005, 0.505, 0, 0, 0.9],\n    \"8942\": [0.03, 0.903, 0, 0, 0.278],\n    \"8943\": [-0.19, 0.313, 0, 0, 1.172],\n    \"8945\": [-0.1, 0.823, 0, 0, 1.282],\n    \"8968\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8969\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8970\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8971\": [0.25, 0.75, 0, 0, 0.44445],\n    \"8994\": [-0.14236, 0.35764, 0, 0, 1.0],\n    \"8995\": [-0.14236, 0.35764, 0, 0, 1.0],\n    \"9136\": [0.244, 0.744, 0, 0, 0.412],\n    \"9137\": [0.244, 0.745, 0, 0, 0.412],\n    \"9651\": [0.19444, 0.69444, 0, 0, 0.88889],\n    \"9657\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"9661\": [0.19444, 0.69444, 0, 0, 0.88889],\n    \"9667\": [-0.03472, 0.46528, 0, 0, 0.5],\n    \"9711\": [0.19444, 0.69444, 0, 0, 1.0],\n    \"9824\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9825\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9826\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9827\": [0.12963, 0.69444, 0, 0, 0.77778],\n    \"9837\": [0, 0.75, 0, 0, 0.38889],\n    \"9838\": [0.19444, 0.69444, 0, 0, 0.38889],\n    \"9839\": [0.19444, 0.69444, 0, 0, 0.38889],\n    \"10216\": [0.25, 0.75, 0, 0, 0.38889],\n    \"10217\": [0.25, 0.75, 0, 0, 0.38889],\n    \"10222\": [0.244, 0.744, 0, 0, 0.412],\n    \"10223\": [0.244, 0.745, 0, 0, 0.412],\n    \"10229\": [0.011, 0.511, 0, 0, 1.609],\n    \"10230\": [0.011, 0.511, 0, 0, 1.638],\n    \"10231\": [0.011, 0.511, 0, 0, 1.859],\n    \"10232\": [0.024, 0.525, 0, 0, 1.609],\n    \"10233\": [0.024, 0.525, 0, 0, 1.638],\n    \"10234\": [0.024, 0.525, 0, 0, 1.858],\n    \"10236\": [0.011, 0.511, 0, 0, 1.638],\n    \"10815\": [0, 0.68333, 0, 0, 0.75],\n    \"10927\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"10928\": [0.13597, 0.63597, 0, 0, 0.77778],\n    \"57376\": [0.19444, 0.69444, 0, 0, 0]\n  },\n  \"Math-BoldItalic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"48\": [0, 0.44444, 0, 0, 0.575],\n    \"49\": [0, 0.44444, 0, 0, 0.575],\n    \"50\": [0, 0.44444, 0, 0, 0.575],\n    \"51\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"52\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"53\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"54\": [0, 0.64444, 0, 0, 0.575],\n    \"55\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"56\": [0, 0.64444, 0, 0, 0.575],\n    \"57\": [0.19444, 0.44444, 0, 0, 0.575],\n    \"65\": [0, 0.68611, 0, 0, 0.86944],\n    \"66\": [0, 0.68611, 0.04835, 0, 0.8664],\n    \"67\": [0, 0.68611, 0.06979, 0, 0.81694],\n    \"68\": [0, 0.68611, 0.03194, 0, 0.93812],\n    \"69\": [0, 0.68611, 0.05451, 0, 0.81007],\n    \"70\": [0, 0.68611, 0.15972, 0, 0.68889],\n    \"71\": [0, 0.68611, 0, 0, 0.88673],\n    \"72\": [0, 0.68611, 0.08229, 0, 0.98229],\n    \"73\": [0, 0.68611, 0.07778, 0, 0.51111],\n    \"74\": [0, 0.68611, 0.10069, 0, 0.63125],\n    \"75\": [0, 0.68611, 0.06979, 0, 0.97118],\n    \"76\": [0, 0.68611, 0, 0, 0.75555],\n    \"77\": [0, 0.68611, 0.11424, 0, 1.14201],\n    \"78\": [0, 0.68611, 0.11424, 0, 0.95034],\n    \"79\": [0, 0.68611, 0.03194, 0, 0.83666],\n    \"80\": [0, 0.68611, 0.15972, 0, 0.72309],\n    \"81\": [0.19444, 0.68611, 0, 0, 0.86861],\n    \"82\": [0, 0.68611, 0.00421, 0, 0.87235],\n    \"83\": [0, 0.68611, 0.05382, 0, 0.69271],\n    \"84\": [0, 0.68611, 0.15972, 0, 0.63663],\n    \"85\": [0, 0.68611, 0.11424, 0, 0.80027],\n    \"86\": [0, 0.68611, 0.25555, 0, 0.67778],\n    \"87\": [0, 0.68611, 0.15972, 0, 1.09305],\n    \"88\": [0, 0.68611, 0.07778, 0, 0.94722],\n    \"89\": [0, 0.68611, 0.25555, 0, 0.67458],\n    \"90\": [0, 0.68611, 0.06979, 0, 0.77257],\n    \"97\": [0, 0.44444, 0, 0, 0.63287],\n    \"98\": [0, 0.69444, 0, 0, 0.52083],\n    \"99\": [0, 0.44444, 0, 0, 0.51342],\n    \"100\": [0, 0.69444, 0, 0, 0.60972],\n    \"101\": [0, 0.44444, 0, 0, 0.55361],\n    \"102\": [0.19444, 0.69444, 0.11042, 0, 0.56806],\n    \"103\": [0.19444, 0.44444, 0.03704, 0, 0.5449],\n    \"104\": [0, 0.69444, 0, 0, 0.66759],\n    \"105\": [0, 0.69326, 0, 0, 0.4048],\n    \"106\": [0.19444, 0.69326, 0.0622, 0, 0.47083],\n    \"107\": [0, 0.69444, 0.01852, 0, 0.6037],\n    \"108\": [0, 0.69444, 0.0088, 0, 0.34815],\n    \"109\": [0, 0.44444, 0, 0, 1.0324],\n    \"110\": [0, 0.44444, 0, 0, 0.71296],\n    \"111\": [0, 0.44444, 0, 0, 0.58472],\n    \"112\": [0.19444, 0.44444, 0, 0, 0.60092],\n    \"113\": [0.19444, 0.44444, 0.03704, 0, 0.54213],\n    \"114\": [0, 0.44444, 0.03194, 0, 0.5287],\n    \"115\": [0, 0.44444, 0, 0, 0.53125],\n    \"116\": [0, 0.63492, 0, 0, 0.41528],\n    \"117\": [0, 0.44444, 0, 0, 0.68102],\n    \"118\": [0, 0.44444, 0.03704, 0, 0.56666],\n    \"119\": [0, 0.44444, 0.02778, 0, 0.83148],\n    \"120\": [0, 0.44444, 0, 0, 0.65903],\n    \"121\": [0.19444, 0.44444, 0.03704, 0, 0.59028],\n    \"122\": [0, 0.44444, 0.04213, 0, 0.55509],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"915\": [0, 0.68611, 0.15972, 0, 0.65694],\n    \"916\": [0, 0.68611, 0, 0, 0.95833],\n    \"920\": [0, 0.68611, 0.03194, 0, 0.86722],\n    \"923\": [0, 0.68611, 0, 0, 0.80555],\n    \"926\": [0, 0.68611, 0.07458, 0, 0.84125],\n    \"928\": [0, 0.68611, 0.08229, 0, 0.98229],\n    \"931\": [0, 0.68611, 0.05451, 0, 0.88507],\n    \"933\": [0, 0.68611, 0.15972, 0, 0.67083],\n    \"934\": [0, 0.68611, 0, 0, 0.76666],\n    \"936\": [0, 0.68611, 0.11653, 0, 0.71402],\n    \"937\": [0, 0.68611, 0.04835, 0, 0.8789],\n    \"945\": [0, 0.44444, 0, 0, 0.76064],\n    \"946\": [0.19444, 0.69444, 0.03403, 0, 0.65972],\n    \"947\": [0.19444, 0.44444, 0.06389, 0, 0.59003],\n    \"948\": [0, 0.69444, 0.03819, 0, 0.52222],\n    \"949\": [0, 0.44444, 0, 0, 0.52882],\n    \"950\": [0.19444, 0.69444, 0.06215, 0, 0.50833],\n    \"951\": [0.19444, 0.44444, 0.03704, 0, 0.6],\n    \"952\": [0, 0.69444, 0.03194, 0, 0.5618],\n    \"953\": [0, 0.44444, 0, 0, 0.41204],\n    \"954\": [0, 0.44444, 0, 0, 0.66759],\n    \"955\": [0, 0.69444, 0, 0, 0.67083],\n    \"956\": [0.19444, 0.44444, 0, 0, 0.70787],\n    \"957\": [0, 0.44444, 0.06898, 0, 0.57685],\n    \"958\": [0.19444, 0.69444, 0.03021, 0, 0.50833],\n    \"959\": [0, 0.44444, 0, 0, 0.58472],\n    \"960\": [0, 0.44444, 0.03704, 0, 0.68241],\n    \"961\": [0.19444, 0.44444, 0, 0, 0.6118],\n    \"962\": [0.09722, 0.44444, 0.07917, 0, 0.42361],\n    \"963\": [0, 0.44444, 0.03704, 0, 0.68588],\n    \"964\": [0, 0.44444, 0.13472, 0, 0.52083],\n    \"965\": [0, 0.44444, 0.03704, 0, 0.63055],\n    \"966\": [0.19444, 0.44444, 0, 0, 0.74722],\n    \"967\": [0.19444, 0.44444, 0, 0, 0.71805],\n    \"968\": [0.19444, 0.69444, 0.03704, 0, 0.75833],\n    \"969\": [0, 0.44444, 0.03704, 0, 0.71782],\n    \"977\": [0, 0.69444, 0, 0, 0.69155],\n    \"981\": [0.19444, 0.69444, 0, 0, 0.7125],\n    \"982\": [0, 0.44444, 0.03194, 0, 0.975],\n    \"1009\": [0.19444, 0.44444, 0, 0, 0.6118],\n    \"1013\": [0, 0.44444, 0, 0, 0.48333],\n    \"57649\": [0, 0.44444, 0, 0, 0.39352],\n    \"57911\": [0.19444, 0.44444, 0, 0, 0.43889]\n  },\n  \"Math-Italic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"48\": [0, 0.43056, 0, 0, 0.5],\n    \"49\": [0, 0.43056, 0, 0, 0.5],\n    \"50\": [0, 0.43056, 0, 0, 0.5],\n    \"51\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"52\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"53\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"54\": [0, 0.64444, 0, 0, 0.5],\n    \"55\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"56\": [0, 0.64444, 0, 0, 0.5],\n    \"57\": [0.19444, 0.43056, 0, 0, 0.5],\n    \"65\": [0, 0.68333, 0, 0.13889, 0.75],\n    \"66\": [0, 0.68333, 0.05017, 0.08334, 0.75851],\n    \"67\": [0, 0.68333, 0.07153, 0.08334, 0.71472],\n    \"68\": [0, 0.68333, 0.02778, 0.05556, 0.82792],\n    \"69\": [0, 0.68333, 0.05764, 0.08334, 0.7382],\n    \"70\": [0, 0.68333, 0.13889, 0.08334, 0.64306],\n    \"71\": [0, 0.68333, 0, 0.08334, 0.78625],\n    \"72\": [0, 0.68333, 0.08125, 0.05556, 0.83125],\n    \"73\": [0, 0.68333, 0.07847, 0.11111, 0.43958],\n    \"74\": [0, 0.68333, 0.09618, 0.16667, 0.55451],\n    \"75\": [0, 0.68333, 0.07153, 0.05556, 0.84931],\n    \"76\": [0, 0.68333, 0, 0.02778, 0.68056],\n    \"77\": [0, 0.68333, 0.10903, 0.08334, 0.97014],\n    \"78\": [0, 0.68333, 0.10903, 0.08334, 0.80347],\n    \"79\": [0, 0.68333, 0.02778, 0.08334, 0.76278],\n    \"80\": [0, 0.68333, 0.13889, 0.08334, 0.64201],\n    \"81\": [0.19444, 0.68333, 0, 0.08334, 0.79056],\n    \"82\": [0, 0.68333, 0.00773, 0.08334, 0.75929],\n    \"83\": [0, 0.68333, 0.05764, 0.08334, 0.6132],\n    \"84\": [0, 0.68333, 0.13889, 0.08334, 0.58438],\n    \"85\": [0, 0.68333, 0.10903, 0.02778, 0.68278],\n    \"86\": [0, 0.68333, 0.22222, 0, 0.58333],\n    \"87\": [0, 0.68333, 0.13889, 0, 0.94445],\n    \"88\": [0, 0.68333, 0.07847, 0.08334, 0.82847],\n    \"89\": [0, 0.68333, 0.22222, 0, 0.58056],\n    \"90\": [0, 0.68333, 0.07153, 0.08334, 0.68264],\n    \"97\": [0, 0.43056, 0, 0, 0.52859],\n    \"98\": [0, 0.69444, 0, 0, 0.42917],\n    \"99\": [0, 0.43056, 0, 0.05556, 0.43276],\n    \"100\": [0, 0.69444, 0, 0.16667, 0.52049],\n    \"101\": [0, 0.43056, 0, 0.05556, 0.46563],\n    \"102\": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],\n    \"103\": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],\n    \"104\": [0, 0.69444, 0, 0, 0.57616],\n    \"105\": [0, 0.65952, 0, 0, 0.34451],\n    \"106\": [0.19444, 0.65952, 0.05724, 0, 0.41181],\n    \"107\": [0, 0.69444, 0.03148, 0, 0.5206],\n    \"108\": [0, 0.69444, 0.01968, 0.08334, 0.29838],\n    \"109\": [0, 0.43056, 0, 0, 0.87801],\n    \"110\": [0, 0.43056, 0, 0, 0.60023],\n    \"111\": [0, 0.43056, 0, 0.05556, 0.48472],\n    \"112\": [0.19444, 0.43056, 0, 0.08334, 0.50313],\n    \"113\": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],\n    \"114\": [0, 0.43056, 0.02778, 0.05556, 0.45116],\n    \"115\": [0, 0.43056, 0, 0.05556, 0.46875],\n    \"116\": [0, 0.61508, 0, 0.08334, 0.36111],\n    \"117\": [0, 0.43056, 0, 0.02778, 0.57246],\n    \"118\": [0, 0.43056, 0.03588, 0.02778, 0.48472],\n    \"119\": [0, 0.43056, 0.02691, 0.08334, 0.71592],\n    \"120\": [0, 0.43056, 0, 0.02778, 0.57153],\n    \"121\": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],\n    \"122\": [0, 0.43056, 0.04398, 0.05556, 0.46505],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"915\": [0, 0.68333, 0.13889, 0.08334, 0.61528],\n    \"916\": [0, 0.68333, 0, 0.16667, 0.83334],\n    \"920\": [0, 0.68333, 0.02778, 0.08334, 0.76278],\n    \"923\": [0, 0.68333, 0, 0.16667, 0.69445],\n    \"926\": [0, 0.68333, 0.07569, 0.08334, 0.74236],\n    \"928\": [0, 0.68333, 0.08125, 0.05556, 0.83125],\n    \"931\": [0, 0.68333, 0.05764, 0.08334, 0.77986],\n    \"933\": [0, 0.68333, 0.13889, 0.05556, 0.58333],\n    \"934\": [0, 0.68333, 0, 0.08334, 0.66667],\n    \"936\": [0, 0.68333, 0.11, 0.05556, 0.61222],\n    \"937\": [0, 0.68333, 0.05017, 0.08334, 0.7724],\n    \"945\": [0, 0.43056, 0.0037, 0.02778, 0.6397],\n    \"946\": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],\n    \"947\": [0.19444, 0.43056, 0.05556, 0, 0.51773],\n    \"948\": [0, 0.69444, 0.03785, 0.05556, 0.44444],\n    \"949\": [0, 0.43056, 0, 0.08334, 0.46632],\n    \"950\": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],\n    \"951\": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],\n    \"952\": [0, 0.69444, 0.02778, 0.08334, 0.46944],\n    \"953\": [0, 0.43056, 0, 0.05556, 0.35394],\n    \"954\": [0, 0.43056, 0, 0, 0.57616],\n    \"955\": [0, 0.69444, 0, 0, 0.58334],\n    \"956\": [0.19444, 0.43056, 0, 0.02778, 0.60255],\n    \"957\": [0, 0.43056, 0.06366, 0.02778, 0.49398],\n    \"958\": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],\n    \"959\": [0, 0.43056, 0, 0.05556, 0.48472],\n    \"960\": [0, 0.43056, 0.03588, 0, 0.57003],\n    \"961\": [0.19444, 0.43056, 0, 0.08334, 0.51702],\n    \"962\": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],\n    \"963\": [0, 0.43056, 0.03588, 0, 0.57141],\n    \"964\": [0, 0.43056, 0.1132, 0.02778, 0.43715],\n    \"965\": [0, 0.43056, 0.03588, 0.02778, 0.54028],\n    \"966\": [0.19444, 0.43056, 0, 0.08334, 0.65417],\n    \"967\": [0.19444, 0.43056, 0, 0.05556, 0.62569],\n    \"968\": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],\n    \"969\": [0, 0.43056, 0.03588, 0, 0.62245],\n    \"977\": [0, 0.69444, 0, 0.08334, 0.59144],\n    \"981\": [0.19444, 0.69444, 0, 0.08334, 0.59583],\n    \"982\": [0, 0.43056, 0.02778, 0, 0.82813],\n    \"1009\": [0.19444, 0.43056, 0, 0.08334, 0.51702],\n    \"1013\": [0, 0.43056, 0, 0.05556, 0.4059],\n    \"57649\": [0, 0.43056, 0, 0.02778, 0.32246],\n    \"57911\": [0.19444, 0.43056, 0, 0.08334, 0.38403]\n  },\n  \"SansSerif-Bold\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0, 0, 0.36667],\n    \"34\": [0, 0.69444, 0, 0, 0.55834],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.91667],\n    \"36\": [0.05556, 0.75, 0, 0, 0.55],\n    \"37\": [0.05556, 0.75, 0, 0, 1.02912],\n    \"38\": [0, 0.69444, 0, 0, 0.83056],\n    \"39\": [0, 0.69444, 0, 0, 0.30556],\n    \"40\": [0.25, 0.75, 0, 0, 0.42778],\n    \"41\": [0.25, 0.75, 0, 0, 0.42778],\n    \"42\": [0, 0.75, 0, 0, 0.55],\n    \"43\": [0.11667, 0.61667, 0, 0, 0.85556],\n    \"44\": [0.10556, 0.13056, 0, 0, 0.30556],\n    \"45\": [0, 0.45833, 0, 0, 0.36667],\n    \"46\": [0, 0.13056, 0, 0, 0.30556],\n    \"47\": [0.25, 0.75, 0, 0, 0.55],\n    \"48\": [0, 0.69444, 0, 0, 0.55],\n    \"49\": [0, 0.69444, 0, 0, 0.55],\n    \"50\": [0, 0.69444, 0, 0, 0.55],\n    \"51\": [0, 0.69444, 0, 0, 0.55],\n    \"52\": [0, 0.69444, 0, 0, 0.55],\n    \"53\": [0, 0.69444, 0, 0, 0.55],\n    \"54\": [0, 0.69444, 0, 0, 0.55],\n    \"55\": [0, 0.69444, 0, 0, 0.55],\n    \"56\": [0, 0.69444, 0, 0, 0.55],\n    \"57\": [0, 0.69444, 0, 0, 0.55],\n    \"58\": [0, 0.45833, 0, 0, 0.30556],\n    \"59\": [0.10556, 0.45833, 0, 0, 0.30556],\n    \"61\": [-0.09375, 0.40625, 0, 0, 0.85556],\n    \"63\": [0, 0.69444, 0, 0, 0.51945],\n    \"64\": [0, 0.69444, 0, 0, 0.73334],\n    \"65\": [0, 0.69444, 0, 0, 0.73334],\n    \"66\": [0, 0.69444, 0, 0, 0.73334],\n    \"67\": [0, 0.69444, 0, 0, 0.70278],\n    \"68\": [0, 0.69444, 0, 0, 0.79445],\n    \"69\": [0, 0.69444, 0, 0, 0.64167],\n    \"70\": [0, 0.69444, 0, 0, 0.61111],\n    \"71\": [0, 0.69444, 0, 0, 0.73334],\n    \"72\": [0, 0.69444, 0, 0, 0.79445],\n    \"73\": [0, 0.69444, 0, 0, 0.33056],\n    \"74\": [0, 0.69444, 0, 0, 0.51945],\n    \"75\": [0, 0.69444, 0, 0, 0.76389],\n    \"76\": [0, 0.69444, 0, 0, 0.58056],\n    \"77\": [0, 0.69444, 0, 0, 0.97778],\n    \"78\": [0, 0.69444, 0, 0, 0.79445],\n    \"79\": [0, 0.69444, 0, 0, 0.79445],\n    \"80\": [0, 0.69444, 0, 0, 0.70278],\n    \"81\": [0.10556, 0.69444, 0, 0, 0.79445],\n    \"82\": [0, 0.69444, 0, 0, 0.70278],\n    \"83\": [0, 0.69444, 0, 0, 0.61111],\n    \"84\": [0, 0.69444, 0, 0, 0.73334],\n    \"85\": [0, 0.69444, 0, 0, 0.76389],\n    \"86\": [0, 0.69444, 0.01528, 0, 0.73334],\n    \"87\": [0, 0.69444, 0.01528, 0, 1.03889],\n    \"88\": [0, 0.69444, 0, 0, 0.73334],\n    \"89\": [0, 0.69444, 0.0275, 0, 0.73334],\n    \"90\": [0, 0.69444, 0, 0, 0.67223],\n    \"91\": [0.25, 0.75, 0, 0, 0.34306],\n    \"93\": [0.25, 0.75, 0, 0, 0.34306],\n    \"94\": [0, 0.69444, 0, 0, 0.55],\n    \"95\": [0.35, 0.10833, 0.03056, 0, 0.55],\n    \"97\": [0, 0.45833, 0, 0, 0.525],\n    \"98\": [0, 0.69444, 0, 0, 0.56111],\n    \"99\": [0, 0.45833, 0, 0, 0.48889],\n    \"100\": [0, 0.69444, 0, 0, 0.56111],\n    \"101\": [0, 0.45833, 0, 0, 0.51111],\n    \"102\": [0, 0.69444, 0.07639, 0, 0.33611],\n    \"103\": [0.19444, 0.45833, 0.01528, 0, 0.55],\n    \"104\": [0, 0.69444, 0, 0, 0.56111],\n    \"105\": [0, 0.69444, 0, 0, 0.25556],\n    \"106\": [0.19444, 0.69444, 0, 0, 0.28611],\n    \"107\": [0, 0.69444, 0, 0, 0.53056],\n    \"108\": [0, 0.69444, 0, 0, 0.25556],\n    \"109\": [0, 0.45833, 0, 0, 0.86667],\n    \"110\": [0, 0.45833, 0, 0, 0.56111],\n    \"111\": [0, 0.45833, 0, 0, 0.55],\n    \"112\": [0.19444, 0.45833, 0, 0, 0.56111],\n    \"113\": [0.19444, 0.45833, 0, 0, 0.56111],\n    \"114\": [0, 0.45833, 0.01528, 0, 0.37222],\n    \"115\": [0, 0.45833, 0, 0, 0.42167],\n    \"116\": [0, 0.58929, 0, 0, 0.40417],\n    \"117\": [0, 0.45833, 0, 0, 0.56111],\n    \"118\": [0, 0.45833, 0.01528, 0, 0.5],\n    \"119\": [0, 0.45833, 0.01528, 0, 0.74445],\n    \"120\": [0, 0.45833, 0, 0, 0.5],\n    \"121\": [0.19444, 0.45833, 0.01528, 0, 0.5],\n    \"122\": [0, 0.45833, 0, 0, 0.47639],\n    \"126\": [0.35, 0.34444, 0, 0, 0.55],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.69444, 0, 0, 0.55],\n    \"176\": [0, 0.69444, 0, 0, 0.73334],\n    \"180\": [0, 0.69444, 0, 0, 0.55],\n    \"184\": [0.17014, 0, 0, 0, 0.48889],\n    \"305\": [0, 0.45833, 0, 0, 0.25556],\n    \"567\": [0.19444, 0.45833, 0, 0, 0.28611],\n    \"710\": [0, 0.69444, 0, 0, 0.55],\n    \"711\": [0, 0.63542, 0, 0, 0.55],\n    \"713\": [0, 0.63778, 0, 0, 0.55],\n    \"728\": [0, 0.69444, 0, 0, 0.55],\n    \"729\": [0, 0.69444, 0, 0, 0.30556],\n    \"730\": [0, 0.69444, 0, 0, 0.73334],\n    \"732\": [0, 0.69444, 0, 0, 0.55],\n    \"733\": [0, 0.69444, 0, 0, 0.55],\n    \"915\": [0, 0.69444, 0, 0, 0.58056],\n    \"916\": [0, 0.69444, 0, 0, 0.91667],\n    \"920\": [0, 0.69444, 0, 0, 0.85556],\n    \"923\": [0, 0.69444, 0, 0, 0.67223],\n    \"926\": [0, 0.69444, 0, 0, 0.73334],\n    \"928\": [0, 0.69444, 0, 0, 0.79445],\n    \"931\": [0, 0.69444, 0, 0, 0.79445],\n    \"933\": [0, 0.69444, 0, 0, 0.85556],\n    \"934\": [0, 0.69444, 0, 0, 0.79445],\n    \"936\": [0, 0.69444, 0, 0, 0.85556],\n    \"937\": [0, 0.69444, 0, 0, 0.79445],\n    \"8211\": [0, 0.45833, 0.03056, 0, 0.55],\n    \"8212\": [0, 0.45833, 0.03056, 0, 1.10001],\n    \"8216\": [0, 0.69444, 0, 0, 0.30556],\n    \"8217\": [0, 0.69444, 0, 0, 0.30556],\n    \"8220\": [0, 0.69444, 0, 0, 0.55834],\n    \"8221\": [0, 0.69444, 0, 0, 0.55834]\n  },\n  \"SansSerif-Italic\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0.05733, 0, 0.31945],\n    \"34\": [0, 0.69444, 0.00316, 0, 0.5],\n    \"35\": [0.19444, 0.69444, 0.05087, 0, 0.83334],\n    \"36\": [0.05556, 0.75, 0.11156, 0, 0.5],\n    \"37\": [0.05556, 0.75, 0.03126, 0, 0.83334],\n    \"38\": [0, 0.69444, 0.03058, 0, 0.75834],\n    \"39\": [0, 0.69444, 0.07816, 0, 0.27778],\n    \"40\": [0.25, 0.75, 0.13164, 0, 0.38889],\n    \"41\": [0.25, 0.75, 0.02536, 0, 0.38889],\n    \"42\": [0, 0.75, 0.11775, 0, 0.5],\n    \"43\": [0.08333, 0.58333, 0.02536, 0, 0.77778],\n    \"44\": [0.125, 0.08333, 0, 0, 0.27778],\n    \"45\": [0, 0.44444, 0.01946, 0, 0.33333],\n    \"46\": [0, 0.08333, 0, 0, 0.27778],\n    \"47\": [0.25, 0.75, 0.13164, 0, 0.5],\n    \"48\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"49\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"50\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"51\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"52\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"53\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"54\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"55\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"56\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"57\": [0, 0.65556, 0.11156, 0, 0.5],\n    \"58\": [0, 0.44444, 0.02502, 0, 0.27778],\n    \"59\": [0.125, 0.44444, 0.02502, 0, 0.27778],\n    \"61\": [-0.13, 0.37, 0.05087, 0, 0.77778],\n    \"63\": [0, 0.69444, 0.11809, 0, 0.47222],\n    \"64\": [0, 0.69444, 0.07555, 0, 0.66667],\n    \"65\": [0, 0.69444, 0, 0, 0.66667],\n    \"66\": [0, 0.69444, 0.08293, 0, 0.66667],\n    \"67\": [0, 0.69444, 0.11983, 0, 0.63889],\n    \"68\": [0, 0.69444, 0.07555, 0, 0.72223],\n    \"69\": [0, 0.69444, 0.11983, 0, 0.59722],\n    \"70\": [0, 0.69444, 0.13372, 0, 0.56945],\n    \"71\": [0, 0.69444, 0.11983, 0, 0.66667],\n    \"72\": [0, 0.69444, 0.08094, 0, 0.70834],\n    \"73\": [0, 0.69444, 0.13372, 0, 0.27778],\n    \"74\": [0, 0.69444, 0.08094, 0, 0.47222],\n    \"75\": [0, 0.69444, 0.11983, 0, 0.69445],\n    \"76\": [0, 0.69444, 0, 0, 0.54167],\n    \"77\": [0, 0.69444, 0.08094, 0, 0.875],\n    \"78\": [0, 0.69444, 0.08094, 0, 0.70834],\n    \"79\": [0, 0.69444, 0.07555, 0, 0.73611],\n    \"80\": [0, 0.69444, 0.08293, 0, 0.63889],\n    \"81\": [0.125, 0.69444, 0.07555, 0, 0.73611],\n    \"82\": [0, 0.69444, 0.08293, 0, 0.64584],\n    \"83\": [0, 0.69444, 0.09205, 0, 0.55556],\n    \"84\": [0, 0.69444, 0.13372, 0, 0.68056],\n    \"85\": [0, 0.69444, 0.08094, 0, 0.6875],\n    \"86\": [0, 0.69444, 0.1615, 0, 0.66667],\n    \"87\": [0, 0.69444, 0.1615, 0, 0.94445],\n    \"88\": [0, 0.69444, 0.13372, 0, 0.66667],\n    \"89\": [0, 0.69444, 0.17261, 0, 0.66667],\n    \"90\": [0, 0.69444, 0.11983, 0, 0.61111],\n    \"91\": [0.25, 0.75, 0.15942, 0, 0.28889],\n    \"93\": [0.25, 0.75, 0.08719, 0, 0.28889],\n    \"94\": [0, 0.69444, 0.0799, 0, 0.5],\n    \"95\": [0.35, 0.09444, 0.08616, 0, 0.5],\n    \"97\": [0, 0.44444, 0.00981, 0, 0.48056],\n    \"98\": [0, 0.69444, 0.03057, 0, 0.51667],\n    \"99\": [0, 0.44444, 0.08336, 0, 0.44445],\n    \"100\": [0, 0.69444, 0.09483, 0, 0.51667],\n    \"101\": [0, 0.44444, 0.06778, 0, 0.44445],\n    \"102\": [0, 0.69444, 0.21705, 0, 0.30556],\n    \"103\": [0.19444, 0.44444, 0.10836, 0, 0.5],\n    \"104\": [0, 0.69444, 0.01778, 0, 0.51667],\n    \"105\": [0, 0.67937, 0.09718, 0, 0.23889],\n    \"106\": [0.19444, 0.67937, 0.09162, 0, 0.26667],\n    \"107\": [0, 0.69444, 0.08336, 0, 0.48889],\n    \"108\": [0, 0.69444, 0.09483, 0, 0.23889],\n    \"109\": [0, 0.44444, 0.01778, 0, 0.79445],\n    \"110\": [0, 0.44444, 0.01778, 0, 0.51667],\n    \"111\": [0, 0.44444, 0.06613, 0, 0.5],\n    \"112\": [0.19444, 0.44444, 0.0389, 0, 0.51667],\n    \"113\": [0.19444, 0.44444, 0.04169, 0, 0.51667],\n    \"114\": [0, 0.44444, 0.10836, 0, 0.34167],\n    \"115\": [0, 0.44444, 0.0778, 0, 0.38333],\n    \"116\": [0, 0.57143, 0.07225, 0, 0.36111],\n    \"117\": [0, 0.44444, 0.04169, 0, 0.51667],\n    \"118\": [0, 0.44444, 0.10836, 0, 0.46111],\n    \"119\": [0, 0.44444, 0.10836, 0, 0.68334],\n    \"120\": [0, 0.44444, 0.09169, 0, 0.46111],\n    \"121\": [0.19444, 0.44444, 0.10836, 0, 0.46111],\n    \"122\": [0, 0.44444, 0.08752, 0, 0.43472],\n    \"126\": [0.35, 0.32659, 0.08826, 0, 0.5],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.67937, 0.06385, 0, 0.5],\n    \"176\": [0, 0.69444, 0, 0, 0.73752],\n    \"184\": [0.17014, 0, 0, 0, 0.44445],\n    \"305\": [0, 0.44444, 0.04169, 0, 0.23889],\n    \"567\": [0.19444, 0.44444, 0.04169, 0, 0.26667],\n    \"710\": [0, 0.69444, 0.0799, 0, 0.5],\n    \"711\": [0, 0.63194, 0.08432, 0, 0.5],\n    \"713\": [0, 0.60889, 0.08776, 0, 0.5],\n    \"714\": [0, 0.69444, 0.09205, 0, 0.5],\n    \"715\": [0, 0.69444, 0, 0, 0.5],\n    \"728\": [0, 0.69444, 0.09483, 0, 0.5],\n    \"729\": [0, 0.67937, 0.07774, 0, 0.27778],\n    \"730\": [0, 0.69444, 0, 0, 0.73752],\n    \"732\": [0, 0.67659, 0.08826, 0, 0.5],\n    \"733\": [0, 0.69444, 0.09205, 0, 0.5],\n    \"915\": [0, 0.69444, 0.13372, 0, 0.54167],\n    \"916\": [0, 0.69444, 0, 0, 0.83334],\n    \"920\": [0, 0.69444, 0.07555, 0, 0.77778],\n    \"923\": [0, 0.69444, 0, 0, 0.61111],\n    \"926\": [0, 0.69444, 0.12816, 0, 0.66667],\n    \"928\": [0, 0.69444, 0.08094, 0, 0.70834],\n    \"931\": [0, 0.69444, 0.11983, 0, 0.72222],\n    \"933\": [0, 0.69444, 0.09031, 0, 0.77778],\n    \"934\": [0, 0.69444, 0.04603, 0, 0.72222],\n    \"936\": [0, 0.69444, 0.09031, 0, 0.77778],\n    \"937\": [0, 0.69444, 0.08293, 0, 0.72222],\n    \"8211\": [0, 0.44444, 0.08616, 0, 0.5],\n    \"8212\": [0, 0.44444, 0.08616, 0, 1.0],\n    \"8216\": [0, 0.69444, 0.07816, 0, 0.27778],\n    \"8217\": [0, 0.69444, 0.07816, 0, 0.27778],\n    \"8220\": [0, 0.69444, 0.14205, 0, 0.5],\n    \"8221\": [0, 0.69444, 0.00316, 0, 0.5]\n  },\n  \"SansSerif-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"33\": [0, 0.69444, 0, 0, 0.31945],\n    \"34\": [0, 0.69444, 0, 0, 0.5],\n    \"35\": [0.19444, 0.69444, 0, 0, 0.83334],\n    \"36\": [0.05556, 0.75, 0, 0, 0.5],\n    \"37\": [0.05556, 0.75, 0, 0, 0.83334],\n    \"38\": [0, 0.69444, 0, 0, 0.75834],\n    \"39\": [0, 0.69444, 0, 0, 0.27778],\n    \"40\": [0.25, 0.75, 0, 0, 0.38889],\n    \"41\": [0.25, 0.75, 0, 0, 0.38889],\n    \"42\": [0, 0.75, 0, 0, 0.5],\n    \"43\": [0.08333, 0.58333, 0, 0, 0.77778],\n    \"44\": [0.125, 0.08333, 0, 0, 0.27778],\n    \"45\": [0, 0.44444, 0, 0, 0.33333],\n    \"46\": [0, 0.08333, 0, 0, 0.27778],\n    \"47\": [0.25, 0.75, 0, 0, 0.5],\n    \"48\": [0, 0.65556, 0, 0, 0.5],\n    \"49\": [0, 0.65556, 0, 0, 0.5],\n    \"50\": [0, 0.65556, 0, 0, 0.5],\n    \"51\": [0, 0.65556, 0, 0, 0.5],\n    \"52\": [0, 0.65556, 0, 0, 0.5],\n    \"53\": [0, 0.65556, 0, 0, 0.5],\n    \"54\": [0, 0.65556, 0, 0, 0.5],\n    \"55\": [0, 0.65556, 0, 0, 0.5],\n    \"56\": [0, 0.65556, 0, 0, 0.5],\n    \"57\": [0, 0.65556, 0, 0, 0.5],\n    \"58\": [0, 0.44444, 0, 0, 0.27778],\n    \"59\": [0.125, 0.44444, 0, 0, 0.27778],\n    \"61\": [-0.13, 0.37, 0, 0, 0.77778],\n    \"63\": [0, 0.69444, 0, 0, 0.47222],\n    \"64\": [0, 0.69444, 0, 0, 0.66667],\n    \"65\": [0, 0.69444, 0, 0, 0.66667],\n    \"66\": [0, 0.69444, 0, 0, 0.66667],\n    \"67\": [0, 0.69444, 0, 0, 0.63889],\n    \"68\": [0, 0.69444, 0, 0, 0.72223],\n    \"69\": [0, 0.69444, 0, 0, 0.59722],\n    \"70\": [0, 0.69444, 0, 0, 0.56945],\n    \"71\": [0, 0.69444, 0, 0, 0.66667],\n    \"72\": [0, 0.69444, 0, 0, 0.70834],\n    \"73\": [0, 0.69444, 0, 0, 0.27778],\n    \"74\": [0, 0.69444, 0, 0, 0.47222],\n    \"75\": [0, 0.69444, 0, 0, 0.69445],\n    \"76\": [0, 0.69444, 0, 0, 0.54167],\n    \"77\": [0, 0.69444, 0, 0, 0.875],\n    \"78\": [0, 0.69444, 0, 0, 0.70834],\n    \"79\": [0, 0.69444, 0, 0, 0.73611],\n    \"80\": [0, 0.69444, 0, 0, 0.63889],\n    \"81\": [0.125, 0.69444, 0, 0, 0.73611],\n    \"82\": [0, 0.69444, 0, 0, 0.64584],\n    \"83\": [0, 0.69444, 0, 0, 0.55556],\n    \"84\": [0, 0.69444, 0, 0, 0.68056],\n    \"85\": [0, 0.69444, 0, 0, 0.6875],\n    \"86\": [0, 0.69444, 0.01389, 0, 0.66667],\n    \"87\": [0, 0.69444, 0.01389, 0, 0.94445],\n    \"88\": [0, 0.69444, 0, 0, 0.66667],\n    \"89\": [0, 0.69444, 0.025, 0, 0.66667],\n    \"90\": [0, 0.69444, 0, 0, 0.61111],\n    \"91\": [0.25, 0.75, 0, 0, 0.28889],\n    \"93\": [0.25, 0.75, 0, 0, 0.28889],\n    \"94\": [0, 0.69444, 0, 0, 0.5],\n    \"95\": [0.35, 0.09444, 0.02778, 0, 0.5],\n    \"97\": [0, 0.44444, 0, 0, 0.48056],\n    \"98\": [0, 0.69444, 0, 0, 0.51667],\n    \"99\": [0, 0.44444, 0, 0, 0.44445],\n    \"100\": [0, 0.69444, 0, 0, 0.51667],\n    \"101\": [0, 0.44444, 0, 0, 0.44445],\n    \"102\": [0, 0.69444, 0.06944, 0, 0.30556],\n    \"103\": [0.19444, 0.44444, 0.01389, 0, 0.5],\n    \"104\": [0, 0.69444, 0, 0, 0.51667],\n    \"105\": [0, 0.67937, 0, 0, 0.23889],\n    \"106\": [0.19444, 0.67937, 0, 0, 0.26667],\n    \"107\": [0, 0.69444, 0, 0, 0.48889],\n    \"108\": [0, 0.69444, 0, 0, 0.23889],\n    \"109\": [0, 0.44444, 0, 0, 0.79445],\n    \"110\": [0, 0.44444, 0, 0, 0.51667],\n    \"111\": [0, 0.44444, 0, 0, 0.5],\n    \"112\": [0.19444, 0.44444, 0, 0, 0.51667],\n    \"113\": [0.19444, 0.44444, 0, 0, 0.51667],\n    \"114\": [0, 0.44444, 0.01389, 0, 0.34167],\n    \"115\": [0, 0.44444, 0, 0, 0.38333],\n    \"116\": [0, 0.57143, 0, 0, 0.36111],\n    \"117\": [0, 0.44444, 0, 0, 0.51667],\n    \"118\": [0, 0.44444, 0.01389, 0, 0.46111],\n    \"119\": [0, 0.44444, 0.01389, 0, 0.68334],\n    \"120\": [0, 0.44444, 0, 0, 0.46111],\n    \"121\": [0.19444, 0.44444, 0.01389, 0, 0.46111],\n    \"122\": [0, 0.44444, 0, 0, 0.43472],\n    \"126\": [0.35, 0.32659, 0, 0, 0.5],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"168\": [0, 0.67937, 0, 0, 0.5],\n    \"176\": [0, 0.69444, 0, 0, 0.66667],\n    \"184\": [0.17014, 0, 0, 0, 0.44445],\n    \"305\": [0, 0.44444, 0, 0, 0.23889],\n    \"567\": [0.19444, 0.44444, 0, 0, 0.26667],\n    \"710\": [0, 0.69444, 0, 0, 0.5],\n    \"711\": [0, 0.63194, 0, 0, 0.5],\n    \"713\": [0, 0.60889, 0, 0, 0.5],\n    \"714\": [0, 0.69444, 0, 0, 0.5],\n    \"715\": [0, 0.69444, 0, 0, 0.5],\n    \"728\": [0, 0.69444, 0, 0, 0.5],\n    \"729\": [0, 0.67937, 0, 0, 0.27778],\n    \"730\": [0, 0.69444, 0, 0, 0.66667],\n    \"732\": [0, 0.67659, 0, 0, 0.5],\n    \"733\": [0, 0.69444, 0, 0, 0.5],\n    \"915\": [0, 0.69444, 0, 0, 0.54167],\n    \"916\": [0, 0.69444, 0, 0, 0.83334],\n    \"920\": [0, 0.69444, 0, 0, 0.77778],\n    \"923\": [0, 0.69444, 0, 0, 0.61111],\n    \"926\": [0, 0.69444, 0, 0, 0.66667],\n    \"928\": [0, 0.69444, 0, 0, 0.70834],\n    \"931\": [0, 0.69444, 0, 0, 0.72222],\n    \"933\": [0, 0.69444, 0, 0, 0.77778],\n    \"934\": [0, 0.69444, 0, 0, 0.72222],\n    \"936\": [0, 0.69444, 0, 0, 0.77778],\n    \"937\": [0, 0.69444, 0, 0, 0.72222],\n    \"8211\": [0, 0.44444, 0.02778, 0, 0.5],\n    \"8212\": [0, 0.44444, 0.02778, 0, 1.0],\n    \"8216\": [0, 0.69444, 0, 0, 0.27778],\n    \"8217\": [0, 0.69444, 0, 0, 0.27778],\n    \"8220\": [0, 0.69444, 0, 0, 0.5],\n    \"8221\": [0, 0.69444, 0, 0, 0.5]\n  },\n  \"Script-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"65\": [0, 0.7, 0.22925, 0, 0.80253],\n    \"66\": [0, 0.7, 0.04087, 0, 0.90757],\n    \"67\": [0, 0.7, 0.1689, 0, 0.66619],\n    \"68\": [0, 0.7, 0.09371, 0, 0.77443],\n    \"69\": [0, 0.7, 0.18583, 0, 0.56162],\n    \"70\": [0, 0.7, 0.13634, 0, 0.89544],\n    \"71\": [0, 0.7, 0.17322, 0, 0.60961],\n    \"72\": [0, 0.7, 0.29694, 0, 0.96919],\n    \"73\": [0, 0.7, 0.19189, 0, 0.80907],\n    \"74\": [0.27778, 0.7, 0.19189, 0, 1.05159],\n    \"75\": [0, 0.7, 0.31259, 0, 0.91364],\n    \"76\": [0, 0.7, 0.19189, 0, 0.87373],\n    \"77\": [0, 0.7, 0.15981, 0, 1.08031],\n    \"78\": [0, 0.7, 0.3525, 0, 0.9015],\n    \"79\": [0, 0.7, 0.08078, 0, 0.73787],\n    \"80\": [0, 0.7, 0.08078, 0, 1.01262],\n    \"81\": [0, 0.7, 0.03305, 0, 0.88282],\n    \"82\": [0, 0.7, 0.06259, 0, 0.85],\n    \"83\": [0, 0.7, 0.19189, 0, 0.86767],\n    \"84\": [0, 0.7, 0.29087, 0, 0.74697],\n    \"85\": [0, 0.7, 0.25815, 0, 0.79996],\n    \"86\": [0, 0.7, 0.27523, 0, 0.62204],\n    \"87\": [0, 0.7, 0.27523, 0, 0.80532],\n    \"88\": [0, 0.7, 0.26006, 0, 0.94445],\n    \"89\": [0, 0.7, 0.2939, 0, 0.70961],\n    \"90\": [0, 0.7, 0.24037, 0, 0.8212],\n    \"160\": [0, 0, 0, 0, 0.25]\n  },\n  \"Size1-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"40\": [0.35001, 0.85, 0, 0, 0.45834],\n    \"41\": [0.35001, 0.85, 0, 0, 0.45834],\n    \"47\": [0.35001, 0.85, 0, 0, 0.57778],\n    \"91\": [0.35001, 0.85, 0, 0, 0.41667],\n    \"92\": [0.35001, 0.85, 0, 0, 0.57778],\n    \"93\": [0.35001, 0.85, 0, 0, 0.41667],\n    \"123\": [0.35001, 0.85, 0, 0, 0.58334],\n    \"125\": [0.35001, 0.85, 0, 0, 0.58334],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"710\": [0, 0.72222, 0, 0, 0.55556],\n    \"732\": [0, 0.72222, 0, 0, 0.55556],\n    \"770\": [0, 0.72222, 0, 0, 0.55556],\n    \"771\": [0, 0.72222, 0, 0, 0.55556],\n    \"8214\": [-0.00099, 0.601, 0, 0, 0.77778],\n    \"8593\": [1e-05, 0.6, 0, 0, 0.66667],\n    \"8595\": [1e-05, 0.6, 0, 0, 0.66667],\n    \"8657\": [1e-05, 0.6, 0, 0, 0.77778],\n    \"8659\": [1e-05, 0.6, 0, 0, 0.77778],\n    \"8719\": [0.25001, 0.75, 0, 0, 0.94445],\n    \"8720\": [0.25001, 0.75, 0, 0, 0.94445],\n    \"8721\": [0.25001, 0.75, 0, 0, 1.05556],\n    \"8730\": [0.35001, 0.85, 0, 0, 1.0],\n    \"8739\": [-0.00599, 0.606, 0, 0, 0.33333],\n    \"8741\": [-0.00599, 0.606, 0, 0, 0.55556],\n    \"8747\": [0.30612, 0.805, 0.19445, 0, 0.47222],\n    \"8748\": [0.306, 0.805, 0.19445, 0, 0.47222],\n    \"8749\": [0.306, 0.805, 0.19445, 0, 0.47222],\n    \"8750\": [0.30612, 0.805, 0.19445, 0, 0.47222],\n    \"8896\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8897\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8898\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8899\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"8968\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"8969\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"8970\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"8971\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"9168\": [-0.00099, 0.601, 0, 0, 0.66667],\n    \"10216\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"10217\": [0.35001, 0.85, 0, 0, 0.47222],\n    \"10752\": [0.25001, 0.75, 0, 0, 1.11111],\n    \"10753\": [0.25001, 0.75, 0, 0, 1.11111],\n    \"10754\": [0.25001, 0.75, 0, 0, 1.11111],\n    \"10756\": [0.25001, 0.75, 0, 0, 0.83334],\n    \"10758\": [0.25001, 0.75, 0, 0, 0.83334]\n  },\n  \"Size2-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"40\": [0.65002, 1.15, 0, 0, 0.59722],\n    \"41\": [0.65002, 1.15, 0, 0, 0.59722],\n    \"47\": [0.65002, 1.15, 0, 0, 0.81111],\n    \"91\": [0.65002, 1.15, 0, 0, 0.47222],\n    \"92\": [0.65002, 1.15, 0, 0, 0.81111],\n    \"93\": [0.65002, 1.15, 0, 0, 0.47222],\n    \"123\": [0.65002, 1.15, 0, 0, 0.66667],\n    \"125\": [0.65002, 1.15, 0, 0, 0.66667],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"710\": [0, 0.75, 0, 0, 1.0],\n    \"732\": [0, 0.75, 0, 0, 1.0],\n    \"770\": [0, 0.75, 0, 0, 1.0],\n    \"771\": [0, 0.75, 0, 0, 1.0],\n    \"8719\": [0.55001, 1.05, 0, 0, 1.27778],\n    \"8720\": [0.55001, 1.05, 0, 0, 1.27778],\n    \"8721\": [0.55001, 1.05, 0, 0, 1.44445],\n    \"8730\": [0.65002, 1.15, 0, 0, 1.0],\n    \"8747\": [0.86225, 1.36, 0.44445, 0, 0.55556],\n    \"8748\": [0.862, 1.36, 0.44445, 0, 0.55556],\n    \"8749\": [0.862, 1.36, 0.44445, 0, 0.55556],\n    \"8750\": [0.86225, 1.36, 0.44445, 0, 0.55556],\n    \"8896\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8897\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8898\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8899\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"8968\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"8969\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"8970\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"8971\": [0.65002, 1.15, 0, 0, 0.52778],\n    \"10216\": [0.65002, 1.15, 0, 0, 0.61111],\n    \"10217\": [0.65002, 1.15, 0, 0, 0.61111],\n    \"10752\": [0.55001, 1.05, 0, 0, 1.51112],\n    \"10753\": [0.55001, 1.05, 0, 0, 1.51112],\n    \"10754\": [0.55001, 1.05, 0, 0, 1.51112],\n    \"10756\": [0.55001, 1.05, 0, 0, 1.11111],\n    \"10758\": [0.55001, 1.05, 0, 0, 1.11111]\n  },\n  \"Size3-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"40\": [0.95003, 1.45, 0, 0, 0.73611],\n    \"41\": [0.95003, 1.45, 0, 0, 0.73611],\n    \"47\": [0.95003, 1.45, 0, 0, 1.04445],\n    \"91\": [0.95003, 1.45, 0, 0, 0.52778],\n    \"92\": [0.95003, 1.45, 0, 0, 1.04445],\n    \"93\": [0.95003, 1.45, 0, 0, 0.52778],\n    \"123\": [0.95003, 1.45, 0, 0, 0.75],\n    \"125\": [0.95003, 1.45, 0, 0, 0.75],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"710\": [0, 0.75, 0, 0, 1.44445],\n    \"732\": [0, 0.75, 0, 0, 1.44445],\n    \"770\": [0, 0.75, 0, 0, 1.44445],\n    \"771\": [0, 0.75, 0, 0, 1.44445],\n    \"8730\": [0.95003, 1.45, 0, 0, 1.0],\n    \"8968\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"8969\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"8970\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"8971\": [0.95003, 1.45, 0, 0, 0.58334],\n    \"10216\": [0.95003, 1.45, 0, 0, 0.75],\n    \"10217\": [0.95003, 1.45, 0, 0, 0.75]\n  },\n  \"Size4-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.25],\n    \"40\": [1.25003, 1.75, 0, 0, 0.79167],\n    \"41\": [1.25003, 1.75, 0, 0, 0.79167],\n    \"47\": [1.25003, 1.75, 0, 0, 1.27778],\n    \"91\": [1.25003, 1.75, 0, 0, 0.58334],\n    \"92\": [1.25003, 1.75, 0, 0, 1.27778],\n    \"93\": [1.25003, 1.75, 0, 0, 0.58334],\n    \"123\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"125\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"160\": [0, 0, 0, 0, 0.25],\n    \"710\": [0, 0.825, 0, 0, 1.8889],\n    \"732\": [0, 0.825, 0, 0, 1.8889],\n    \"770\": [0, 0.825, 0, 0, 1.8889],\n    \"771\": [0, 0.825, 0, 0, 1.8889],\n    \"8730\": [1.25003, 1.75, 0, 0, 1.0],\n    \"8968\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"8969\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"8970\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"8971\": [1.25003, 1.75, 0, 0, 0.63889],\n    \"9115\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9116\": [1e-05, 0.6, 0, 0, 0.875],\n    \"9117\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9118\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9119\": [1e-05, 0.6, 0, 0, 0.875],\n    \"9120\": [0.64502, 1.155, 0, 0, 0.875],\n    \"9121\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9122\": [-0.00099, 0.601, 0, 0, 0.66667],\n    \"9123\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9124\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9125\": [-0.00099, 0.601, 0, 0, 0.66667],\n    \"9126\": [0.64502, 1.155, 0, 0, 0.66667],\n    \"9127\": [1e-05, 0.9, 0, 0, 0.88889],\n    \"9128\": [0.65002, 1.15, 0, 0, 0.88889],\n    \"9129\": [0.90001, 0, 0, 0, 0.88889],\n    \"9130\": [0, 0.3, 0, 0, 0.88889],\n    \"9131\": [1e-05, 0.9, 0, 0, 0.88889],\n    \"9132\": [0.65002, 1.15, 0, 0, 0.88889],\n    \"9133\": [0.90001, 0, 0, 0, 0.88889],\n    \"9143\": [0.88502, 0.915, 0, 0, 1.05556],\n    \"10216\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"10217\": [1.25003, 1.75, 0, 0, 0.80556],\n    \"57344\": [-0.00499, 0.605, 0, 0, 1.05556],\n    \"57345\": [-0.00499, 0.605, 0, 0, 1.05556],\n    \"57680\": [0, 0.12, 0, 0, 0.45],\n    \"57681\": [0, 0.12, 0, 0, 0.45],\n    \"57682\": [0, 0.12, 0, 0, 0.45],\n    \"57683\": [0, 0.12, 0, 0, 0.45]\n  },\n  \"Typewriter-Regular\": {\n    \"32\": [0, 0, 0, 0, 0.525],\n    \"33\": [0, 0.61111, 0, 0, 0.525],\n    \"34\": [0, 0.61111, 0, 0, 0.525],\n    \"35\": [0, 0.61111, 0, 0, 0.525],\n    \"36\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"37\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"38\": [0, 0.61111, 0, 0, 0.525],\n    \"39\": [0, 0.61111, 0, 0, 0.525],\n    \"40\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"41\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"42\": [0, 0.52083, 0, 0, 0.525],\n    \"43\": [-0.08056, 0.53055, 0, 0, 0.525],\n    \"44\": [0.13889, 0.125, 0, 0, 0.525],\n    \"45\": [-0.08056, 0.53055, 0, 0, 0.525],\n    \"46\": [0, 0.125, 0, 0, 0.525],\n    \"47\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"48\": [0, 0.61111, 0, 0, 0.525],\n    \"49\": [0, 0.61111, 0, 0, 0.525],\n    \"50\": [0, 0.61111, 0, 0, 0.525],\n    \"51\": [0, 0.61111, 0, 0, 0.525],\n    \"52\": [0, 0.61111, 0, 0, 0.525],\n    \"53\": [0, 0.61111, 0, 0, 0.525],\n    \"54\": [0, 0.61111, 0, 0, 0.525],\n    \"55\": [0, 0.61111, 0, 0, 0.525],\n    \"56\": [0, 0.61111, 0, 0, 0.525],\n    \"57\": [0, 0.61111, 0, 0, 0.525],\n    \"58\": [0, 0.43056, 0, 0, 0.525],\n    \"59\": [0.13889, 0.43056, 0, 0, 0.525],\n    \"60\": [-0.05556, 0.55556, 0, 0, 0.525],\n    \"61\": [-0.19549, 0.41562, 0, 0, 0.525],\n    \"62\": [-0.05556, 0.55556, 0, 0, 0.525],\n    \"63\": [0, 0.61111, 0, 0, 0.525],\n    \"64\": [0, 0.61111, 0, 0, 0.525],\n    \"65\": [0, 0.61111, 0, 0, 0.525],\n    \"66\": [0, 0.61111, 0, 0, 0.525],\n    \"67\": [0, 0.61111, 0, 0, 0.525],\n    \"68\": [0, 0.61111, 0, 0, 0.525],\n    \"69\": [0, 0.61111, 0, 0, 0.525],\n    \"70\": [0, 0.61111, 0, 0, 0.525],\n    \"71\": [0, 0.61111, 0, 0, 0.525],\n    \"72\": [0, 0.61111, 0, 0, 0.525],\n    \"73\": [0, 0.61111, 0, 0, 0.525],\n    \"74\": [0, 0.61111, 0, 0, 0.525],\n    \"75\": [0, 0.61111, 0, 0, 0.525],\n    \"76\": [0, 0.61111, 0, 0, 0.525],\n    \"77\": [0, 0.61111, 0, 0, 0.525],\n    \"78\": [0, 0.61111, 0, 0, 0.525],\n    \"79\": [0, 0.61111, 0, 0, 0.525],\n    \"80\": [0, 0.61111, 0, 0, 0.525],\n    \"81\": [0.13889, 0.61111, 0, 0, 0.525],\n    \"82\": [0, 0.61111, 0, 0, 0.525],\n    \"83\": [0, 0.61111, 0, 0, 0.525],\n    \"84\": [0, 0.61111, 0, 0, 0.525],\n    \"85\": [0, 0.61111, 0, 0, 0.525],\n    \"86\": [0, 0.61111, 0, 0, 0.525],\n    \"87\": [0, 0.61111, 0, 0, 0.525],\n    \"88\": [0, 0.61111, 0, 0, 0.525],\n    \"89\": [0, 0.61111, 0, 0, 0.525],\n    \"90\": [0, 0.61111, 0, 0, 0.525],\n    \"91\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"92\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"93\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"94\": [0, 0.61111, 0, 0, 0.525],\n    \"95\": [0.09514, 0, 0, 0, 0.525],\n    \"96\": [0, 0.61111, 0, 0, 0.525],\n    \"97\": [0, 0.43056, 0, 0, 0.525],\n    \"98\": [0, 0.61111, 0, 0, 0.525],\n    \"99\": [0, 0.43056, 0, 0, 0.525],\n    \"100\": [0, 0.61111, 0, 0, 0.525],\n    \"101\": [0, 0.43056, 0, 0, 0.525],\n    \"102\": [0, 0.61111, 0, 0, 0.525],\n    \"103\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"104\": [0, 0.61111, 0, 0, 0.525],\n    \"105\": [0, 0.61111, 0, 0, 0.525],\n    \"106\": [0.22222, 0.61111, 0, 0, 0.525],\n    \"107\": [0, 0.61111, 0, 0, 0.525],\n    \"108\": [0, 0.61111, 0, 0, 0.525],\n    \"109\": [0, 0.43056, 0, 0, 0.525],\n    \"110\": [0, 0.43056, 0, 0, 0.525],\n    \"111\": [0, 0.43056, 0, 0, 0.525],\n    \"112\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"113\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"114\": [0, 0.43056, 0, 0, 0.525],\n    \"115\": [0, 0.43056, 0, 0, 0.525],\n    \"116\": [0, 0.55358, 0, 0, 0.525],\n    \"117\": [0, 0.43056, 0, 0, 0.525],\n    \"118\": [0, 0.43056, 0, 0, 0.525],\n    \"119\": [0, 0.43056, 0, 0, 0.525],\n    \"120\": [0, 0.43056, 0, 0, 0.525],\n    \"121\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"122\": [0, 0.43056, 0, 0, 0.525],\n    \"123\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"124\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"125\": [0.08333, 0.69444, 0, 0, 0.525],\n    \"126\": [0, 0.61111, 0, 0, 0.525],\n    \"127\": [0, 0.61111, 0, 0, 0.525],\n    \"160\": [0, 0, 0, 0, 0.525],\n    \"176\": [0, 0.61111, 0, 0, 0.525],\n    \"184\": [0.19445, 0, 0, 0, 0.525],\n    \"305\": [0, 0.43056, 0, 0, 0.525],\n    \"567\": [0.22222, 0.43056, 0, 0, 0.525],\n    \"711\": [0, 0.56597, 0, 0, 0.525],\n    \"713\": [0, 0.56555, 0, 0, 0.525],\n    \"714\": [0, 0.61111, 0, 0, 0.525],\n    \"715\": [0, 0.61111, 0, 0, 0.525],\n    \"728\": [0, 0.61111, 0, 0, 0.525],\n    \"730\": [0, 0.61111, 0, 0, 0.525],\n    \"770\": [0, 0.61111, 0, 0, 0.525],\n    \"771\": [0, 0.61111, 0, 0, 0.525],\n    \"776\": [0, 0.61111, 0, 0, 0.525],\n    \"915\": [0, 0.61111, 0, 0, 0.525],\n    \"916\": [0, 0.61111, 0, 0, 0.525],\n    \"920\": [0, 0.61111, 0, 0, 0.525],\n    \"923\": [0, 0.61111, 0, 0, 0.525],\n    \"926\": [0, 0.61111, 0, 0, 0.525],\n    \"928\": [0, 0.61111, 0, 0, 0.525],\n    \"931\": [0, 0.61111, 0, 0, 0.525],\n    \"933\": [0, 0.61111, 0, 0, 0.525],\n    \"934\": [0, 0.61111, 0, 0, 0.525],\n    \"936\": [0, 0.61111, 0, 0, 0.525],\n    \"937\": [0, 0.61111, 0, 0, 0.525],\n    \"8216\": [0, 0.61111, 0, 0, 0.525],\n    \"8217\": [0, 0.61111, 0, 0, 0.525],\n    \"8242\": [0, 0.61111, 0, 0, 0.525],\n    \"9251\": [0.11111, 0.21944, 0, 0, 0.525]\n  }\n};\n\n/**\n * This file contains metrics regarding fonts and individual symbols. The sigma\n * and xi variables, as well as the metricMap map contain data extracted from\n * TeX, TeX font metrics, and the TTF files. These data are then exposed via the\n * `metrics` variable and the getCharacterMetrics function.\n */\n// In TeX, there are actually three sets of dimensions, one for each of\n// textstyle (size index 5 and higher: >=9pt), scriptstyle (size index 3 and 4:\n// 7-8pt), and scriptscriptstyle (size index 1 and 2: 5-6pt).  These are\n// provided in the arrays below, in that order.\n//\n// The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respectively.\n// This was determined by running the following script:\n//\n//     latex -interaction=nonstopmode \\\n//     '\\documentclass{article}\\usepackage{amsmath}\\begin{document}' \\\n//     '$a$ \\expandafter\\show\\the\\textfont2' \\\n//     '\\expandafter\\show\\the\\scriptfont2' \\\n//     '\\expandafter\\show\\the\\scriptscriptfont2' \\\n//     '\\stop'\n//\n// The metrics themselves were retrieved using the following commands:\n//\n//     tftopl cmsy10\n//     tftopl cmsy7\n//     tftopl cmsy5\n//\n// The output of each of these commands is quite lengthy.  The only part we\n// care about is the FONTDIMEN section. Each value is measured in EMs.\nvar sigmasAndXis = {\n  slant: [0.250, 0.250, 0.250],\n  // sigma1\n  space: [0.000, 0.000, 0.000],\n  // sigma2\n  stretch: [0.000, 0.000, 0.000],\n  // sigma3\n  shrink: [0.000, 0.000, 0.000],\n  // sigma4\n  xHeight: [0.431, 0.431, 0.431],\n  // sigma5\n  quad: [1.000, 1.171, 1.472],\n  // sigma6\n  extraSpace: [0.000, 0.000, 0.000],\n  // sigma7\n  num1: [0.677, 0.732, 0.925],\n  // sigma8\n  num2: [0.394, 0.384, 0.387],\n  // sigma9\n  num3: [0.444, 0.471, 0.504],\n  // sigma10\n  denom1: [0.686, 0.752, 1.025],\n  // sigma11\n  denom2: [0.345, 0.344, 0.532],\n  // sigma12\n  sup1: [0.413, 0.503, 0.504],\n  // sigma13\n  sup2: [0.363, 0.431, 0.404],\n  // sigma14\n  sup3: [0.289, 0.286, 0.294],\n  // sigma15\n  sub1: [0.150, 0.143, 0.200],\n  // sigma16\n  sub2: [0.247, 0.286, 0.400],\n  // sigma17\n  supDrop: [0.386, 0.353, 0.494],\n  // sigma18\n  subDrop: [0.050, 0.071, 0.100],\n  // sigma19\n  delim1: [2.390, 1.700, 1.980],\n  // sigma20\n  delim2: [1.010, 1.157, 1.420],\n  // sigma21\n  axisHeight: [0.250, 0.250, 0.250],\n  // sigma22\n  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;\n  // they correspond to the font parameters of the extension fonts (family 3).\n  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to\n  // match cmex7, we'd use cmex7.tfm values for script and scriptscript\n  // values.\n  defaultRuleThickness: [0.04, 0.049, 0.049],\n  // xi8; cmex7: 0.049\n  bigOpSpacing1: [0.111, 0.111, 0.111],\n  // xi9\n  bigOpSpacing2: [0.166, 0.166, 0.166],\n  // xi10\n  bigOpSpacing3: [0.2, 0.2, 0.2],\n  // xi11\n  bigOpSpacing4: [0.6, 0.611, 0.611],\n  // xi12; cmex7: 0.611\n  bigOpSpacing5: [0.1, 0.143, 0.143],\n  // xi13; cmex7: 0.143\n  // The \\sqrt rule width is taken from the height of the surd character.\n  // Since we use the same font at all sizes, this thickness doesn't scale.\n  sqrtRuleThickness: [0.04, 0.04, 0.04],\n  // This value determines how large a pt is, for metrics which are defined\n  // in terms of pts.\n  // This value is also used in katex.scss; if you change it make sure the\n  // values match.\n  ptPerEm: [10.0, 10.0, 10.0],\n  // The space between adjacent `|` columns in an array definition. From\n  // `\\showthe\\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.\n  doubleRuleSep: [0.2, 0.2, 0.2],\n  // The width of separator lines in {array} environments. From\n  // `\\showthe\\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.\n  arrayRuleWidth: [0.04, 0.04, 0.04],\n  // Two values from LaTeX source2e:\n  fboxsep: [0.3, 0.3, 0.3],\n  //        3 pt / ptPerEm\n  fboxrule: [0.04, 0.04, 0.04] // 0.4 pt / ptPerEm\n\n}; // This map contains a mapping from font name and character code to character\n// should have Latin-1 and Cyrillic characters, but may not depending on the\n// operating system.  The metrics do not account for extra height from the\n// accents.  In the case of Cyrillic characters which have both ascenders and\n// descenders we prefer approximations with ascenders, primarily to prevent\n// the fraction bar or root line from intersecting the glyph.\n// TODO(kevinb) allow union of multiple glyph metrics for better accuracy.\n\nvar extraCharacterMap = {\n  // Latin-1\n  '': 'A',\n  '': 'D',\n  '': 'o',\n  '': 'a',\n  '': 'd',\n  '': 'o',\n  // Cyrillic\n  '': 'A',\n  '': 'B',\n  '': 'B',\n  '': 'F',\n  '': 'A',\n  '': 'E',\n  '': 'K',\n  '': '3',\n  '': 'N',\n  '': 'N',\n  '': 'K',\n  '': 'N',\n  '': 'M',\n  '': 'H',\n  '': 'O',\n  '': 'N',\n  '': 'P',\n  '': 'C',\n  '': 'T',\n  '': 'y',\n  '': 'O',\n  '': 'X',\n  '': 'U',\n  '': 'h',\n  '': 'W',\n  '': 'W',\n  '': 'B',\n  '': 'X',\n  '': 'B',\n  '': '3',\n  '': 'X',\n  '': 'R',\n  '': 'a',\n  '': 'b',\n  '': 'a',\n  '': 'r',\n  '': 'y',\n  '': 'e',\n  '': 'm',\n  '': 'e',\n  '': 'n',\n  '': 'n',\n  '': 'n',\n  '': 'n',\n  '': 'm',\n  '': 'n',\n  '': 'o',\n  '': 'n',\n  '': 'p',\n  '': 'c',\n  '': 'o',\n  '': 'y',\n  '': 'b',\n  '': 'x',\n  '': 'n',\n  '': 'n',\n  '': 'w',\n  '': 'w',\n  '': 'a',\n  '': 'm',\n  '': 'a',\n  '': 'e',\n  '': 'm',\n  '': 'r'\n};\n\n/**\n * This function adds new font metrics to default metricMap\n * It can also override existing metrics\n */\nfunction setFontMetrics(fontName, metrics) {\n  fontMetricsData[fontName] = metrics;\n}\n/**\n * This function is a convenience function for looking up information in the\n * metricMap table. It takes a character as a string, and a font.\n *\n * Note: the `width` property may be undefined if fontMetricsData.js wasn't\n * built using `Make extended_metrics`.\n */\n\nfunction getCharacterMetrics(character, font, mode) {\n  if (!fontMetricsData[font]) {\n    throw new Error(\"Font metrics not found for font: \" + font + \".\");\n  }\n\n  var ch = character.charCodeAt(0);\n  var metrics = fontMetricsData[font][ch];\n\n  if (!metrics && character[0] in extraCharacterMap) {\n    ch = extraCharacterMap[character[0]].charCodeAt(0);\n    metrics = fontMetricsData[font][ch];\n  }\n\n  if (!metrics && mode === 'text') {\n    // We don't typically have font metrics for Asian scripts.\n    // But since we support them in text mode, we need to return\n    // some sort of metrics.\n    // So if the character is in a script we support but we\n    // don't have metrics for it, just use the metrics for\n    // the Latin capital letter M. This is close enough because\n    // we (currently) only care about the height of the glyph\n    // not its width.\n    if (supportedCodepoint(ch)) {\n      metrics = fontMetricsData[font][77]; // 77 is the charcode for 'M'\n    }\n  }\n\n  if (metrics) {\n    return {\n      depth: metrics[0],\n      height: metrics[1],\n      italic: metrics[2],\n      skew: metrics[3],\n      width: metrics[4]\n    };\n  }\n}\nvar fontMetricsBySizeIndex = {};\n/**\n * Get the font metrics for a given size.\n */\n\nfunction getGlobalMetrics(size) {\n  var sizeIndex;\n\n  if (size >= 5) {\n    sizeIndex = 0;\n  } else if (size >= 3) {\n    sizeIndex = 1;\n  } else {\n    sizeIndex = 2;\n  }\n\n  if (!fontMetricsBySizeIndex[sizeIndex]) {\n    var metrics = fontMetricsBySizeIndex[sizeIndex] = {\n      cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18\n    };\n\n    for (var key in sigmasAndXis) {\n      if (sigmasAndXis.hasOwnProperty(key)) {\n        metrics[key] = sigmasAndXis[key][sizeIndex];\n      }\n    }\n  }\n\n  return fontMetricsBySizeIndex[sizeIndex];\n}\n\n/**\n * This file contains information about the options that the Parser carries\n * around with it while parsing. Data is held in an `Options` object, and when\n * recursing, a new `Options` object can be created with the `.with*` and\n * `.reset` functions.\n */\nvar sizeStyleMap = [// Each element contains [textsize, scriptsize, scriptscriptsize].\n// The size mappings are taken from TeX with \\normalsize=10pt.\n[1, 1, 1], // size1: [5, 5, 5]              \\tiny\n[2, 1, 1], // size2: [6, 5, 5]\n[3, 1, 1], // size3: [7, 5, 5]              \\scriptsize\n[4, 2, 1], // size4: [8, 6, 5]              \\footnotesize\n[5, 2, 1], // size5: [9, 6, 5]              \\small\n[6, 3, 1], // size6: [10, 7, 5]             \\normalsize\n[7, 4, 2], // size7: [12, 8, 6]             \\large\n[8, 6, 3], // size8: [14.4, 10, 7]          \\Large\n[9, 7, 6], // size9: [17.28, 12, 10]        \\LARGE\n[10, 8, 7], // size10: [20.74, 14.4, 12]     \\huge\n[11, 10, 9] // size11: [24.88, 20.74, 17.28] \\HUGE\n];\nvar sizeMultipliers = [// fontMetrics.js:getGlobalMetrics also uses size indexes, so if\n// you change size indexes, change that function.\n0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.2, 1.44, 1.728, 2.074, 2.488];\n\nvar sizeAtStyle = function sizeAtStyle(size, style) {\n  return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];\n}; // In these types, \"\" (empty string) means \"no change\".\n\n\n/**\n * This is the main options class. It contains the current style, size, color,\n * and font.\n *\n * Options objects should not be modified. To create a new Options with\n * different properties, call a `.having*` method.\n */\nclass Options {\n  // A font family applies to a group of fonts (i.e. SansSerif), while a font\n  // represents a specific font (i.e. SansSerif Bold).\n  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm\n\n  /**\n   * The base size index.\n   */\n  constructor(data) {\n    this.style = void 0;\n    this.color = void 0;\n    this.size = void 0;\n    this.textSize = void 0;\n    this.phantom = void 0;\n    this.font = void 0;\n    this.fontFamily = void 0;\n    this.fontWeight = void 0;\n    this.fontShape = void 0;\n    this.sizeMultiplier = void 0;\n    this.maxSize = void 0;\n    this.minRuleThickness = void 0;\n    this._fontMetrics = void 0;\n    this.style = data.style;\n    this.color = data.color;\n    this.size = data.size || Options.BASESIZE;\n    this.textSize = data.textSize || this.size;\n    this.phantom = !!data.phantom;\n    this.font = data.font || \"\";\n    this.fontFamily = data.fontFamily || \"\";\n    this.fontWeight = data.fontWeight || '';\n    this.fontShape = data.fontShape || '';\n    this.sizeMultiplier = sizeMultipliers[this.size - 1];\n    this.maxSize = data.maxSize;\n    this.minRuleThickness = data.minRuleThickness;\n    this._fontMetrics = undefined;\n  }\n  /**\n   * Returns a new options object with the same properties as \"this\".  Properties\n   * from \"extension\" will be copied to the new options object.\n   */\n\n\n  extend(extension) {\n    var data = {\n      style: this.style,\n      size: this.size,\n      textSize: this.textSize,\n      color: this.color,\n      phantom: this.phantom,\n      font: this.font,\n      fontFamily: this.fontFamily,\n      fontWeight: this.fontWeight,\n      fontShape: this.fontShape,\n      maxSize: this.maxSize,\n      minRuleThickness: this.minRuleThickness\n    };\n\n    for (var key in extension) {\n      if (extension.hasOwnProperty(key)) {\n        data[key] = extension[key];\n      }\n    }\n\n    return new Options(data);\n  }\n  /**\n   * Return an options object with the given style. If `this.style === style`,\n   * returns `this`.\n   */\n\n\n  havingStyle(style) {\n    if (this.style === style) {\n      return this;\n    } else {\n      return this.extend({\n        style: style,\n        size: sizeAtStyle(this.textSize, style)\n      });\n    }\n  }\n  /**\n   * Return an options object with a cramped version of the current style. If\n   * the current style is cramped, returns `this`.\n   */\n\n\n  havingCrampedStyle() {\n    return this.havingStyle(this.style.cramp());\n  }\n  /**\n   * Return an options object with the given size and in at least `\\textstyle`.\n   * Returns `this` if appropriate.\n   */\n\n\n  havingSize(size) {\n    if (this.size === size && this.textSize === size) {\n      return this;\n    } else {\n      return this.extend({\n        style: this.style.text(),\n        size: size,\n        textSize: size,\n        sizeMultiplier: sizeMultipliers[size - 1]\n      });\n    }\n  }\n  /**\n   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,\n   * changes to at least `\\textstyle`.\n   */\n\n\n  havingBaseStyle(style) {\n    style = style || this.style.text();\n    var wantSize = sizeAtStyle(Options.BASESIZE, style);\n\n    if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {\n      return this;\n    } else {\n      return this.extend({\n        style: style,\n        size: wantSize\n      });\n    }\n  }\n  /**\n   * Remove the effect of sizing changes such as \\Huge.\n   * Keep the effect of the current style, such as \\scriptstyle.\n   */\n\n\n  havingBaseSizing() {\n    var size;\n\n    switch (this.style.id) {\n      case 4:\n      case 5:\n        size = 3; // normalsize in scriptstyle\n\n        break;\n\n      case 6:\n      case 7:\n        size = 1; // normalsize in scriptscriptstyle\n\n        break;\n\n      default:\n        size = 6;\n      // normalsize in textstyle or displaystyle\n    }\n\n    return this.extend({\n      style: this.style.text(),\n      size: size\n    });\n  }\n  /**\n   * Create a new options object with the given color.\n   */\n\n\n  withColor(color) {\n    return this.extend({\n      color: color\n    });\n  }\n  /**\n   * Create a new options object with \"phantom\" set to true.\n   */\n\n\n  withPhantom() {\n    return this.extend({\n      phantom: true\n    });\n  }\n  /**\n   * Creates a new options object with the given math font or old text font.\n   * @type {[type]}\n   */\n\n\n  withFont(font) {\n    return this.extend({\n      font\n    });\n  }\n  /**\n   * Create a new options objects with the given fontFamily.\n   */\n\n\n  withTextFontFamily(fontFamily) {\n    return this.extend({\n      fontFamily,\n      font: \"\"\n    });\n  }\n  /**\n   * Creates a new options object with the given font weight\n   */\n\n\n  withTextFontWeight(fontWeight) {\n    return this.extend({\n      fontWeight,\n      font: \"\"\n    });\n  }\n  /**\n   * Creates a new options object with the given font weight\n   */\n\n\n  withTextFontShape(fontShape) {\n    return this.extend({\n      fontShape,\n      font: \"\"\n    });\n  }\n  /**\n   * Return the CSS sizing classes required to switch from enclosing options\n   * `oldOptions` to `this`. Returns an array of classes.\n   */\n\n\n  sizingClasses(oldOptions) {\n    if (oldOptions.size !== this.size) {\n      return [\"sizing\", \"reset-size\" + oldOptions.size, \"size\" + this.size];\n    } else {\n      return [];\n    }\n  }\n  /**\n   * Return the CSS sizing classes required to switch to the base size. Like\n   * `this.havingSize(BASESIZE).sizingClasses(this)`.\n   */\n\n\n  baseSizingClasses() {\n    if (this.size !== Options.BASESIZE) {\n      return [\"sizing\", \"reset-size\" + this.size, \"size\" + Options.BASESIZE];\n    } else {\n      return [];\n    }\n  }\n  /**\n   * Return the font metrics for this size.\n   */\n\n\n  fontMetrics() {\n    if (!this._fontMetrics) {\n      this._fontMetrics = getGlobalMetrics(this.size);\n    }\n\n    return this._fontMetrics;\n  }\n  /**\n   * Gets the CSS color of the current options object\n   */\n\n\n  getColor() {\n    if (this.phantom) {\n      return \"transparent\";\n    } else {\n      return this.color;\n    }\n  }\n\n}\n\nOptions.BASESIZE = 6;\n\n/**\n * This file does conversion between units.  In particular, it provides\n * calculateSize to convert other units into ems.\n */\n// Thus, multiplying a length by this number converts the length from units\n// into pts.  Dividing the result by ptPerEm gives the number of ems\n// *assuming* a font size of ptPerEm (normal size, normal style).\n\nvar ptPerUnit = {\n  // https://en.wikibooks.org/wiki/LaTeX/Lengths and\n  // https://tex.stackexchange.com/a/8263\n  \"pt\": 1,\n  // TeX point\n  \"mm\": 7227 / 2540,\n  // millimeter\n  \"cm\": 7227 / 254,\n  // centimeter\n  \"in\": 72.27,\n  // inch\n  \"bp\": 803 / 800,\n  // big (PostScript) points\n  \"pc\": 12,\n  // pica\n  \"dd\": 1238 / 1157,\n  // didot\n  \"cc\": 14856 / 1157,\n  // cicero (12 didot)\n  \"nd\": 685 / 642,\n  // new didot\n  \"nc\": 1370 / 107,\n  // new cicero (12 new didot)\n  \"sp\": 1 / 65536,\n  // scaled point (TeX's internal smallest unit)\n  // https://tex.stackexchange.com/a/41371\n  \"px\": 803 / 800 // \\pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX\n\n}; // Dictionary of relative units, for fast validity testing.\n\nvar relativeUnit = {\n  \"ex\": true,\n  \"em\": true,\n  \"mu\": true\n};\n\n/**\n * Determine whether the specified unit (either a string defining the unit\n * or a \"size\" parse node containing a unit field) is valid.\n */\nvar validUnit = function validUnit(unit) {\n  if (typeof unit !== \"string\") {\n    unit = unit.unit;\n  }\n\n  return unit in ptPerUnit || unit in relativeUnit || unit === \"ex\";\n};\n/*\n * Convert a \"size\" parse node (with numeric \"number\" and string \"unit\" fields,\n * as parsed by functions.js argType \"size\") into a CSS em value for the\n * current style/scale.  `options` gives the current options.\n */\n\nvar calculateSize = function calculateSize(sizeValue, options) {\n  var scale;\n\n  if (sizeValue.unit in ptPerUnit) {\n    // Absolute units\n    scale = ptPerUnit[sizeValue.unit] // Convert unit to pt\n    / options.fontMetrics().ptPerEm // Convert pt to CSS em\n    / options.sizeMultiplier; // Unscale to make absolute units\n  } else if (sizeValue.unit === \"mu\") {\n    // `mu` units scale with scriptstyle/scriptscriptstyle.\n    scale = options.fontMetrics().cssEmPerMu;\n  } else {\n    // Other relative units always refer to the *textstyle* font\n    // in the current size.\n    var unitOptions;\n\n    if (options.style.isTight()) {\n      // isTight() means current style is script/scriptscript.\n      unitOptions = options.havingStyle(options.style.text());\n    } else {\n      unitOptions = options;\n    } // TODO: In TeX these units are relative to the quad of the current\n    // *text* font, e.g. cmr10. KaTeX instead uses values from the\n    // comparably-sized *Computer Modern symbol* font. At 10pt, these\n    // match. At 7pt and 5pt, they differ: cmr7=1.138894, cmsy7=1.170641;\n    // cmr5=1.361133, cmsy5=1.472241. Consider $\\scriptsize a\\kern1emb$.\n    // TeX \\showlists shows a kern of 1.13889 * fontsize;\n    // KaTeX shows a kern of 1.171 * fontsize.\n\n\n    if (sizeValue.unit === \"ex\") {\n      scale = unitOptions.fontMetrics().xHeight;\n    } else if (sizeValue.unit === \"em\") {\n      scale = unitOptions.fontMetrics().quad;\n    } else {\n      throw new ParseError(\"Invalid unit: '\" + sizeValue.unit + \"'\");\n    }\n\n    if (unitOptions !== options) {\n      scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;\n    }\n  }\n\n  return Math.min(sizeValue.number * scale, options.maxSize);\n};\n/**\n * Round `n` to 4 decimal places, or to the nearest 1/10,000th em. See\n * https://github.com/KaTeX/KaTeX/pull/2460.\n */\n\nvar makeEm = function makeEm(n) {\n  return +n.toFixed(4) + \"em\";\n};\n\n/**\n * These objects store the data about the DOM nodes we create, as well as some\n * extra data. They can then be transformed into real DOM nodes with the\n * `toNode` function or HTML markup using `toMarkup`. They are useful for both\n * storing extra properties on the nodes, as well as providing a way to easily\n * work with the DOM.\n *\n * Similar functions for working with MathML nodes exist in mathMLTree.js.\n *\n * TODO: refactor `span` and `anchor` into common superclass when\n * target environments support class inheritance\n */\n\n/**\n * Create an HTML className based on a list of classes. In addition to joining\n * with spaces, we also remove empty classes.\n */\nvar createClass = function createClass(classes) {\n  return classes.filter(cls => cls).join(\" \");\n};\n\nvar initNode = function initNode(classes, options, style) {\n  this.classes = classes || [];\n  this.attributes = {};\n  this.height = 0;\n  this.depth = 0;\n  this.maxFontSize = 0;\n  this.style = style || {};\n\n  if (options) {\n    if (options.style.isTight()) {\n      this.classes.push(\"mtight\");\n    }\n\n    var color = options.getColor();\n\n    if (color) {\n      this.style.color = color;\n    }\n  }\n};\n/**\n * Convert into an HTML node\n */\n\n\nvar toNode = function toNode(tagName) {\n  var node = document.createElement(tagName); // Apply the class\n\n  node.className = createClass(this.classes); // Apply inline styles\n\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      // $FlowFixMe Flow doesn't seem to understand span.style's type.\n      node.style[style] = this.style[style];\n    }\n  } // Apply attributes\n\n\n  for (var attr in this.attributes) {\n    if (this.attributes.hasOwnProperty(attr)) {\n      node.setAttribute(attr, this.attributes[attr]);\n    }\n  } // Append the children, also as HTML nodes\n\n\n  for (var i = 0; i < this.children.length; i++) {\n    node.appendChild(this.children[i].toNode());\n  }\n\n  return node;\n};\n/**\n * https://w3c.github.io/html-reference/syntax.html#syntax-attributes\n *\n * > Attribute Names must consist of one or more characters\n * other than the space characters, U+0000 NULL,\n * '\"', \"'\", \">\", \"/\", \"=\", the control characters,\n * and any characters that are not defined by Unicode.\n */\n\n\nvar invalidAttributeNameRegex = /[\\s\"'>/=\\x00-\\x1f]/;\n/**\n * Convert into an HTML markup string\n */\n\nvar toMarkup = function toMarkup(tagName) {\n  var markup = \"<\" + tagName; // Add the class\n\n  if (this.classes.length) {\n    markup += \" class=\\\"\" + utils.escape(createClass(this.classes)) + \"\\\"\";\n  }\n\n  var styles = \"\"; // Add the styles, after hyphenation\n\n  for (var style in this.style) {\n    if (this.style.hasOwnProperty(style)) {\n      styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n    }\n  }\n\n  if (styles) {\n    markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n  } // Add the attributes\n\n\n  for (var attr in this.attributes) {\n    if (this.attributes.hasOwnProperty(attr)) {\n      if (invalidAttributeNameRegex.test(attr)) {\n        throw new ParseError(\"Invalid attribute name '\" + attr + \"'\");\n      }\n\n      markup += \" \" + attr + \"=\\\"\" + utils.escape(this.attributes[attr]) + \"\\\"\";\n    }\n  }\n\n  markup += \">\"; // Add the markup of the children, also as markup\n\n  for (var i = 0; i < this.children.length; i++) {\n    markup += this.children[i].toMarkup();\n  }\n\n  markup += \"</\" + tagName + \">\";\n  return markup;\n}; // Making the type below exact with all optional fields doesn't work due to\n// - https://github.com/facebook/flow/issues/4582\n// - https://github.com/facebook/flow/issues/5688\n// However, since *all* fields are optional, $Shape<> works as suggested in 5688\n// above.\n// This type does not include all CSS properties. Additional properties should\n// be added as needed.\n\n\n/**\n * This node represents a span node, with a className, a list of children, and\n * an inline style. It also contains information about its height, depth, and\n * maxFontSize.\n *\n * Represents two types with different uses: SvgSpan to wrap an SVG and DomSpan\n * otherwise. This typesafety is important when HTML builders access a span's\n * children.\n */\nclass Span {\n  constructor(classes, children, options, style) {\n    this.children = void 0;\n    this.attributes = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.width = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    initNode.call(this, classes, options, style);\n    this.children = children || [];\n  }\n  /**\n   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not\n   * all browsers support attributes the same, and having too many custom\n   * attributes is probably bad.\n   */\n\n\n  setAttribute(attribute, value) {\n    this.attributes[attribute] = value;\n  }\n\n  hasClass(className) {\n    return this.classes.includes(className);\n  }\n\n  toNode() {\n    return toNode.call(this, \"span\");\n  }\n\n  toMarkup() {\n    return toMarkup.call(this, \"span\");\n  }\n\n}\n/**\n * This node represents an anchor (<a>) element with a hyperlink.  See `span`\n * for further details.\n */\n\nclass Anchor {\n  constructor(href, classes, children, options) {\n    this.children = void 0;\n    this.attributes = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    initNode.call(this, classes, options);\n    this.children = children || [];\n    this.setAttribute('href', href);\n  }\n\n  setAttribute(attribute, value) {\n    this.attributes[attribute] = value;\n  }\n\n  hasClass(className) {\n    return this.classes.includes(className);\n  }\n\n  toNode() {\n    return toNode.call(this, \"a\");\n  }\n\n  toMarkup() {\n    return toMarkup.call(this, \"a\");\n  }\n\n}\n/**\n * This node represents an image embed (<img>) element.\n */\n\nclass Img {\n  constructor(src, alt, style) {\n    this.src = void 0;\n    this.alt = void 0;\n    this.classes = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.maxFontSize = void 0;\n    this.style = void 0;\n    this.alt = alt;\n    this.src = src;\n    this.classes = [\"mord\"];\n    this.style = style;\n  }\n\n  hasClass(className) {\n    return this.classes.includes(className);\n  }\n\n  toNode() {\n    var node = document.createElement(\"img\");\n    node.src = this.src;\n    node.alt = this.alt;\n    node.className = \"mord\"; // Apply inline styles\n\n    for (var style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        // $FlowFixMe\n        node.style[style] = this.style[style];\n      }\n    }\n\n    return node;\n  }\n\n  toMarkup() {\n    var markup = \"<img src=\\\"\" + utils.escape(this.src) + \"\\\"\" + (\" alt=\\\"\" + utils.escape(this.alt) + \"\\\"\"); // Add the styles, after hyphenation\n\n    var styles = \"\";\n\n    for (var style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n      }\n    }\n\n    if (styles) {\n      markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n    }\n\n    markup += \"'/>\";\n    return markup;\n  }\n\n}\nvar iCombinations = {\n  '': '\\u0131\\u0302',\n  '': '\\u0131\\u0308',\n  '': '\\u0131\\u0301',\n  // '': '\\u0131\\u0304', // enable when we add Extended Latin\n  '': '\\u0131\\u0300'\n};\n/**\n * A symbol node contains information about a single symbol. It either renders\n * to a single text node, or a span with a single text node in it, depending on\n * whether it has CSS classes, styles, or needs italic correction.\n */\n\nclass SymbolNode {\n  constructor(text, height, depth, italic, skew, width, classes, style) {\n    this.text = void 0;\n    this.height = void 0;\n    this.depth = void 0;\n    this.italic = void 0;\n    this.skew = void 0;\n    this.width = void 0;\n    this.maxFontSize = void 0;\n    this.classes = void 0;\n    this.style = void 0;\n    this.text = text;\n    this.height = height || 0;\n    this.depth = depth || 0;\n    this.italic = italic || 0;\n    this.skew = skew || 0;\n    this.width = width || 0;\n    this.classes = classes || [];\n    this.style = style || {};\n    this.maxFontSize = 0; // Mark text from non-Latin scripts with specific classes so that we\n    // can specify which fonts to use.  This allows us to render these\n    // characters with a serif font in situations where the browser would\n    // either default to a sans serif or render a placeholder character.\n    // We use CSS class names like cjk_fallback, hangul_fallback and\n    // brahmic_fallback. See ./unicodeScripts.js for the set of possible\n    // script names\n\n    var script = scriptFromCodepoint(this.text.charCodeAt(0));\n\n    if (script) {\n      this.classes.push(script + \"_fallback\");\n    }\n\n    if (/[]/.test(this.text)) {\n      // add  when we add Extended Latin\n      this.text = iCombinations[this.text];\n    }\n  }\n\n  hasClass(className) {\n    return this.classes.includes(className);\n  }\n  /**\n   * Creates a text node or span from a symbol node. Note that a span is only\n   * created if it is needed.\n   */\n\n\n  toNode() {\n    var node = document.createTextNode(this.text);\n    var span = null;\n\n    if (this.italic > 0) {\n      span = document.createElement(\"span\");\n      span.style.marginRight = makeEm(this.italic);\n    }\n\n    if (this.classes.length > 0) {\n      span = span || document.createElement(\"span\");\n      span.className = createClass(this.classes);\n    }\n\n    for (var style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        span = span || document.createElement(\"span\"); // $FlowFixMe Flow doesn't seem to understand span.style's type.\n\n        span.style[style] = this.style[style];\n      }\n    }\n\n    if (span) {\n      span.appendChild(node);\n      return span;\n    } else {\n      return node;\n    }\n  }\n  /**\n   * Creates markup for a symbol node.\n   */\n\n\n  toMarkup() {\n    // TODO(alpert): More duplication than I'd like from\n    // span.prototype.toMarkup and symbolNode.prototype.toNode...\n    var needsSpan = false;\n    var markup = \"<span\";\n\n    if (this.classes.length) {\n      needsSpan = true;\n      markup += \" class=\\\"\";\n      markup += utils.escape(createClass(this.classes));\n      markup += \"\\\"\";\n    }\n\n    var styles = \"\";\n\n    if (this.italic > 0) {\n      styles += \"margin-right:\" + this.italic + \"em;\";\n    }\n\n    for (var style in this.style) {\n      if (this.style.hasOwnProperty(style)) {\n        styles += utils.hyphenate(style) + \":\" + this.style[style] + \";\";\n      }\n    }\n\n    if (styles) {\n      needsSpan = true;\n      markup += \" style=\\\"\" + utils.escape(styles) + \"\\\"\";\n    }\n\n    var escaped = utils.escape(this.text);\n\n    if (needsSpan) {\n      markup += \">\";\n      markup += escaped;\n      markup += \"</span>\";\n      return markup;\n    } else {\n      return escaped;\n    }\n  }\n\n}\n/**\n * SVG nodes are used to render stretchy wide elements.\n */\n\nclass SvgNode {\n  constructor(children, attributes) {\n    this.children = void 0;\n    this.attributes = void 0;\n    this.children = children || [];\n    this.attributes = attributes || {};\n  }\n\n  toNode() {\n    var svgNS = \"http://www.w3.org/2000/svg\";\n    var node = document.createElementNS(svgNS, \"svg\"); // Apply attributes\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        node.setAttribute(attr, this.attributes[attr]);\n      }\n    }\n\n    for (var i = 0; i < this.children.length; i++) {\n      node.appendChild(this.children[i].toNode());\n    }\n\n    return node;\n  }\n\n  toMarkup() {\n    var markup = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\"\"; // Apply attributes\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        markup += \" \" + attr + \"=\\\"\" + utils.escape(this.attributes[attr]) + \"\\\"\";\n      }\n    }\n\n    markup += \">\";\n\n    for (var i = 0; i < this.children.length; i++) {\n      markup += this.children[i].toMarkup();\n    }\n\n    markup += \"</svg>\";\n    return markup;\n  }\n\n}\nclass PathNode {\n  constructor(pathName, alternate) {\n    this.pathName = void 0;\n    this.alternate = void 0;\n    this.pathName = pathName;\n    this.alternate = alternate; // Used only for \\sqrt, \\phase, & tall delims\n  }\n\n  toNode() {\n    var svgNS = \"http://www.w3.org/2000/svg\";\n    var node = document.createElementNS(svgNS, \"path\");\n\n    if (this.alternate) {\n      node.setAttribute(\"d\", this.alternate);\n    } else {\n      node.setAttribute(\"d\", path[this.pathName]);\n    }\n\n    return node;\n  }\n\n  toMarkup() {\n    if (this.alternate) {\n      return \"<path d=\\\"\" + utils.escape(this.alternate) + \"\\\"/>\";\n    } else {\n      return \"<path d=\\\"\" + utils.escape(path[this.pathName]) + \"\\\"/>\";\n    }\n  }\n\n}\nclass LineNode {\n  constructor(attributes) {\n    this.attributes = void 0;\n    this.attributes = attributes || {};\n  }\n\n  toNode() {\n    var svgNS = \"http://www.w3.org/2000/svg\";\n    var node = document.createElementNS(svgNS, \"line\"); // Apply attributes\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        node.setAttribute(attr, this.attributes[attr]);\n      }\n    }\n\n    return node;\n  }\n\n  toMarkup() {\n    var markup = \"<line\";\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        markup += \" \" + attr + \"=\\\"\" + utils.escape(this.attributes[attr]) + \"\\\"\";\n      }\n    }\n\n    markup += \"/>\";\n    return markup;\n  }\n\n}\nfunction assertSymbolDomNode(group) {\n  if (group instanceof SymbolNode) {\n    return group;\n  } else {\n    throw new Error(\"Expected symbolNode but got \" + String(group) + \".\");\n  }\n}\nfunction assertSpan(group) {\n  if (group instanceof Span) {\n    return group;\n  } else {\n    throw new Error(\"Expected span<HtmlDomNode> but got \" + String(group) + \".\");\n  }\n}\n\n/**\n * This file holds a list of all no-argument functions and single-character\n * symbols (like 'a' or ';').\n *\n * For each of the symbols, there are three properties they can have:\n * - font (required): the font to be used for this symbol. Either \"main\" (the\n     normal font), or \"ams\" (the ams fonts).\n * - group (required): the ParseNode group type the symbol should have (i.e.\n     \"textord\", \"mathord\", etc).\n     See https://github.com/KaTeX/KaTeX/wiki/Examining-TeX#group-types\n * - replace: the character that this symbol or function should be\n *   replaced with (i.e. \"\\phi\" has a replace value of \"\\u03d5\", the phi\n *   character in the main font).\n *\n * The outermost map in the table indicates what mode the symbols should be\n * accepted in (e.g. \"math\" or \"text\").\n */\n// Some of these have a \"-token\" suffix since these are also used as `ParseNode`\n// types for raw text tokens, and we want to avoid conflicts with higher-level\n// `ParseNode` types. These `ParseNode`s are constructed within `Parser` by\n// looking up the `symbols` map.\nvar ATOMS = {\n  \"bin\": 1,\n  \"close\": 1,\n  \"inner\": 1,\n  \"open\": 1,\n  \"punct\": 1,\n  \"rel\": 1\n};\nvar NON_ATOMS = {\n  \"accent-token\": 1,\n  \"mathord\": 1,\n  \"op-token\": 1,\n  \"spacing\": 1,\n  \"textord\": 1\n};\nvar symbols = {\n  \"math\": {},\n  \"text\": {}\n};\n/** `acceptUnicodeChar = true` is only applicable if `replace` is set. */\n\nfunction defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {\n  symbols[mode][name] = {\n    font,\n    group,\n    replace\n  };\n\n  if (acceptUnicodeChar && replace) {\n    symbols[mode][replace] = symbols[mode][name];\n  }\n} // Some abbreviations for commonly used strings.\n// This helps minify the code, and also spotting typos using jshint.\n// modes:\n\nvar math = \"math\";\nvar text = \"text\"; // fonts:\n\nvar main = \"main\";\nvar ams = \"ams\"; // groups:\n\nvar accent = \"accent-token\";\nvar bin = \"bin\";\nvar close = \"close\";\nvar inner = \"inner\";\nvar mathord = \"mathord\";\nvar op = \"op-token\";\nvar open = \"open\";\nvar punct = \"punct\";\nvar rel = \"rel\";\nvar spacing = \"spacing\";\nvar textord = \"textord\"; // Now comes the symbol table\n// Relation Symbols\n\ndefineSymbol(math, main, rel, \"\\u2261\", \"\\\\equiv\", true);\ndefineSymbol(math, main, rel, \"\\u227a\", \"\\\\prec\", true);\ndefineSymbol(math, main, rel, \"\\u227b\", \"\\\\succ\", true);\ndefineSymbol(math, main, rel, \"\\u223c\", \"\\\\sim\", true);\ndefineSymbol(math, main, rel, \"\\u22a5\", \"\\\\perp\");\ndefineSymbol(math, main, rel, \"\\u2aaf\", \"\\\\preceq\", true);\ndefineSymbol(math, main, rel, \"\\u2ab0\", \"\\\\succeq\", true);\ndefineSymbol(math, main, rel, \"\\u2243\", \"\\\\simeq\", true);\ndefineSymbol(math, main, rel, \"\\u2223\", \"\\\\mid\", true);\ndefineSymbol(math, main, rel, \"\\u226a\", \"\\\\ll\", true);\ndefineSymbol(math, main, rel, \"\\u226b\", \"\\\\gg\", true);\ndefineSymbol(math, main, rel, \"\\u224d\", \"\\\\asymp\", true);\ndefineSymbol(math, main, rel, \"\\u2225\", \"\\\\parallel\");\ndefineSymbol(math, main, rel, \"\\u22c8\", \"\\\\bowtie\", true);\ndefineSymbol(math, main, rel, \"\\u2323\", \"\\\\smile\", true);\ndefineSymbol(math, main, rel, \"\\u2291\", \"\\\\sqsubseteq\", true);\ndefineSymbol(math, main, rel, \"\\u2292\", \"\\\\sqsupseteq\", true);\ndefineSymbol(math, main, rel, \"\\u2250\", \"\\\\doteq\", true);\ndefineSymbol(math, main, rel, \"\\u2322\", \"\\\\frown\", true);\ndefineSymbol(math, main, rel, \"\\u220b\", \"\\\\ni\", true);\ndefineSymbol(math, main, rel, \"\\u221d\", \"\\\\propto\", true);\ndefineSymbol(math, main, rel, \"\\u22a2\", \"\\\\vdash\", true);\ndefineSymbol(math, main, rel, \"\\u22a3\", \"\\\\dashv\", true);\ndefineSymbol(math, main, rel, \"\\u220b\", \"\\\\owns\"); // Punctuation\n\ndefineSymbol(math, main, punct, \"\\u002e\", \"\\\\ldotp\");\ndefineSymbol(math, main, punct, \"\\u22c5\", \"\\\\cdotp\"); // Misc Symbols\n\ndefineSymbol(math, main, textord, \"\\u0023\", \"\\\\#\");\ndefineSymbol(text, main, textord, \"\\u0023\", \"\\\\#\");\ndefineSymbol(math, main, textord, \"\\u0026\", \"\\\\&\");\ndefineSymbol(text, main, textord, \"\\u0026\", \"\\\\&\");\ndefineSymbol(math, main, textord, \"\\u2135\", \"\\\\aleph\", true);\ndefineSymbol(math, main, textord, \"\\u2200\", \"\\\\forall\", true);\ndefineSymbol(math, main, textord, \"\\u210f\", \"\\\\hbar\", true);\ndefineSymbol(math, main, textord, \"\\u2203\", \"\\\\exists\", true);\ndefineSymbol(math, main, textord, \"\\u2207\", \"\\\\nabla\", true);\ndefineSymbol(math, main, textord, \"\\u266d\", \"\\\\flat\", true);\ndefineSymbol(math, main, textord, \"\\u2113\", \"\\\\ell\", true);\ndefineSymbol(math, main, textord, \"\\u266e\", \"\\\\natural\", true);\ndefineSymbol(math, main, textord, \"\\u2663\", \"\\\\clubsuit\", true);\ndefineSymbol(math, main, textord, \"\\u2118\", \"\\\\wp\", true);\ndefineSymbol(math, main, textord, \"\\u266f\", \"\\\\sharp\", true);\ndefineSymbol(math, main, textord, \"\\u2662\", \"\\\\diamondsuit\", true);\ndefineSymbol(math, main, textord, \"\\u211c\", \"\\\\Re\", true);\ndefineSymbol(math, main, textord, \"\\u2661\", \"\\\\heartsuit\", true);\ndefineSymbol(math, main, textord, \"\\u2111\", \"\\\\Im\", true);\ndefineSymbol(math, main, textord, \"\\u2660\", \"\\\\spadesuit\", true);\ndefineSymbol(math, main, textord, \"\\u00a7\", \"\\\\S\", true);\ndefineSymbol(text, main, textord, \"\\u00a7\", \"\\\\S\");\ndefineSymbol(math, main, textord, \"\\u00b6\", \"\\\\P\", true);\ndefineSymbol(text, main, textord, \"\\u00b6\", \"\\\\P\"); // Math and Text\n\ndefineSymbol(math, main, textord, \"\\u2020\", \"\\\\dag\");\ndefineSymbol(text, main, textord, \"\\u2020\", \"\\\\dag\");\ndefineSymbol(text, main, textord, \"\\u2020\", \"\\\\textdagger\");\ndefineSymbol(math, main, textord, \"\\u2021\", \"\\\\ddag\");\ndefineSymbol(text, main, textord, \"\\u2021\", \"\\\\ddag\");\ndefineSymbol(text, main, textord, \"\\u2021\", \"\\\\textdaggerdbl\"); // Large Delimiters\n\ndefineSymbol(math, main, close, \"\\u23b1\", \"\\\\rmoustache\", true);\ndefineSymbol(math, main, open, \"\\u23b0\", \"\\\\lmoustache\", true);\ndefineSymbol(math, main, close, \"\\u27ef\", \"\\\\rgroup\", true);\ndefineSymbol(math, main, open, \"\\u27ee\", \"\\\\lgroup\", true); // Binary Operators\n\ndefineSymbol(math, main, bin, \"\\u2213\", \"\\\\mp\", true);\ndefineSymbol(math, main, bin, \"\\u2296\", \"\\\\ominus\", true);\ndefineSymbol(math, main, bin, \"\\u228e\", \"\\\\uplus\", true);\ndefineSymbol(math, main, bin, \"\\u2293\", \"\\\\sqcap\", true);\ndefineSymbol(math, main, bin, \"\\u2217\", \"\\\\ast\");\ndefineSymbol(math, main, bin, \"\\u2294\", \"\\\\sqcup\", true);\ndefineSymbol(math, main, bin, \"\\u25ef\", \"\\\\bigcirc\", true);\ndefineSymbol(math, main, bin, \"\\u2219\", \"\\\\bullet\", true);\ndefineSymbol(math, main, bin, \"\\u2021\", \"\\\\ddagger\");\ndefineSymbol(math, main, bin, \"\\u2240\", \"\\\\wr\", true);\ndefineSymbol(math, main, bin, \"\\u2a3f\", \"\\\\amalg\");\ndefineSymbol(math, main, bin, \"\\u0026\", \"\\\\And\"); // from amsmath\n// Arrow Symbols\n\ndefineSymbol(math, main, rel, \"\\u27f5\", \"\\\\longleftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d0\", \"\\\\Leftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27f8\", \"\\\\Longleftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27f6\", \"\\\\longrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d2\", \"\\\\Rightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27f9\", \"\\\\Longrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2194\", \"\\\\leftrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27f7\", \"\\\\longleftrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d4\", \"\\\\Leftrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u27fa\", \"\\\\Longleftrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21a6\", \"\\\\mapsto\", true);\ndefineSymbol(math, main, rel, \"\\u27fc\", \"\\\\longmapsto\", true);\ndefineSymbol(math, main, rel, \"\\u2197\", \"\\\\nearrow\", true);\ndefineSymbol(math, main, rel, \"\\u21a9\", \"\\\\hookleftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21aa\", \"\\\\hookrightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2198\", \"\\\\searrow\", true);\ndefineSymbol(math, main, rel, \"\\u21bc\", \"\\\\leftharpoonup\", true);\ndefineSymbol(math, main, rel, \"\\u21c0\", \"\\\\rightharpoonup\", true);\ndefineSymbol(math, main, rel, \"\\u2199\", \"\\\\swarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21bd\", \"\\\\leftharpoondown\", true);\ndefineSymbol(math, main, rel, \"\\u21c1\", \"\\\\rightharpoondown\", true);\ndefineSymbol(math, main, rel, \"\\u2196\", \"\\\\nwarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21cc\", \"\\\\rightleftharpoons\", true); // AMS Negated Binary Relations\n\ndefineSymbol(math, ams, rel, \"\\u226e\", \"\\\\nless\", true); // Symbol names preceded by \"@\" each have a corresponding macro.\n\ndefineSymbol(math, ams, rel, \"\\ue010\", \"\\\\@nleqslant\");\ndefineSymbol(math, ams, rel, \"\\ue011\", \"\\\\@nleqq\");\ndefineSymbol(math, ams, rel, \"\\u2a87\", \"\\\\lneq\", true);\ndefineSymbol(math, ams, rel, \"\\u2268\", \"\\\\lneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue00c\", \"\\\\@lvertneqq\");\ndefineSymbol(math, ams, rel, \"\\u22e6\", \"\\\\lnsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2a89\", \"\\\\lnapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u2280\", \"\\\\nprec\", true); // unicode-math maps \\u22e0 to \\npreccurlyeq. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u22e0\", \"\\\\npreceq\", true);\ndefineSymbol(math, ams, rel, \"\\u22e8\", \"\\\\precnsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab9\", \"\\\\precnapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u2241\", \"\\\\nsim\", true);\ndefineSymbol(math, ams, rel, \"\\ue006\", \"\\\\@nshortmid\");\ndefineSymbol(math, ams, rel, \"\\u2224\", \"\\\\nmid\", true);\ndefineSymbol(math, ams, rel, \"\\u22ac\", \"\\\\nvdash\", true);\ndefineSymbol(math, ams, rel, \"\\u22ad\", \"\\\\nvDash\", true);\ndefineSymbol(math, ams, rel, \"\\u22ea\", \"\\\\ntriangleleft\");\ndefineSymbol(math, ams, rel, \"\\u22ec\", \"\\\\ntrianglelefteq\", true);\ndefineSymbol(math, ams, rel, \"\\u228a\", \"\\\\subsetneq\", true);\ndefineSymbol(math, ams, rel, \"\\ue01a\", \"\\\\@varsubsetneq\");\ndefineSymbol(math, ams, rel, \"\\u2acb\", \"\\\\subsetneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue017\", \"\\\\@varsubsetneqq\");\ndefineSymbol(math, ams, rel, \"\\u226f\", \"\\\\ngtr\", true);\ndefineSymbol(math, ams, rel, \"\\ue00f\", \"\\\\@ngeqslant\");\ndefineSymbol(math, ams, rel, \"\\ue00e\", \"\\\\@ngeqq\");\ndefineSymbol(math, ams, rel, \"\\u2a88\", \"\\\\gneq\", true);\ndefineSymbol(math, ams, rel, \"\\u2269\", \"\\\\gneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue00d\", \"\\\\@gvertneqq\");\ndefineSymbol(math, ams, rel, \"\\u22e7\", \"\\\\gnsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2a8a\", \"\\\\gnapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u2281\", \"\\\\nsucc\", true); // unicode-math maps \\u22e1 to \\nsucccurlyeq. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u22e1\", \"\\\\nsucceq\", true);\ndefineSymbol(math, ams, rel, \"\\u22e9\", \"\\\\succnsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2aba\", \"\\\\succnapprox\", true); // unicode-math maps \\u2246 to \\simneqq. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u2246\", \"\\\\ncong\", true);\ndefineSymbol(math, ams, rel, \"\\ue007\", \"\\\\@nshortparallel\");\ndefineSymbol(math, ams, rel, \"\\u2226\", \"\\\\nparallel\", true);\ndefineSymbol(math, ams, rel, \"\\u22af\", \"\\\\nVDash\", true);\ndefineSymbol(math, ams, rel, \"\\u22eb\", \"\\\\ntriangleright\");\ndefineSymbol(math, ams, rel, \"\\u22ed\", \"\\\\ntrianglerighteq\", true);\ndefineSymbol(math, ams, rel, \"\\ue018\", \"\\\\@nsupseteqq\");\ndefineSymbol(math, ams, rel, \"\\u228b\", \"\\\\supsetneq\", true);\ndefineSymbol(math, ams, rel, \"\\ue01b\", \"\\\\@varsupsetneq\");\ndefineSymbol(math, ams, rel, \"\\u2acc\", \"\\\\supsetneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue019\", \"\\\\@varsupsetneqq\");\ndefineSymbol(math, ams, rel, \"\\u22ae\", \"\\\\nVdash\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab5\", \"\\\\precneqq\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab6\", \"\\\\succneqq\", true);\ndefineSymbol(math, ams, rel, \"\\ue016\", \"\\\\@nsubseteqq\");\ndefineSymbol(math, ams, bin, \"\\u22b4\", \"\\\\unlhd\");\ndefineSymbol(math, ams, bin, \"\\u22b5\", \"\\\\unrhd\"); // AMS Negated Arrows\n\ndefineSymbol(math, ams, rel, \"\\u219a\", \"\\\\nleftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u219b\", \"\\\\nrightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21cd\", \"\\\\nLeftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21cf\", \"\\\\nRightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21ae\", \"\\\\nleftrightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21ce\", \"\\\\nLeftrightarrow\", true); // AMS Misc\n\ndefineSymbol(math, ams, rel, \"\\u25b3\", \"\\\\vartriangle\");\ndefineSymbol(math, ams, textord, \"\\u210f\", \"\\\\hslash\");\ndefineSymbol(math, ams, textord, \"\\u25bd\", \"\\\\triangledown\");\ndefineSymbol(math, ams, textord, \"\\u25ca\", \"\\\\lozenge\");\ndefineSymbol(math, ams, textord, \"\\u24c8\", \"\\\\circledS\");\ndefineSymbol(math, ams, textord, \"\\u00ae\", \"\\\\circledR\");\ndefineSymbol(text, ams, textord, \"\\u00ae\", \"\\\\circledR\");\ndefineSymbol(math, ams, textord, \"\\u2221\", \"\\\\measuredangle\", true);\ndefineSymbol(math, ams, textord, \"\\u2204\", \"\\\\nexists\");\ndefineSymbol(math, ams, textord, \"\\u2127\", \"\\\\mho\");\ndefineSymbol(math, ams, textord, \"\\u2132\", \"\\\\Finv\", true);\ndefineSymbol(math, ams, textord, \"\\u2141\", \"\\\\Game\", true);\ndefineSymbol(math, ams, textord, \"\\u2035\", \"\\\\backprime\");\ndefineSymbol(math, ams, textord, \"\\u25b2\", \"\\\\blacktriangle\");\ndefineSymbol(math, ams, textord, \"\\u25bc\", \"\\\\blacktriangledown\");\ndefineSymbol(math, ams, textord, \"\\u25a0\", \"\\\\blacksquare\");\ndefineSymbol(math, ams, textord, \"\\u29eb\", \"\\\\blacklozenge\");\ndefineSymbol(math, ams, textord, \"\\u2605\", \"\\\\bigstar\");\ndefineSymbol(math, ams, textord, \"\\u2222\", \"\\\\sphericalangle\", true);\ndefineSymbol(math, ams, textord, \"\\u2201\", \"\\\\complement\", true); // unicode-math maps U+F0 to \\matheth. We map to AMS function \\eth\n\ndefineSymbol(math, ams, textord, \"\\u00f0\", \"\\\\eth\", true);\ndefineSymbol(text, main, textord, \"\\u00f0\", \"\\u00f0\");\ndefineSymbol(math, ams, textord, \"\\u2571\", \"\\\\diagup\");\ndefineSymbol(math, ams, textord, \"\\u2572\", \"\\\\diagdown\");\ndefineSymbol(math, ams, textord, \"\\u25a1\", \"\\\\square\");\ndefineSymbol(math, ams, textord, \"\\u25a1\", \"\\\\Box\");\ndefineSymbol(math, ams, textord, \"\\u25ca\", \"\\\\Diamond\"); // unicode-math maps U+A5 to \\mathyen. We map to AMS function \\yen\n\ndefineSymbol(math, ams, textord, \"\\u00a5\", \"\\\\yen\", true);\ndefineSymbol(text, ams, textord, \"\\u00a5\", \"\\\\yen\", true);\ndefineSymbol(math, ams, textord, \"\\u2713\", \"\\\\checkmark\", true);\ndefineSymbol(text, ams, textord, \"\\u2713\", \"\\\\checkmark\"); // AMS Hebrew\n\ndefineSymbol(math, ams, textord, \"\\u2136\", \"\\\\beth\", true);\ndefineSymbol(math, ams, textord, \"\\u2138\", \"\\\\daleth\", true);\ndefineSymbol(math, ams, textord, \"\\u2137\", \"\\\\gimel\", true); // AMS Greek\n\ndefineSymbol(math, ams, textord, \"\\u03dd\", \"\\\\digamma\", true);\ndefineSymbol(math, ams, textord, \"\\u03f0\", \"\\\\varkappa\"); // AMS Delimiters\n\ndefineSymbol(math, ams, open, \"\\u250c\", \"\\\\@ulcorner\", true);\ndefineSymbol(math, ams, close, \"\\u2510\", \"\\\\@urcorner\", true);\ndefineSymbol(math, ams, open, \"\\u2514\", \"\\\\@llcorner\", true);\ndefineSymbol(math, ams, close, \"\\u2518\", \"\\\\@lrcorner\", true); // AMS Binary Relations\n\ndefineSymbol(math, ams, rel, \"\\u2266\", \"\\\\leqq\", true);\ndefineSymbol(math, ams, rel, \"\\u2a7d\", \"\\\\leqslant\", true);\ndefineSymbol(math, ams, rel, \"\\u2a95\", \"\\\\eqslantless\", true);\ndefineSymbol(math, ams, rel, \"\\u2272\", \"\\\\lesssim\", true);\ndefineSymbol(math, ams, rel, \"\\u2a85\", \"\\\\lessapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u224a\", \"\\\\approxeq\", true);\ndefineSymbol(math, ams, bin, \"\\u22d6\", \"\\\\lessdot\");\ndefineSymbol(math, ams, rel, \"\\u22d8\", \"\\\\lll\", true);\ndefineSymbol(math, ams, rel, \"\\u2276\", \"\\\\lessgtr\", true);\ndefineSymbol(math, ams, rel, \"\\u22da\", \"\\\\lesseqgtr\", true);\ndefineSymbol(math, ams, rel, \"\\u2a8b\", \"\\\\lesseqqgtr\", true);\ndefineSymbol(math, ams, rel, \"\\u2251\", \"\\\\doteqdot\");\ndefineSymbol(math, ams, rel, \"\\u2253\", \"\\\\risingdotseq\", true);\ndefineSymbol(math, ams, rel, \"\\u2252\", \"\\\\fallingdotseq\", true);\ndefineSymbol(math, ams, rel, \"\\u223d\", \"\\\\backsim\", true);\ndefineSymbol(math, ams, rel, \"\\u22cd\", \"\\\\backsimeq\", true);\ndefineSymbol(math, ams, rel, \"\\u2ac5\", \"\\\\subseteqq\", true);\ndefineSymbol(math, ams, rel, \"\\u22d0\", \"\\\\Subset\", true);\ndefineSymbol(math, ams, rel, \"\\u228f\", \"\\\\sqsubset\", true);\ndefineSymbol(math, ams, rel, \"\\u227c\", \"\\\\preccurlyeq\", true);\ndefineSymbol(math, ams, rel, \"\\u22de\", \"\\\\curlyeqprec\", true);\ndefineSymbol(math, ams, rel, \"\\u227e\", \"\\\\precsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab7\", \"\\\\precapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u22b2\", \"\\\\vartriangleleft\");\ndefineSymbol(math, ams, rel, \"\\u22b4\", \"\\\\trianglelefteq\");\ndefineSymbol(math, ams, rel, \"\\u22a8\", \"\\\\vDash\", true);\ndefineSymbol(math, ams, rel, \"\\u22aa\", \"\\\\Vvdash\", true);\ndefineSymbol(math, ams, rel, \"\\u2323\", \"\\\\smallsmile\");\ndefineSymbol(math, ams, rel, \"\\u2322\", \"\\\\smallfrown\");\ndefineSymbol(math, ams, rel, \"\\u224f\", \"\\\\bumpeq\", true);\ndefineSymbol(math, ams, rel, \"\\u224e\", \"\\\\Bumpeq\", true);\ndefineSymbol(math, ams, rel, \"\\u2267\", \"\\\\geqq\", true);\ndefineSymbol(math, ams, rel, \"\\u2a7e\", \"\\\\geqslant\", true);\ndefineSymbol(math, ams, rel, \"\\u2a96\", \"\\\\eqslantgtr\", true);\ndefineSymbol(math, ams, rel, \"\\u2273\", \"\\\\gtrsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2a86\", \"\\\\gtrapprox\", true);\ndefineSymbol(math, ams, bin, \"\\u22d7\", \"\\\\gtrdot\");\ndefineSymbol(math, ams, rel, \"\\u22d9\", \"\\\\ggg\", true);\ndefineSymbol(math, ams, rel, \"\\u2277\", \"\\\\gtrless\", true);\ndefineSymbol(math, ams, rel, \"\\u22db\", \"\\\\gtreqless\", true);\ndefineSymbol(math, ams, rel, \"\\u2a8c\", \"\\\\gtreqqless\", true);\ndefineSymbol(math, ams, rel, \"\\u2256\", \"\\\\eqcirc\", true);\ndefineSymbol(math, ams, rel, \"\\u2257\", \"\\\\circeq\", true);\ndefineSymbol(math, ams, rel, \"\\u225c\", \"\\\\triangleq\", true);\ndefineSymbol(math, ams, rel, \"\\u223c\", \"\\\\thicksim\");\ndefineSymbol(math, ams, rel, \"\\u2248\", \"\\\\thickapprox\");\ndefineSymbol(math, ams, rel, \"\\u2ac6\", \"\\\\supseteqq\", true);\ndefineSymbol(math, ams, rel, \"\\u22d1\", \"\\\\Supset\", true);\ndefineSymbol(math, ams, rel, \"\\u2290\", \"\\\\sqsupset\", true);\ndefineSymbol(math, ams, rel, \"\\u227d\", \"\\\\succcurlyeq\", true);\ndefineSymbol(math, ams, rel, \"\\u22df\", \"\\\\curlyeqsucc\", true);\ndefineSymbol(math, ams, rel, \"\\u227f\", \"\\\\succsim\", true);\ndefineSymbol(math, ams, rel, \"\\u2ab8\", \"\\\\succapprox\", true);\ndefineSymbol(math, ams, rel, \"\\u22b3\", \"\\\\vartriangleright\");\ndefineSymbol(math, ams, rel, \"\\u22b5\", \"\\\\trianglerighteq\");\ndefineSymbol(math, ams, rel, \"\\u22a9\", \"\\\\Vdash\", true);\ndefineSymbol(math, ams, rel, \"\\u2223\", \"\\\\shortmid\");\ndefineSymbol(math, ams, rel, \"\\u2225\", \"\\\\shortparallel\");\ndefineSymbol(math, ams, rel, \"\\u226c\", \"\\\\between\", true);\ndefineSymbol(math, ams, rel, \"\\u22d4\", \"\\\\pitchfork\", true);\ndefineSymbol(math, ams, rel, \"\\u221d\", \"\\\\varpropto\");\ndefineSymbol(math, ams, rel, \"\\u25c0\", \"\\\\blacktriangleleft\"); // unicode-math says that \\therefore is a mathord atom.\n// We kept the amssymb atom type, which is rel.\n\ndefineSymbol(math, ams, rel, \"\\u2234\", \"\\\\therefore\", true);\ndefineSymbol(math, ams, rel, \"\\u220d\", \"\\\\backepsilon\");\ndefineSymbol(math, ams, rel, \"\\u25b6\", \"\\\\blacktriangleright\"); // unicode-math says that \\because is a mathord atom.\n// We kept the amssymb atom type, which is rel.\n\ndefineSymbol(math, ams, rel, \"\\u2235\", \"\\\\because\", true);\ndefineSymbol(math, ams, rel, \"\\u22d8\", \"\\\\llless\");\ndefineSymbol(math, ams, rel, \"\\u22d9\", \"\\\\gggtr\");\ndefineSymbol(math, ams, bin, \"\\u22b2\", \"\\\\lhd\");\ndefineSymbol(math, ams, bin, \"\\u22b3\", \"\\\\rhd\");\ndefineSymbol(math, ams, rel, \"\\u2242\", \"\\\\eqsim\", true);\ndefineSymbol(math, main, rel, \"\\u22c8\", \"\\\\Join\");\ndefineSymbol(math, ams, rel, \"\\u2251\", \"\\\\Doteq\", true); // AMS Binary Operators\n\ndefineSymbol(math, ams, bin, \"\\u2214\", \"\\\\dotplus\", true);\ndefineSymbol(math, ams, bin, \"\\u2216\", \"\\\\smallsetminus\");\ndefineSymbol(math, ams, bin, \"\\u22d2\", \"\\\\Cap\", true);\ndefineSymbol(math, ams, bin, \"\\u22d3\", \"\\\\Cup\", true);\ndefineSymbol(math, ams, bin, \"\\u2a5e\", \"\\\\doublebarwedge\", true);\ndefineSymbol(math, ams, bin, \"\\u229f\", \"\\\\boxminus\", true);\ndefineSymbol(math, ams, bin, \"\\u229e\", \"\\\\boxplus\", true);\ndefineSymbol(math, ams, bin, \"\\u22c7\", \"\\\\divideontimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22c9\", \"\\\\ltimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22ca\", \"\\\\rtimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22cb\", \"\\\\leftthreetimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22cc\", \"\\\\rightthreetimes\", true);\ndefineSymbol(math, ams, bin, \"\\u22cf\", \"\\\\curlywedge\", true);\ndefineSymbol(math, ams, bin, \"\\u22ce\", \"\\\\curlyvee\", true);\ndefineSymbol(math, ams, bin, \"\\u229d\", \"\\\\circleddash\", true);\ndefineSymbol(math, ams, bin, \"\\u229b\", \"\\\\circledast\", true);\ndefineSymbol(math, ams, bin, \"\\u22c5\", \"\\\\centerdot\");\ndefineSymbol(math, ams, bin, \"\\u22ba\", \"\\\\intercal\", true);\ndefineSymbol(math, ams, bin, \"\\u22d2\", \"\\\\doublecap\");\ndefineSymbol(math, ams, bin, \"\\u22d3\", \"\\\\doublecup\");\ndefineSymbol(math, ams, bin, \"\\u22a0\", \"\\\\boxtimes\", true); // AMS Arrows\n// Note: unicode-math maps \\u21e2 to their own function \\rightdasharrow.\n// We'll map it to AMS function \\dashrightarrow. It produces the same atom.\n\ndefineSymbol(math, ams, rel, \"\\u21e2\", \"\\\\dashrightarrow\", true); // unicode-math maps \\u21e0 to \\leftdasharrow. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u21e0\", \"\\\\dashleftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21c7\", \"\\\\leftleftarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21c6\", \"\\\\leftrightarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21da\", \"\\\\Lleftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u219e\", \"\\\\twoheadleftarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21a2\", \"\\\\leftarrowtail\", true);\ndefineSymbol(math, ams, rel, \"\\u21ab\", \"\\\\looparrowleft\", true);\ndefineSymbol(math, ams, rel, \"\\u21cb\", \"\\\\leftrightharpoons\", true);\ndefineSymbol(math, ams, rel, \"\\u21b6\", \"\\\\curvearrowleft\", true); // unicode-math maps \\u21ba to \\acwopencirclearrow. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u21ba\", \"\\\\circlearrowleft\", true);\ndefineSymbol(math, ams, rel, \"\\u21b0\", \"\\\\Lsh\", true);\ndefineSymbol(math, ams, rel, \"\\u21c8\", \"\\\\upuparrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21bf\", \"\\\\upharpoonleft\", true);\ndefineSymbol(math, ams, rel, \"\\u21c3\", \"\\\\downharpoonleft\", true);\ndefineSymbol(math, main, rel, \"\\u22b6\", \"\\\\origof\", true); // not in font\n\ndefineSymbol(math, main, rel, \"\\u22b7\", \"\\\\imageof\", true); // not in font\n\ndefineSymbol(math, ams, rel, \"\\u22b8\", \"\\\\multimap\", true);\ndefineSymbol(math, ams, rel, \"\\u21ad\", \"\\\\leftrightsquigarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21c9\", \"\\\\rightrightarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21c4\", \"\\\\rightleftarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21a0\", \"\\\\twoheadrightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21a3\", \"\\\\rightarrowtail\", true);\ndefineSymbol(math, ams, rel, \"\\u21ac\", \"\\\\looparrowright\", true);\ndefineSymbol(math, ams, rel, \"\\u21b7\", \"\\\\curvearrowright\", true); // unicode-math maps \\u21bb to \\cwopencirclearrow. We'll use the AMS synonym.\n\ndefineSymbol(math, ams, rel, \"\\u21bb\", \"\\\\circlearrowright\", true);\ndefineSymbol(math, ams, rel, \"\\u21b1\", \"\\\\Rsh\", true);\ndefineSymbol(math, ams, rel, \"\\u21ca\", \"\\\\downdownarrows\", true);\ndefineSymbol(math, ams, rel, \"\\u21be\", \"\\\\upharpoonright\", true);\ndefineSymbol(math, ams, rel, \"\\u21c2\", \"\\\\downharpoonright\", true);\ndefineSymbol(math, ams, rel, \"\\u21dd\", \"\\\\rightsquigarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21dd\", \"\\\\leadsto\");\ndefineSymbol(math, ams, rel, \"\\u21db\", \"\\\\Rrightarrow\", true);\ndefineSymbol(math, ams, rel, \"\\u21be\", \"\\\\restriction\");\ndefineSymbol(math, main, textord, \"\\u2018\", \"`\");\ndefineSymbol(math, main, textord, \"$\", \"\\\\$\");\ndefineSymbol(text, main, textord, \"$\", \"\\\\$\");\ndefineSymbol(text, main, textord, \"$\", \"\\\\textdollar\");\ndefineSymbol(math, main, textord, \"%\", \"\\\\%\");\ndefineSymbol(text, main, textord, \"%\", \"\\\\%\");\ndefineSymbol(math, main, textord, \"_\", \"\\\\_\");\ndefineSymbol(text, main, textord, \"_\", \"\\\\_\");\ndefineSymbol(text, main, textord, \"_\", \"\\\\textunderscore\");\ndefineSymbol(math, main, textord, \"\\u2220\", \"\\\\angle\", true);\ndefineSymbol(math, main, textord, \"\\u221e\", \"\\\\infty\", true);\ndefineSymbol(math, main, textord, \"\\u2032\", \"\\\\prime\");\ndefineSymbol(math, main, textord, \"\\u25b3\", \"\\\\triangle\");\ndefineSymbol(math, main, textord, \"\\u0393\", \"\\\\Gamma\", true);\ndefineSymbol(math, main, textord, \"\\u0394\", \"\\\\Delta\", true);\ndefineSymbol(math, main, textord, \"\\u0398\", \"\\\\Theta\", true);\ndefineSymbol(math, main, textord, \"\\u039b\", \"\\\\Lambda\", true);\ndefineSymbol(math, main, textord, \"\\u039e\", \"\\\\Xi\", true);\ndefineSymbol(math, main, textord, \"\\u03a0\", \"\\\\Pi\", true);\ndefineSymbol(math, main, textord, \"\\u03a3\", \"\\\\Sigma\", true);\ndefineSymbol(math, main, textord, \"\\u03a5\", \"\\\\Upsilon\", true);\ndefineSymbol(math, main, textord, \"\\u03a6\", \"\\\\Phi\", true);\ndefineSymbol(math, main, textord, \"\\u03a8\", \"\\\\Psi\", true);\ndefineSymbol(math, main, textord, \"\\u03a9\", \"\\\\Omega\", true);\ndefineSymbol(math, main, textord, \"A\", \"\\u0391\");\ndefineSymbol(math, main, textord, \"B\", \"\\u0392\");\ndefineSymbol(math, main, textord, \"E\", \"\\u0395\");\ndefineSymbol(math, main, textord, \"Z\", \"\\u0396\");\ndefineSymbol(math, main, textord, \"H\", \"\\u0397\");\ndefineSymbol(math, main, textord, \"I\", \"\\u0399\");\ndefineSymbol(math, main, textord, \"K\", \"\\u039A\");\ndefineSymbol(math, main, textord, \"M\", \"\\u039C\");\ndefineSymbol(math, main, textord, \"N\", \"\\u039D\");\ndefineSymbol(math, main, textord, \"O\", \"\\u039F\");\ndefineSymbol(math, main, textord, \"P\", \"\\u03A1\");\ndefineSymbol(math, main, textord, \"T\", \"\\u03A4\");\ndefineSymbol(math, main, textord, \"X\", \"\\u03A7\");\ndefineSymbol(math, main, textord, \"\\u00ac\", \"\\\\neg\", true);\ndefineSymbol(math, main, textord, \"\\u00ac\", \"\\\\lnot\");\ndefineSymbol(math, main, textord, \"\\u22a4\", \"\\\\top\");\ndefineSymbol(math, main, textord, \"\\u22a5\", \"\\\\bot\");\ndefineSymbol(math, main, textord, \"\\u2205\", \"\\\\emptyset\");\ndefineSymbol(math, ams, textord, \"\\u2205\", \"\\\\varnothing\");\ndefineSymbol(math, main, mathord, \"\\u03b1\", \"\\\\alpha\", true);\ndefineSymbol(math, main, mathord, \"\\u03b2\", \"\\\\beta\", true);\ndefineSymbol(math, main, mathord, \"\\u03b3\", \"\\\\gamma\", true);\ndefineSymbol(math, main, mathord, \"\\u03b4\", \"\\\\delta\", true);\ndefineSymbol(math, main, mathord, \"\\u03f5\", \"\\\\epsilon\", true);\ndefineSymbol(math, main, mathord, \"\\u03b6\", \"\\\\zeta\", true);\ndefineSymbol(math, main, mathord, \"\\u03b7\", \"\\\\eta\", true);\ndefineSymbol(math, main, mathord, \"\\u03b8\", \"\\\\theta\", true);\ndefineSymbol(math, main, mathord, \"\\u03b9\", \"\\\\iota\", true);\ndefineSymbol(math, main, mathord, \"\\u03ba\", \"\\\\kappa\", true);\ndefineSymbol(math, main, mathord, \"\\u03bb\", \"\\\\lambda\", true);\ndefineSymbol(math, main, mathord, \"\\u03bc\", \"\\\\mu\", true);\ndefineSymbol(math, main, mathord, \"\\u03bd\", \"\\\\nu\", true);\ndefineSymbol(math, main, mathord, \"\\u03be\", \"\\\\xi\", true);\ndefineSymbol(math, main, mathord, \"\\u03bf\", \"\\\\omicron\", true);\ndefineSymbol(math, main, mathord, \"\\u03c0\", \"\\\\pi\", true);\ndefineSymbol(math, main, mathord, \"\\u03c1\", \"\\\\rho\", true);\ndefineSymbol(math, main, mathord, \"\\u03c3\", \"\\\\sigma\", true);\ndefineSymbol(math, main, mathord, \"\\u03c4\", \"\\\\tau\", true);\ndefineSymbol(math, main, mathord, \"\\u03c5\", \"\\\\upsilon\", true);\ndefineSymbol(math, main, mathord, \"\\u03d5\", \"\\\\phi\", true);\ndefineSymbol(math, main, mathord, \"\\u03c7\", \"\\\\chi\", true);\ndefineSymbol(math, main, mathord, \"\\u03c8\", \"\\\\psi\", true);\ndefineSymbol(math, main, mathord, \"\\u03c9\", \"\\\\omega\", true);\ndefineSymbol(math, main, mathord, \"\\u03b5\", \"\\\\varepsilon\", true);\ndefineSymbol(math, main, mathord, \"\\u03d1\", \"\\\\vartheta\", true);\ndefineSymbol(math, main, mathord, \"\\u03d6\", \"\\\\varpi\", true);\ndefineSymbol(math, main, mathord, \"\\u03f1\", \"\\\\varrho\", true);\ndefineSymbol(math, main, mathord, \"\\u03c2\", \"\\\\varsigma\", true);\ndefineSymbol(math, main, mathord, \"\\u03c6\", \"\\\\varphi\", true);\ndefineSymbol(math, main, bin, \"\\u2217\", \"*\", true);\ndefineSymbol(math, main, bin, \"+\", \"+\");\ndefineSymbol(math, main, bin, \"\\u2212\", \"-\", true);\ndefineSymbol(math, main, bin, \"\\u22c5\", \"\\\\cdot\", true);\ndefineSymbol(math, main, bin, \"\\u2218\", \"\\\\circ\", true);\ndefineSymbol(math, main, bin, \"\\u00f7\", \"\\\\div\", true);\ndefineSymbol(math, main, bin, \"\\u00b1\", \"\\\\pm\", true);\ndefineSymbol(math, main, bin, \"\\u00d7\", \"\\\\times\", true);\ndefineSymbol(math, main, bin, \"\\u2229\", \"\\\\cap\", true);\ndefineSymbol(math, main, bin, \"\\u222a\", \"\\\\cup\", true);\ndefineSymbol(math, main, bin, \"\\u2216\", \"\\\\setminus\", true);\ndefineSymbol(math, main, bin, \"\\u2227\", \"\\\\land\");\ndefineSymbol(math, main, bin, \"\\u2228\", \"\\\\lor\");\ndefineSymbol(math, main, bin, \"\\u2227\", \"\\\\wedge\", true);\ndefineSymbol(math, main, bin, \"\\u2228\", \"\\\\vee\", true);\ndefineSymbol(math, main, textord, \"\\u221a\", \"\\\\surd\");\ndefineSymbol(math, main, open, \"\\u27e8\", \"\\\\langle\", true);\ndefineSymbol(math, main, open, \"\\u2223\", \"\\\\lvert\");\ndefineSymbol(math, main, open, \"\\u2225\", \"\\\\lVert\");\ndefineSymbol(math, main, close, \"?\", \"?\");\ndefineSymbol(math, main, close, \"!\", \"!\");\ndefineSymbol(math, main, close, \"\\u27e9\", \"\\\\rangle\", true);\ndefineSymbol(math, main, close, \"\\u2223\", \"\\\\rvert\");\ndefineSymbol(math, main, close, \"\\u2225\", \"\\\\rVert\");\ndefineSymbol(math, main, rel, \"=\", \"=\");\ndefineSymbol(math, main, rel, \":\", \":\");\ndefineSymbol(math, main, rel, \"\\u2248\", \"\\\\approx\", true);\ndefineSymbol(math, main, rel, \"\\u2245\", \"\\\\cong\", true);\ndefineSymbol(math, main, rel, \"\\u2265\", \"\\\\ge\");\ndefineSymbol(math, main, rel, \"\\u2265\", \"\\\\geq\", true);\ndefineSymbol(math, main, rel, \"\\u2190\", \"\\\\gets\");\ndefineSymbol(math, main, rel, \">\", \"\\\\gt\", true);\ndefineSymbol(math, main, rel, \"\\u2208\", \"\\\\in\", true);\ndefineSymbol(math, main, rel, \"\\ue020\", \"\\\\@not\");\ndefineSymbol(math, main, rel, \"\\u2282\", \"\\\\subset\", true);\ndefineSymbol(math, main, rel, \"\\u2283\", \"\\\\supset\", true);\ndefineSymbol(math, main, rel, \"\\u2286\", \"\\\\subseteq\", true);\ndefineSymbol(math, main, rel, \"\\u2287\", \"\\\\supseteq\", true);\ndefineSymbol(math, ams, rel, \"\\u2288\", \"\\\\nsubseteq\", true);\ndefineSymbol(math, ams, rel, \"\\u2289\", \"\\\\nsupseteq\", true);\ndefineSymbol(math, main, rel, \"\\u22a8\", \"\\\\models\");\ndefineSymbol(math, main, rel, \"\\u2190\", \"\\\\leftarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2264\", \"\\\\le\");\ndefineSymbol(math, main, rel, \"\\u2264\", \"\\\\leq\", true);\ndefineSymbol(math, main, rel, \"<\", \"\\\\lt\", true);\ndefineSymbol(math, main, rel, \"\\u2192\", \"\\\\rightarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2192\", \"\\\\to\");\ndefineSymbol(math, ams, rel, \"\\u2271\", \"\\\\ngeq\", true);\ndefineSymbol(math, ams, rel, \"\\u2270\", \"\\\\nleq\", true);\ndefineSymbol(math, main, spacing, \"\\u00a0\", \"\\\\ \");\ndefineSymbol(math, main, spacing, \"\\u00a0\", \"\\\\space\"); // Ref: LaTeX Source 2e: \\DeclareRobustCommand{\\nobreakspace}{%\n\ndefineSymbol(math, main, spacing, \"\\u00a0\", \"\\\\nobreakspace\");\ndefineSymbol(text, main, spacing, \"\\u00a0\", \"\\\\ \");\ndefineSymbol(text, main, spacing, \"\\u00a0\", \" \");\ndefineSymbol(text, main, spacing, \"\\u00a0\", \"\\\\space\");\ndefineSymbol(text, main, spacing, \"\\u00a0\", \"\\\\nobreakspace\");\ndefineSymbol(math, main, spacing, null, \"\\\\nobreak\");\ndefineSymbol(math, main, spacing, null, \"\\\\allowbreak\");\ndefineSymbol(math, main, punct, \",\", \",\");\ndefineSymbol(math, main, punct, \";\", \";\");\ndefineSymbol(math, ams, bin, \"\\u22bc\", \"\\\\barwedge\", true);\ndefineSymbol(math, ams, bin, \"\\u22bb\", \"\\\\veebar\", true);\ndefineSymbol(math, main, bin, \"\\u2299\", \"\\\\odot\", true);\ndefineSymbol(math, main, bin, \"\\u2295\", \"\\\\oplus\", true);\ndefineSymbol(math, main, bin, \"\\u2297\", \"\\\\otimes\", true);\ndefineSymbol(math, main, textord, \"\\u2202\", \"\\\\partial\", true);\ndefineSymbol(math, main, bin, \"\\u2298\", \"\\\\oslash\", true);\ndefineSymbol(math, ams, bin, \"\\u229a\", \"\\\\circledcirc\", true);\ndefineSymbol(math, ams, bin, \"\\u22a1\", \"\\\\boxdot\", true);\ndefineSymbol(math, main, bin, \"\\u25b3\", \"\\\\bigtriangleup\");\ndefineSymbol(math, main, bin, \"\\u25bd\", \"\\\\bigtriangledown\");\ndefineSymbol(math, main, bin, \"\\u2020\", \"\\\\dagger\");\ndefineSymbol(math, main, bin, \"\\u22c4\", \"\\\\diamond\");\ndefineSymbol(math, main, bin, \"\\u22c6\", \"\\\\star\");\ndefineSymbol(math, main, bin, \"\\u25c3\", \"\\\\triangleleft\");\ndefineSymbol(math, main, bin, \"\\u25b9\", \"\\\\triangleright\");\ndefineSymbol(math, main, open, \"{\", \"\\\\{\");\ndefineSymbol(text, main, textord, \"{\", \"\\\\{\");\ndefineSymbol(text, main, textord, \"{\", \"\\\\textbraceleft\");\ndefineSymbol(math, main, close, \"}\", \"\\\\}\");\ndefineSymbol(text, main, textord, \"}\", \"\\\\}\");\ndefineSymbol(text, main, textord, \"}\", \"\\\\textbraceright\");\ndefineSymbol(math, main, open, \"{\", \"\\\\lbrace\");\ndefineSymbol(math, main, close, \"}\", \"\\\\rbrace\");\ndefineSymbol(math, main, open, \"[\", \"\\\\lbrack\", true);\ndefineSymbol(text, main, textord, \"[\", \"\\\\lbrack\", true);\ndefineSymbol(math, main, close, \"]\", \"\\\\rbrack\", true);\ndefineSymbol(text, main, textord, \"]\", \"\\\\rbrack\", true);\ndefineSymbol(math, main, open, \"(\", \"\\\\lparen\", true);\ndefineSymbol(math, main, close, \")\", \"\\\\rparen\", true);\ndefineSymbol(text, main, textord, \"<\", \"\\\\textless\", true); // in T1 fontenc\n\ndefineSymbol(text, main, textord, \">\", \"\\\\textgreater\", true); // in T1 fontenc\n\ndefineSymbol(math, main, open, \"\\u230a\", \"\\\\lfloor\", true);\ndefineSymbol(math, main, close, \"\\u230b\", \"\\\\rfloor\", true);\ndefineSymbol(math, main, open, \"\\u2308\", \"\\\\lceil\", true);\ndefineSymbol(math, main, close, \"\\u2309\", \"\\\\rceil\", true);\ndefineSymbol(math, main, textord, \"\\\\\", \"\\\\backslash\");\ndefineSymbol(math, main, textord, \"\\u2223\", \"|\");\ndefineSymbol(math, main, textord, \"\\u2223\", \"\\\\vert\");\ndefineSymbol(text, main, textord, \"|\", \"\\\\textbar\", true); // in T1 fontenc\n\ndefineSymbol(math, main, textord, \"\\u2225\", \"\\\\|\");\ndefineSymbol(math, main, textord, \"\\u2225\", \"\\\\Vert\");\ndefineSymbol(text, main, textord, \"\\u2225\", \"\\\\textbardbl\");\ndefineSymbol(text, main, textord, \"~\", \"\\\\textasciitilde\");\ndefineSymbol(text, main, textord, \"\\\\\", \"\\\\textbackslash\");\ndefineSymbol(text, main, textord, \"^\", \"\\\\textasciicircum\");\ndefineSymbol(math, main, rel, \"\\u2191\", \"\\\\uparrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d1\", \"\\\\Uparrow\", true);\ndefineSymbol(math, main, rel, \"\\u2193\", \"\\\\downarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d3\", \"\\\\Downarrow\", true);\ndefineSymbol(math, main, rel, \"\\u2195\", \"\\\\updownarrow\", true);\ndefineSymbol(math, main, rel, \"\\u21d5\", \"\\\\Updownarrow\", true);\ndefineSymbol(math, main, op, \"\\u2210\", \"\\\\coprod\");\ndefineSymbol(math, main, op, \"\\u22c1\", \"\\\\bigvee\");\ndefineSymbol(math, main, op, \"\\u22c0\", \"\\\\bigwedge\");\ndefineSymbol(math, main, op, \"\\u2a04\", \"\\\\biguplus\");\ndefineSymbol(math, main, op, \"\\u22c2\", \"\\\\bigcap\");\ndefineSymbol(math, main, op, \"\\u22c3\", \"\\\\bigcup\");\ndefineSymbol(math, main, op, \"\\u222b\", \"\\\\int\");\ndefineSymbol(math, main, op, \"\\u222b\", \"\\\\intop\");\ndefineSymbol(math, main, op, \"\\u222c\", \"\\\\iint\");\ndefineSymbol(math, main, op, \"\\u222d\", \"\\\\iiint\");\ndefineSymbol(math, main, op, \"\\u220f\", \"\\\\prod\");\ndefineSymbol(math, main, op, \"\\u2211\", \"\\\\sum\");\ndefineSymbol(math, main, op, \"\\u2a02\", \"\\\\bigotimes\");\ndefineSymbol(math, main, op, \"\\u2a01\", \"\\\\bigoplus\");\ndefineSymbol(math, main, op, \"\\u2a00\", \"\\\\bigodot\");\ndefineSymbol(math, main, op, \"\\u222e\", \"\\\\oint\");\ndefineSymbol(math, main, op, \"\\u222f\", \"\\\\oiint\");\ndefineSymbol(math, main, op, \"\\u2230\", \"\\\\oiiint\");\ndefineSymbol(math, main, op, \"\\u2a06\", \"\\\\bigsqcup\");\ndefineSymbol(math, main, op, \"\\u222b\", \"\\\\smallint\");\ndefineSymbol(text, main, inner, \"\\u2026\", \"\\\\textellipsis\");\ndefineSymbol(math, main, inner, \"\\u2026\", \"\\\\mathellipsis\");\ndefineSymbol(text, main, inner, \"\\u2026\", \"\\\\ldots\", true);\ndefineSymbol(math, main, inner, \"\\u2026\", \"\\\\ldots\", true);\ndefineSymbol(math, main, inner, \"\\u22ef\", \"\\\\@cdots\", true);\ndefineSymbol(math, main, inner, \"\\u22f1\", \"\\\\ddots\", true); // \\vdots is a macro that uses one of these two symbols (with made-up names):\n\ndefineSymbol(math, main, textord, \"\\u22ee\", \"\\\\varvdots\");\ndefineSymbol(text, main, textord, \"\\u22ee\", \"\\\\varvdots\");\ndefineSymbol(math, main, accent, \"\\u02ca\", \"\\\\acute\");\ndefineSymbol(math, main, accent, \"\\u02cb\", \"\\\\grave\");\ndefineSymbol(math, main, accent, \"\\u00a8\", \"\\\\ddot\");\ndefineSymbol(math, main, accent, \"\\u007e\", \"\\\\tilde\");\ndefineSymbol(math, main, accent, \"\\u02c9\", \"\\\\bar\");\ndefineSymbol(math, main, accent, \"\\u02d8\", \"\\\\breve\");\ndefineSymbol(math, main, accent, \"\\u02c7\", \"\\\\check\");\ndefineSymbol(math, main, accent, \"\\u005e\", \"\\\\hat\");\ndefineSymbol(math, main, accent, \"\\u20d7\", \"\\\\vec\");\ndefineSymbol(math, main, accent, \"\\u02d9\", \"\\\\dot\");\ndefineSymbol(math, main, accent, \"\\u02da\", \"\\\\mathring\"); // \\imath and \\jmath should be invariant to \\mathrm, \\mathbf, etc., so use PUA\n\ndefineSymbol(math, main, mathord, \"\\ue131\", \"\\\\@imath\");\ndefineSymbol(math, main, mathord, \"\\ue237\", \"\\\\@jmath\");\ndefineSymbol(math, main, textord, \"\\u0131\", \"\\u0131\");\ndefineSymbol(math, main, textord, \"\\u0237\", \"\\u0237\");\ndefineSymbol(text, main, textord, \"\\u0131\", \"\\\\i\", true);\ndefineSymbol(text, main, textord, \"\\u0237\", \"\\\\j\", true);\ndefineSymbol(text, main, textord, \"\\u00df\", \"\\\\ss\", true);\ndefineSymbol(text, main, textord, \"\\u00e6\", \"\\\\ae\", true);\ndefineSymbol(text, main, textord, \"\\u0153\", \"\\\\oe\", true);\ndefineSymbol(text, main, textord, \"\\u00f8\", \"\\\\o\", true);\ndefineSymbol(text, main, textord, \"\\u00c6\", \"\\\\AE\", true);\ndefineSymbol(text, main, textord, \"\\u0152\", \"\\\\OE\", true);\ndefineSymbol(text, main, textord, \"\\u00d8\", \"\\\\O\", true);\ndefineSymbol(text, main, accent, \"\\u02ca\", \"\\\\'\"); // acute\n\ndefineSymbol(text, main, accent, \"\\u02cb\", \"\\\\`\"); // grave\n\ndefineSymbol(text, main, accent, \"\\u02c6\", \"\\\\^\"); // circumflex\n\ndefineSymbol(text, main, accent, \"\\u02dc\", \"\\\\~\"); // tilde\n\ndefineSymbol(text, main, accent, \"\\u02c9\", \"\\\\=\"); // macron\n\ndefineSymbol(text, main, accent, \"\\u02d8\", \"\\\\u\"); // breve\n\ndefineSymbol(text, main, accent, \"\\u02d9\", \"\\\\.\"); // dot above\n\ndefineSymbol(text, main, accent, \"\\u00b8\", \"\\\\c\"); // cedilla\n\ndefineSymbol(text, main, accent, \"\\u02da\", \"\\\\r\"); // ring above\n\ndefineSymbol(text, main, accent, \"\\u02c7\", \"\\\\v\"); // caron\n\ndefineSymbol(text, main, accent, \"\\u00a8\", '\\\\\"'); // diaeresis\n\ndefineSymbol(text, main, accent, \"\\u02dd\", \"\\\\H\"); // double acute\n\ndefineSymbol(text, main, accent, \"\\u25ef\", \"\\\\textcircled\"); // \\bigcirc glyph\n// These ligatures are detected and created in Parser.js's `formLigatures`.\n\nvar ligatures = {\n  \"--\": true,\n  \"---\": true,\n  \"``\": true,\n  \"''\": true\n};\ndefineSymbol(text, main, textord, \"\\u2013\", \"--\", true);\ndefineSymbol(text, main, textord, \"\\u2013\", \"\\\\textendash\");\ndefineSymbol(text, main, textord, \"\\u2014\", \"---\", true);\ndefineSymbol(text, main, textord, \"\\u2014\", \"\\\\textemdash\");\ndefineSymbol(text, main, textord, \"\\u2018\", \"`\", true);\ndefineSymbol(text, main, textord, \"\\u2018\", \"\\\\textquoteleft\");\ndefineSymbol(text, main, textord, \"\\u2019\", \"'\", true);\ndefineSymbol(text, main, textord, \"\\u2019\", \"\\\\textquoteright\");\ndefineSymbol(text, main, textord, \"\\u201c\", \"``\", true);\ndefineSymbol(text, main, textord, \"\\u201c\", \"\\\\textquotedblleft\");\ndefineSymbol(text, main, textord, \"\\u201d\", \"''\", true);\ndefineSymbol(text, main, textord, \"\\u201d\", \"\\\\textquotedblright\"); //  \\degree from gensymb package\n\ndefineSymbol(math, main, textord, \"\\u00b0\", \"\\\\degree\", true);\ndefineSymbol(text, main, textord, \"\\u00b0\", \"\\\\degree\"); // \\textdegree from inputenc package\n\ndefineSymbol(text, main, textord, \"\\u00b0\", \"\\\\textdegree\", true); // TODO: In LaTeX, \\pounds can generate a different character in text and math\n// mode, but among our fonts, only Main-Regular defines this character \"163\".\n\ndefineSymbol(math, main, textord, \"\\u00a3\", \"\\\\pounds\");\ndefineSymbol(math, main, textord, \"\\u00a3\", \"\\\\mathsterling\", true);\ndefineSymbol(text, main, textord, \"\\u00a3\", \"\\\\pounds\");\ndefineSymbol(text, main, textord, \"\\u00a3\", \"\\\\textsterling\", true);\ndefineSymbol(math, ams, textord, \"\\u2720\", \"\\\\maltese\");\ndefineSymbol(text, ams, textord, \"\\u2720\", \"\\\\maltese\"); // There are lots of symbols which are the same, so we add them in afterwards.\n// All of these are textords in math mode\n\nvar mathTextSymbols = \"0123456789/@.\\\"\";\n\nfor (var i = 0; i < mathTextSymbols.length; i++) {\n  var ch = mathTextSymbols.charAt(i);\n  defineSymbol(math, main, textord, ch, ch);\n} // All of these are textords in text mode\n\n\nvar textSymbols = \"0123456789!@*()-=+\\\";:?/.,\";\n\nfor (var _i = 0; _i < textSymbols.length; _i++) {\n  var _ch = textSymbols.charAt(_i);\n\n  defineSymbol(text, main, textord, _ch, _ch);\n} // All of these are textords in text mode, and mathords in math mode\n\n\nvar letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\nfor (var _i2 = 0; _i2 < letters.length; _i2++) {\n  var _ch2 = letters.charAt(_i2);\n\n  defineSymbol(math, main, mathord, _ch2, _ch2);\n  defineSymbol(text, main, textord, _ch2, _ch2);\n} // Blackboard bold and script letters in Unicode range\n\n\ndefineSymbol(math, ams, textord, \"C\", \"\\u2102\"); // blackboard bold\n\ndefineSymbol(text, ams, textord, \"C\", \"\\u2102\");\ndefineSymbol(math, ams, textord, \"H\", \"\\u210D\");\ndefineSymbol(text, ams, textord, \"H\", \"\\u210D\");\ndefineSymbol(math, ams, textord, \"N\", \"\\u2115\");\ndefineSymbol(text, ams, textord, \"N\", \"\\u2115\");\ndefineSymbol(math, ams, textord, \"P\", \"\\u2119\");\ndefineSymbol(text, ams, textord, \"P\", \"\\u2119\");\ndefineSymbol(math, ams, textord, \"Q\", \"\\u211A\");\ndefineSymbol(text, ams, textord, \"Q\", \"\\u211A\");\ndefineSymbol(math, ams, textord, \"R\", \"\\u211D\");\ndefineSymbol(text, ams, textord, \"R\", \"\\u211D\");\ndefineSymbol(math, ams, textord, \"Z\", \"\\u2124\");\ndefineSymbol(text, ams, textord, \"Z\", \"\\u2124\");\ndefineSymbol(math, main, mathord, \"h\", \"\\u210E\"); // italic h, Planck constant\n\ndefineSymbol(text, main, mathord, \"h\", \"\\u210E\"); // The next loop loads wide (surrogate pair) characters.\n// We support some letters in the Unicode range U+1D400 to U+1D7FF,\n// Mathematical Alphanumeric Symbols.\n// Some editors do not deal well with wide characters. So don't write the\n// string into this file. Instead, create the string from the surrogate pair.\n\nvar wideChar = \"\";\n\nfor (var _i3 = 0; _i3 < letters.length; _i3++) {\n  var _ch3 = letters.charAt(_i3); // The hex numbers in the next line are a surrogate pair.\n  // 0xD835 is the high surrogate for all letters in the range we support.\n  // 0xDC00 is the low surrogate for bold A.\n\n\n  wideChar = String.fromCharCode(0xD835, 0xDC00 + _i3); // A-Z a-z bold\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDC34 + _i3); // A-Z a-z italic\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDC68 + _i3); // A-Z a-z bold italic\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDD04 + _i3); // A-Z a-z Fraktur\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDD6C + _i3); // A-Z a-z bold Fraktur\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDDA0 + _i3); // A-Z a-z sans-serif\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDDD4 + _i3); // A-Z a-z sans bold\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDE08 + _i3); // A-Z a-z sans italic\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDE70 + _i3); // A-Z a-z monospace\n\n  defineSymbol(math, main, mathord, _ch3, wideChar);\n  defineSymbol(text, main, textord, _ch3, wideChar);\n\n  if (_i3 < 26) {\n    // KaTeX fonts have only capital letters for blackboard bold and script.\n    // See exception for k below.\n    wideChar = String.fromCharCode(0xD835, 0xDD38 + _i3); // A-Z double struck\n\n    defineSymbol(math, main, mathord, _ch3, wideChar);\n    defineSymbol(text, main, textord, _ch3, wideChar);\n    wideChar = String.fromCharCode(0xD835, 0xDC9C + _i3); // A-Z script\n\n    defineSymbol(math, main, mathord, _ch3, wideChar);\n    defineSymbol(text, main, textord, _ch3, wideChar);\n  } // TODO: Add bold script when it is supported by a KaTeX font.\n\n} // \"k\" is the only double struck lower case letter in the KaTeX fonts.\n\n\nwideChar = String.fromCharCode(0xD835, 0xDD5C); // k double struck\n\ndefineSymbol(math, main, mathord, \"k\", wideChar);\ndefineSymbol(text, main, textord, \"k\", wideChar); // Next, some wide character numerals\n\nfor (var _i4 = 0; _i4 < 10; _i4++) {\n  var _ch4 = _i4.toString();\n\n  wideChar = String.fromCharCode(0xD835, 0xDFCE + _i4); // 0-9 bold\n\n  defineSymbol(math, main, mathord, _ch4, wideChar);\n  defineSymbol(text, main, textord, _ch4, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDFE2 + _i4); // 0-9 sans serif\n\n  defineSymbol(math, main, mathord, _ch4, wideChar);\n  defineSymbol(text, main, textord, _ch4, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDFEC + _i4); // 0-9 bold sans\n\n  defineSymbol(math, main, mathord, _ch4, wideChar);\n  defineSymbol(text, main, textord, _ch4, wideChar);\n  wideChar = String.fromCharCode(0xD835, 0xDFF6 + _i4); // 0-9 monospace\n\n  defineSymbol(math, main, mathord, _ch4, wideChar);\n  defineSymbol(text, main, textord, _ch4, wideChar);\n} // We add these Latin-1 letters as symbols for backwards-compatibility,\n// but they are not actually in the font, nor are they supported by the\n// Unicode accent mechanism, so they fall back to Times font and look ugly.\n// TODO(edemaine): Fix this.\n\n\nvar extraLatin = \"\\u00d0\\u00de\\u00fe\";\n\nfor (var _i5 = 0; _i5 < extraLatin.length; _i5++) {\n  var _ch5 = extraLatin.charAt(_i5);\n\n  defineSymbol(math, main, mathord, _ch5, _ch5);\n  defineSymbol(text, main, textord, _ch5, _ch5);\n}\n\n/**\n * This file provides support for Unicode range U+1D400 to U+1D7FF,\n * Mathematical Alphanumeric Symbols.\n *\n * Function wideCharacterFont takes a wide character as input and returns\n * the font information necessary to render it properly.\n */\n/**\n * Data below is from https://www.unicode.org/charts/PDF/U1D400.pdf\n * That document sorts characters into groups by font type, say bold or italic.\n *\n * In the arrays below, each subarray consists three elements:\n *      * The CSS class of that group when in math mode.\n *      * The CSS class of that group when in text mode.\n *      * The font name, so that KaTeX can get font metrics.\n */\n\nvar wideLatinLetterData = [[\"mathbf\", \"textbf\", \"Main-Bold\"], // A-Z bold upright\n[\"mathbf\", \"textbf\", \"Main-Bold\"], // a-z bold upright\n[\"mathnormal\", \"textit\", \"Math-Italic\"], // A-Z italic\n[\"mathnormal\", \"textit\", \"Math-Italic\"], // a-z italic\n[\"boldsymbol\", \"boldsymbol\", \"Main-BoldItalic\"], // A-Z bold italic\n[\"boldsymbol\", \"boldsymbol\", \"Main-BoldItalic\"], // a-z bold italic\n// Map fancy A-Z letters to script, not calligraphic.\n// This aligns with unicode-math and math fonts (except Cambria Math).\n[\"mathscr\", \"textscr\", \"Script-Regular\"], // A-Z script\n[\"\", \"\", \"\"], // a-z script.  No font\n[\"\", \"\", \"\"], // A-Z bold script. No font\n[\"\", \"\", \"\"], // a-z bold script. No font\n[\"mathfrak\", \"textfrak\", \"Fraktur-Regular\"], // A-Z Fraktur\n[\"mathfrak\", \"textfrak\", \"Fraktur-Regular\"], // a-z Fraktur\n[\"mathbb\", \"textbb\", \"AMS-Regular\"], // A-Z double-struck\n[\"mathbb\", \"textbb\", \"AMS-Regular\"], // k double-struck\n// Note that we are using a bold font, but font metrics for regular Fraktur.\n[\"mathboldfrak\", \"textboldfrak\", \"Fraktur-Regular\"], // A-Z bold Fraktur\n[\"mathboldfrak\", \"textboldfrak\", \"Fraktur-Regular\"], // a-z bold Fraktur\n[\"mathsf\", \"textsf\", \"SansSerif-Regular\"], // A-Z sans-serif\n[\"mathsf\", \"textsf\", \"SansSerif-Regular\"], // a-z sans-serif\n[\"mathboldsf\", \"textboldsf\", \"SansSerif-Bold\"], // A-Z bold sans-serif\n[\"mathboldsf\", \"textboldsf\", \"SansSerif-Bold\"], // a-z bold sans-serif\n[\"mathitsf\", \"textitsf\", \"SansSerif-Italic\"], // A-Z italic sans-serif\n[\"mathitsf\", \"textitsf\", \"SansSerif-Italic\"], // a-z italic sans-serif\n[\"\", \"\", \"\"], // A-Z bold italic sans. No font\n[\"\", \"\", \"\"], // a-z bold italic sans. No font\n[\"mathtt\", \"texttt\", \"Typewriter-Regular\"], // A-Z monospace\n[\"mathtt\", \"texttt\", \"Typewriter-Regular\"] // a-z monospace\n];\nvar wideNumeralData = [[\"mathbf\", \"textbf\", \"Main-Bold\"], // 0-9 bold\n[\"\", \"\", \"\"], // 0-9 double-struck. No KaTeX font.\n[\"mathsf\", \"textsf\", \"SansSerif-Regular\"], // 0-9 sans-serif\n[\"mathboldsf\", \"textboldsf\", \"SansSerif-Bold\"], // 0-9 bold sans-serif\n[\"mathtt\", \"texttt\", \"Typewriter-Regular\"] // 0-9 monospace\n];\nvar wideCharacterFont = function wideCharacterFont(wideChar, mode) {\n  // IE doesn't support codePointAt(). So work with the surrogate pair.\n  var H = wideChar.charCodeAt(0); // high surrogate\n\n  var L = wideChar.charCodeAt(1); // low surrogate\n\n  var codePoint = (H - 0xD800) * 0x400 + (L - 0xDC00) + 0x10000;\n  var j = mode === \"math\" ? 0 : 1; // column index for CSS class.\n\n  if (0x1D400 <= codePoint && codePoint < 0x1D6A4) {\n    // wideLatinLetterData contains exactly 26 chars on each row.\n    // So we can calculate the relevant row. No traverse necessary.\n    var i = Math.floor((codePoint - 0x1D400) / 26);\n    return [wideLatinLetterData[i][2], wideLatinLetterData[i][j]];\n  } else if (0x1D7CE <= codePoint && codePoint <= 0x1D7FF) {\n    // Numerals, ten per row.\n    var _i = Math.floor((codePoint - 0x1D7CE) / 10);\n\n    return [wideNumeralData[_i][2], wideNumeralData[_i][j]];\n  } else if (codePoint === 0x1D6A5 || codePoint === 0x1D6A6) {\n    // dotless i or j\n    return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];\n  } else if (0x1D6A6 < codePoint && codePoint < 0x1D7CE) {\n    // Greek letters. Not supported, yet.\n    return [\"\", \"\"];\n  } else {\n    // We don't support any wide characters outside 1D4001D7FF.\n    throw new ParseError(\"Unsupported character: \" + wideChar);\n  }\n};\n\n/* eslint no-console:0 */\n\n/**\n * Looks up the given symbol in fontMetrics, after applying any symbol\n * replacements defined in symbol.js\n */\nvar lookupSymbol = function lookupSymbol(value, // TODO(#963): Use a union type for this.\nfontName, mode) {\n  // Replace the value with its replaced value from symbol.js\n  if (symbols[mode][value] && symbols[mode][value].replace) {\n    value = symbols[mode][value].replace;\n  }\n\n  return {\n    value: value,\n    metrics: getCharacterMetrics(value, fontName, mode)\n  };\n};\n/**\n * Makes a symbolNode after translation via the list of symbols in symbols.js.\n * Correctly pulls out metrics for the character, and optionally takes a list of\n * classes to be attached to the node.\n *\n * TODO: make argument order closer to makeSpan\n * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which\n * should if present come first in `classes`.\n * TODO(#953): Make `options` mandatory and always pass it in.\n */\n\n\nvar makeSymbol = function makeSymbol(value, fontName, mode, options, classes) {\n  var lookup = lookupSymbol(value, fontName, mode);\n  var metrics = lookup.metrics;\n  value = lookup.value;\n  var symbolNode;\n\n  if (metrics) {\n    var italic = metrics.italic;\n\n    if (mode === \"text\" || options && options.font === \"mathit\") {\n      italic = 0;\n    }\n\n    symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);\n  } else {\n    // TODO(emily): Figure out a good way to only print this in development\n    typeof console !== \"undefined\" && console.warn(\"No character metrics \" + (\"for '\" + value + \"' in style '\" + fontName + \"' and mode '\" + mode + \"'\"));\n    symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);\n  }\n\n  if (options) {\n    symbolNode.maxFontSize = options.sizeMultiplier;\n\n    if (options.style.isTight()) {\n      symbolNode.classes.push(\"mtight\");\n    }\n\n    var color = options.getColor();\n\n    if (color) {\n      symbolNode.style.color = color;\n    }\n  }\n\n  return symbolNode;\n};\n/**\n * Makes a symbol in Main-Regular or AMS-Regular.\n * Used for rel, bin, open, close, inner, and punct.\n */\n\n\nvar mathsym = function mathsym(value, mode, options, classes) {\n  if (classes === void 0) {\n    classes = [];\n  }\n\n  // Decide what font to render the symbol in by its entry in the symbols\n  // table.\n  // Have a special case for when the value = \\ because the \\ is used as a\n  // textord in unsupported command errors but cannot be parsed as a regular\n  // text ordinal and is therefore not present as a symbol in the symbols\n  // table for text, as well as a special case for boldsymbol because it\n  // can be used for bold + and -\n  if (options.font === \"boldsymbol\" && lookupSymbol(value, \"Main-Bold\", mode).metrics) {\n    return makeSymbol(value, \"Main-Bold\", mode, options, classes.concat([\"mathbf\"]));\n  } else if (value === \"\\\\\" || symbols[mode][value].font === \"main\") {\n    return makeSymbol(value, \"Main-Regular\", mode, options, classes);\n  } else {\n    return makeSymbol(value, \"AMS-Regular\", mode, options, classes.concat([\"amsrm\"]));\n  }\n};\n/**\n * Determines which of the two font names (Main-Bold and Math-BoldItalic) and\n * corresponding style tags (mathbf or boldsymbol) to use for font \"boldsymbol\",\n * depending on the symbol.  Use this function instead of fontMap for font\n * \"boldsymbol\".\n */\n\n\nvar boldsymbol = function boldsymbol(value, mode, options, classes, type) {\n  if (type !== \"textord\" && lookupSymbol(value, \"Math-BoldItalic\", mode).metrics) {\n    return {\n      fontName: \"Math-BoldItalic\",\n      fontClass: \"boldsymbol\"\n    };\n  } else {\n    // Some glyphs do not exist in Math-BoldItalic so we need to use\n    // Main-Bold instead.\n    return {\n      fontName: \"Main-Bold\",\n      fontClass: \"mathbf\"\n    };\n  }\n};\n/**\n * Makes either a mathord or textord in the correct font and color.\n */\n\n\nvar makeOrd = function makeOrd(group, options, type) {\n  var mode = group.mode;\n  var text = group.text;\n  var classes = [\"mord\"]; // Math mode or Old font (i.e. \\rm)\n\n  var isFont = mode === \"math\" || mode === \"text\" && options.font;\n  var fontOrFamily = isFont ? options.font : options.fontFamily;\n  var wideFontName = \"\";\n  var wideFontClass = \"\";\n\n  if (text.charCodeAt(0) === 0xD835) {\n    [wideFontName, wideFontClass] = wideCharacterFont(text, mode);\n  }\n\n  if (wideFontName.length > 0) {\n    // surrogate pairs get special treatment\n    return makeSymbol(text, wideFontName, mode, options, classes.concat(wideFontClass));\n  } else if (fontOrFamily) {\n    var fontName;\n    var fontClasses;\n\n    if (fontOrFamily === \"boldsymbol\") {\n      var fontData = boldsymbol(text, mode, options, classes, type);\n      fontName = fontData.fontName;\n      fontClasses = [fontData.fontClass];\n    } else if (isFont) {\n      fontName = fontMap[fontOrFamily].fontName;\n      fontClasses = [fontOrFamily];\n    } else {\n      fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);\n      fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];\n    }\n\n    if (lookupSymbol(text, fontName, mode).metrics) {\n      return makeSymbol(text, fontName, mode, options, classes.concat(fontClasses));\n    } else if (ligatures.hasOwnProperty(text) && fontName.slice(0, 10) === \"Typewriter\") {\n      // Deconstruct ligatures in monospace fonts (\\texttt, \\tt).\n      var parts = [];\n\n      for (var i = 0; i < text.length; i++) {\n        parts.push(makeSymbol(text[i], fontName, mode, options, classes.concat(fontClasses)));\n      }\n\n      return makeFragment(parts);\n    }\n  } // Makes a symbol in the default font for mathords and textords.\n\n\n  if (type === \"mathord\") {\n    return makeSymbol(text, \"Math-Italic\", mode, options, classes.concat([\"mathnormal\"]));\n  } else if (type === \"textord\") {\n    var font = symbols[mode][text] && symbols[mode][text].font;\n\n    if (font === \"ams\") {\n      var _fontName = retrieveTextFontName(\"amsrm\", options.fontWeight, options.fontShape);\n\n      return makeSymbol(text, _fontName, mode, options, classes.concat(\"amsrm\", options.fontWeight, options.fontShape));\n    } else if (font === \"main\" || !font) {\n      var _fontName2 = retrieveTextFontName(\"textrm\", options.fontWeight, options.fontShape);\n\n      return makeSymbol(text, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));\n    } else {\n      // fonts added by plugins\n      var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape); // We add font name as a css class\n\n\n      return makeSymbol(text, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));\n    }\n  } else {\n    throw new Error(\"unexpected type: \" + type + \" in makeOrd\");\n  }\n};\n/**\n * Returns true if subsequent symbolNodes have the same classes, skew, maxFont,\n * and styles.\n */\n\n\nvar canCombine = (prev, next) => {\n  if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {\n    return false;\n  } // If prev and next both are just \"mbin\"s or \"mord\"s we don't combine them\n  // so that the proper spacing can be preserved.\n\n\n  if (prev.classes.length === 1) {\n    var cls = prev.classes[0];\n\n    if (cls === \"mbin\" || cls === \"mord\") {\n      return false;\n    }\n  }\n\n  for (var style in prev.style) {\n    if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {\n      return false;\n    }\n  }\n\n  for (var _style in next.style) {\n    if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Combine consecutive domTree.symbolNodes into a single symbolNode.\n * Note: this function mutates the argument.\n */\n\n\nvar tryCombineChars = chars => {\n  for (var i = 0; i < chars.length - 1; i++) {\n    var prev = chars[i];\n    var next = chars[i + 1];\n\n    if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {\n      prev.text += next.text;\n      prev.height = Math.max(prev.height, next.height);\n      prev.depth = Math.max(prev.depth, next.depth); // Use the last character's italic correction since we use\n      // it to add padding to the right of the span created from\n      // the combined characters.\n\n      prev.italic = next.italic;\n      chars.splice(i + 1, 1);\n      i--;\n    }\n  }\n\n  return chars;\n};\n/**\n * Calculate the height, depth, and maxFontSize of an element based on its\n * children.\n */\n\n\nvar sizeElementFromChildren = function sizeElementFromChildren(elem) {\n  var height = 0;\n  var depth = 0;\n  var maxFontSize = 0;\n\n  for (var i = 0; i < elem.children.length; i++) {\n    var child = elem.children[i];\n\n    if (child.height > height) {\n      height = child.height;\n    }\n\n    if (child.depth > depth) {\n      depth = child.depth;\n    }\n\n    if (child.maxFontSize > maxFontSize) {\n      maxFontSize = child.maxFontSize;\n    }\n  }\n\n  elem.height = height;\n  elem.depth = depth;\n  elem.maxFontSize = maxFontSize;\n};\n/**\n * Makes a span with the given list of classes, list of children, and options.\n *\n * TODO(#953): Ensure that `options` is always provided (currently some call\n * sites don't pass it) and make the type below mandatory.\n * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which\n * should if present come first in `classes`.\n */\n\n\nvar makeSpan$2 = function makeSpan(classes, children, options, style) {\n  var span = new Span(classes, children, options, style);\n  sizeElementFromChildren(span);\n  return span;\n}; // SVG one is simpler -- doesn't require height, depth, max-font setting.\n// This is also a separate method for typesafety.\n\n\nvar makeSvgSpan = (classes, children, options, style) => new Span(classes, children, options, style);\n\nvar makeLineSpan = function makeLineSpan(className, options, thickness) {\n  var line = makeSpan$2([className], [], options);\n  line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);\n  line.style.borderBottomWidth = makeEm(line.height);\n  line.maxFontSize = 1.0;\n  return line;\n};\n/**\n * Makes an anchor with the given href, list of classes, list of children,\n * and options.\n */\n\n\nvar makeAnchor = function makeAnchor(href, classes, children, options) {\n  var anchor = new Anchor(href, classes, children, options);\n  sizeElementFromChildren(anchor);\n  return anchor;\n};\n/**\n * Makes a document fragment with the given list of children.\n */\n\n\nvar makeFragment = function makeFragment(children) {\n  var fragment = new DocumentFragment(children);\n  sizeElementFromChildren(fragment);\n  return fragment;\n};\n/**\n * Wraps group in a span if it's a document fragment, allowing to apply classes\n * and styles\n */\n\n\nvar wrapFragment = function wrapFragment(group, options) {\n  if (group instanceof DocumentFragment) {\n    return makeSpan$2([], [group], options);\n  }\n\n  return group;\n}; // These are exact object types to catch typos in the names of the optional fields.\n\n\n// Computes the updated `children` list and the overall depth.\n//\n// This helper function for makeVList makes it easier to enforce type safety by\n// allowing early exits (returns) in the logic.\nvar getVListChildrenAndDepth = function getVListChildrenAndDepth(params) {\n  if (params.positionType === \"individualShift\") {\n    var oldChildren = params.children;\n    var children = [oldChildren[0]]; // Add in kerns to the list of params.children to get each element to be\n    // shifted to the correct specified shift\n\n    var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;\n\n    var currPos = _depth;\n\n    for (var i = 1; i < oldChildren.length; i++) {\n      var diff = -oldChildren[i].shift - currPos - oldChildren[i].elem.depth;\n      var size = diff - (oldChildren[i - 1].elem.height + oldChildren[i - 1].elem.depth);\n      currPos = currPos + diff;\n      children.push({\n        type: \"kern\",\n        size\n      });\n      children.push(oldChildren[i]);\n    }\n\n    return {\n      children,\n      depth: _depth\n    };\n  }\n\n  var depth;\n\n  if (params.positionType === \"top\") {\n    // We always start at the bottom, so calculate the bottom by adding up\n    // all the sizes\n    var bottom = params.positionData;\n\n    for (var _i = 0; _i < params.children.length; _i++) {\n      var child = params.children[_i];\n      bottom -= child.type === \"kern\" ? child.size : child.elem.height + child.elem.depth;\n    }\n\n    depth = bottom;\n  } else if (params.positionType === \"bottom\") {\n    depth = -params.positionData;\n  } else {\n    var firstChild = params.children[0];\n\n    if (firstChild.type !== \"elem\") {\n      throw new Error('First child must have type \"elem\".');\n    }\n\n    if (params.positionType === \"shift\") {\n      depth = -firstChild.elem.depth - params.positionData;\n    } else if (params.positionType === \"firstBaseline\") {\n      depth = -firstChild.elem.depth;\n    } else {\n      throw new Error(\"Invalid positionType \" + params.positionType + \".\");\n    }\n  }\n\n  return {\n    children: params.children,\n    depth\n  };\n};\n/**\n * Makes a vertical list by stacking elements and kerns on top of each other.\n * Allows for many different ways of specifying the positioning method.\n *\n * See VListParam documentation above.\n */\n\n\nvar makeVList = function makeVList(params, options) {\n  var {\n    children,\n    depth\n  } = getVListChildrenAndDepth(params); // Create a strut that is taller than any list item. The strut is added to\n  // each item, where it will determine the item's baseline. Since it has\n  // `overflow:hidden`, the strut's top edge will sit on the item's line box's\n  // top edge and the strut's bottom edge will sit on the item's baseline,\n  // with no additional line-height spacing. This allows the item baseline to\n  // be positioned precisely without worrying about font ascent and\n  // line-height.\n\n  var pstrutSize = 0;\n\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n\n    if (child.type === \"elem\") {\n      var elem = child.elem;\n      pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);\n    }\n  }\n\n  pstrutSize += 2;\n  var pstrut = makeSpan$2([\"pstrut\"], []);\n  pstrut.style.height = makeEm(pstrutSize); // Create a new list of actual children at the correct offsets\n\n  var realChildren = [];\n  var minPos = depth;\n  var maxPos = depth;\n  var currPos = depth;\n\n  for (var _i2 = 0; _i2 < children.length; _i2++) {\n    var _child = children[_i2];\n\n    if (_child.type === \"kern\") {\n      currPos += _child.size;\n    } else {\n      var _elem = _child.elem;\n      var classes = _child.wrapperClasses || [];\n      var style = _child.wrapperStyle || {};\n      var childWrap = makeSpan$2(classes, [pstrut, _elem], undefined, style);\n      childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);\n\n      if (_child.marginLeft) {\n        childWrap.style.marginLeft = _child.marginLeft;\n      }\n\n      if (_child.marginRight) {\n        childWrap.style.marginRight = _child.marginRight;\n      }\n\n      realChildren.push(childWrap);\n      currPos += _elem.height + _elem.depth;\n    }\n\n    minPos = Math.min(minPos, currPos);\n    maxPos = Math.max(maxPos, currPos);\n  } // The vlist contents go in a table-cell with `vertical-align:bottom`.\n  // This cell's bottom edge will determine the containing table's baseline\n  // without overly expanding the containing line-box.\n\n\n  var vlist = makeSpan$2([\"vlist\"], realChildren);\n  vlist.style.height = makeEm(maxPos); // A second row is used if necessary to represent the vlist's depth.\n\n  var rows;\n\n  if (minPos < 0) {\n    // We will define depth in an empty span with display: table-cell.\n    // It should render with the height that we define. But Chrome, in\n    // contenteditable mode only, treats that span as if it contains some\n    // text content. And that min-height over-rides our desired height.\n    // So we put another empty span inside the depth strut span.\n    var emptySpan = makeSpan$2([], []);\n    var depthStrut = makeSpan$2([\"vlist\"], [emptySpan]);\n    depthStrut.style.height = makeEm(-minPos); // Safari wants the first row to have inline content; otherwise it\n    // puts the bottom of the *second* row on the baseline.\n\n    var topStrut = makeSpan$2([\"vlist-s\"], [new SymbolNode(\"\\u200b\")]);\n    rows = [makeSpan$2([\"vlist-r\"], [vlist, topStrut]), makeSpan$2([\"vlist-r\"], [depthStrut])];\n  } else {\n    rows = [makeSpan$2([\"vlist-r\"], [vlist])];\n  }\n\n  var vtable = makeSpan$2([\"vlist-t\"], rows);\n\n  if (rows.length === 2) {\n    vtable.classes.push(\"vlist-t2\");\n  }\n\n  vtable.height = maxPos;\n  vtable.depth = -minPos;\n  return vtable;\n}; // Glue is a concept from TeX which is a flexible space between elements in\n// either a vertical or horizontal list. In KaTeX, at least for now, it's\n// static space between elements in a horizontal layout.\n\n\nvar makeGlue = (measurement, options) => {\n  // Make an empty span for the space\n  var rule = makeSpan$2([\"mspace\"], [], options);\n  var size = calculateSize(measurement, options);\n  rule.style.marginRight = makeEm(size);\n  return rule;\n}; // Takes font options, and returns the appropriate fontLookup name\n\n\nvar retrieveTextFontName = function retrieveTextFontName(fontFamily, fontWeight, fontShape) {\n  var baseFontName = \"\";\n\n  switch (fontFamily) {\n    case \"amsrm\":\n      baseFontName = \"AMS\";\n      break;\n\n    case \"textrm\":\n      baseFontName = \"Main\";\n      break;\n\n    case \"textsf\":\n      baseFontName = \"SansSerif\";\n      break;\n\n    case \"texttt\":\n      baseFontName = \"Typewriter\";\n      break;\n\n    default:\n      baseFontName = fontFamily;\n    // use fonts added by a plugin\n  }\n\n  var fontStylesName;\n\n  if (fontWeight === \"textbf\" && fontShape === \"textit\") {\n    fontStylesName = \"BoldItalic\";\n  } else if (fontWeight === \"textbf\") {\n    fontStylesName = \"Bold\";\n  } else if (fontWeight === \"textit\") {\n    fontStylesName = \"Italic\";\n  } else {\n    fontStylesName = \"Regular\";\n  }\n\n  return baseFontName + \"-\" + fontStylesName;\n};\n/**\n * Maps TeX font commands to objects containing:\n * - variant: string used for \"mathvariant\" attribute in buildMathML.js\n * - fontName: the \"style\" parameter to fontMetrics.getCharacterMetrics\n */\n// A map between tex font commands an MathML mathvariant attribute values\n\n\nvar fontMap = {\n  // styles\n  \"mathbf\": {\n    variant: \"bold\",\n    fontName: \"Main-Bold\"\n  },\n  \"mathrm\": {\n    variant: \"normal\",\n    fontName: \"Main-Regular\"\n  },\n  \"textit\": {\n    variant: \"italic\",\n    fontName: \"Main-Italic\"\n  },\n  \"mathit\": {\n    variant: \"italic\",\n    fontName: \"Main-Italic\"\n  },\n  \"mathnormal\": {\n    variant: \"italic\",\n    fontName: \"Math-Italic\"\n  },\n  \"mathsfit\": {\n    variant: \"sans-serif-italic\",\n    fontName: \"SansSerif-Italic\"\n  },\n  // \"boldsymbol\" is missing because they require the use of multiple fonts:\n  // Math-BoldItalic and Main-Bold.  This is handled by a special case in\n  // makeOrd which ends up calling boldsymbol.\n  // families\n  \"mathbb\": {\n    variant: \"double-struck\",\n    fontName: \"AMS-Regular\"\n  },\n  \"mathcal\": {\n    variant: \"script\",\n    fontName: \"Caligraphic-Regular\"\n  },\n  \"mathfrak\": {\n    variant: \"fraktur\",\n    fontName: \"Fraktur-Regular\"\n  },\n  \"mathscr\": {\n    variant: \"script\",\n    fontName: \"Script-Regular\"\n  },\n  \"mathsf\": {\n    variant: \"sans-serif\",\n    fontName: \"SansSerif-Regular\"\n  },\n  \"mathtt\": {\n    variant: \"monospace\",\n    fontName: \"Typewriter-Regular\"\n  }\n};\nvar svgData = {\n  //   path, width, height\n  vec: [\"vec\", 0.471, 0.714],\n  // values from the font glyph\n  oiintSize1: [\"oiintSize1\", 0.957, 0.499],\n  // oval to overlay the integrand\n  oiintSize2: [\"oiintSize2\", 1.472, 0.659],\n  oiiintSize1: [\"oiiintSize1\", 1.304, 0.499],\n  oiiintSize2: [\"oiiintSize2\", 1.98, 0.659]\n};\n\nvar staticSvg = function staticSvg(value, options) {\n  // Create a span with inline SVG for the element.\n  var [pathName, width, height] = svgData[value];\n  var path = new PathNode(pathName);\n  var svgNode = new SvgNode([path], {\n    \"width\": makeEm(width),\n    \"height\": makeEm(height),\n    // Override CSS rule `.katex svg { width: 100% }`\n    \"style\": \"width:\" + makeEm(width),\n    \"viewBox\": \"0 0 \" + 1000 * width + \" \" + 1000 * height,\n    \"preserveAspectRatio\": \"xMinYMin\"\n  });\n  var span = makeSvgSpan([\"overlay\"], [svgNode], options);\n  span.height = height;\n  span.style.height = makeEm(height);\n  span.style.width = makeEm(width);\n  return span;\n};\n\nvar buildCommon = {\n  fontMap,\n  makeSymbol,\n  mathsym,\n  makeSpan: makeSpan$2,\n  makeSvgSpan,\n  makeLineSpan,\n  makeAnchor,\n  makeFragment,\n  wrapFragment,\n  makeVList,\n  makeOrd,\n  makeGlue,\n  staticSvg,\n  svgData,\n  tryCombineChars\n};\n\n/**\n * Describes spaces between different classes of atoms.\n */\nvar thinspace = {\n  number: 3,\n  unit: \"mu\"\n};\nvar mediumspace = {\n  number: 4,\n  unit: \"mu\"\n};\nvar thickspace = {\n  number: 5,\n  unit: \"mu\"\n}; // Making the type below exact with all optional fields doesn't work due to\n// - https://github.com/facebook/flow/issues/4582\n// - https://github.com/facebook/flow/issues/5688\n// However, since *all* fields are optional, $Shape<> works as suggested in 5688\n// above.\n\n// Spacing relationships for display and text styles\nvar spacings = {\n  mord: {\n    mop: thinspace,\n    mbin: mediumspace,\n    mrel: thickspace,\n    minner: thinspace\n  },\n  mop: {\n    mord: thinspace,\n    mop: thinspace,\n    mrel: thickspace,\n    minner: thinspace\n  },\n  mbin: {\n    mord: mediumspace,\n    mop: mediumspace,\n    mopen: mediumspace,\n    minner: mediumspace\n  },\n  mrel: {\n    mord: thickspace,\n    mop: thickspace,\n    mopen: thickspace,\n    minner: thickspace\n  },\n  mopen: {},\n  mclose: {\n    mop: thinspace,\n    mbin: mediumspace,\n    mrel: thickspace,\n    minner: thinspace\n  },\n  mpunct: {\n    mord: thinspace,\n    mop: thinspace,\n    mrel: thickspace,\n    mopen: thinspace,\n    mclose: thinspace,\n    mpunct: thinspace,\n    minner: thinspace\n  },\n  minner: {\n    mord: thinspace,\n    mop: thinspace,\n    mbin: mediumspace,\n    mrel: thickspace,\n    mopen: thinspace,\n    mpunct: thinspace,\n    minner: thinspace\n  }\n}; // Spacing relationships for script and scriptscript styles\n\nvar tightSpacings = {\n  mord: {\n    mop: thinspace\n  },\n  mop: {\n    mord: thinspace,\n    mop: thinspace\n  },\n  mbin: {},\n  mrel: {},\n  mopen: {},\n  mclose: {\n    mop: thinspace\n  },\n  mpunct: {},\n  minner: {\n    mop: thinspace\n  }\n};\n\n/** Context provided to function handlers for error messages. */\n// Note: reverse the order of the return type union will cause a flow error.\n// See https://github.com/facebook/flow/issues/3663.\n// More general version of `HtmlBuilder` for nodes (e.g. \\sum, accent types)\n// whose presence impacts super/subscripting. In this case, ParseNode<\"supsub\">\n// delegates its HTML building to the HtmlBuilder corresponding to these nodes.\n\n/**\n * Final function spec for use at parse time.\n * This is almost identical to `FunctionPropSpec`, except it\n * 1. includes the function handler, and\n * 2. requires all arguments except argTypes.\n * It is generated by `defineFunction()` below.\n */\n\n/**\n * All registered functions.\n * `functions.js` just exports this same dictionary again and makes it public.\n * `Parser.js` requires this dictionary.\n */\nvar _functions = {};\n/**\n * All HTML builders. Should be only used in the `define*` and the `build*ML`\n * functions.\n */\n\nvar _htmlGroupBuilders = {};\n/**\n * All MathML builders. Should be only used in the `define*` and the `build*ML`\n * functions.\n */\n\nvar _mathmlGroupBuilders = {};\nfunction defineFunction(_ref) {\n  var {\n    type,\n    names,\n    props,\n    handler,\n    htmlBuilder,\n    mathmlBuilder\n  } = _ref;\n  // Set default values of functions\n  var data = {\n    type,\n    numArgs: props.numArgs,\n    argTypes: props.argTypes,\n    allowedInArgument: !!props.allowedInArgument,\n    allowedInText: !!props.allowedInText,\n    allowedInMath: props.allowedInMath === undefined ? true : props.allowedInMath,\n    numOptionalArgs: props.numOptionalArgs || 0,\n    infix: !!props.infix,\n    primitive: !!props.primitive,\n    handler: handler\n  };\n\n  for (var i = 0; i < names.length; ++i) {\n    _functions[names[i]] = data;\n  }\n\n  if (type) {\n    if (htmlBuilder) {\n      _htmlGroupBuilders[type] = htmlBuilder;\n    }\n\n    if (mathmlBuilder) {\n      _mathmlGroupBuilders[type] = mathmlBuilder;\n    }\n  }\n}\n/**\n * Use this to register only the HTML and MathML builders for a function (e.g.\n * if the function's ParseNode is generated in Parser.js rather than via a\n * stand-alone handler provided to `defineFunction`).\n */\n\nfunction defineFunctionBuilders(_ref2) {\n  var {\n    type,\n    htmlBuilder,\n    mathmlBuilder\n  } = _ref2;\n  defineFunction({\n    type,\n    names: [],\n    props: {\n      numArgs: 0\n    },\n\n    handler() {\n      throw new Error('Should never be called.');\n    },\n\n    htmlBuilder,\n    mathmlBuilder\n  });\n}\nvar normalizeArgument = function normalizeArgument(arg) {\n  return arg.type === \"ordgroup\" && arg.body.length === 1 ? arg.body[0] : arg;\n}; // Since the corresponding buildHTML/buildMathML function expects a\n// list of elements, we normalize for different kinds of arguments\n\nvar ordargument = function ordargument(arg) {\n  return arg.type === \"ordgroup\" ? arg.body : [arg];\n};\n\n/**\n * This file does the main work of building a domTree structure from a parse\n * tree. The entry point is the `buildHTML` function, which takes a parse tree.\n * Then, the buildExpression, buildGroup, and various groupBuilders functions\n * are called, to produce a final HTML tree.\n */\nvar makeSpan$1 = buildCommon.makeSpan; // Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)\n// depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,\n// and the text before Rule 19.\n\nvar binLeftCanceller = [\"leftmost\", \"mbin\", \"mopen\", \"mrel\", \"mop\", \"mpunct\"];\nvar binRightCanceller = [\"rightmost\", \"mrel\", \"mclose\", \"mpunct\"];\nvar styleMap$1 = {\n  \"display\": Style$1.DISPLAY,\n  \"text\": Style$1.TEXT,\n  \"script\": Style$1.SCRIPT,\n  \"scriptscript\": Style$1.SCRIPTSCRIPT\n};\nvar DomEnum = {\n  mord: \"mord\",\n  mop: \"mop\",\n  mbin: \"mbin\",\n  mrel: \"mrel\",\n  mopen: \"mopen\",\n  mclose: \"mclose\",\n  mpunct: \"mpunct\",\n  minner: \"minner\"\n};\n\n/**\n * Take a list of nodes, build them in order, and return a list of the built\n * nodes. documentFragments are flattened into their contents, so the\n * returned list contains no fragments. `isRealGroup` is true if `expression`\n * is a real group (no atoms will be added on either side), as opposed to\n * a partial group (e.g. one created by \\color). `surrounding` is an array\n * consisting type of nodes that will be added to the left and right.\n */\nvar buildExpression$1 = function buildExpression(expression, options, isRealGroup, surrounding) {\n  if (surrounding === void 0) {\n    surrounding = [null, null];\n  }\n\n  // Parse expressions into `groups`.\n  var groups = [];\n\n  for (var i = 0; i < expression.length; i++) {\n    var output = buildGroup$1(expression[i], options);\n\n    if (output instanceof DocumentFragment) {\n      var children = output.children;\n      groups.push(...children);\n    } else {\n      groups.push(output);\n    }\n  } // Combine consecutive domTree.symbolNodes into a single symbolNode.\n\n\n  buildCommon.tryCombineChars(groups); // If `expression` is a partial group, let the parent handle spacings\n  // to avoid processing groups multiple times.\n\n  if (!isRealGroup) {\n    return groups;\n  }\n\n  var glueOptions = options;\n\n  if (expression.length === 1) {\n    var node = expression[0];\n\n    if (node.type === \"sizing\") {\n      glueOptions = options.havingSize(node.size);\n    } else if (node.type === \"styling\") {\n      glueOptions = options.havingStyle(styleMap$1[node.style]);\n    }\n  } // Dummy spans for determining spacings between surrounding atoms.\n  // If `expression` has no atoms on the left or right, class \"leftmost\"\n  // or \"rightmost\", respectively, is used to indicate it.\n\n\n  var dummyPrev = makeSpan$1([surrounding[0] || \"leftmost\"], [], options);\n  var dummyNext = makeSpan$1([surrounding[1] || \"rightmost\"], [], options); // TODO: These code assumes that a node's math class is the first element\n  // of its `classes` array. A later cleanup should ensure this, for\n  // instance by changing the signature of `makeSpan`.\n  // Before determining what spaces to insert, perform bin cancellation.\n  // Binary operators change to ordinary symbols in some contexts.\n\n  var isRoot = isRealGroup === \"root\";\n  traverseNonSpaceNodes(groups, (node, prev) => {\n    var prevType = prev.classes[0];\n    var type = node.classes[0];\n\n    if (prevType === \"mbin\" && binRightCanceller.includes(type)) {\n      prev.classes[0] = \"mord\";\n    } else if (type === \"mbin\" && binLeftCanceller.includes(prevType)) {\n      node.classes[0] = \"mord\";\n    }\n  }, {\n    node: dummyPrev\n  }, dummyNext, isRoot);\n  traverseNonSpaceNodes(groups, (node, prev) => {\n    var prevType = getTypeOfDomTree(prev);\n    var type = getTypeOfDomTree(node); // 'mtight' indicates that the node is script or scriptscript style.\n\n    var space = prevType && type ? node.hasClass(\"mtight\") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;\n\n    if (space) {\n      // Insert glue (spacing) after the `prev`.\n      return buildCommon.makeGlue(space, glueOptions);\n    }\n  }, {\n    node: dummyPrev\n  }, dummyNext, isRoot);\n  return groups;\n}; // Depth-first traverse non-space `nodes`, calling `callback` with the current and\n// previous node as arguments, optionally returning a node to insert after the\n// previous node. `prev` is an object with the previous node and `insertAfter`\n// function to insert after it. `next` is a node that will be added to the right.\n// Used for bin cancellation and inserting spacings.\n\nvar traverseNonSpaceNodes = function traverseNonSpaceNodes(nodes, callback, prev, next, isRoot) {\n  if (next) {\n    // temporarily append the right node, if exists\n    nodes.push(next);\n  }\n\n  var i = 0;\n\n  for (; i < nodes.length; i++) {\n    var node = nodes[i];\n    var partialGroup = checkPartialGroup(node);\n\n    if (partialGroup) {\n      // Recursive DFS\n      // $FlowFixMe: make nodes a $ReadOnlyArray by returning a new array\n      traverseNonSpaceNodes(partialGroup.children, callback, prev, null, isRoot);\n      continue;\n    } // Ignore explicit spaces (e.g., \\;, \\,) when determining what implicit\n    // spacing should go between atoms of different classes\n\n\n    var nonspace = !node.hasClass(\"mspace\");\n\n    if (nonspace) {\n      var result = callback(node, prev.node);\n\n      if (result) {\n        if (prev.insertAfter) {\n          prev.insertAfter(result);\n        } else {\n          // insert at front\n          nodes.unshift(result);\n          i++;\n        }\n      }\n    }\n\n    if (nonspace) {\n      prev.node = node;\n    } else if (isRoot && node.hasClass(\"newline\")) {\n      prev.node = makeSpan$1([\"leftmost\"]); // treat like beginning of line\n    }\n\n    prev.insertAfter = (index => n => {\n      nodes.splice(index + 1, 0, n);\n      i++;\n    })(i);\n  }\n\n  if (next) {\n    nodes.pop();\n  }\n}; // Check if given node is a partial group, i.e., does not affect spacing around.\n\n\nvar checkPartialGroup = function checkPartialGroup(node) {\n  if (node instanceof DocumentFragment || node instanceof Anchor || node instanceof Span && node.hasClass(\"enclosing\")) {\n    return node;\n  }\n\n  return null;\n}; // Return the outermost node of a domTree.\n\n\nvar getOutermostNode = function getOutermostNode(node, side) {\n  var partialGroup = checkPartialGroup(node);\n\n  if (partialGroup) {\n    var children = partialGroup.children;\n\n    if (children.length) {\n      if (side === \"right\") {\n        return getOutermostNode(children[children.length - 1], \"right\");\n      } else if (side === \"left\") {\n        return getOutermostNode(children[0], \"left\");\n      }\n    }\n  }\n\n  return node;\n}; // Return math atom class (mclass) of a domTree.\n// If `side` is given, it will get the type of the outermost node at given side.\n\n\nvar getTypeOfDomTree = function getTypeOfDomTree(node, side) {\n  if (!node) {\n    return null;\n  }\n\n  if (side) {\n    node = getOutermostNode(node, side);\n  } // This makes a lot of assumptions as to where the type of atom\n  // appears.  We should do a better job of enforcing this.\n\n\n  return DomEnum[node.classes[0]] || null;\n};\nvar makeNullDelimiter = function makeNullDelimiter(options, classes) {\n  var moreClasses = [\"nulldelimiter\"].concat(options.baseSizingClasses());\n  return makeSpan$1(classes.concat(moreClasses));\n};\n/**\n * buildGroup is the function that takes a group and calls the correct groupType\n * function for it. It also handles the interaction of size and style changes\n * between parents and children.\n */\n\nvar buildGroup$1 = function buildGroup(group, options, baseOptions) {\n  if (!group) {\n    return makeSpan$1();\n  }\n\n  if (_htmlGroupBuilders[group.type]) {\n    // Call the groupBuilders function\n    // $FlowFixMe\n    var groupNode = _htmlGroupBuilders[group.type](group, options); // If the size changed between the parent and the current group, account\n    // for that size difference.\n\n    if (baseOptions && options.size !== baseOptions.size) {\n      groupNode = makeSpan$1(options.sizingClasses(baseOptions), [groupNode], options);\n      var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;\n      groupNode.height *= multiplier;\n      groupNode.depth *= multiplier;\n    }\n\n    return groupNode;\n  } else {\n    throw new ParseError(\"Got group of unknown type: '\" + group.type + \"'\");\n  }\n};\n/**\n * Combine an array of HTML DOM nodes (e.g., the output of `buildExpression`)\n * into an unbreakable HTML node of class .base, with proper struts to\n * guarantee correct vertical extent.  `buildHTML` calls this repeatedly to\n * make up the entire expression as a sequence of unbreakable units.\n */\n\nfunction buildHTMLUnbreakable(children, options) {\n  // Compute height and depth of this chunk.\n  var body = makeSpan$1([\"base\"], children, options); // Add strut, which ensures that the top of the HTML element falls at\n  // the height of the expression, and the bottom of the HTML element\n  // falls at the depth of the expression.\n\n  var strut = makeSpan$1([\"strut\"]);\n  strut.style.height = makeEm(body.height + body.depth);\n\n  if (body.depth) {\n    strut.style.verticalAlign = makeEm(-body.depth);\n  }\n\n  body.children.unshift(strut);\n  return body;\n}\n/**\n * Take an entire parse tree, and build it into an appropriate set of HTML\n * nodes.\n */\n\n\nfunction buildHTML(tree, options) {\n  // Strip off outer tag wrapper for processing below.\n  var tag = null;\n\n  if (tree.length === 1 && tree[0].type === \"tag\") {\n    tag = tree[0].tag;\n    tree = tree[0].body;\n  } // Build the expression contained in the tree\n\n\n  var expression = buildExpression$1(tree, options, \"root\");\n  var eqnNum;\n\n  if (expression.length === 2 && expression[1].hasClass(\"tag\")) {\n    // An environment with automatic equation numbers, e.g. {gather}.\n    eqnNum = expression.pop();\n  }\n\n  var children = []; // Create one base node for each chunk between potential line breaks.\n  // The TeXBook [p.173] says \"A formula will be broken only after a\n  // relation symbol like $=$ or $<$ or $\\rightarrow$, or after a binary\n  // operation symbol like $+$ or $-$ or $\\times$, where the relation or\n  // binary operation is on the ``outer level'' of the formula (i.e., not\n  // enclosed in {...} and not part of an \\over construction).\"\n\n  var parts = [];\n\n  for (var i = 0; i < expression.length; i++) {\n    parts.push(expression[i]);\n\n    if (expression[i].hasClass(\"mbin\") || expression[i].hasClass(\"mrel\") || expression[i].hasClass(\"allowbreak\")) {\n      // Put any post-operator glue on same line as operator.\n      // Watch for \\nobreak along the way, and stop at \\newline.\n      var nobreak = false;\n\n      while (i < expression.length - 1 && expression[i + 1].hasClass(\"mspace\") && !expression[i + 1].hasClass(\"newline\")) {\n        i++;\n        parts.push(expression[i]);\n\n        if (expression[i].hasClass(\"nobreak\")) {\n          nobreak = true;\n        }\n      } // Don't allow break if \\nobreak among the post-operator glue.\n\n\n      if (!nobreak) {\n        children.push(buildHTMLUnbreakable(parts, options));\n        parts = [];\n      }\n    } else if (expression[i].hasClass(\"newline\")) {\n      // Write the line except the newline\n      parts.pop();\n\n      if (parts.length > 0) {\n        children.push(buildHTMLUnbreakable(parts, options));\n        parts = [];\n      } // Put the newline at the top level\n\n\n      children.push(expression[i]);\n    }\n  }\n\n  if (parts.length > 0) {\n    children.push(buildHTMLUnbreakable(parts, options));\n  } // Now, if there was a tag, build it too and append it as a final child.\n\n\n  var tagChild;\n\n  if (tag) {\n    tagChild = buildHTMLUnbreakable(buildExpression$1(tag, options, true));\n    tagChild.classes = [\"tag\"];\n    children.push(tagChild);\n  } else if (eqnNum) {\n    children.push(eqnNum);\n  }\n\n  var htmlNode = makeSpan$1([\"katex-html\"], children);\n  htmlNode.setAttribute(\"aria-hidden\", \"true\"); // Adjust the strut of the tag to be the maximum height of all children\n  // (the height of the enclosing htmlNode) for proper vertical alignment.\n\n  if (tagChild) {\n    var strut = tagChild.children[0];\n    strut.style.height = makeEm(htmlNode.height + htmlNode.depth);\n\n    if (htmlNode.depth) {\n      strut.style.verticalAlign = makeEm(-htmlNode.depth);\n    }\n  }\n\n  return htmlNode;\n}\n\n/**\n * These objects store data about MathML nodes. This is the MathML equivalent\n * of the types in domTree.js. Since MathML handles its own rendering, and\n * since we're mainly using MathML to improve accessibility, we don't manage\n * any of the styling state that the plain DOM nodes do.\n *\n * The `toNode` and `toMarkup` functions work similarly to how they do in\n * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.\n */\nfunction newDocumentFragment(children) {\n  return new DocumentFragment(children);\n}\n/**\n * This node represents a general purpose MathML node of any type. The\n * constructor requires the type of node to create (for example, `\"mo\"` or\n * `\"mspace\"`, corresponding to `<mo>` and `<mspace>` tags).\n */\n\nclass MathNode {\n  constructor(type, children, classes) {\n    this.type = void 0;\n    this.attributes = void 0;\n    this.children = void 0;\n    this.classes = void 0;\n    this.type = type;\n    this.attributes = {};\n    this.children = children || [];\n    this.classes = classes || [];\n  }\n  /**\n   * Sets an attribute on a MathML node. MathML depends on attributes to convey a\n   * semantic content, so this is used heavily.\n   */\n\n\n  setAttribute(name, value) {\n    this.attributes[name] = value;\n  }\n  /**\n   * Gets an attribute on a MathML node.\n   */\n\n\n  getAttribute(name) {\n    return this.attributes[name];\n  }\n  /**\n   * Converts the math node into a MathML-namespaced DOM element.\n   */\n\n\n  toNode() {\n    var node = document.createElementNS(\"http://www.w3.org/1998/Math/MathML\", this.type);\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        node.setAttribute(attr, this.attributes[attr]);\n      }\n    }\n\n    if (this.classes.length > 0) {\n      node.className = createClass(this.classes);\n    }\n\n    for (var i = 0; i < this.children.length; i++) {\n      // Combine multiple TextNodes into one TextNode, to prevent\n      // screen readers from reading each as a separate word [#3995]\n      if (this.children[i] instanceof TextNode && this.children[i + 1] instanceof TextNode) {\n        var text = this.children[i].toText() + this.children[++i].toText();\n\n        while (this.children[i + 1] instanceof TextNode) {\n          text += this.children[++i].toText();\n        }\n\n        node.appendChild(new TextNode(text).toNode());\n      } else {\n        node.appendChild(this.children[i].toNode());\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Converts the math node into an HTML markup string.\n   */\n\n\n  toMarkup() {\n    var markup = \"<\" + this.type; // Add the attributes\n\n    for (var attr in this.attributes) {\n      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {\n        markup += \" \" + attr + \"=\\\"\";\n        markup += utils.escape(this.attributes[attr]);\n        markup += \"\\\"\";\n      }\n    }\n\n    if (this.classes.length > 0) {\n      markup += \" class =\\\"\" + utils.escape(createClass(this.classes)) + \"\\\"\";\n    }\n\n    markup += \">\";\n\n    for (var i = 0; i < this.children.length; i++) {\n      markup += this.children[i].toMarkup();\n    }\n\n    markup += \"</\" + this.type + \">\";\n    return markup;\n  }\n  /**\n   * Converts the math node into a string, similar to innerText, but escaped.\n   */\n\n\n  toText() {\n    return this.children.map(child => child.toText()).join(\"\");\n  }\n\n}\n/**\n * This node represents a piece of text.\n */\n\nclass TextNode {\n  constructor(text) {\n    this.text = void 0;\n    this.text = text;\n  }\n  /**\n   * Converts the text node into a DOM text node.\n   */\n\n\n  toNode() {\n    return document.createTextNode(this.text);\n  }\n  /**\n   * Converts the text node into escaped HTML markup\n   * (representing the text itself).\n   */\n\n\n  toMarkup() {\n    return utils.escape(this.toText());\n  }\n  /**\n   * Converts the text node into a string\n   * (representing the text itself).\n   */\n\n\n  toText() {\n    return this.text;\n  }\n\n}\n/**\n * This node represents a space, but may render as <mspace.../> or as text,\n * depending on the width.\n */\n\nclass SpaceNode {\n  /**\n   * Create a Space node with width given in CSS ems.\n   */\n  constructor(width) {\n    this.width = void 0;\n    this.character = void 0;\n    this.width = width; // See https://www.w3.org/TR/2000/WD-MathML2-20000328/chapter6.html\n    // for a table of space-like characters.  We use Unicode\n    // representations instead of &LongNames; as it's not clear how to\n    // make the latter via document.createTextNode.\n\n    if (width >= 0.05555 && width <= 0.05556) {\n      this.character = \"\\u200a\"; // &VeryThinSpace;\n    } else if (width >= 0.1666 && width <= 0.1667) {\n      this.character = \"\\u2009\"; // &ThinSpace;\n    } else if (width >= 0.2222 && width <= 0.2223) {\n      this.character = \"\\u2005\"; // &MediumSpace;\n    } else if (width >= 0.2777 && width <= 0.2778) {\n      this.character = \"\\u2005\\u200a\"; // &ThickSpace;\n    } else if (width >= -0.05556 && width <= -0.05555) {\n      this.character = \"\\u200a\\u2063\"; // &NegativeVeryThinSpace;\n    } else if (width >= -0.1667 && width <= -0.1666) {\n      this.character = \"\\u2009\\u2063\"; // &NegativeThinSpace;\n    } else if (width >= -0.2223 && width <= -0.2222) {\n      this.character = \"\\u205f\\u2063\"; // &NegativeMediumSpace;\n    } else if (width >= -0.2778 && width <= -0.2777) {\n      this.character = \"\\u2005\\u2063\"; // &NegativeThickSpace;\n    } else {\n      this.character = null;\n    }\n  }\n  /**\n   * Converts the math node into a MathML-namespaced DOM element.\n   */\n\n\n  toNode() {\n    if (this.character) {\n      return document.createTextNode(this.character);\n    } else {\n      var node = document.createElementNS(\"http://www.w3.org/1998/Math/MathML\", \"mspace\");\n      node.setAttribute(\"width\", makeEm(this.width));\n      return node;\n    }\n  }\n  /**\n   * Converts the math node into an HTML markup string.\n   */\n\n\n  toMarkup() {\n    if (this.character) {\n      return \"<mtext>\" + this.character + \"</mtext>\";\n    } else {\n      return \"<mspace width=\\\"\" + makeEm(this.width) + \"\\\"/>\";\n    }\n  }\n  /**\n   * Converts the math node into a string, similar to innerText.\n   */\n\n\n  toText() {\n    if (this.character) {\n      return this.character;\n    } else {\n      return \" \";\n    }\n  }\n\n}\n\nvar mathMLTree = {\n  MathNode,\n  TextNode,\n  SpaceNode,\n  newDocumentFragment\n};\n\n/**\n * This file converts a parse tree into a corresponding MathML tree. The main\n * entry point is the `buildMathML` function, which takes a parse tree from the\n * parser.\n */\n\n/**\n * Takes a symbol and converts it into a MathML text node after performing\n * optional replacement from symbols.js.\n */\nvar makeText = function makeText(text, mode, options) {\n  if (symbols[mode][text] && symbols[mode][text].replace && text.charCodeAt(0) !== 0xD835 && !(ligatures.hasOwnProperty(text) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === \"tt\" || options.font && options.font.slice(4, 6) === \"tt\"))) {\n    text = symbols[mode][text].replace;\n  }\n\n  return new mathMLTree.TextNode(text);\n};\n/**\n * Wrap the given array of nodes in an <mrow> node if needed, i.e.,\n * unless the array has length 1.  Always returns a single node.\n */\n\nvar makeRow = function makeRow(body) {\n  if (body.length === 1) {\n    return body[0];\n  } else {\n    return new mathMLTree.MathNode(\"mrow\", body);\n  }\n};\n/**\n * Returns the math variant as a string or null if none is required.\n */\n\nvar getVariant = function getVariant(group, options) {\n  // Handle \\text... font specifiers as best we can.\n  // MathML has a limited list of allowable mathvariant specifiers; see\n  // https://www.w3.org/TR/MathML3/chapter3.html#presm.commatt\n  if (options.fontFamily === \"texttt\") {\n    return \"monospace\";\n  } else if (options.fontFamily === \"textsf\") {\n    if (options.fontShape === \"textit\" && options.fontWeight === \"textbf\") {\n      return \"sans-serif-bold-italic\";\n    } else if (options.fontShape === \"textit\") {\n      return \"sans-serif-italic\";\n    } else if (options.fontWeight === \"textbf\") {\n      return \"bold-sans-serif\";\n    } else {\n      return \"sans-serif\";\n    }\n  } else if (options.fontShape === \"textit\" && options.fontWeight === \"textbf\") {\n    return \"bold-italic\";\n  } else if (options.fontShape === \"textit\") {\n    return \"italic\";\n  } else if (options.fontWeight === \"textbf\") {\n    return \"bold\";\n  }\n\n  var font = options.font;\n\n  if (!font || font === \"mathnormal\") {\n    return null;\n  }\n\n  var mode = group.mode;\n\n  if (font === \"mathit\") {\n    return \"italic\";\n  } else if (font === \"boldsymbol\") {\n    return group.type === \"textord\" ? \"bold\" : \"bold-italic\";\n  } else if (font === \"mathbf\") {\n    return \"bold\";\n  } else if (font === \"mathbb\") {\n    return \"double-struck\";\n  } else if (font === \"mathsfit\") {\n    return \"sans-serif-italic\";\n  } else if (font === \"mathfrak\") {\n    return \"fraktur\";\n  } else if (font === \"mathscr\" || font === \"mathcal\") {\n    // MathML makes no distinction between script and calligraphic\n    return \"script\";\n  } else if (font === \"mathsf\") {\n    return \"sans-serif\";\n  } else if (font === \"mathtt\") {\n    return \"monospace\";\n  }\n\n  var text = group.text;\n\n  if ([\"\\\\imath\", \"\\\\jmath\"].includes(text)) {\n    return null;\n  }\n\n  if (symbols[mode][text] && symbols[mode][text].replace) {\n    text = symbols[mode][text].replace;\n  }\n\n  var fontName = buildCommon.fontMap[font].fontName;\n\n  if (getCharacterMetrics(text, fontName, mode)) {\n    return buildCommon.fontMap[font].variant;\n  }\n\n  return null;\n};\n/**\n * Check for <mi>.</mi> which is how a dot renders in MathML,\n * or <mo separator=\"true\" lspace=\"0em\" rspace=\"0em\">,</mo>\n * which is how a braced comma {,} renders in MathML\n */\n\nfunction isNumberPunctuation(group) {\n  if (!group) {\n    return false;\n  }\n\n  if (group.type === 'mi' && group.children.length === 1) {\n    var child = group.children[0];\n    return child instanceof TextNode && child.text === '.';\n  } else if (group.type === 'mo' && group.children.length === 1 && group.getAttribute('separator') === 'true' && group.getAttribute('lspace') === '0em' && group.getAttribute('rspace') === '0em') {\n    var _child = group.children[0];\n    return _child instanceof TextNode && _child.text === ',';\n  } else {\n    return false;\n  }\n}\n/**\n * Takes a list of nodes, builds them, and returns a list of the generated\n * MathML nodes.  Also combine consecutive <mtext> outputs into a single\n * <mtext> tag.\n */\n\n\nvar buildExpression = function buildExpression(expression, options, isOrdgroup) {\n  if (expression.length === 1) {\n    var group = buildGroup(expression[0], options);\n\n    if (isOrdgroup && group instanceof MathNode && group.type === \"mo\") {\n      // When TeX writers want to suppress spacing on an operator,\n      // they often put the operator by itself inside braces.\n      group.setAttribute(\"lspace\", \"0em\");\n      group.setAttribute(\"rspace\", \"0em\");\n    }\n\n    return [group];\n  }\n\n  var groups = [];\n  var lastGroup;\n\n  for (var i = 0; i < expression.length; i++) {\n    var _group = buildGroup(expression[i], options);\n\n    if (_group instanceof MathNode && lastGroup instanceof MathNode) {\n      // Concatenate adjacent <mtext>s\n      if (_group.type === 'mtext' && lastGroup.type === 'mtext' && _group.getAttribute('mathvariant') === lastGroup.getAttribute('mathvariant')) {\n        lastGroup.children.push(..._group.children);\n        continue; // Concatenate adjacent <mn>s\n      } else if (_group.type === 'mn' && lastGroup.type === 'mn') {\n        lastGroup.children.push(..._group.children);\n        continue; // Concatenate <mn>...</mn> followed by <mi>.</mi>\n      } else if (isNumberPunctuation(_group) && lastGroup.type === 'mn') {\n        lastGroup.children.push(..._group.children);\n        continue; // Concatenate <mi>.</mi> followed by <mn>...</mn>\n      } else if (_group.type === 'mn' && isNumberPunctuation(lastGroup)) {\n        _group.children = [...lastGroup.children, ..._group.children];\n        groups.pop(); // Put preceding <mn>...</mn> or <mi>.</mi> inside base of\n        // <msup><mn>...base...</mn>...exponent...</msup> (or <msub>)\n      } else if ((_group.type === 'msup' || _group.type === 'msub') && _group.children.length >= 1 && (lastGroup.type === 'mn' || isNumberPunctuation(lastGroup))) {\n        var base = _group.children[0];\n\n        if (base instanceof MathNode && base.type === 'mn') {\n          base.children = [...lastGroup.children, ...base.children];\n          groups.pop();\n        } // \\not\n\n      } else if (lastGroup.type === 'mi' && lastGroup.children.length === 1) {\n        var lastChild = lastGroup.children[0];\n\n        if (lastChild instanceof TextNode && lastChild.text === '\\u0338' && (_group.type === 'mo' || _group.type === 'mi' || _group.type === 'mn')) {\n          var child = _group.children[0];\n\n          if (child instanceof TextNode && child.text.length > 0) {\n            // Overlay with combining character long solidus\n            child.text = child.text.slice(0, 1) + \"\\u0338\" + child.text.slice(1);\n            groups.pop();\n          }\n        }\n      }\n    }\n\n    groups.push(_group);\n    lastGroup = _group;\n  }\n\n  return groups;\n};\n/**\n * Equivalent to buildExpression, but wraps the elements in an <mrow>\n * if there's more than one.  Returns a single node instead of an array.\n */\n\nvar buildExpressionRow = function buildExpressionRow(expression, options, isOrdgroup) {\n  return makeRow(buildExpression(expression, options, isOrdgroup));\n};\n/**\n * Takes a group from the parser and calls the appropriate groupBuilders function\n * on it to produce a MathML node.\n */\n\nvar buildGroup = function buildGroup(group, options) {\n  if (!group) {\n    return new mathMLTree.MathNode(\"mrow\");\n  }\n\n  if (_mathmlGroupBuilders[group.type]) {\n    // Call the groupBuilders function\n    // $FlowFixMe\n    var result = _mathmlGroupBuilders[group.type](group, options); // $FlowFixMe\n\n    return result;\n  } else {\n    throw new ParseError(\"Got group of unknown type: '\" + group.type + \"'\");\n  }\n};\n/**\n * Takes a full parse tree and settings and builds a MathML representation of\n * it. In particular, we put the elements from building the parse tree into a\n * <semantics> tag so we can also include that TeX source as an annotation.\n *\n * Note that we actually return a domTree element with a `<math>` inside it so\n * we can do appropriate styling.\n */\n\nfunction buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {\n  var expression = buildExpression(tree, options); // TODO: Make a pass thru the MathML similar to buildHTML.traverseNonSpaceNodes\n  // and add spacing nodes. This is necessary only adjacent to math operators\n  // like \\sin or \\lim or to subsup elements that contain math operators.\n  // MathML takes care of the other spacing issues.\n  // Wrap up the expression in an mrow so it is presented in the semantics\n  // tag correctly, unless it's a single <mrow> or <mtable>.\n\n  var wrapper;\n\n  if (expression.length === 1 && expression[0] instanceof MathNode && [\"mrow\", \"mtable\"].includes(expression[0].type)) {\n    wrapper = expression[0];\n  } else {\n    wrapper = new mathMLTree.MathNode(\"mrow\", expression);\n  } // Build a TeX annotation of the source\n\n\n  var annotation = new mathMLTree.MathNode(\"annotation\", [new mathMLTree.TextNode(texExpression)]);\n  annotation.setAttribute(\"encoding\", \"application/x-tex\");\n  var semantics = new mathMLTree.MathNode(\"semantics\", [wrapper, annotation]);\n  var math = new mathMLTree.MathNode(\"math\", [semantics]);\n  math.setAttribute(\"xmlns\", \"http://www.w3.org/1998/Math/MathML\");\n\n  if (isDisplayMode) {\n    math.setAttribute(\"display\", \"block\");\n  } // You can't style <math> nodes, so we wrap the node in a span.\n  // NOTE: The span class is not typed to have <math> nodes as children, and\n  // we don't want to make the children type more generic since the children\n  // of span are expected to have more fields in `buildHtml` contexts.\n\n\n  var wrapperClass = forMathmlOnly ? \"katex\" : \"katex-mathml\"; // $FlowFixMe\n\n  return buildCommon.makeSpan([wrapperClass], [math]);\n}\n\nvar optionsFromSettings = function optionsFromSettings(settings) {\n  return new Options({\n    style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,\n    maxSize: settings.maxSize,\n    minRuleThickness: settings.minRuleThickness\n  });\n};\n\nvar displayWrap = function displayWrap(node, settings) {\n  if (settings.displayMode) {\n    var classes = [\"katex-display\"];\n\n    if (settings.leqno) {\n      classes.push(\"leqno\");\n    }\n\n    if (settings.fleqn) {\n      classes.push(\"fleqn\");\n    }\n\n    node = buildCommon.makeSpan(classes, [node]);\n  }\n\n  return node;\n};\n\nvar buildTree = function buildTree(tree, expression, settings) {\n  var options = optionsFromSettings(settings);\n  var katexNode;\n\n  if (settings.output === \"mathml\") {\n    return buildMathML(tree, expression, options, settings.displayMode, true);\n  } else if (settings.output === \"html\") {\n    var htmlNode = buildHTML(tree, options);\n    katexNode = buildCommon.makeSpan([\"katex\"], [htmlNode]);\n  } else {\n    var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);\n\n    var _htmlNode = buildHTML(tree, options);\n\n    katexNode = buildCommon.makeSpan([\"katex\"], [mathMLNode, _htmlNode]);\n  }\n\n  return displayWrap(katexNode, settings);\n};\nvar buildHTMLTree = function buildHTMLTree(tree, expression, settings) {\n  var options = optionsFromSettings(settings);\n  var htmlNode = buildHTML(tree, options);\n  var katexNode = buildCommon.makeSpan([\"katex\"], [htmlNode]);\n  return displayWrap(katexNode, settings);\n};\n\n/**\n * This file provides support to buildMathML.js and buildHTML.js\n * for stretchy wide elements rendered from SVG files\n * and other CSS trickery.\n */\nvar stretchyCodePoint = {\n  widehat: \"^\",\n  widecheck: \"\",\n  widetilde: \"~\",\n  utilde: \"~\",\n  overleftarrow: \"\\u2190\",\n  underleftarrow: \"\\u2190\",\n  xleftarrow: \"\\u2190\",\n  overrightarrow: \"\\u2192\",\n  underrightarrow: \"\\u2192\",\n  xrightarrow: \"\\u2192\",\n  underbrace: \"\\u23df\",\n  overbrace: \"\\u23de\",\n  overgroup: \"\\u23e0\",\n  undergroup: \"\\u23e1\",\n  overleftrightarrow: \"\\u2194\",\n  underleftrightarrow: \"\\u2194\",\n  xleftrightarrow: \"\\u2194\",\n  Overrightarrow: \"\\u21d2\",\n  xRightarrow: \"\\u21d2\",\n  overleftharpoon: \"\\u21bc\",\n  xleftharpoonup: \"\\u21bc\",\n  overrightharpoon: \"\\u21c0\",\n  xrightharpoonup: \"\\u21c0\",\n  xLeftarrow: \"\\u21d0\",\n  xLeftrightarrow: \"\\u21d4\",\n  xhookleftarrow: \"\\u21a9\",\n  xhookrightarrow: \"\\u21aa\",\n  xmapsto: \"\\u21a6\",\n  xrightharpoondown: \"\\u21c1\",\n  xleftharpoondown: \"\\u21bd\",\n  xrightleftharpoons: \"\\u21cc\",\n  xleftrightharpoons: \"\\u21cb\",\n  xtwoheadleftarrow: \"\\u219e\",\n  xtwoheadrightarrow: \"\\u21a0\",\n  xlongequal: \"=\",\n  xtofrom: \"\\u21c4\",\n  xrightleftarrows: \"\\u21c4\",\n  xrightequilibrium: \"\\u21cc\",\n  // Not a perfect match.\n  xleftequilibrium: \"\\u21cb\",\n  // None better available.\n  \"\\\\cdrightarrow\": \"\\u2192\",\n  \"\\\\cdleftarrow\": \"\\u2190\",\n  \"\\\\cdlongequal\": \"=\"\n};\n\nvar mathMLnode = function mathMLnode(label) {\n  var node = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\\\/, '')])]);\n  node.setAttribute(\"stretchy\", \"true\");\n  return node;\n}; // Many of the KaTeX SVG images have been adapted from glyphs in KaTeX fonts.\n// Copyright (c) 2009-2010, Design Science, Inc. (<www.mathjax.org>)\n// Copyright (c) 2014-2017 Khan Academy (<www.khanacademy.org>)\n// Licensed under the SIL Open Font License, Version 1.1.\n// See \\nhttp://scripts.sil.org/OFL\n// Very Long SVGs\n//    Many of the KaTeX stretchy wide elements use a long SVG image and an\n//    overflow: hidden tactic to achieve a stretchy image while avoiding\n//    distortion of arrowheads or brace corners.\n//    The SVG typically contains a very long (400 em) arrow.\n//    The SVG is in a container span that has overflow: hidden, so the span\n//    acts like a window that exposes only part of the  SVG.\n//    The SVG always has a longer, thinner aspect ratio than the container span.\n//    After the SVG fills 100% of the height of the container span,\n//    there is a long arrow shaft left over. That left-over shaft is not shown.\n//    Instead, it is sliced off because the span's CSS has overflow: hidden.\n//    Thus, the reader sees an arrow that matches the subject matter width\n//    without distortion.\n//    Some functions, such as \\cancel, need to vary their aspect ratio. These\n//    functions do not get the overflow SVG treatment.\n// Second Brush Stroke\n//    Low resolution monitors struggle to display images in fine detail.\n//    So browsers apply anti-aliasing. A long straight arrow shaft therefore\n//    will sometimes appear as if it has a blurred edge.\n//    To mitigate this, these SVG files contain a second \"brush-stroke\" on the\n//    arrow shafts. That is, a second long thin rectangular SVG path has been\n//    written directly on top of each arrow shaft. This reinforcement causes\n//    some of the screen pixels to display as black instead of the anti-aliased\n//    gray pixel that a  single path would generate. So we get arrow shafts\n//    whose edges appear to be sharper.\n// In the katexImagesData object just below, the dimensions all\n// correspond to path geometry inside the relevant SVG.\n// For example, \\overrightarrow uses the same arrowhead as glyph U+2192\n// from the KaTeX Main font. The scaling factor is 1000.\n// That is, inside the font, that arrowhead is 522 units tall, which\n// corresponds to 0.522 em inside the document.\n\n\nvar katexImagesData = {\n  //   path(s), minWidth, height, align\n  overrightarrow: [[\"rightarrow\"], 0.888, 522, \"xMaxYMin\"],\n  overleftarrow: [[\"leftarrow\"], 0.888, 522, \"xMinYMin\"],\n  underrightarrow: [[\"rightarrow\"], 0.888, 522, \"xMaxYMin\"],\n  underleftarrow: [[\"leftarrow\"], 0.888, 522, \"xMinYMin\"],\n  xrightarrow: [[\"rightarrow\"], 1.469, 522, \"xMaxYMin\"],\n  \"\\\\cdrightarrow\": [[\"rightarrow\"], 3.0, 522, \"xMaxYMin\"],\n  // CD minwwidth2.5pc\n  xleftarrow: [[\"leftarrow\"], 1.469, 522, \"xMinYMin\"],\n  \"\\\\cdleftarrow\": [[\"leftarrow\"], 3.0, 522, \"xMinYMin\"],\n  Overrightarrow: [[\"doublerightarrow\"], 0.888, 560, \"xMaxYMin\"],\n  xRightarrow: [[\"doublerightarrow\"], 1.526, 560, \"xMaxYMin\"],\n  xLeftarrow: [[\"doubleleftarrow\"], 1.526, 560, \"xMinYMin\"],\n  overleftharpoon: [[\"leftharpoon\"], 0.888, 522, \"xMinYMin\"],\n  xleftharpoonup: [[\"leftharpoon\"], 0.888, 522, \"xMinYMin\"],\n  xleftharpoondown: [[\"leftharpoondown\"], 0.888, 522, \"xMinYMin\"],\n  overrightharpoon: [[\"rightharpoon\"], 0.888, 522, \"xMaxYMin\"],\n  xrightharpoonup: [[\"rightharpoon\"], 0.888, 522, \"xMaxYMin\"],\n  xrightharpoondown: [[\"rightharpoondown\"], 0.888, 522, \"xMaxYMin\"],\n  xlongequal: [[\"longequal\"], 0.888, 334, \"xMinYMin\"],\n  \"\\\\cdlongequal\": [[\"longequal\"], 3.0, 334, \"xMinYMin\"],\n  xtwoheadleftarrow: [[\"twoheadleftarrow\"], 0.888, 334, \"xMinYMin\"],\n  xtwoheadrightarrow: [[\"twoheadrightarrow\"], 0.888, 334, \"xMaxYMin\"],\n  overleftrightarrow: [[\"leftarrow\", \"rightarrow\"], 0.888, 522],\n  overbrace: [[\"leftbrace\", \"midbrace\", \"rightbrace\"], 1.6, 548],\n  underbrace: [[\"leftbraceunder\", \"midbraceunder\", \"rightbraceunder\"], 1.6, 548],\n  underleftrightarrow: [[\"leftarrow\", \"rightarrow\"], 0.888, 522],\n  xleftrightarrow: [[\"leftarrow\", \"rightarrow\"], 1.75, 522],\n  xLeftrightarrow: [[\"doubleleftarrow\", \"doublerightarrow\"], 1.75, 560],\n  xrightleftharpoons: [[\"leftharpoondownplus\", \"rightharpoonplus\"], 1.75, 716],\n  xleftrightharpoons: [[\"leftharpoonplus\", \"rightharpoondownplus\"], 1.75, 716],\n  xhookleftarrow: [[\"leftarrow\", \"righthook\"], 1.08, 522],\n  xhookrightarrow: [[\"lefthook\", \"rightarrow\"], 1.08, 522],\n  overlinesegment: [[\"leftlinesegment\", \"rightlinesegment\"], 0.888, 522],\n  underlinesegment: [[\"leftlinesegment\", \"rightlinesegment\"], 0.888, 522],\n  overgroup: [[\"leftgroup\", \"rightgroup\"], 0.888, 342],\n  undergroup: [[\"leftgroupunder\", \"rightgroupunder\"], 0.888, 342],\n  xmapsto: [[\"leftmapsto\", \"rightarrow\"], 1.5, 522],\n  xtofrom: [[\"leftToFrom\", \"rightToFrom\"], 1.75, 528],\n  // The next three arrows are from the mhchem package.\n  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the\n  // document as \\xrightarrow or \\xrightleftharpoons. Those have\n  // min-length = 1.75em, so we set min-length on these next three to match.\n  xrightleftarrows: [[\"baraboveleftarrow\", \"rightarrowabovebar\"], 1.75, 901],\n  xrightequilibrium: [[\"baraboveshortleftharpoon\", \"rightharpoonaboveshortbar\"], 1.75, 716],\n  xleftequilibrium: [[\"shortbaraboveleftharpoon\", \"shortrightharpoonabovebar\"], 1.75, 716]\n};\n\nvar groupLength = function groupLength(arg) {\n  if (arg.type === \"ordgroup\") {\n    return arg.body.length;\n  } else {\n    return 1;\n  }\n};\n\nvar svgSpan = function svgSpan(group, options) {\n  // Create a span with inline SVG for the element.\n  function buildSvgSpan_() {\n    var viewBoxWidth = 400000; // default\n\n    var label = group.label.slice(1);\n\n    if ([\"widehat\", \"widecheck\", \"widetilde\", \"utilde\"].includes(label)) {\n      // Each type in the `if` statement corresponds to one of the ParseNode\n      // types below. This narrowing is required to access `grp.base`.\n      // $FlowFixMe\n      var grp = group; // There are four SVG images available for each function.\n      // Choose a taller image when there are more characters.\n\n      var numChars = groupLength(grp.base);\n      var viewBoxHeight;\n      var pathName;\n\n      var _height;\n\n      if (numChars > 5) {\n        if (label === \"widehat\" || label === \"widecheck\") {\n          viewBoxHeight = 420;\n          viewBoxWidth = 2364;\n          _height = 0.42;\n          pathName = label + \"4\";\n        } else {\n          viewBoxHeight = 312;\n          viewBoxWidth = 2340;\n          _height = 0.34;\n          pathName = \"tilde4\";\n        }\n      } else {\n        var imgIndex = [1, 1, 2, 2, 3, 3][numChars];\n\n        if (label === \"widehat\" || label === \"widecheck\") {\n          viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];\n          viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];\n          _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];\n          pathName = label + imgIndex;\n        } else {\n          viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];\n          viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];\n          _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];\n          pathName = \"tilde\" + imgIndex;\n        }\n      }\n\n      var path = new PathNode(pathName);\n      var svgNode = new SvgNode([path], {\n        \"width\": \"100%\",\n        \"height\": makeEm(_height),\n        \"viewBox\": \"0 0 \" + viewBoxWidth + \" \" + viewBoxHeight,\n        \"preserveAspectRatio\": \"none\"\n      });\n      return {\n        span: buildCommon.makeSvgSpan([], [svgNode], options),\n        minWidth: 0,\n        height: _height\n      };\n    } else {\n      var spans = [];\n      var data = katexImagesData[label];\n      var [paths, _minWidth, _viewBoxHeight] = data;\n\n      var _height2 = _viewBoxHeight / 1000;\n\n      var numSvgChildren = paths.length;\n      var widthClasses;\n      var aligns;\n\n      if (numSvgChildren === 1) {\n        // $FlowFixMe: All these cases must be of the 4-tuple type.\n        var align1 = data[3];\n        widthClasses = [\"hide-tail\"];\n        aligns = [align1];\n      } else if (numSvgChildren === 2) {\n        widthClasses = [\"halfarrow-left\", \"halfarrow-right\"];\n        aligns = [\"xMinYMin\", \"xMaxYMin\"];\n      } else if (numSvgChildren === 3) {\n        widthClasses = [\"brace-left\", \"brace-center\", \"brace-right\"];\n        aligns = [\"xMinYMin\", \"xMidYMin\", \"xMaxYMin\"];\n      } else {\n        throw new Error(\"Correct katexImagesData or update code here to support\\n                    \" + numSvgChildren + \" children.\");\n      }\n\n      for (var i = 0; i < numSvgChildren; i++) {\n        var _path = new PathNode(paths[i]);\n\n        var _svgNode = new SvgNode([_path], {\n          \"width\": \"400em\",\n          \"height\": makeEm(_height2),\n          \"viewBox\": \"0 0 \" + viewBoxWidth + \" \" + _viewBoxHeight,\n          \"preserveAspectRatio\": aligns[i] + \" slice\"\n        });\n\n        var _span = buildCommon.makeSvgSpan([widthClasses[i]], [_svgNode], options);\n\n        if (numSvgChildren === 1) {\n          return {\n            span: _span,\n            minWidth: _minWidth,\n            height: _height2\n          };\n        } else {\n          _span.style.height = makeEm(_height2);\n          spans.push(_span);\n        }\n      }\n\n      return {\n        span: buildCommon.makeSpan([\"stretchy\"], spans, options),\n        minWidth: _minWidth,\n        height: _height2\n      };\n    }\n  } // buildSvgSpan_()\n\n\n  var {\n    span,\n    minWidth,\n    height\n  } = buildSvgSpan_(); // Note that we are returning span.depth = 0.\n  // Any adjustments relative to the baseline must be done in buildHTML.\n\n  span.height = height;\n  span.style.height = makeEm(height);\n\n  if (minWidth > 0) {\n    span.style.minWidth = makeEm(minWidth);\n  }\n\n  return span;\n};\n\nvar encloseSpan = function encloseSpan(inner, label, topPad, bottomPad, options) {\n  // Return an image span for \\cancel, \\bcancel, \\xcancel, \\fbox, or \\angl\n  var img;\n  var totalHeight = inner.height + inner.depth + topPad + bottomPad;\n\n  if (/fbox|color|angl/.test(label)) {\n    img = buildCommon.makeSpan([\"stretchy\", label], [], options);\n\n    if (label === \"fbox\") {\n      var color = options.color && options.getColor();\n\n      if (color) {\n        img.style.borderColor = color;\n      }\n    }\n  } else {\n    // \\cancel, \\bcancel, or \\xcancel\n    // Since \\cancel's SVG is inline and it omits the viewBox attribute,\n    // its stroke-width will not vary with span area.\n    var lines = [];\n\n    if (/^[bx]cancel$/.test(label)) {\n      lines.push(new LineNode({\n        \"x1\": \"0\",\n        \"y1\": \"0\",\n        \"x2\": \"100%\",\n        \"y2\": \"100%\",\n        \"stroke-width\": \"0.046em\"\n      }));\n    }\n\n    if (/^x?cancel$/.test(label)) {\n      lines.push(new LineNode({\n        \"x1\": \"0\",\n        \"y1\": \"100%\",\n        \"x2\": \"100%\",\n        \"y2\": \"0\",\n        \"stroke-width\": \"0.046em\"\n      }));\n    }\n\n    var svgNode = new SvgNode(lines, {\n      \"width\": \"100%\",\n      \"height\": makeEm(totalHeight)\n    });\n    img = buildCommon.makeSvgSpan([], [svgNode], options);\n  }\n\n  img.height = totalHeight;\n  img.style.height = makeEm(totalHeight);\n  return img;\n};\n\nvar stretchy = {\n  encloseSpan,\n  mathMLnode,\n  svgSpan\n};\n\n/**\n * Asserts that the node is of the given type and returns it with stricter\n * typing. Throws if the node's type does not match.\n */\nfunction assertNodeType(node, type) {\n  if (!node || node.type !== type) {\n    throw new Error(\"Expected node of type \" + type + \", but got \" + (node ? \"node of type \" + node.type : String(node)));\n  } // $FlowFixMe, >=0.125\n\n\n  return node;\n}\n/**\n * Returns the node more strictly typed iff it is of the given type. Otherwise,\n * returns null.\n */\n\nfunction assertSymbolNodeType(node) {\n  var typedNode = checkSymbolNodeType(node);\n\n  if (!typedNode) {\n    throw new Error(\"Expected node of symbol group type, but got \" + (node ? \"node of type \" + node.type : String(node)));\n  }\n\n  return typedNode;\n}\n/**\n * Returns the node more strictly typed iff it is of the given type. Otherwise,\n * returns null.\n */\n\nfunction checkSymbolNodeType(node) {\n  if (node && (node.type === \"atom\" || NON_ATOMS.hasOwnProperty(node.type))) {\n    // $FlowFixMe\n    return node;\n  }\n\n  return null;\n}\n\n// NOTE: Unlike most `htmlBuilder`s, this one handles not only \"accent\", but\n// also \"supsub\" since an accent can affect super/subscripting.\nvar htmlBuilder$a = (grp, options) => {\n  // Accents are handled in the TeXbook pg. 443, rule 12.\n  var base;\n  var group;\n  var supSubGroup;\n\n  if (grp && grp.type === \"supsub\") {\n    // If our base is a character box, and we have superscripts and\n    // subscripts, the supsub will defer to us. In particular, we want\n    // to attach the superscripts and subscripts to the inner body (so\n    // that the position of the superscripts and subscripts won't be\n    // affected by the height of the accent). We accomplish this by\n    // sticking the base of the accent into the base of the supsub, and\n    // rendering that, while keeping track of where the accent is.\n    // The real accent group is the base of the supsub group\n    group = assertNodeType(grp.base, \"accent\"); // The character box is the base of the accent group\n\n    base = group.base; // Stick the character box into the base of the supsub group\n\n    grp.base = base; // Rerender the supsub group with its new base, and store that\n    // result.\n\n    supSubGroup = assertSpan(buildGroup$1(grp, options)); // reset original base\n\n    grp.base = group;\n  } else {\n    group = assertNodeType(grp, \"accent\");\n    base = group.base;\n  } // Build the base group\n\n\n  var body = buildGroup$1(base, options.havingCrampedStyle()); // Does the accent need to shift for the skew of a character?\n\n  var mustShift = group.isShifty && utils.isCharacterBox(base); // Calculate the skew of the accent. This is based on the line \"If the\n  // nucleus is not a single character, let s = 0; otherwise set s to the\n  // kern amount for the nucleus followed by the \\skewchar of its font.\"\n  // Note that our skew metrics are just the kern between each character\n  // and the skewchar.\n\n  var skew = 0;\n\n  if (mustShift) {\n    // If the base is a character box, then we want the skew of the\n    // innermost character. To do that, we find the innermost character:\n    var baseChar = utils.getBaseElem(base); // Then, we render its group to get the symbol inside it\n\n    var baseGroup = buildGroup$1(baseChar, options.havingCrampedStyle()); // Finally, we pull the skew off of the symbol.\n\n    skew = assertSymbolDomNode(baseGroup).skew; // Note that we now throw away baseGroup, because the layers we\n    // removed with getBaseElem might contain things like \\color which\n    // we can't get rid of.\n    // TODO(emily): Find a better way to get the skew\n  }\n\n  var accentBelow = group.label === \"\\\\c\"; // calculate the amount of space between the body and the accent\n\n  var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight); // Build the accent\n\n  var accentBody;\n\n  if (!group.isStretchy) {\n    var accent;\n    var width;\n\n    if (group.label === \"\\\\vec\") {\n      // Before version 0.9, \\vec used the combining font glyph U+20D7.\n      // But browsers, especially Safari, are not consistent in how they\n      // render combining characters when not preceded by a character.\n      // So now we use an SVG.\n      // If Safari reforms, we should consider reverting to the glyph.\n      accent = buildCommon.staticSvg(\"vec\", options);\n      width = buildCommon.svgData.vec[1];\n    } else {\n      accent = buildCommon.makeOrd({\n        mode: group.mode,\n        text: group.label\n      }, options, \"textord\");\n      accent = assertSymbolDomNode(accent); // Remove the italic correction of the accent, because it only serves to\n      // shift the accent over to a place we don't want.\n\n      accent.italic = 0;\n      width = accent.width;\n\n      if (accentBelow) {\n        clearance += accent.depth;\n      }\n    }\n\n    accentBody = buildCommon.makeSpan([\"accent-body\"], [accent]); // \"Full\" accents expand the width of the resulting symbol to be\n    // at least the width of the accent, and overlap directly onto the\n    // character without any vertical offset.\n\n    var accentFull = group.label === \"\\\\textcircled\";\n\n    if (accentFull) {\n      accentBody.classes.push('accent-full');\n      clearance = body.height;\n    } // Shift the accent over by the skew.\n\n\n    var left = skew; // CSS defines `.katex .accent .accent-body:not(.accent-full) { width: 0 }`\n    // so that the accent doesn't contribute to the bounding box.\n    // We need to shift the character by its width (effectively half\n    // its width) to compensate.\n\n    if (!accentFull) {\n      left -= width / 2;\n    }\n\n    accentBody.style.left = makeEm(left); // \\textcircled uses the \\bigcirc glyph, so it needs some\n    // vertical adjustment to match LaTeX.\n\n    if (group.label === \"\\\\textcircled\") {\n      accentBody.style.top = \".2em\";\n    }\n\n    accentBody = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: body\n      }, {\n        type: \"kern\",\n        size: -clearance\n      }, {\n        type: \"elem\",\n        elem: accentBody\n      }]\n    }, options);\n  } else {\n    accentBody = stretchy.svgSpan(group, options);\n    accentBody = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: body\n      }, {\n        type: \"elem\",\n        elem: accentBody,\n        wrapperClasses: [\"svg-align\"],\n        wrapperStyle: skew > 0 ? {\n          width: \"calc(100% - \" + makeEm(2 * skew) + \")\",\n          marginLeft: makeEm(2 * skew)\n        } : undefined\n      }]\n    }, options);\n  }\n\n  var accentWrap = buildCommon.makeSpan([\"mord\", \"accent\"], [accentBody], options);\n\n  if (supSubGroup) {\n    // Here, we replace the \"base\" child of the supsub with our newly\n    // generated accent.\n    supSubGroup.children[0] = accentWrap; // Since we don't rerun the height calculation after replacing the\n    // accent, we manually recalculate height.\n\n    supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height); // Accents should always be ords, even when their innards are not.\n\n    supSubGroup.classes[0] = \"mord\";\n    return supSubGroup;\n  } else {\n    return accentWrap;\n  }\n};\n\nvar mathmlBuilder$9 = (group, options) => {\n  var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode(\"mo\", [makeText(group.label, group.mode)]);\n  var node = new mathMLTree.MathNode(\"mover\", [buildGroup(group.base, options), accentNode]);\n  node.setAttribute(\"accent\", \"true\");\n  return node;\n};\n\nvar NON_STRETCHY_ACCENT_REGEX = new RegExp([\"\\\\acute\", \"\\\\grave\", \"\\\\ddot\", \"\\\\tilde\", \"\\\\bar\", \"\\\\breve\", \"\\\\check\", \"\\\\hat\", \"\\\\vec\", \"\\\\dot\", \"\\\\mathring\"].map(accent => \"\\\\\" + accent).join(\"|\")); // Accents\n\ndefineFunction({\n  type: \"accent\",\n  names: [\"\\\\acute\", \"\\\\grave\", \"\\\\ddot\", \"\\\\tilde\", \"\\\\bar\", \"\\\\breve\", \"\\\\check\", \"\\\\hat\", \"\\\\vec\", \"\\\\dot\", \"\\\\mathring\", \"\\\\widecheck\", \"\\\\widehat\", \"\\\\widetilde\", \"\\\\overrightarrow\", \"\\\\overleftarrow\", \"\\\\Overrightarrow\", \"\\\\overleftrightarrow\", \"\\\\overgroup\", \"\\\\overlinesegment\", \"\\\\overleftharpoon\", \"\\\\overrightharpoon\"],\n  props: {\n    numArgs: 1\n  },\n  handler: (context, args) => {\n    var base = normalizeArgument(args[0]);\n    var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);\n    var isShifty = !isStretchy || context.funcName === \"\\\\widehat\" || context.funcName === \"\\\\widetilde\" || context.funcName === \"\\\\widecheck\";\n    return {\n      type: \"accent\",\n      mode: context.parser.mode,\n      label: context.funcName,\n      isStretchy: isStretchy,\n      isShifty: isShifty,\n      base: base\n    };\n  },\n  htmlBuilder: htmlBuilder$a,\n  mathmlBuilder: mathmlBuilder$9\n}); // Text-mode accents\n\ndefineFunction({\n  type: \"accent\",\n  names: [\"\\\\'\", \"\\\\`\", \"\\\\^\", \"\\\\~\", \"\\\\=\", \"\\\\u\", \"\\\\.\", '\\\\\"', \"\\\\c\", \"\\\\r\", \"\\\\H\", \"\\\\v\", \"\\\\textcircled\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true,\n    allowedInMath: true,\n    // unless in strict mode\n    argTypes: [\"primitive\"]\n  },\n  handler: (context, args) => {\n    var base = args[0];\n    var mode = context.parser.mode;\n\n    if (mode === \"math\") {\n      context.parser.settings.reportNonstrict(\"mathVsTextAccents\", \"LaTeX's accent \" + context.funcName + \" works only in text mode\");\n      mode = \"text\";\n    }\n\n    return {\n      type: \"accent\",\n      mode: mode,\n      label: context.funcName,\n      isStretchy: false,\n      isShifty: true,\n      base: base\n    };\n  },\n  htmlBuilder: htmlBuilder$a,\n  mathmlBuilder: mathmlBuilder$9\n});\n\n// Horizontal overlap functions\ndefineFunction({\n  type: \"accentUnder\",\n  names: [\"\\\\underleftarrow\", \"\\\\underrightarrow\", \"\\\\underleftrightarrow\", \"\\\\undergroup\", \"\\\\underlinesegment\", \"\\\\utilde\"],\n  props: {\n    numArgs: 1\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var base = args[0];\n    return {\n      type: \"accentUnder\",\n      mode: parser.mode,\n      label: funcName,\n      base: base\n    };\n  },\n  htmlBuilder: (group, options) => {\n    // Treat under accents much like underlines.\n    var innerGroup = buildGroup$1(group.base, options);\n    var accentBody = stretchy.svgSpan(group, options);\n    var kern = group.label === \"\\\\utilde\" ? 0.12 : 0; // Generate the vlist, with the appropriate kerns\n\n    var vlist = buildCommon.makeVList({\n      positionType: \"top\",\n      positionData: innerGroup.height,\n      children: [{\n        type: \"elem\",\n        elem: accentBody,\n        wrapperClasses: [\"svg-align\"]\n      }, {\n        type: \"kern\",\n        size: kern\n      }, {\n        type: \"elem\",\n        elem: innerGroup\n      }]\n    }, options);\n    return buildCommon.makeSpan([\"mord\", \"accentunder\"], [vlist], options);\n  },\n  mathmlBuilder: (group, options) => {\n    var accentNode = stretchy.mathMLnode(group.label);\n    var node = new mathMLTree.MathNode(\"munder\", [buildGroup(group.base, options), accentNode]);\n    node.setAttribute(\"accentunder\", \"true\");\n    return node;\n  }\n});\n\n// Helper function\nvar paddedNode = group => {\n  var node = new mathMLTree.MathNode(\"mpadded\", group ? [group] : []);\n  node.setAttribute(\"width\", \"+0.6em\");\n  node.setAttribute(\"lspace\", \"0.3em\");\n  return node;\n}; // Stretchy arrows with an optional argument\n\n\ndefineFunction({\n  type: \"xArrow\",\n  names: [\"\\\\xleftarrow\", \"\\\\xrightarrow\", \"\\\\xLeftarrow\", \"\\\\xRightarrow\", \"\\\\xleftrightarrow\", \"\\\\xLeftrightarrow\", \"\\\\xhookleftarrow\", \"\\\\xhookrightarrow\", \"\\\\xmapsto\", \"\\\\xrightharpoondown\", \"\\\\xrightharpoonup\", \"\\\\xleftharpoondown\", \"\\\\xleftharpoonup\", \"\\\\xrightleftharpoons\", \"\\\\xleftrightharpoons\", \"\\\\xlongequal\", \"\\\\xtwoheadrightarrow\", \"\\\\xtwoheadleftarrow\", \"\\\\xtofrom\", // The next 3 functions are here to support the mhchem extension.\n  // Direct use of these functions is discouraged and may break someday.\n  \"\\\\xrightleftarrows\", \"\\\\xrightequilibrium\", \"\\\\xleftequilibrium\", // The next 3 functions are here only to support the {CD} environment.\n  \"\\\\\\\\cdrightarrow\", \"\\\\\\\\cdleftarrow\", \"\\\\\\\\cdlongequal\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1\n  },\n\n  handler(_ref, args, optArgs) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    return {\n      type: \"xArrow\",\n      mode: parser.mode,\n      label: funcName,\n      body: args[0],\n      below: optArgs[0]\n    };\n  },\n\n  // Flow is unable to correctly infer the type of `group`, even though it's\n  // unambiguously determined from the passed-in `type` above.\n  htmlBuilder(group, options) {\n    var style = options.style; // Build the argument groups in the appropriate style.\n    // Ref: amsmath.dtx:   \\hbox{$\\scriptstyle\\mkern#3mu{#6}\\mkern#4mu$}%\n    // Some groups can return document fragments.  Handle those by wrapping\n    // them in a span.\n\n    var newOptions = options.havingStyle(style.sup());\n    var upperGroup = buildCommon.wrapFragment(buildGroup$1(group.body, newOptions, options), options);\n    var arrowPrefix = group.label.slice(0, 2) === \"\\\\x\" ? \"x\" : \"cd\";\n    upperGroup.classes.push(arrowPrefix + \"-arrow-pad\");\n    var lowerGroup;\n\n    if (group.below) {\n      // Build the lower group\n      newOptions = options.havingStyle(style.sub());\n      lowerGroup = buildCommon.wrapFragment(buildGroup$1(group.below, newOptions, options), options);\n      lowerGroup.classes.push(arrowPrefix + \"-arrow-pad\");\n    }\n\n    var arrowBody = stretchy.svgSpan(group, options); // Re shift: Note that stretchy.svgSpan returned arrowBody.depth = 0.\n    // The point we want on the math axis is at 0.5 * arrowBody.height.\n\n    var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height; // 2 mu kern. Ref: amsmath.dtx: #7\\if0#2\\else\\mkern#2mu\\fi\n\n    var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111; // 0.111 em = 2 mu\n\n    if (upperGroup.depth > 0.25 || group.label === \"\\\\xleftequilibrium\") {\n      upperShift -= upperGroup.depth; // shift up if depth encroaches\n    } // Generate the vlist\n\n\n    var vlist;\n\n    if (lowerGroup) {\n      var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;\n      vlist = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: [{\n          type: \"elem\",\n          elem: upperGroup,\n          shift: upperShift\n        }, {\n          type: \"elem\",\n          elem: arrowBody,\n          shift: arrowShift\n        }, {\n          type: \"elem\",\n          elem: lowerGroup,\n          shift: lowerShift\n        }]\n      }, options);\n    } else {\n      vlist = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: [{\n          type: \"elem\",\n          elem: upperGroup,\n          shift: upperShift\n        }, {\n          type: \"elem\",\n          elem: arrowBody,\n          shift: arrowShift\n        }]\n      }, options);\n    } // $FlowFixMe: Replace this with passing \"svg-align\" into makeVList.\n\n\n    vlist.children[0].children[0].children[1].classes.push(\"svg-align\");\n    return buildCommon.makeSpan([\"mrel\", \"x-arrow\"], [vlist], options);\n  },\n\n  mathmlBuilder(group, options) {\n    var arrowNode = stretchy.mathMLnode(group.label);\n    arrowNode.setAttribute(\"minsize\", group.label.charAt(0) === \"x\" ? \"1.75em\" : \"3.0em\");\n    var node;\n\n    if (group.body) {\n      var upperNode = paddedNode(buildGroup(group.body, options));\n\n      if (group.below) {\n        var lowerNode = paddedNode(buildGroup(group.below, options));\n        node = new mathMLTree.MathNode(\"munderover\", [arrowNode, lowerNode, upperNode]);\n      } else {\n        node = new mathMLTree.MathNode(\"mover\", [arrowNode, upperNode]);\n      }\n    } else if (group.below) {\n      var _lowerNode = paddedNode(buildGroup(group.below, options));\n\n      node = new mathMLTree.MathNode(\"munder\", [arrowNode, _lowerNode]);\n    } else {\n      // This should never happen.\n      // Parser.js throws an error if there is no argument.\n      node = paddedNode();\n      node = new mathMLTree.MathNode(\"mover\", [arrowNode, node]);\n    }\n\n    return node;\n  }\n\n});\n\nvar makeSpan = buildCommon.makeSpan;\n\nfunction htmlBuilder$9(group, options) {\n  var elements = buildExpression$1(group.body, options, true);\n  return makeSpan([group.mclass], elements, options);\n}\n\nfunction mathmlBuilder$8(group, options) {\n  var node;\n  var inner = buildExpression(group.body, options);\n\n  if (group.mclass === \"minner\") {\n    node = new mathMLTree.MathNode(\"mpadded\", inner);\n  } else if (group.mclass === \"mord\") {\n    if (group.isCharacterBox) {\n      node = inner[0];\n      node.type = \"mi\";\n    } else {\n      node = new mathMLTree.MathNode(\"mi\", inner);\n    }\n  } else {\n    if (group.isCharacterBox) {\n      node = inner[0];\n      node.type = \"mo\";\n    } else {\n      node = new mathMLTree.MathNode(\"mo\", inner);\n    } // Set spacing based on what is the most likely adjacent atom type.\n    // See TeXbook p170.\n\n\n    if (group.mclass === \"mbin\") {\n      node.attributes.lspace = \"0.22em\"; // medium space\n\n      node.attributes.rspace = \"0.22em\";\n    } else if (group.mclass === \"mpunct\") {\n      node.attributes.lspace = \"0em\";\n      node.attributes.rspace = \"0.17em\"; // thinspace\n    } else if (group.mclass === \"mopen\" || group.mclass === \"mclose\") {\n      node.attributes.lspace = \"0em\";\n      node.attributes.rspace = \"0em\";\n    } else if (group.mclass === \"minner\") {\n      node.attributes.lspace = \"0.0556em\"; // 1 mu is the most likely option\n\n      node.attributes.width = \"+0.1111em\";\n    } // MathML <mo> default space is 5/18 em, so <mrel> needs no action.\n    // Ref: https://developer.mozilla.org/en-US/docs/Web/MathML/Element/mo\n\n  }\n\n  return node;\n} // Math class commands except \\mathop\n\n\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\mathord\", \"\\\\mathbin\", \"\\\\mathrel\", \"\\\\mathopen\", \"\\\\mathclose\", \"\\\\mathpunct\", \"\\\\mathinner\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass: \"m\" + funcName.slice(5),\n      // TODO(kevinb): don't prefix with 'm'\n      body: ordargument(body),\n      isCharacterBox: utils.isCharacterBox(body)\n    };\n  },\n\n  htmlBuilder: htmlBuilder$9,\n  mathmlBuilder: mathmlBuilder$8\n});\nvar binrelClass = arg => {\n  // \\binrel@ spacing varies with (bin|rel|ord) of the atom in the argument.\n  // (by rendering separately and with {}s before and after, and measuring\n  // the change in spacing).  We'll do roughly the same by detecting the\n  // atom type directly.\n  var atom = arg.type === \"ordgroup\" && arg.body.length ? arg.body[0] : arg;\n\n  if (atom.type === \"atom\" && (atom.family === \"bin\" || atom.family === \"rel\")) {\n    return \"m\" + atom.family;\n  } else {\n    return \"mord\";\n  }\n}; // \\@binrel{x}{y} renders like y but as mbin/mrel/mord if x is mbin/mrel/mord.\n// This is equivalent to \\binrel@{x}\\binrel@@{y} in AMSTeX.\n\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\@binrel\"],\n  props: {\n    numArgs: 2\n  },\n\n  handler(_ref2, args) {\n    var {\n      parser\n    } = _ref2;\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass: binrelClass(args[0]),\n      body: ordargument(args[1]),\n      isCharacterBox: utils.isCharacterBox(args[1])\n    };\n  }\n\n}); // Build a relation or stacked op by placing one symbol on top of another\n\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\stackrel\", \"\\\\overset\", \"\\\\underset\"],\n  props: {\n    numArgs: 2\n  },\n\n  handler(_ref3, args) {\n    var {\n      parser,\n      funcName\n    } = _ref3;\n    var baseArg = args[1];\n    var shiftedArg = args[0];\n    var mclass;\n\n    if (funcName !== \"\\\\stackrel\") {\n      // LaTeX applies \\binrel spacing to \\overset and \\underset.\n      mclass = binrelClass(baseArg);\n    } else {\n      mclass = \"mrel\"; // for \\stackrel\n    }\n\n    var baseOp = {\n      type: \"op\",\n      mode: baseArg.mode,\n      limits: true,\n      alwaysHandleSupSub: true,\n      parentIsSupSub: false,\n      symbol: false,\n      suppressBaseShift: funcName !== \"\\\\stackrel\",\n      body: ordargument(baseArg)\n    };\n    var supsub = {\n      type: \"supsub\",\n      mode: shiftedArg.mode,\n      base: baseOp,\n      sup: funcName === \"\\\\underset\" ? null : shiftedArg,\n      sub: funcName === \"\\\\underset\" ? shiftedArg : null\n    };\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass,\n      body: [supsub],\n      isCharacterBox: utils.isCharacterBox(supsub)\n    };\n  },\n\n  htmlBuilder: htmlBuilder$9,\n  mathmlBuilder: mathmlBuilder$8\n});\n\n// \\pmb is a simulation of bold font.\n// The version of \\pmb in ambsy.sty works by typesetting three copies\n// with small offsets. We use CSS text-shadow.\n// It's a hack. Not as good as a real bold font. Better than nothing.\ndefineFunction({\n  type: \"pmb\",\n  names: [\"\\\\pmb\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"pmb\",\n      mode: parser.mode,\n      mclass: binrelClass(args[0]),\n      body: ordargument(args[0])\n    };\n  },\n\n  htmlBuilder(group, options) {\n    var elements = buildExpression$1(group.body, options, true);\n    var node = buildCommon.makeSpan([group.mclass], elements, options);\n    node.style.textShadow = \"0.02em 0.01em 0.04px\";\n    return node;\n  },\n\n  mathmlBuilder(group, style) {\n    var inner = buildExpression(group.body, style); // Wrap with an <mstyle> element.\n\n    var node = new mathMLTree.MathNode(\"mstyle\", inner);\n    node.setAttribute(\"style\", \"text-shadow: 0.02em 0.01em 0.04px\");\n    return node;\n  }\n\n});\n\nvar cdArrowFunctionName = {\n  \">\": \"\\\\\\\\cdrightarrow\",\n  \"<\": \"\\\\\\\\cdleftarrow\",\n  \"=\": \"\\\\\\\\cdlongequal\",\n  \"A\": \"\\\\uparrow\",\n  \"V\": \"\\\\downarrow\",\n  \"|\": \"\\\\Vert\",\n  \".\": \"no arrow\"\n};\n\nvar newCell = () => {\n  // Create an empty cell, to be filled below with parse nodes.\n  // The parseTree from this module must be constructed like the\n  // one created by parseArray(), so an empty CD cell must\n  // be a ParseNode<\"styling\">. And CD is always displaystyle.\n  // So these values are fixed and flow can do implicit typing.\n  return {\n    type: \"styling\",\n    body: [],\n    mode: \"math\",\n    style: \"display\"\n  };\n};\n\nvar isStartOfArrow = node => {\n  return node.type === \"textord\" && node.text === \"@\";\n};\n\nvar isLabelEnd = (node, endChar) => {\n  return (node.type === \"mathord\" || node.type === \"atom\") && node.text === endChar;\n};\n\nfunction cdArrow(arrowChar, labels, parser) {\n  // Return a parse tree of an arrow and its labels.\n  // This acts in a way similar to a macro expansion.\n  var funcName = cdArrowFunctionName[arrowChar];\n\n  switch (funcName) {\n    case \"\\\\\\\\cdrightarrow\":\n    case \"\\\\\\\\cdleftarrow\":\n      return parser.callFunction(funcName, [labels[0]], [labels[1]]);\n\n    case \"\\\\uparrow\":\n    case \"\\\\downarrow\":\n      {\n        var leftLabel = parser.callFunction(\"\\\\\\\\cdleft\", [labels[0]], []);\n        var bareArrow = {\n          type: \"atom\",\n          text: funcName,\n          mode: \"math\",\n          family: \"rel\"\n        };\n        var sizedArrow = parser.callFunction(\"\\\\Big\", [bareArrow], []);\n        var rightLabel = parser.callFunction(\"\\\\\\\\cdright\", [labels[1]], []);\n        var arrowGroup = {\n          type: \"ordgroup\",\n          mode: \"math\",\n          body: [leftLabel, sizedArrow, rightLabel]\n        };\n        return parser.callFunction(\"\\\\\\\\cdparent\", [arrowGroup], []);\n      }\n\n    case \"\\\\\\\\cdlongequal\":\n      return parser.callFunction(\"\\\\\\\\cdlongequal\", [], []);\n\n    case \"\\\\Vert\":\n      {\n        var arrow = {\n          type: \"textord\",\n          text: \"\\\\Vert\",\n          mode: \"math\"\n        };\n        return parser.callFunction(\"\\\\Big\", [arrow], []);\n      }\n\n    default:\n      return {\n        type: \"textord\",\n        text: \" \",\n        mode: \"math\"\n      };\n  }\n}\n\nfunction parseCD(parser) {\n  // Get the array's parse nodes with \\\\ temporarily mapped to \\cr.\n  var parsedRows = [];\n  parser.gullet.beginGroup();\n  parser.gullet.macros.set(\"\\\\cr\", \"\\\\\\\\\\\\relax\");\n  parser.gullet.beginGroup();\n\n  while (true) {\n    // eslint-disable-line no-constant-condition\n    // Get the parse nodes for the next row.\n    parsedRows.push(parser.parseExpression(false, \"\\\\\\\\\"));\n    parser.gullet.endGroup();\n    parser.gullet.beginGroup();\n    var next = parser.fetch().text;\n\n    if (next === \"&\" || next === \"\\\\\\\\\") {\n      parser.consume();\n    } else if (next === \"\\\\end\") {\n      if (parsedRows[parsedRows.length - 1].length === 0) {\n        parsedRows.pop(); // final row ended in \\\\\n      }\n\n      break;\n    } else {\n      throw new ParseError(\"Expected \\\\\\\\ or \\\\cr or \\\\end\", parser.nextToken);\n    }\n  }\n\n  var row = [];\n  var body = [row]; // Loop thru the parse nodes. Collect them into cells and arrows.\n\n  for (var i = 0; i < parsedRows.length; i++) {\n    // Start a new row.\n    var rowNodes = parsedRows[i]; // Create the first cell.\n\n    var cell = newCell();\n\n    for (var j = 0; j < rowNodes.length; j++) {\n      if (!isStartOfArrow(rowNodes[j])) {\n        // If a parseNode is not an arrow, it goes into a cell.\n        cell.body.push(rowNodes[j]);\n      } else {\n        // Parse node j is an \"@\", the start of an arrow.\n        // Before starting on the arrow, push the cell into `row`.\n        row.push(cell); // Now collect parseNodes into an arrow.\n        // The character after \"@\" defines the arrow type.\n\n        j += 1;\n        var arrowChar = assertSymbolNodeType(rowNodes[j]).text; // Create two empty label nodes. We may or may not use them.\n\n        var labels = new Array(2);\n        labels[0] = {\n          type: \"ordgroup\",\n          mode: \"math\",\n          body: []\n        };\n        labels[1] = {\n          type: \"ordgroup\",\n          mode: \"math\",\n          body: []\n        }; // Process the arrow.\n\n        if (\"=|.\".indexOf(arrowChar) > -1) ; else if (\"<>AV\".indexOf(arrowChar) > -1) {\n          // Four arrows, `@>>>`, `@<<<`, `@AAA`, and `@VVV`, each take\n          // two optional labels. E.g. the right-point arrow syntax is\n          // really:  @>{optional label}>{optional label}>\n          // Collect parseNodes into labels.\n          for (var labelNum = 0; labelNum < 2; labelNum++) {\n            var inLabel = true;\n\n            for (var k = j + 1; k < rowNodes.length; k++) {\n              if (isLabelEnd(rowNodes[k], arrowChar)) {\n                inLabel = false;\n                j = k;\n                break;\n              }\n\n              if (isStartOfArrow(rowNodes[k])) {\n                throw new ParseError(\"Missing a \" + arrowChar + \" character to complete a CD arrow.\", rowNodes[k]);\n              }\n\n              labels[labelNum].body.push(rowNodes[k]);\n            }\n\n            if (inLabel) {\n              // isLabelEnd never returned a true.\n              throw new ParseError(\"Missing a \" + arrowChar + \" character to complete a CD arrow.\", rowNodes[j]);\n            }\n          }\n        } else {\n          throw new ParseError(\"Expected one of \\\"<>AV=|.\\\" after @\", rowNodes[j]);\n        } // Now join the arrow to its labels.\n\n\n        var arrow = cdArrow(arrowChar, labels, parser); // Wrap the arrow in  ParseNode<\"styling\">.\n        // This is done to match parseArray() behavior.\n\n        var wrappedArrow = {\n          type: \"styling\",\n          body: [arrow],\n          mode: \"math\",\n          style: \"display\" // CD is always displaystyle.\n\n        };\n        row.push(wrappedArrow); // In CD's syntax, cells are implicit. That is, everything that\n        // is not an arrow gets collected into a cell. So create an empty\n        // cell now. It will collect upcoming parseNodes.\n\n        cell = newCell();\n      }\n    }\n\n    if (i % 2 === 0) {\n      // Even-numbered rows consist of: cell, arrow, cell, arrow, ... cell\n      // The last cell is not yet pushed into `row`, so:\n      row.push(cell);\n    } else {\n      // Odd-numbered rows consist of: vert arrow, empty cell, ... vert arrow\n      // Remove the empty cell that was placed at the beginning of `row`.\n      row.shift();\n    }\n\n    row = [];\n    body.push(row);\n  } // End row group\n\n\n  parser.gullet.endGroup(); // End array group defining \\\\\n\n  parser.gullet.endGroup(); // define column separation.\n\n  var cols = new Array(body[0].length).fill({\n    type: \"align\",\n    align: \"c\",\n    pregap: 0.25,\n    // CD package sets \\enskip between columns.\n    postgap: 0.25 // So pre and post each get half an \\enskip, i.e. 0.25em.\n\n  });\n  return {\n    type: \"array\",\n    mode: \"math\",\n    body,\n    arraystretch: 1,\n    addJot: true,\n    rowGaps: [null],\n    cols,\n    colSeparationType: \"CD\",\n    hLinesBeforeRow: new Array(body.length + 1).fill([])\n  };\n} // The functions below are not available for general use.\n// They are here only for internal use by the {CD} environment in placing labels\n// next to vertical arrows.\n// We don't need any such functions for horizontal arrows because we can reuse\n// the functionality that already exists for extensible arrows.\n\ndefineFunction({\n  type: \"cdlabel\",\n  names: [\"\\\\\\\\cdleft\", \"\\\\\\\\cdright\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    return {\n      type: \"cdlabel\",\n      mode: parser.mode,\n      side: funcName.slice(4),\n      label: args[0]\n    };\n  },\n\n  htmlBuilder(group, options) {\n    var newOptions = options.havingStyle(options.style.sup());\n    var label = buildCommon.wrapFragment(buildGroup$1(group.label, newOptions, options), options);\n    label.classes.push(\"cd-label-\" + group.side);\n    label.style.bottom = makeEm(0.8 - label.depth); // Zero out label height & depth, so vertical align of arrow is set\n    // by the arrow height, not by the label.\n\n    label.height = 0;\n    label.depth = 0;\n    return label;\n  },\n\n  mathmlBuilder(group, options) {\n    var label = new mathMLTree.MathNode(\"mrow\", [buildGroup(group.label, options)]);\n    label = new mathMLTree.MathNode(\"mpadded\", [label]);\n    label.setAttribute(\"width\", \"0\");\n\n    if (group.side === \"left\") {\n      label.setAttribute(\"lspace\", \"-1width\");\n    } // We have to guess at vertical alignment. We know the arrow is 1.8em tall,\n    // But we don't know the height or depth of the label.\n\n\n    label.setAttribute(\"voffset\", \"0.7em\");\n    label = new mathMLTree.MathNode(\"mstyle\", [label]);\n    label.setAttribute(\"displaystyle\", \"false\");\n    label.setAttribute(\"scriptlevel\", \"1\");\n    return label;\n  }\n\n});\ndefineFunction({\n  type: \"cdlabelparent\",\n  names: [\"\\\\\\\\cdparent\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref2, args) {\n    var {\n      parser\n    } = _ref2;\n    return {\n      type: \"cdlabelparent\",\n      mode: parser.mode,\n      fragment: args[0]\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Wrap the vertical arrow and its labels.\n    // The parent gets position: relative. The child gets position: absolute.\n    // So CSS can locate the label correctly.\n    var parent = buildCommon.wrapFragment(buildGroup$1(group.fragment, options), options);\n    parent.classes.push(\"cd-vert-arrow\");\n    return parent;\n  },\n\n  mathmlBuilder(group, options) {\n    return new mathMLTree.MathNode(\"mrow\", [buildGroup(group.fragment, options)]);\n  }\n\n});\n\n// {123} and converts into symbol with code 123.  It is used by the *macro*\n// \\char defined in macros.js.\n\ndefineFunction({\n  type: \"textord\",\n  names: [\"\\\\@char\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    var arg = assertNodeType(args[0], \"ordgroup\");\n    var group = arg.body;\n    var number = \"\";\n\n    for (var i = 0; i < group.length; i++) {\n      var node = assertNodeType(group[i], \"textord\");\n      number += node.text;\n    }\n\n    var code = parseInt(number);\n    var text;\n\n    if (isNaN(code)) {\n      throw new ParseError(\"\\\\@char has non-numeric argument \" + number); // If we drop IE support, the following code could be replaced with\n      // text = String.fromCodePoint(code)\n    } else if (code < 0 || code >= 0x10ffff) {\n      throw new ParseError(\"\\\\@char with invalid code point \" + number);\n    } else if (code <= 0xffff) {\n      text = String.fromCharCode(code);\n    } else {\n      // Astral code point; split into surrogate halves\n      code -= 0x10000;\n      text = String.fromCharCode((code >> 10) + 0xd800, (code & 0x3ff) + 0xdc00);\n    }\n\n    return {\n      type: \"textord\",\n      mode: parser.mode,\n      text: text\n    };\n  }\n\n});\n\nvar htmlBuilder$8 = (group, options) => {\n  var elements = buildExpression$1(group.body, options.withColor(group.color), false); // \\color isn't supposed to affect the type of the elements it contains.\n  // To accomplish this, we wrap the results in a fragment, so the inner\n  // elements will be able to directly interact with their neighbors. For\n  // example, `\\color{red}{2 +} 3` has the same spacing as `2 + 3`\n\n  return buildCommon.makeFragment(elements);\n};\n\nvar mathmlBuilder$7 = (group, options) => {\n  var inner = buildExpression(group.body, options.withColor(group.color));\n  var node = new mathMLTree.MathNode(\"mstyle\", inner);\n  node.setAttribute(\"mathcolor\", group.color);\n  return node;\n};\n\ndefineFunction({\n  type: \"color\",\n  names: [\"\\\\textcolor\"],\n  props: {\n    numArgs: 2,\n    allowedInText: true,\n    argTypes: [\"color\", \"original\"]\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    var color = assertNodeType(args[0], \"color-token\").color;\n    var body = args[1];\n    return {\n      type: \"color\",\n      mode: parser.mode,\n      color,\n      body: ordargument(body)\n    };\n  },\n\n  htmlBuilder: htmlBuilder$8,\n  mathmlBuilder: mathmlBuilder$7\n});\ndefineFunction({\n  type: \"color\",\n  names: [\"\\\\color\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true,\n    argTypes: [\"color\"]\n  },\n\n  handler(_ref2, args) {\n    var {\n      parser,\n      breakOnTokenText\n    } = _ref2;\n    var color = assertNodeType(args[0], \"color-token\").color; // Set macro \\current@color in current namespace to store the current\n    // color, mimicking the behavior of color.sty.\n    // This is currently used just to correctly color a \\right\n    // that follows a \\color command.\n\n    parser.gullet.macros.set(\"\\\\current@color\", color); // Parse out the implicit body that should be colored.\n\n    var body = parser.parseExpression(true, breakOnTokenText);\n    return {\n      type: \"color\",\n      mode: parser.mode,\n      color,\n      body\n    };\n  },\n\n  htmlBuilder: htmlBuilder$8,\n  mathmlBuilder: mathmlBuilder$7\n});\n\n// Row breaks within tabular environments, and line breaks at top level\n\ndefineFunction({\n  type: \"cr\",\n  names: [\"\\\\\\\\\"],\n  props: {\n    numArgs: 0,\n    numOptionalArgs: 0,\n    allowedInText: true\n  },\n\n  handler(_ref, args, optArgs) {\n    var {\n      parser\n    } = _ref;\n    var size = parser.gullet.future().text === \"[\" ? parser.parseSizeGroup(true) : null;\n    var newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior(\"newLineInDisplayMode\", \"In LaTeX, \\\\\\\\ or \\\\newline \" + \"does nothing in display mode\");\n    return {\n      type: \"cr\",\n      mode: parser.mode,\n      newLine,\n      size: size && assertNodeType(size, \"size\").value\n    };\n  },\n\n  // The following builders are called only at the top level,\n  // not within tabular/array environments.\n  htmlBuilder(group, options) {\n    var span = buildCommon.makeSpan([\"mspace\"], [], options);\n\n    if (group.newLine) {\n      span.classes.push(\"newline\");\n\n      if (group.size) {\n        span.style.marginTop = makeEm(calculateSize(group.size, options));\n      }\n    }\n\n    return span;\n  },\n\n  mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mspace\");\n\n    if (group.newLine) {\n      node.setAttribute(\"linebreak\", \"newline\");\n\n      if (group.size) {\n        node.setAttribute(\"height\", makeEm(calculateSize(group.size, options)));\n      }\n    }\n\n    return node;\n  }\n\n});\n\nvar globalMap = {\n  \"\\\\global\": \"\\\\global\",\n  \"\\\\long\": \"\\\\\\\\globallong\",\n  \"\\\\\\\\globallong\": \"\\\\\\\\globallong\",\n  \"\\\\def\": \"\\\\gdef\",\n  \"\\\\gdef\": \"\\\\gdef\",\n  \"\\\\edef\": \"\\\\xdef\",\n  \"\\\\xdef\": \"\\\\xdef\",\n  \"\\\\let\": \"\\\\\\\\globallet\",\n  \"\\\\futurelet\": \"\\\\\\\\globalfuture\"\n};\n\nvar checkControlSequence = tok => {\n  var name = tok.text;\n\n  if (/^(?:[\\\\{}$&#^_]|EOF)$/.test(name)) {\n    throw new ParseError(\"Expected a control sequence\", tok);\n  }\n\n  return name;\n};\n\nvar getRHS = parser => {\n  var tok = parser.gullet.popToken();\n\n  if (tok.text === \"=\") {\n    // consume optional equals\n    tok = parser.gullet.popToken();\n\n    if (tok.text === \" \") {\n      // consume one optional space\n      tok = parser.gullet.popToken();\n    }\n  }\n\n  return tok;\n};\n\nvar letCommand = (parser, name, tok, global) => {\n  var macro = parser.gullet.macros.get(tok.text);\n\n  if (macro == null) {\n    // don't expand it later even if a macro with the same name is defined\n    // e.g., \\let\\foo=\\frac \\def\\frac{\\relax} \\frac12\n    tok.noexpand = true;\n    macro = {\n      tokens: [tok],\n      numArgs: 0,\n      // reproduce the same behavior in expansion\n      unexpandable: !parser.gullet.isExpandable(tok.text)\n    };\n  }\n\n  parser.gullet.macros.set(name, macro, global);\n}; // <assignment> -> <non-macro assignment>|<macro assignment>\n// <non-macro assignment> -> <simple assignment>|\\global<non-macro assignment>\n// <macro assignment> -> <definition>|<prefix><macro assignment>\n// <prefix> -> \\global|\\long|\\outer\n\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\global\", \"\\\\long\", \"\\\\\\\\globallong\" // cant be entered directly\n  ],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n\n  handler(_ref) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    parser.consumeSpaces();\n    var token = parser.fetch();\n\n    if (globalMap[token.text]) {\n      // KaTeX doesn't have \\par, so ignore \\long\n      if (funcName === \"\\\\global\" || funcName === \"\\\\\\\\globallong\") {\n        token.text = globalMap[token.text];\n      }\n\n      return assertNodeType(parser.parseFunction(), \"internal\");\n    }\n\n    throw new ParseError(\"Invalid token after macro prefix\", token);\n  }\n\n}); // Basic support for macro definitions: \\def, \\gdef, \\edef, \\xdef\n// <definition> -> <def><control sequence><definition text>\n// <def> -> \\def|\\gdef|\\edef|\\xdef\n// <definition text> -> <parameter text><left brace><balanced text><right brace>\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\def\", \"\\\\gdef\", \"\\\\edef\", \"\\\\xdef\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref2) {\n    var {\n      parser,\n      funcName\n    } = _ref2;\n    var tok = parser.gullet.popToken();\n    var name = tok.text;\n\n    if (/^(?:[\\\\{}$&#^_]|EOF)$/.test(name)) {\n      throw new ParseError(\"Expected a control sequence\", tok);\n    }\n\n    var numArgs = 0;\n    var insert;\n    var delimiters = [[]]; // <parameter text> contains no braces\n\n    while (parser.gullet.future().text !== \"{\") {\n      tok = parser.gullet.popToken();\n\n      if (tok.text === \"#\") {\n        // If the very last character of the <parameter text> is #, so that\n        // this # is immediately followed by {, TeX will behave as if the {\n        // had been inserted at the right end of both the parameter text\n        // and the replacement text.\n        if (parser.gullet.future().text === \"{\") {\n          insert = parser.gullet.future();\n          delimiters[numArgs].push(\"{\");\n          break;\n        } // A parameter, the first appearance of # must be followed by 1,\n        // the next by 2, and so on; up to nine #s are allowed\n\n\n        tok = parser.gullet.popToken();\n\n        if (!/^[1-9]$/.test(tok.text)) {\n          throw new ParseError(\"Invalid argument number \\\"\" + tok.text + \"\\\"\");\n        }\n\n        if (parseInt(tok.text) !== numArgs + 1) {\n          throw new ParseError(\"Argument number \\\"\" + tok.text + \"\\\" out of order\");\n        }\n\n        numArgs++;\n        delimiters.push([]);\n      } else if (tok.text === \"EOF\") {\n        throw new ParseError(\"Expected a macro definition\");\n      } else {\n        delimiters[numArgs].push(tok.text);\n      }\n    } // replacement text, enclosed in '{' and '}' and properly nested\n\n\n    var {\n      tokens\n    } = parser.gullet.consumeArg();\n\n    if (insert) {\n      tokens.unshift(insert);\n    }\n\n    if (funcName === \"\\\\edef\" || funcName === \"\\\\xdef\") {\n      tokens = parser.gullet.expandTokens(tokens);\n      tokens.reverse(); // to fit in with stack order\n    } // Final arg is the expansion of the macro\n\n\n    parser.gullet.macros.set(name, {\n      tokens,\n      numArgs,\n      delimiters\n    }, funcName === globalMap[funcName]);\n    return {\n      type: \"internal\",\n      mode: parser.mode\n    };\n  }\n\n}); // <simple assignment> -> <let assignment>\n// <let assignment> -> \\futurelet<control sequence><token><token>\n//     | \\let<control sequence><equals><one optional space><token>\n// <equals> -> <optional spaces>|<optional spaces>=\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\let\", \"\\\\\\\\globallet\" // cant be entered directly\n  ],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref3) {\n    var {\n      parser,\n      funcName\n    } = _ref3;\n    var name = checkControlSequence(parser.gullet.popToken());\n    parser.gullet.consumeSpaces();\n    var tok = getRHS(parser);\n    letCommand(parser, name, tok, funcName === \"\\\\\\\\globallet\");\n    return {\n      type: \"internal\",\n      mode: parser.mode\n    };\n  }\n\n}); // ref: https://www.tug.org/TUGboat/tb09-3/tb22bechtolsheim.pdf\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\futurelet\", \"\\\\\\\\globalfuture\" // cant be entered directly\n  ],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref4) {\n    var {\n      parser,\n      funcName\n    } = _ref4;\n    var name = checkControlSequence(parser.gullet.popToken());\n    var middle = parser.gullet.popToken();\n    var tok = parser.gullet.popToken();\n    letCommand(parser, name, tok, funcName === \"\\\\\\\\globalfuture\");\n    parser.gullet.pushToken(tok);\n    parser.gullet.pushToken(middle);\n    return {\n      type: \"internal\",\n      mode: parser.mode\n    };\n  }\n\n});\n\n/**\n * This file deals with creating delimiters of various sizes. The TeXbook\n * discusses these routines on page 441-442, in the \"Another subroutine sets box\n * x to a specified variable delimiter\" paragraph.\n *\n * There are three main routines here. `makeSmallDelim` makes a delimiter in the\n * normal font, but in either text, script, or scriptscript style.\n * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,\n * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of\n * smaller pieces that are stacked on top of one another.\n *\n * The functions take a parameter `center`, which determines if the delimiter\n * should be centered around the axis.\n *\n * Then, there are three exposed functions. `sizedDelim` makes a delimiter in\n * one of the given sizes. This is used for things like `\\bigl`.\n * `customSizedDelim` makes a delimiter with a given total height+depth. It is\n * called in places like `\\sqrt`. `leftRightDelim` makes an appropriate\n * delimiter which surrounds an expression of a given height an depth. It is\n * used in `\\left` and `\\right`.\n */\n\n/**\n * Get the metrics for a given symbol and font, after transformation (i.e.\n * after following replacement from symbols.js)\n */\nvar getMetrics = function getMetrics(symbol, font, mode) {\n  var replace = symbols.math[symbol] && symbols.math[symbol].replace;\n  var metrics = getCharacterMetrics(replace || symbol, font, mode);\n\n  if (!metrics) {\n    throw new Error(\"Unsupported symbol \" + symbol + \" and font size \" + font + \".\");\n  }\n\n  return metrics;\n};\n/**\n * Puts a delimiter span in a given style, and adds appropriate height, depth,\n * and maxFontSizes.\n */\n\n\nvar styleWrap = function styleWrap(delim, toStyle, options, classes) {\n  var newOptions = options.havingBaseStyle(toStyle);\n  var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);\n  var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;\n  span.height *= delimSizeMultiplier;\n  span.depth *= delimSizeMultiplier;\n  span.maxFontSize = newOptions.sizeMultiplier;\n  return span;\n};\n\nvar centerSpan = function centerSpan(span, options, style) {\n  var newOptions = options.havingBaseStyle(style);\n  var shift = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;\n  span.classes.push(\"delimcenter\");\n  span.style.top = makeEm(shift);\n  span.height -= shift;\n  span.depth += shift;\n};\n/**\n * Makes a small delimiter. This is a delimiter that comes in the Main-Regular\n * font, but is restyled to either be in textstyle, scriptstyle, or\n * scriptscriptstyle.\n */\n\n\nvar makeSmallDelim = function makeSmallDelim(delim, style, center, options, mode, classes) {\n  var text = buildCommon.makeSymbol(delim, \"Main-Regular\", mode, options);\n  var span = styleWrap(text, style, options, classes);\n\n  if (center) {\n    centerSpan(span, options, style);\n  }\n\n  return span;\n};\n/**\n * Builds a symbol in the given font size (note size is an integer)\n */\n\n\nvar mathrmSize = function mathrmSize(value, size, mode, options) {\n  return buildCommon.makeSymbol(value, \"Size\" + size + \"-Regular\", mode, options);\n};\n/**\n * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,\n * Size3, or Size4 fonts. It is always rendered in textstyle.\n */\n\n\nvar makeLargeDelim = function makeLargeDelim(delim, size, center, options, mode, classes) {\n  var inner = mathrmSize(delim, size, mode, options);\n  var span = styleWrap(buildCommon.makeSpan([\"delimsizing\", \"size\" + size], [inner], options), Style$1.TEXT, options, classes);\n\n  if (center) {\n    centerSpan(span, options, Style$1.TEXT);\n  }\n\n  return span;\n};\n/**\n * Make a span from a font glyph with the given offset and in the given font.\n * This is used in makeStackedDelim to make the stacking pieces for the delimiter.\n */\n\n\nvar makeGlyphSpan = function makeGlyphSpan(symbol, font, mode) {\n  var sizeClass; // Apply the correct CSS class to choose the right font.\n\n  if (font === \"Size1-Regular\") {\n    sizeClass = \"delim-size1\";\n  } else\n    /* if (font === \"Size4-Regular\") */\n    {\n      sizeClass = \"delim-size4\";\n    }\n\n  var corner = buildCommon.makeSpan([\"delimsizinginner\", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]); // Since this will be passed into `makeVList` in the end, wrap the element\n  // in the appropriate tag that VList uses.\n\n  return {\n    type: \"elem\",\n    elem: corner\n  };\n};\n\nvar makeInner = function makeInner(ch, height, options) {\n  // Create a span with inline SVG for the inner part of a tall stacked delimiter.\n  var width = fontMetricsData['Size4-Regular'][ch.charCodeAt(0)] ? fontMetricsData['Size4-Regular'][ch.charCodeAt(0)][4] : fontMetricsData['Size1-Regular'][ch.charCodeAt(0)][4];\n  var path = new PathNode(\"inner\", innerPath(ch, Math.round(1000 * height)));\n  var svgNode = new SvgNode([path], {\n    \"width\": makeEm(width),\n    \"height\": makeEm(height),\n    // Override CSS rule `.katex svg { width: 100% }`\n    \"style\": \"width:\" + makeEm(width),\n    \"viewBox\": \"0 0 \" + 1000 * width + \" \" + Math.round(1000 * height),\n    \"preserveAspectRatio\": \"xMinYMin\"\n  });\n  var span = buildCommon.makeSvgSpan([], [svgNode], options);\n  span.height = height;\n  span.style.height = makeEm(height);\n  span.style.width = makeEm(width);\n  return {\n    type: \"elem\",\n    elem: span\n  };\n}; // Helpers for makeStackedDelim\n\n\nvar lapInEms = 0.008;\nvar lap = {\n  type: \"kern\",\n  size: -1 * lapInEms\n};\nvar verts = [\"|\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\vert\"];\nvar doubleVerts = [\"\\\\|\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\Vert\"];\n/**\n * Make a stacked delimiter out of a given delimiter, with the total height at\n * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.\n */\n\nvar makeStackedDelim = function makeStackedDelim(delim, heightTotal, center, options, mode, classes) {\n  // There are four parts, the top, an optional middle, a repeated part, and a\n  // bottom.\n  var top;\n  var middle;\n  var repeat;\n  var bottom;\n  var svgLabel = \"\";\n  var viewBoxWidth = 0;\n  top = repeat = bottom = delim;\n  middle = null; // Also keep track of what font the delimiters are in\n\n  var font = \"Size1-Regular\"; // We set the parts and font based on the symbol. Note that we use\n  // '\\u23d0' instead of '|' and '\\u2016' instead of '\\\\|' for the\n  // repeats of the arrows\n\n  if (delim === \"\\\\uparrow\") {\n    repeat = bottom = \"\\u23d0\";\n  } else if (delim === \"\\\\Uparrow\") {\n    repeat = bottom = \"\\u2016\";\n  } else if (delim === \"\\\\downarrow\") {\n    top = repeat = \"\\u23d0\";\n  } else if (delim === \"\\\\Downarrow\") {\n    top = repeat = \"\\u2016\";\n  } else if (delim === \"\\\\updownarrow\") {\n    top = \"\\\\uparrow\";\n    repeat = \"\\u23d0\";\n    bottom = \"\\\\downarrow\";\n  } else if (delim === \"\\\\Updownarrow\") {\n    top = \"\\\\Uparrow\";\n    repeat = \"\\u2016\";\n    bottom = \"\\\\Downarrow\";\n  } else if (verts.includes(delim)) {\n    repeat = \"\\u2223\";\n    svgLabel = \"vert\";\n    viewBoxWidth = 333;\n  } else if (doubleVerts.includes(delim)) {\n    repeat = \"\\u2225\";\n    svgLabel = \"doublevert\";\n    viewBoxWidth = 556;\n  } else if (delim === \"[\" || delim === \"\\\\lbrack\") {\n    top = \"\\u23a1\";\n    repeat = \"\\u23a2\";\n    bottom = \"\\u23a3\";\n    font = \"Size4-Regular\";\n    svgLabel = \"lbrack\";\n    viewBoxWidth = 667;\n  } else if (delim === \"]\" || delim === \"\\\\rbrack\") {\n    top = \"\\u23a4\";\n    repeat = \"\\u23a5\";\n    bottom = \"\\u23a6\";\n    font = \"Size4-Regular\";\n    svgLabel = \"rbrack\";\n    viewBoxWidth = 667;\n  } else if (delim === \"\\\\lfloor\" || delim === \"\\u230a\") {\n    repeat = top = \"\\u23a2\";\n    bottom = \"\\u23a3\";\n    font = \"Size4-Regular\";\n    svgLabel = \"lfloor\";\n    viewBoxWidth = 667;\n  } else if (delim === \"\\\\lceil\" || delim === \"\\u2308\") {\n    top = \"\\u23a1\";\n    repeat = bottom = \"\\u23a2\";\n    font = \"Size4-Regular\";\n    svgLabel = \"lceil\";\n    viewBoxWidth = 667;\n  } else if (delim === \"\\\\rfloor\" || delim === \"\\u230b\") {\n    repeat = top = \"\\u23a5\";\n    bottom = \"\\u23a6\";\n    font = \"Size4-Regular\";\n    svgLabel = \"rfloor\";\n    viewBoxWidth = 667;\n  } else if (delim === \"\\\\rceil\" || delim === \"\\u2309\") {\n    top = \"\\u23a4\";\n    repeat = bottom = \"\\u23a5\";\n    font = \"Size4-Regular\";\n    svgLabel = \"rceil\";\n    viewBoxWidth = 667;\n  } else if (delim === \"(\" || delim === \"\\\\lparen\") {\n    top = \"\\u239b\";\n    repeat = \"\\u239c\";\n    bottom = \"\\u239d\";\n    font = \"Size4-Regular\";\n    svgLabel = \"lparen\";\n    viewBoxWidth = 875;\n  } else if (delim === \")\" || delim === \"\\\\rparen\") {\n    top = \"\\u239e\";\n    repeat = \"\\u239f\";\n    bottom = \"\\u23a0\";\n    font = \"Size4-Regular\";\n    svgLabel = \"rparen\";\n    viewBoxWidth = 875;\n  } else if (delim === \"\\\\{\" || delim === \"\\\\lbrace\") {\n    top = \"\\u23a7\";\n    middle = \"\\u23a8\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\}\" || delim === \"\\\\rbrace\") {\n    top = \"\\u23ab\";\n    middle = \"\\u23ac\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lgroup\" || delim === \"\\u27ee\") {\n    top = \"\\u23a7\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rgroup\" || delim === \"\\u27ef\") {\n    top = \"\\u23ab\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\lmoustache\" || delim === \"\\u23b0\") {\n    top = \"\\u23a7\";\n    bottom = \"\\u23ad\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } else if (delim === \"\\\\rmoustache\" || delim === \"\\u23b1\") {\n    top = \"\\u23ab\";\n    bottom = \"\\u23a9\";\n    repeat = \"\\u23aa\";\n    font = \"Size4-Regular\";\n  } // Get the metrics of the four sections\n\n\n  var topMetrics = getMetrics(top, font, mode);\n  var topHeightTotal = topMetrics.height + topMetrics.depth;\n  var repeatMetrics = getMetrics(repeat, font, mode);\n  var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;\n  var bottomMetrics = getMetrics(bottom, font, mode);\n  var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;\n  var middleHeightTotal = 0;\n  var middleFactor = 1;\n\n  if (middle !== null) {\n    var middleMetrics = getMetrics(middle, font, mode);\n    middleHeightTotal = middleMetrics.height + middleMetrics.depth;\n    middleFactor = 2; // repeat symmetrically above and below middle\n  } // Calculate the minimal height that the delimiter can have.\n  // It is at least the size of the top, bottom, and optional middle combined.\n\n\n  var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal; // Compute the number of copies of the repeat symbol we will need\n\n  var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal))); // Compute the total height of the delimiter including all the symbols\n\n  var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal; // The center of the delimiter is placed at the center of the axis. Note\n  // that in this context, \"center\" means that the delimiter should be\n  // centered around the axis in the current style, while normally it is\n  // centered around the axis in textstyle.\n\n  var axisHeight = options.fontMetrics().axisHeight;\n\n  if (center) {\n    axisHeight *= options.sizeMultiplier;\n  } // Calculate the depth\n\n\n  var depth = realHeightTotal / 2 - axisHeight; // Now, we start building the pieces that will go into the vlist\n  // Keep a list of the pieces of the stacked delimiter\n\n  var stack = [];\n\n  if (svgLabel.length > 0) {\n    // Instead of stacking glyphs, create a single SVG.\n    // This evades browser problems with imprecise positioning of spans.\n    var midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;\n    var viewBoxHeight = Math.round(realHeightTotal * 1000);\n    var pathStr = tallDelim(svgLabel, Math.round(midHeight * 1000));\n    var path = new PathNode(svgLabel, pathStr);\n    var width = (viewBoxWidth / 1000).toFixed(3) + \"em\";\n    var height = (viewBoxHeight / 1000).toFixed(3) + \"em\";\n    var svg = new SvgNode([path], {\n      \"width\": width,\n      \"height\": height,\n      \"viewBox\": \"0 0 \" + viewBoxWidth + \" \" + viewBoxHeight\n    });\n    var wrapper = buildCommon.makeSvgSpan([], [svg], options);\n    wrapper.height = viewBoxHeight / 1000;\n    wrapper.style.width = width;\n    wrapper.style.height = height;\n    stack.push({\n      type: \"elem\",\n      elem: wrapper\n    });\n  } else {\n    // Stack glyphs\n    // Start by adding the bottom symbol\n    stack.push(makeGlyphSpan(bottom, font, mode));\n    stack.push(lap); // overlap\n\n    if (middle === null) {\n      // The middle section will be an SVG. Make it an extra 0.016em tall.\n      // We'll overlap by 0.008em at top and bottom.\n      var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;\n      stack.push(makeInner(repeat, innerHeight, options));\n    } else {\n      // When there is a middle bit, we need the middle part and two repeated\n      // sections\n      var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;\n\n      stack.push(makeInner(repeat, _innerHeight, options)); // Now insert the middle of the brace.\n\n      stack.push(lap);\n      stack.push(makeGlyphSpan(middle, font, mode));\n      stack.push(lap);\n      stack.push(makeInner(repeat, _innerHeight, options));\n    } // Add the top symbol\n\n\n    stack.push(lap);\n    stack.push(makeGlyphSpan(top, font, mode));\n  } // Finally, build the vlist\n\n\n  var newOptions = options.havingBaseStyle(Style$1.TEXT);\n  var inner = buildCommon.makeVList({\n    positionType: \"bottom\",\n    positionData: depth,\n    children: stack\n  }, newOptions);\n  return styleWrap(buildCommon.makeSpan([\"delimsizing\", \"mult\"], [inner], newOptions), Style$1.TEXT, options, classes);\n}; // All surds have 0.08em padding above the vinculum inside the SVG.\n// That keeps browser span height rounding error from pinching the line.\n\n\nvar vbPad = 80; // padding above the surd, measured inside the viewBox.\n\nvar emPad = 0.08; // padding, in ems, measured in the document.\n\nvar sqrtSvg = function sqrtSvg(sqrtName, height, viewBoxHeight, extraVinculum, options) {\n  var path = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);\n  var pathNode = new PathNode(sqrtName, path);\n  var svg = new SvgNode([pathNode], {\n    // Note: 1000:1 ratio of viewBox to document em width.\n    \"width\": \"400em\",\n    \"height\": makeEm(height),\n    \"viewBox\": \"0 0 400000 \" + viewBoxHeight,\n    \"preserveAspectRatio\": \"xMinYMin slice\"\n  });\n  return buildCommon.makeSvgSpan([\"hide-tail\"], [svg], options);\n};\n/**\n * Make a sqrt image of the given height,\n */\n\n\nvar makeSqrtImage = function makeSqrtImage(height, options) {\n  // Define a newOptions that removes the effect of size changes such as \\Huge.\n  // We don't pick different a height surd for \\Huge. For it, we scale up.\n  var newOptions = options.havingBaseSizing(); // Pick the desired surd glyph from a sequence of surds.\n\n  var delim = traverseSequence(\"\\\\surd\", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);\n  var sizeMultiplier = newOptions.sizeMultiplier; // default\n  // The standard sqrt SVGs each have a 0.04em thick vinculum.\n  // If Settings.minRuleThickness is larger than that, we add extraVinculum.\n\n  var extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness); // Create a span containing an SVG image of a sqrt symbol.\n\n  var span;\n  var spanHeight = 0;\n  var texHeight = 0;\n  var viewBoxHeight = 0;\n  var advanceWidth; // We create viewBoxes with 80 units of \"padding\" above each surd.\n  // Then browser rounding error on the parent span height will not\n  // encroach on the ink of the vinculum. But that padding is not\n  // included in the TeX-like `height` used for calculation of\n  // vertical alignment. So texHeight = span.height < span.style.height.\n\n  if (delim.type === \"small\") {\n    // Get an SVG that is derived from glyph U+221A in font KaTeX-Main.\n    // 1000 unit normal glyph height.\n    viewBoxHeight = 1000 + 1000 * extraVinculum + vbPad;\n\n    if (height < 1.0) {\n      sizeMultiplier = 1.0; // mimic a \\textfont radical\n    } else if (height < 1.4) {\n      sizeMultiplier = 0.7; // mimic a \\scriptfont radical\n    }\n\n    spanHeight = (1.0 + extraVinculum + emPad) / sizeMultiplier;\n    texHeight = (1.00 + extraVinculum) / sizeMultiplier;\n    span = sqrtSvg(\"sqrtMain\", spanHeight, viewBoxHeight, extraVinculum, options);\n    span.style.minWidth = \"0.853em\";\n    advanceWidth = 0.833 / sizeMultiplier; // from the font.\n  } else if (delim.type === \"large\") {\n    // These SVGs come from fonts: KaTeX_Size1, _Size2, etc.\n    viewBoxHeight = (1000 + vbPad) * sizeToMaxHeight[delim.size];\n    texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;\n    spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;\n    span = sqrtSvg(\"sqrtSize\" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);\n    span.style.minWidth = \"1.02em\";\n    advanceWidth = 1.0 / sizeMultiplier; // 1.0 from the font.\n  } else {\n    // Tall sqrt. In TeX, this would be stacked using multiple glyphs.\n    // We'll use a single SVG to accomplish the same thing.\n    spanHeight = height + extraVinculum + emPad;\n    texHeight = height + extraVinculum;\n    viewBoxHeight = Math.floor(1000 * height + extraVinculum) + vbPad;\n    span = sqrtSvg(\"sqrtTall\", spanHeight, viewBoxHeight, extraVinculum, options);\n    span.style.minWidth = \"0.742em\";\n    advanceWidth = 1.056;\n  }\n\n  span.height = texHeight;\n  span.style.height = makeEm(spanHeight);\n  return {\n    span,\n    advanceWidth,\n    // Calculate the actual line width.\n    // This actually should depend on the chosen font -- e.g. \\boldmath\n    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and\n    // have thicker rules.\n    ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier\n  };\n}; // There are three kinds of delimiters, delimiters that stack when they become\n// too large\n\n\nvar stackLargeDelimiters = [\"(\", \"\\\\lparen\", \")\", \"\\\\rparen\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\", \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\", \"\\\\lfloor\", \"\\\\rfloor\", \"\\u230a\", \"\\u230b\", \"\\\\lceil\", \"\\\\rceil\", \"\\u2308\", \"\\u2309\", \"\\\\surd\"]; // delimiters that always stack\n\nvar stackAlwaysDelimiters = [\"\\\\uparrow\", \"\\\\downarrow\", \"\\\\updownarrow\", \"\\\\Uparrow\", \"\\\\Downarrow\", \"\\\\Updownarrow\", \"|\", \"\\\\|\", \"\\\\vert\", \"\\\\Vert\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\lgroup\", \"\\\\rgroup\", \"\\u27ee\", \"\\u27ef\", \"\\\\lmoustache\", \"\\\\rmoustache\", \"\\u23b0\", \"\\u23b1\"]; // and delimiters that never stack\n\nvar stackNeverDelimiters = [\"<\", \">\", \"\\\\langle\", \"\\\\rangle\", \"/\", \"\\\\backslash\", \"\\\\lt\", \"\\\\gt\"]; // Metrics of the different sizes. Found by looking at TeX's output of\n// $\\bigl| // \\Bigl| \\biggl| \\Biggl| \\showlists$\n// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.\n\nvar sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];\n/**\n * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.\n */\n\nvar makeSizedDelim = function makeSizedDelim(delim, size, options, mode, classes) {\n  // < and > turn into \\langle and \\rangle in delimiters\n  if (delim === \"<\" || delim === \"\\\\lt\" || delim === \"\\u27e8\") {\n    delim = \"\\\\langle\";\n  } else if (delim === \">\" || delim === \"\\\\gt\" || delim === \"\\u27e9\") {\n    delim = \"\\\\rangle\";\n  } // Sized delimiters are never centered.\n\n\n  if (stackLargeDelimiters.includes(delim) || stackNeverDelimiters.includes(delim)) {\n    return makeLargeDelim(delim, size, false, options, mode, classes);\n  } else if (stackAlwaysDelimiters.includes(delim)) {\n    return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);\n  } else {\n    throw new ParseError(\"Illegal delimiter: '\" + delim + \"'\");\n  }\n};\n/**\n * There are three different sequences of delimiter sizes that the delimiters\n * follow depending on the kind of delimiter. This is used when creating custom\n * sized delimiters to decide whether to create a small, large, or stacked\n * delimiter.\n *\n * In real TeX, these sequences aren't explicitly defined, but are instead\n * defined inside the font metrics. Since there are only three sequences that\n * are possible for the delimiters that TeX defines, it is easier to just encode\n * them explicitly here.\n */\n\n\n// Delimiters that never stack try small delimiters and large delimiters only\nvar stackNeverDelimiterSequence = [{\n  type: \"small\",\n  style: Style$1.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.SCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.TEXT\n}, {\n  type: \"large\",\n  size: 1\n}, {\n  type: \"large\",\n  size: 2\n}, {\n  type: \"large\",\n  size: 3\n}, {\n  type: \"large\",\n  size: 4\n}]; // Delimiters that always stack try the small delimiters first, then stack\n\nvar stackAlwaysDelimiterSequence = [{\n  type: \"small\",\n  style: Style$1.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.SCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.TEXT\n}, {\n  type: \"stack\"\n}]; // Delimiters that stack when large try the small and then large delimiters, and\n// stack afterwards\n\nvar stackLargeDelimiterSequence = [{\n  type: \"small\",\n  style: Style$1.SCRIPTSCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.SCRIPT\n}, {\n  type: \"small\",\n  style: Style$1.TEXT\n}, {\n  type: \"large\",\n  size: 1\n}, {\n  type: \"large\",\n  size: 2\n}, {\n  type: \"large\",\n  size: 3\n}, {\n  type: \"large\",\n  size: 4\n}, {\n  type: \"stack\"\n}];\n/**\n * Get the font used in a delimiter based on what kind of delimiter it is.\n * TODO(#963) Use more specific font family return type once that is introduced.\n */\n\nvar delimTypeToFont = function delimTypeToFont(type) {\n  if (type.type === \"small\") {\n    return \"Main-Regular\";\n  } else if (type.type === \"large\") {\n    return \"Size\" + type.size + \"-Regular\";\n  } else if (type.type === \"stack\") {\n    return \"Size4-Regular\";\n  } else {\n    throw new Error(\"Add support for delim type '\" + type.type + \"' here.\");\n  }\n};\n/**\n * Traverse a sequence of types of delimiters to decide what kind of delimiter\n * should be used to create a delimiter of the given height+depth.\n */\n\n\nvar traverseSequence = function traverseSequence(delim, height, sequence, options) {\n  // Here, we choose the index we should start at in the sequences. In smaller\n  // sizes (which correspond to larger numbers in style.size) we start earlier\n  // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts\n  // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2\n  var start = Math.min(2, 3 - options.style.size);\n\n  for (var i = start; i < sequence.length; i++) {\n    if (sequence[i].type === \"stack\") {\n      // This is always the last delimiter, so we just break the loop now.\n      break;\n    }\n\n    var metrics = getMetrics(delim, delimTypeToFont(sequence[i]), \"math\");\n    var heightDepth = metrics.height + metrics.depth; // Small delimiters are scaled down versions of the same font, so we\n    // account for the style change size.\n\n    if (sequence[i].type === \"small\") {\n      var newOptions = options.havingBaseStyle(sequence[i].style);\n      heightDepth *= newOptions.sizeMultiplier;\n    } // Check if the delimiter at this size works for the given height.\n\n\n    if (heightDepth > height) {\n      return sequence[i];\n    }\n  } // If we reached the end of the sequence, return the last sequence element.\n\n\n  return sequence[sequence.length - 1];\n};\n/**\n * Make a delimiter of a given height+depth, with optional centering. Here, we\n * traverse the sequences, and create a delimiter that the sequence tells us to.\n */\n\n\nvar makeCustomSizedDelim = function makeCustomSizedDelim(delim, height, center, options, mode, classes) {\n  if (delim === \"<\" || delim === \"\\\\lt\" || delim === \"\\u27e8\") {\n    delim = \"\\\\langle\";\n  } else if (delim === \">\" || delim === \"\\\\gt\" || delim === \"\\u27e9\") {\n    delim = \"\\\\rangle\";\n  } // Decide what sequence to use\n\n\n  var sequence;\n\n  if (stackNeverDelimiters.includes(delim)) {\n    sequence = stackNeverDelimiterSequence;\n  } else if (stackLargeDelimiters.includes(delim)) {\n    sequence = stackLargeDelimiterSequence;\n  } else {\n    sequence = stackAlwaysDelimiterSequence;\n  } // Look through the sequence\n\n\n  var delimType = traverseSequence(delim, height, sequence, options); // Get the delimiter from font glyphs.\n  // Depending on the sequence element we decided on, call the\n  // appropriate function.\n\n  if (delimType.type === \"small\") {\n    return makeSmallDelim(delim, delimType.style, center, options, mode, classes);\n  } else if (delimType.type === \"large\") {\n    return makeLargeDelim(delim, delimType.size, center, options, mode, classes);\n  } else\n    /* if (delimType.type === \"stack\") */\n    {\n      return makeStackedDelim(delim, height, center, options, mode, classes);\n    }\n};\n/**\n * Make a delimiter for use with `\\left` and `\\right`, given a height and depth\n * of an expression that the delimiters surround.\n */\n\n\nvar makeLeftRightDelim = function makeLeftRightDelim(delim, height, depth, options, mode, classes) {\n  // We always center \\left/\\right delimiters, so the axis is always shifted\n  var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier; // Taken from TeX source, tex.web, function make_left_right\n\n  var delimiterFactor = 901;\n  var delimiterExtend = 5.0 / options.fontMetrics().ptPerEm;\n  var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);\n  var totalHeight = Math.max( // In real TeX, calculations are done using integral values which are\n  // 65536 per pt, or 655360 per em. So, the division here truncates in\n  // TeX but doesn't here, producing different results. If we wanted to\n  // exactly match TeX's calculation, we could do\n  //   Math.floor(655360 * maxDistFromAxis / 500) *\n  //    delimiterFactor / 655360\n  // (To see the difference, compare\n  //    x^{x^{\\left(\\rule{0.1em}{0.68em}\\right)}}\n  // in TeX and KaTeX)\n  maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend); // Finally, we defer to `makeCustomSizedDelim` with our calculated total\n  // height\n\n  return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);\n};\n\nvar delimiter = {\n  sqrtImage: makeSqrtImage,\n  sizedDelim: makeSizedDelim,\n  sizeToMaxHeight: sizeToMaxHeight,\n  customSizedDelim: makeCustomSizedDelim,\n  leftRightDelim: makeLeftRightDelim\n};\n\n// Extra data needed for the delimiter handler down below\nvar delimiterSizes = {\n  \"\\\\bigl\": {\n    mclass: \"mopen\",\n    size: 1\n  },\n  \"\\\\Bigl\": {\n    mclass: \"mopen\",\n    size: 2\n  },\n  \"\\\\biggl\": {\n    mclass: \"mopen\",\n    size: 3\n  },\n  \"\\\\Biggl\": {\n    mclass: \"mopen\",\n    size: 4\n  },\n  \"\\\\bigr\": {\n    mclass: \"mclose\",\n    size: 1\n  },\n  \"\\\\Bigr\": {\n    mclass: \"mclose\",\n    size: 2\n  },\n  \"\\\\biggr\": {\n    mclass: \"mclose\",\n    size: 3\n  },\n  \"\\\\Biggr\": {\n    mclass: \"mclose\",\n    size: 4\n  },\n  \"\\\\bigm\": {\n    mclass: \"mrel\",\n    size: 1\n  },\n  \"\\\\Bigm\": {\n    mclass: \"mrel\",\n    size: 2\n  },\n  \"\\\\biggm\": {\n    mclass: \"mrel\",\n    size: 3\n  },\n  \"\\\\Biggm\": {\n    mclass: \"mrel\",\n    size: 4\n  },\n  \"\\\\big\": {\n    mclass: \"mord\",\n    size: 1\n  },\n  \"\\\\Big\": {\n    mclass: \"mord\",\n    size: 2\n  },\n  \"\\\\bigg\": {\n    mclass: \"mord\",\n    size: 3\n  },\n  \"\\\\Bigg\": {\n    mclass: \"mord\",\n    size: 4\n  }\n};\nvar delimiters = [\"(\", \"\\\\lparen\", \")\", \"\\\\rparen\", \"[\", \"\\\\lbrack\", \"]\", \"\\\\rbrack\", \"\\\\{\", \"\\\\lbrace\", \"\\\\}\", \"\\\\rbrace\", \"\\\\lfloor\", \"\\\\rfloor\", \"\\u230a\", \"\\u230b\", \"\\\\lceil\", \"\\\\rceil\", \"\\u2308\", \"\\u2309\", \"<\", \">\", \"\\\\langle\", \"\\u27e8\", \"\\\\rangle\", \"\\u27e9\", \"\\\\lt\", \"\\\\gt\", \"\\\\lvert\", \"\\\\rvert\", \"\\\\lVert\", \"\\\\rVert\", \"\\\\lgroup\", \"\\\\rgroup\", \"\\u27ee\", \"\\u27ef\", \"\\\\lmoustache\", \"\\\\rmoustache\", \"\\u23b0\", \"\\u23b1\", \"/\", \"\\\\backslash\", \"|\", \"\\\\vert\", \"\\\\|\", \"\\\\Vert\", \"\\\\uparrow\", \"\\\\Uparrow\", \"\\\\downarrow\", \"\\\\Downarrow\", \"\\\\updownarrow\", \"\\\\Updownarrow\", \".\"];\n\n// Delimiter functions\nfunction checkDelimiter(delim, context) {\n  var symDelim = checkSymbolNodeType(delim);\n\n  if (symDelim && delimiters.includes(symDelim.text)) {\n    return symDelim;\n  } else if (symDelim) {\n    throw new ParseError(\"Invalid delimiter '\" + symDelim.text + \"' after '\" + context.funcName + \"'\", delim);\n  } else {\n    throw new ParseError(\"Invalid delimiter type '\" + delim.type + \"'\", delim);\n  }\n}\n\ndefineFunction({\n  type: \"delimsizing\",\n  names: [\"\\\\bigl\", \"\\\\Bigl\", \"\\\\biggl\", \"\\\\Biggl\", \"\\\\bigr\", \"\\\\Bigr\", \"\\\\biggr\", \"\\\\Biggr\", \"\\\\bigm\", \"\\\\Bigm\", \"\\\\biggm\", \"\\\\Biggm\", \"\\\\big\", \"\\\\Big\", \"\\\\bigg\", \"\\\\Bigg\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"primitive\"]\n  },\n  handler: (context, args) => {\n    var delim = checkDelimiter(args[0], context);\n    return {\n      type: \"delimsizing\",\n      mode: context.parser.mode,\n      size: delimiterSizes[context.funcName].size,\n      mclass: delimiterSizes[context.funcName].mclass,\n      delim: delim.text\n    };\n  },\n  htmlBuilder: (group, options) => {\n    if (group.delim === \".\") {\n      // Empty delimiters still count as elements, even though they don't\n      // show anything.\n      return buildCommon.makeSpan([group.mclass]);\n    } // Use delimiter.sizedDelim to generate the delimiter.\n\n\n    return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);\n  },\n  mathmlBuilder: group => {\n    var children = [];\n\n    if (group.delim !== \".\") {\n      children.push(makeText(group.delim, group.mode));\n    }\n\n    var node = new mathMLTree.MathNode(\"mo\", children);\n\n    if (group.mclass === \"mopen\" || group.mclass === \"mclose\") {\n      // Only some of the delimsizing functions act as fences, and they\n      // return \"mopen\" or \"mclose\" mclass.\n      node.setAttribute(\"fence\", \"true\");\n    } else {\n      // Explicitly disable fencing if it's not a fence, to override the\n      // defaults.\n      node.setAttribute(\"fence\", \"false\");\n    }\n\n    node.setAttribute(\"stretchy\", \"true\");\n    var size = makeEm(delimiter.sizeToMaxHeight[group.size]);\n    node.setAttribute(\"minsize\", size);\n    node.setAttribute(\"maxsize\", size);\n    return node;\n  }\n});\n\nfunction assertParsed(group) {\n  if (!group.body) {\n    throw new Error(\"Bug: The leftright ParseNode wasn't fully parsed.\");\n  }\n}\n\ndefineFunction({\n  type: \"leftright-right\",\n  names: [\"\\\\right\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n  handler: (context, args) => {\n    // \\left case below triggers parsing of \\right in\n    //   `const right = parser.parseFunction();`\n    // uses this return value.\n    var color = context.parser.gullet.macros.get(\"\\\\current@color\");\n\n    if (color && typeof color !== \"string\") {\n      throw new ParseError(\"\\\\current@color set to non-string in \\\\right\");\n    }\n\n    return {\n      type: \"leftright-right\",\n      mode: context.parser.mode,\n      delim: checkDelimiter(args[0], context).text,\n      color // undefined if not set via \\color\n\n    };\n  }\n});\ndefineFunction({\n  type: \"leftright\",\n  names: [\"\\\\left\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n  handler: (context, args) => {\n    var delim = checkDelimiter(args[0], context);\n    var parser = context.parser; // Parse out the implicit body\n\n    ++parser.leftrightDepth; // parseExpression stops before '\\\\right'\n\n    var body = parser.parseExpression(false);\n    --parser.leftrightDepth; // Check the next token\n\n    parser.expect(\"\\\\right\", false);\n    var right = assertNodeType(parser.parseFunction(), \"leftright-right\");\n    return {\n      type: \"leftright\",\n      mode: parser.mode,\n      body,\n      left: delim.text,\n      right: right.delim,\n      rightColor: right.color\n    };\n  },\n  htmlBuilder: (group, options) => {\n    assertParsed(group); // Build the inner expression\n\n    var inner = buildExpression$1(group.body, options, true, [\"mopen\", \"mclose\"]);\n    var innerHeight = 0;\n    var innerDepth = 0;\n    var hadMiddle = false; // Calculate its height and depth\n\n    for (var i = 0; i < inner.length; i++) {\n      // Property `isMiddle` not defined on `span`. See comment in\n      // \"middle\"'s htmlBuilder.\n      // $FlowFixMe\n      if (inner[i].isMiddle) {\n        hadMiddle = true;\n      } else {\n        innerHeight = Math.max(inner[i].height, innerHeight);\n        innerDepth = Math.max(inner[i].depth, innerDepth);\n      }\n    } // The size of delimiters is the same, regardless of what style we are\n    // in. Thus, to correctly calculate the size of delimiter we need around\n    // a group, we scale down the inner size based on the size.\n\n\n    innerHeight *= options.sizeMultiplier;\n    innerDepth *= options.sizeMultiplier;\n    var leftDelim;\n\n    if (group.left === \".\") {\n      // Empty delimiters in \\left and \\right make null delimiter spaces.\n      leftDelim = makeNullDelimiter(options, [\"mopen\"]);\n    } else {\n      // Otherwise, use leftRightDelim to generate the correct sized\n      // delimiter.\n      leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, [\"mopen\"]);\n    } // Add it to the beginning of the expression\n\n\n    inner.unshift(leftDelim); // Handle middle delimiters\n\n    if (hadMiddle) {\n      for (var _i = 1; _i < inner.length; _i++) {\n        var middleDelim = inner[_i]; // Property `isMiddle` not defined on `span`. See comment in\n        // \"middle\"'s htmlBuilder.\n        // $FlowFixMe\n\n        var isMiddle = middleDelim.isMiddle;\n\n        if (isMiddle) {\n          // Apply the options that were active when \\middle was called\n          inner[_i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);\n        }\n      }\n    }\n\n    var rightDelim; // Same for the right delimiter, but using color specified by \\color\n\n    if (group.right === \".\") {\n      rightDelim = makeNullDelimiter(options, [\"mclose\"]);\n    } else {\n      var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;\n      rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, [\"mclose\"]);\n    } // Add it to the end of the expression.\n\n\n    inner.push(rightDelim);\n    return buildCommon.makeSpan([\"minner\"], inner, options);\n  },\n  mathmlBuilder: (group, options) => {\n    assertParsed(group);\n    var inner = buildExpression(group.body, options);\n\n    if (group.left !== \".\") {\n      var leftNode = new mathMLTree.MathNode(\"mo\", [makeText(group.left, group.mode)]);\n      leftNode.setAttribute(\"fence\", \"true\");\n      inner.unshift(leftNode);\n    }\n\n    if (group.right !== \".\") {\n      var rightNode = new mathMLTree.MathNode(\"mo\", [makeText(group.right, group.mode)]);\n      rightNode.setAttribute(\"fence\", \"true\");\n\n      if (group.rightColor) {\n        rightNode.setAttribute(\"mathcolor\", group.rightColor);\n      }\n\n      inner.push(rightNode);\n    }\n\n    return makeRow(inner);\n  }\n});\ndefineFunction({\n  type: \"middle\",\n  names: [\"\\\\middle\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n  handler: (context, args) => {\n    var delim = checkDelimiter(args[0], context);\n\n    if (!context.parser.leftrightDepth) {\n      throw new ParseError(\"\\\\middle without preceding \\\\left\", delim);\n    }\n\n    return {\n      type: \"middle\",\n      mode: context.parser.mode,\n      delim: delim.text\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var middleDelim;\n\n    if (group.delim === \".\") {\n      middleDelim = makeNullDelimiter(options, []);\n    } else {\n      middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);\n      var isMiddle = {\n        delim: group.delim,\n        options\n      }; // Property `isMiddle` not defined on `span`. It is only used in\n      // this file above.\n      // TODO: Fix this violation of the `span` type and possibly rename\n      // things since `isMiddle` sounds like a boolean, but is a struct.\n      // $FlowFixMe\n\n      middleDelim.isMiddle = isMiddle;\n    }\n\n    return middleDelim;\n  },\n  mathmlBuilder: (group, options) => {\n    // A Firefox \\middle will stretch a character vertically only if it\n    // is in the fence part of the operator dictionary at:\n    // https://www.w3.org/TR/MathML3/appendixc.html.\n    // So we need to avoid U+2223 and use plain \"|\" instead.\n    var textNode = group.delim === \"\\\\vert\" || group.delim === \"|\" ? makeText(\"|\", \"text\") : makeText(group.delim, group.mode);\n    var middleNode = new mathMLTree.MathNode(\"mo\", [textNode]);\n    middleNode.setAttribute(\"fence\", \"true\"); // MathML gives 5/18em spacing to each <mo> element.\n    // \\middle should get delimiter spacing instead.\n\n    middleNode.setAttribute(\"lspace\", \"0.05em\");\n    middleNode.setAttribute(\"rspace\", \"0.05em\");\n    return middleNode;\n  }\n});\n\nvar htmlBuilder$7 = (group, options) => {\n  // \\cancel, \\bcancel, \\xcancel, \\sout, \\fbox, \\colorbox, \\fcolorbox, \\phase\n  // Some groups can return document fragments.  Handle those by wrapping\n  // them in a span.\n  var inner = buildCommon.wrapFragment(buildGroup$1(group.body, options), options);\n  var label = group.label.slice(1);\n  var scale = options.sizeMultiplier;\n  var img;\n  var imgShift = 0; // In the LaTeX cancel package, line geometry is slightly different\n  // depending on whether the subject is wider than it is tall, or vice versa.\n  // We don't know the width of a group, so as a proxy, we test if\n  // the subject is a single character. This captures most of the\n  // subjects that should get the \"tall\" treatment.\n\n  var isSingleChar = utils.isCharacterBox(group.body);\n\n  if (label === \"sout\") {\n    img = buildCommon.makeSpan([\"stretchy\", \"sout\"]);\n    img.height = options.fontMetrics().defaultRuleThickness / scale;\n    imgShift = -0.5 * options.fontMetrics().xHeight;\n  } else if (label === \"phase\") {\n    // Set a couple of dimensions from the steinmetz package.\n    var lineWeight = calculateSize({\n      number: 0.6,\n      unit: \"pt\"\n    }, options);\n    var clearance = calculateSize({\n      number: 0.35,\n      unit: \"ex\"\n    }, options); // Prevent size changes like \\Huge from affecting line thickness\n\n    var newOptions = options.havingBaseSizing();\n    scale = scale / newOptions.sizeMultiplier;\n    var angleHeight = inner.height + inner.depth + lineWeight + clearance; // Reserve a left pad for the angle.\n\n    inner.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight); // Create an SVG\n\n    var viewBoxHeight = Math.floor(1000 * angleHeight * scale);\n    var path = phasePath(viewBoxHeight);\n    var svgNode = new SvgNode([new PathNode(\"phase\", path)], {\n      \"width\": \"400em\",\n      \"height\": makeEm(viewBoxHeight / 1000),\n      \"viewBox\": \"0 0 400000 \" + viewBoxHeight,\n      \"preserveAspectRatio\": \"xMinYMin slice\"\n    }); // Wrap it in a span with overflow: hidden.\n\n    img = buildCommon.makeSvgSpan([\"hide-tail\"], [svgNode], options);\n    img.style.height = makeEm(angleHeight);\n    imgShift = inner.depth + lineWeight + clearance;\n  } else {\n    // Add horizontal padding\n    if (/cancel/.test(label)) {\n      if (!isSingleChar) {\n        inner.classes.push(\"cancel-pad\");\n      }\n    } else if (label === \"angl\") {\n      inner.classes.push(\"anglpad\");\n    } else {\n      inner.classes.push(\"boxpad\");\n    } // Add vertical padding\n\n\n    var topPad = 0;\n    var bottomPad = 0;\n    var ruleThickness = 0; // ref: cancel package: \\advance\\totalheight2\\p@ % \"+2\"\n\n    if (/box/.test(label)) {\n      ruleThickness = Math.max(options.fontMetrics().fboxrule, // default\n      options.minRuleThickness // User override.\n      );\n      topPad = options.fontMetrics().fboxsep + (label === \"colorbox\" ? 0 : ruleThickness);\n      bottomPad = topPad;\n    } else if (label === \"angl\") {\n      ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);\n      topPad = 4 * ruleThickness; // gap = 3  line, plus the line itself.\n\n      bottomPad = Math.max(0, 0.25 - inner.depth);\n    } else {\n      topPad = isSingleChar ? 0.2 : 0;\n      bottomPad = topPad;\n    }\n\n    img = stretchy.encloseSpan(inner, label, topPad, bottomPad, options);\n\n    if (/fbox|boxed|fcolorbox/.test(label)) {\n      img.style.borderStyle = \"solid\";\n      img.style.borderWidth = makeEm(ruleThickness);\n    } else if (label === \"angl\" && ruleThickness !== 0.049) {\n      img.style.borderTopWidth = makeEm(ruleThickness);\n      img.style.borderRightWidth = makeEm(ruleThickness);\n    }\n\n    imgShift = inner.depth + bottomPad;\n\n    if (group.backgroundColor) {\n      img.style.backgroundColor = group.backgroundColor;\n\n      if (group.borderColor) {\n        img.style.borderColor = group.borderColor;\n      }\n    }\n  }\n\n  var vlist;\n\n  if (group.backgroundColor) {\n    vlist = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [// Put the color background behind inner;\n      {\n        type: \"elem\",\n        elem: img,\n        shift: imgShift\n      }, {\n        type: \"elem\",\n        elem: inner,\n        shift: 0\n      }]\n    }, options);\n  } else {\n    var classes = /cancel|phase/.test(label) ? [\"svg-align\"] : [];\n    vlist = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [// Write the \\cancel stroke on top of inner.\n      {\n        type: \"elem\",\n        elem: inner,\n        shift: 0\n      }, {\n        type: \"elem\",\n        elem: img,\n        shift: imgShift,\n        wrapperClasses: classes\n      }]\n    }, options);\n  }\n\n  if (/cancel/.test(label)) {\n    // The cancel package documentation says that cancel lines add their height\n    // to the expression, but tests show that isn't how it actually works.\n    vlist.height = inner.height;\n    vlist.depth = inner.depth;\n  }\n\n  if (/cancel/.test(label) && !isSingleChar) {\n    // cancel does not create horiz space for its line extension.\n    return buildCommon.makeSpan([\"mord\", \"cancel-lap\"], [vlist], options);\n  } else {\n    return buildCommon.makeSpan([\"mord\"], [vlist], options);\n  }\n};\n\nvar mathmlBuilder$6 = (group, options) => {\n  var fboxsep = 0;\n  var node = new mathMLTree.MathNode(group.label.indexOf(\"colorbox\") > -1 ? \"mpadded\" : \"menclose\", [buildGroup(group.body, options)]);\n\n  switch (group.label) {\n    case \"\\\\cancel\":\n      node.setAttribute(\"notation\", \"updiagonalstrike\");\n      break;\n\n    case \"\\\\bcancel\":\n      node.setAttribute(\"notation\", \"downdiagonalstrike\");\n      break;\n\n    case \"\\\\phase\":\n      node.setAttribute(\"notation\", \"phasorangle\");\n      break;\n\n    case \"\\\\sout\":\n      node.setAttribute(\"notation\", \"horizontalstrike\");\n      break;\n\n    case \"\\\\fbox\":\n      node.setAttribute(\"notation\", \"box\");\n      break;\n\n    case \"\\\\angl\":\n      node.setAttribute(\"notation\", \"actuarial\");\n      break;\n\n    case \"\\\\fcolorbox\":\n    case \"\\\\colorbox\":\n      // <menclose> doesn't have a good notation option. So use <mpadded>\n      // instead. Set some attributes that come included with <menclose>.\n      fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;\n      node.setAttribute(\"width\", \"+\" + 2 * fboxsep + \"pt\");\n      node.setAttribute(\"height\", \"+\" + 2 * fboxsep + \"pt\");\n      node.setAttribute(\"lspace\", fboxsep + \"pt\"); //\n\n      node.setAttribute(\"voffset\", fboxsep + \"pt\");\n\n      if (group.label === \"\\\\fcolorbox\") {\n        var thk = Math.max(options.fontMetrics().fboxrule, // default\n        options.minRuleThickness // user override\n        );\n        node.setAttribute(\"style\", \"border: \" + thk + \"em solid \" + String(group.borderColor));\n      }\n\n      break;\n\n    case \"\\\\xcancel\":\n      node.setAttribute(\"notation\", \"updiagonalstrike downdiagonalstrike\");\n      break;\n  }\n\n  if (group.backgroundColor) {\n    node.setAttribute(\"mathbackground\", group.backgroundColor);\n  }\n\n  return node;\n};\n\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\colorbox\"],\n  props: {\n    numArgs: 2,\n    allowedInText: true,\n    argTypes: [\"color\", \"text\"]\n  },\n\n  handler(_ref, args, optArgs) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var color = assertNodeType(args[0], \"color-token\").color;\n    var body = args[1];\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: funcName,\n      backgroundColor: color,\n      body\n    };\n  },\n\n  htmlBuilder: htmlBuilder$7,\n  mathmlBuilder: mathmlBuilder$6\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\fcolorbox\"],\n  props: {\n    numArgs: 3,\n    allowedInText: true,\n    argTypes: [\"color\", \"color\", \"text\"]\n  },\n\n  handler(_ref2, args, optArgs) {\n    var {\n      parser,\n      funcName\n    } = _ref2;\n    var borderColor = assertNodeType(args[0], \"color-token\").color;\n    var backgroundColor = assertNodeType(args[1], \"color-token\").color;\n    var body = args[2];\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: funcName,\n      backgroundColor,\n      borderColor,\n      body\n    };\n  },\n\n  htmlBuilder: htmlBuilder$7,\n  mathmlBuilder: mathmlBuilder$6\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\fbox\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"hbox\"],\n    allowedInText: true\n  },\n\n  handler(_ref3, args) {\n    var {\n      parser\n    } = _ref3;\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: \"\\\\fbox\",\n      body: args[0]\n    };\n  }\n\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\cancel\", \"\\\\bcancel\", \"\\\\xcancel\", \"\\\\sout\", \"\\\\phase\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref4, args) {\n    var {\n      parser,\n      funcName\n    } = _ref4;\n    var body = args[0];\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: funcName,\n      body\n    };\n  },\n\n  htmlBuilder: htmlBuilder$7,\n  mathmlBuilder: mathmlBuilder$6\n});\ndefineFunction({\n  type: \"enclose\",\n  names: [\"\\\\angl\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"hbox\"],\n    allowedInText: false\n  },\n\n  handler(_ref5, args) {\n    var {\n      parser\n    } = _ref5;\n    return {\n      type: \"enclose\",\n      mode: parser.mode,\n      label: \"\\\\angl\",\n      body: args[0]\n    };\n  }\n\n});\n\n/**\n * All registered environments.\n * `environments.js` exports this same dictionary again and makes it public.\n * `Parser.js` requires this dictionary via `environments.js`.\n */\nvar _environments = {};\nfunction defineEnvironment(_ref) {\n  var {\n    type,\n    names,\n    props,\n    handler,\n    htmlBuilder,\n    mathmlBuilder\n  } = _ref;\n  // Set default values of environments.\n  var data = {\n    type,\n    numArgs: props.numArgs || 0,\n    allowedInText: false,\n    numOptionalArgs: 0,\n    handler\n  };\n\n  for (var i = 0; i < names.length; ++i) {\n    // TODO: The value type of _environments should be a type union of all\n    // possible `EnvSpec<>` possibilities instead of `EnvSpec<*>`, which is\n    // an existential type.\n    _environments[names[i]] = data;\n  }\n\n  if (htmlBuilder) {\n    _htmlGroupBuilders[type] = htmlBuilder;\n  }\n\n  if (mathmlBuilder) {\n    _mathmlGroupBuilders[type] = mathmlBuilder;\n  }\n}\n\n/**\n * All registered global/built-in macros.\n * `macros.js` exports this same dictionary again and makes it public.\n * `Parser.js` requires this dictionary via `macros.js`.\n */\nvar _macros = {}; // This function might one day accept an additional argument and do more things.\n\nfunction defineMacro(name, body) {\n  _macros[name] = body;\n}\n\n// Helper functions\nfunction getHLines(parser) {\n  // Return an array. The array length = number of hlines.\n  // Each element in the array tells if the line is dashed.\n  var hlineInfo = [];\n  parser.consumeSpaces();\n  var nxt = parser.fetch().text;\n\n  if (nxt === \"\\\\relax\") {\n    // \\relax is an artifact of the \\cr macro below\n    parser.consume();\n    parser.consumeSpaces();\n    nxt = parser.fetch().text;\n  }\n\n  while (nxt === \"\\\\hline\" || nxt === \"\\\\hdashline\") {\n    parser.consume();\n    hlineInfo.push(nxt === \"\\\\hdashline\");\n    parser.consumeSpaces();\n    nxt = parser.fetch().text;\n  }\n\n  return hlineInfo;\n}\n\nvar validateAmsEnvironmentContext = context => {\n  var settings = context.parser.settings;\n\n  if (!settings.displayMode) {\n    throw new ParseError(\"{\" + context.envName + \"} can be used only in\" + \" display mode.\");\n  }\n}; // autoTag (an argument to parseArray) can be one of three values:\n// * undefined: Regular (not-top-level) array; no tags on each row\n// * true: Automatic equation numbering, overridable by \\tag\n// * false: Tags allowed on each row, but no automatic numbering\n// This function *doesn't* work with the \"split\" environment name.\n\n\nfunction getAutoTag(name) {\n  if (name.indexOf(\"ed\") === -1) {\n    return name.indexOf(\"*\") === -1;\n  } // return undefined;\n\n}\n/**\n * Parse the body of the environment, with rows delimited by \\\\ and\n * columns delimited by &, and create a nested list in row-major order\n * with one group per cell.  If given an optional argument style\n * (\"text\", \"display\", etc.), then each cell is cast into that style.\n */\n\n\nfunction parseArray(parser, _ref, style) {\n  var {\n    hskipBeforeAndAfter,\n    addJot,\n    cols,\n    arraystretch,\n    colSeparationType,\n    autoTag,\n    singleRow,\n    emptySingleRow,\n    maxNumCols,\n    leqno\n  } = _ref;\n  parser.gullet.beginGroup();\n\n  if (!singleRow) {\n    // \\cr is equivalent to \\\\ without the optional size argument (see below)\n    // TODO: provide helpful error when \\cr is used outside array environment\n    parser.gullet.macros.set(\"\\\\cr\", \"\\\\\\\\\\\\relax\");\n  } // Get current arraystretch if it's not set by the environment\n\n\n  if (!arraystretch) {\n    var stretch = parser.gullet.expandMacroAsText(\"\\\\arraystretch\");\n\n    if (stretch == null) {\n      // Default \\arraystretch from lttab.dtx\n      arraystretch = 1;\n    } else {\n      arraystretch = parseFloat(stretch);\n\n      if (!arraystretch || arraystretch < 0) {\n        throw new ParseError(\"Invalid \\\\arraystretch: \" + stretch);\n      }\n    }\n  } // Start group for first cell\n\n\n  parser.gullet.beginGroup();\n  var row = [];\n  var body = [row];\n  var rowGaps = [];\n  var hLinesBeforeRow = [];\n  var tags = autoTag != null ? [] : undefined; // amsmath uses \\global\\@eqnswtrue and \\global\\@eqnswfalse to represent\n  // whether this row should have an equation number.  Simulate this with\n  // a \\@eqnsw macro set to 1 or 0.\n\n  function beginRow() {\n    if (autoTag) {\n      parser.gullet.macros.set(\"\\\\@eqnsw\", \"1\", true);\n    }\n  }\n\n  function endRow() {\n    if (tags) {\n      if (parser.gullet.macros.get(\"\\\\df@tag\")) {\n        tags.push(parser.subparse([new Token(\"\\\\df@tag\")]));\n        parser.gullet.macros.set(\"\\\\df@tag\", undefined, true);\n      } else {\n        tags.push(Boolean(autoTag) && parser.gullet.macros.get(\"\\\\@eqnsw\") === \"1\");\n      }\n    }\n  }\n\n  beginRow(); // Test for \\hline at the top of the array.\n\n  hLinesBeforeRow.push(getHLines(parser));\n\n  while (true) {\n    // eslint-disable-line no-constant-condition\n    // Parse each cell in its own group (namespace)\n    var cell = parser.parseExpression(false, singleRow ? \"\\\\end\" : \"\\\\\\\\\");\n    parser.gullet.endGroup();\n    parser.gullet.beginGroup();\n    cell = {\n      type: \"ordgroup\",\n      mode: parser.mode,\n      body: cell\n    };\n\n    if (style) {\n      cell = {\n        type: \"styling\",\n        mode: parser.mode,\n        style,\n        body: [cell]\n      };\n    }\n\n    row.push(cell);\n    var next = parser.fetch().text;\n\n    if (next === \"&\") {\n      if (maxNumCols && row.length === maxNumCols) {\n        if (singleRow || colSeparationType) {\n          // {equation} or {split}\n          throw new ParseError(\"Too many tab characters: &\", parser.nextToken);\n        } else {\n          // {array} environment\n          parser.settings.reportNonstrict(\"textEnv\", \"Too few columns \" + \"specified in the {array} column argument.\");\n        }\n      }\n\n      parser.consume();\n    } else if (next === \"\\\\end\") {\n      endRow(); // Arrays terminate newlines with `\\crcr` which consumes a `\\cr` if\n      // the last line is empty.  However, AMS environments keep the\n      // empty row if it's the only one.\n      // NOTE: Currently, `cell` is the last item added into `row`.\n\n      if (row.length === 1 && cell.type === \"styling\" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {\n        body.pop();\n      }\n\n      if (hLinesBeforeRow.length < body.length + 1) {\n        hLinesBeforeRow.push([]);\n      }\n\n      break;\n    } else if (next === \"\\\\\\\\\") {\n      parser.consume();\n      var size = void 0; // \\def\\Let@{\\let\\\\\\math@cr}\n      // \\def\\math@cr{...\\math@cr@}\n      // \\def\\math@cr@{\\new@ifnextchar[\\math@cr@@{\\math@cr@@[\\z@]}}\n      // \\def\\math@cr@@[#1]{...\\math@cr@@@...}\n      // \\def\\math@cr@@@{\\cr}\n\n      if (parser.gullet.future().text !== \" \") {\n        size = parser.parseSizeGroup(true);\n      }\n\n      rowGaps.push(size ? size.value : null);\n      endRow(); // check for \\hline(s) following the row separator\n\n      hLinesBeforeRow.push(getHLines(parser));\n      row = [];\n      body.push(row);\n      beginRow();\n    } else {\n      throw new ParseError(\"Expected & or \\\\\\\\ or \\\\cr or \\\\end\", parser.nextToken);\n    }\n  } // End cell group\n\n\n  parser.gullet.endGroup(); // End array group defining \\cr\n\n  parser.gullet.endGroup();\n  return {\n    type: \"array\",\n    mode: parser.mode,\n    addJot,\n    arraystretch,\n    body,\n    cols,\n    rowGaps,\n    hskipBeforeAndAfter,\n    hLinesBeforeRow,\n    colSeparationType,\n    tags,\n    leqno\n  };\n} // Decides on a style for cells in an array according to whether the given\n// environment name starts with the letter 'd'.\n\n\nfunction dCellStyle(envName) {\n  if (envName.slice(0, 1) === \"d\") {\n    return \"display\";\n  } else {\n    return \"text\";\n  }\n}\n\nvar htmlBuilder$6 = function htmlBuilder(group, options) {\n  var r;\n  var c;\n  var nr = group.body.length;\n  var hLinesBeforeRow = group.hLinesBeforeRow;\n  var nc = 0;\n  var body = new Array(nr);\n  var hlines = [];\n  var ruleThickness = Math.max( // From LaTeX \\showthe\\arrayrulewidth. Equals 0.04 em.\n  options.fontMetrics().arrayRuleWidth, options.minRuleThickness // User override.\n  ); // Horizontal spacing\n\n  var pt = 1 / options.fontMetrics().ptPerEm;\n  var arraycolsep = 5 * pt; // default value, i.e. \\arraycolsep in article.cls\n\n  if (group.colSeparationType && group.colSeparationType === \"small\") {\n    // We're in a {smallmatrix}. Default column space is \\thickspace,\n    // i.e. 5/18em = 0.2778em, per amsmath.dtx for {smallmatrix}.\n    // But that needs adjustment because LaTeX applies \\scriptstyle to the\n    // entire array, including the colspace, but this function applies\n    // \\scriptstyle only inside each element.\n    var localMultiplier = options.havingStyle(Style$1.SCRIPT).sizeMultiplier;\n    arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);\n  } // Vertical spacing\n\n\n  var baselineskip = group.colSeparationType === \"CD\" ? calculateSize({\n    number: 3,\n    unit: \"ex\"\n  }, options) : 12 * pt; // see size10.clo\n  // Default \\jot from ltmath.dtx\n  // TODO(edemaine): allow overriding \\jot via \\setlength (#687)\n\n  var jot = 3 * pt;\n  var arrayskip = group.arraystretch * baselineskip;\n  var arstrutHeight = 0.7 * arrayskip; // \\strutbox in ltfsstrc.dtx and\n\n  var arstrutDepth = 0.3 * arrayskip; // \\@arstrutbox in lttab.dtx\n\n  var totalHeight = 0; // Set a position for \\hline(s) at the top of the array, if any.\n\n  function setHLinePos(hlinesInGap) {\n    for (var i = 0; i < hlinesInGap.length; ++i) {\n      if (i > 0) {\n        totalHeight += 0.25;\n      }\n\n      hlines.push({\n        pos: totalHeight,\n        isDashed: hlinesInGap[i]\n      });\n    }\n  }\n\n  setHLinePos(hLinesBeforeRow[0]);\n\n  for (r = 0; r < group.body.length; ++r) {\n    var inrow = group.body[r];\n    var height = arstrutHeight; // \\@array adds an \\@arstrut\n\n    var depth = arstrutDepth; // to each tow (via the template)\n\n    if (nc < inrow.length) {\n      nc = inrow.length;\n    }\n\n    var outrow = new Array(inrow.length);\n\n    for (c = 0; c < inrow.length; ++c) {\n      var elt = buildGroup$1(inrow[c], options);\n\n      if (depth < elt.depth) {\n        depth = elt.depth;\n      }\n\n      if (height < elt.height) {\n        height = elt.height;\n      }\n\n      outrow[c] = elt;\n    }\n\n    var rowGap = group.rowGaps[r];\n    var gap = 0;\n\n    if (rowGap) {\n      gap = calculateSize(rowGap, options);\n\n      if (gap > 0) {\n        // \\@argarraycr\n        gap += arstrutDepth;\n\n        if (depth < gap) {\n          depth = gap; // \\@xargarraycr\n        }\n\n        gap = 0;\n      }\n    } // In AMS multiline environments such as aligned and gathered, rows\n    // correspond to lines that have additional \\jot added to the\n    // \\baselineskip via \\openup.\n\n\n    if (group.addJot) {\n      depth += jot;\n    }\n\n    outrow.height = height;\n    outrow.depth = depth;\n    totalHeight += height;\n    outrow.pos = totalHeight;\n    totalHeight += depth + gap; // \\@yargarraycr\n\n    body[r] = outrow; // Set a position for \\hline(s), if any.\n\n    setHLinePos(hLinesBeforeRow[r + 1]);\n  }\n\n  var offset = totalHeight / 2 + options.fontMetrics().axisHeight;\n  var colDescriptions = group.cols || [];\n  var cols = [];\n  var colSep;\n  var colDescrNum;\n  var tagSpans = [];\n\n  if (group.tags && group.tags.some(tag => tag)) {\n    // An environment with manual tags and/or automatic equation numbers.\n    // Create node(s), the latter of which trigger CSS counter increment.\n    for (r = 0; r < nr; ++r) {\n      var rw = body[r];\n      var shift = rw.pos - offset;\n      var tag = group.tags[r];\n      var tagSpan = void 0;\n\n      if (tag === true) {\n        // automatic numbering\n        tagSpan = buildCommon.makeSpan([\"eqn-num\"], [], options);\n      } else if (tag === false) {\n        // \\nonumber/\\notag or starred environment\n        tagSpan = buildCommon.makeSpan([], [], options);\n      } else {\n        // manual \\tag\n        tagSpan = buildCommon.makeSpan([], buildExpression$1(tag, options, true), options);\n      }\n\n      tagSpan.depth = rw.depth;\n      tagSpan.height = rw.height;\n      tagSpans.push({\n        type: \"elem\",\n        elem: tagSpan,\n        shift\n      });\n    }\n  }\n\n  for (c = 0, colDescrNum = 0; // Continue while either there are more columns or more column\n  // descriptions, so trailing separators don't get lost.\n  c < nc || colDescrNum < colDescriptions.length; ++c, ++colDescrNum) {\n    var colDescr = colDescriptions[colDescrNum] || {};\n    var firstSeparator = true;\n\n    while (colDescr.type === \"separator\") {\n      // If there is more than one separator in a row, add a space\n      // between them.\n      if (!firstSeparator) {\n        colSep = buildCommon.makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);\n        cols.push(colSep);\n      }\n\n      if (colDescr.separator === \"|\" || colDescr.separator === \":\") {\n        var lineType = colDescr.separator === \"|\" ? \"solid\" : \"dashed\";\n        var separator = buildCommon.makeSpan([\"vertical-separator\"], [], options);\n        separator.style.height = makeEm(totalHeight);\n        separator.style.borderRightWidth = makeEm(ruleThickness);\n        separator.style.borderRightStyle = lineType;\n        separator.style.margin = \"0 \" + makeEm(-ruleThickness / 2);\n\n        var _shift = totalHeight - offset;\n\n        if (_shift) {\n          separator.style.verticalAlign = makeEm(-_shift);\n        }\n\n        cols.push(separator);\n      } else {\n        throw new ParseError(\"Invalid separator type: \" + colDescr.separator);\n      }\n\n      colDescrNum++;\n      colDescr = colDescriptions[colDescrNum] || {};\n      firstSeparator = false;\n    }\n\n    if (c >= nc) {\n      continue;\n    }\n\n    var sepwidth = void 0;\n\n    if (c > 0 || group.hskipBeforeAndAfter) {\n      sepwidth = utils.deflt(colDescr.pregap, arraycolsep);\n\n      if (sepwidth !== 0) {\n        colSep = buildCommon.makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = makeEm(sepwidth);\n        cols.push(colSep);\n      }\n    }\n\n    var col = [];\n\n    for (r = 0; r < nr; ++r) {\n      var row = body[r];\n      var elem = row[c];\n\n      if (!elem) {\n        continue;\n      }\n\n      var _shift2 = row.pos - offset;\n\n      elem.depth = row.depth;\n      elem.height = row.height;\n      col.push({\n        type: \"elem\",\n        elem: elem,\n        shift: _shift2\n      });\n    }\n\n    col = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: col\n    }, options);\n    col = buildCommon.makeSpan([\"col-align-\" + (colDescr.align || \"c\")], [col]);\n    cols.push(col);\n\n    if (c < nc - 1 || group.hskipBeforeAndAfter) {\n      sepwidth = utils.deflt(colDescr.postgap, arraycolsep);\n\n      if (sepwidth !== 0) {\n        colSep = buildCommon.makeSpan([\"arraycolsep\"], []);\n        colSep.style.width = makeEm(sepwidth);\n        cols.push(colSep);\n      }\n    }\n  }\n\n  body = buildCommon.makeSpan([\"mtable\"], cols); // Add \\hline(s), if any.\n\n  if (hlines.length > 0) {\n    var line = buildCommon.makeLineSpan(\"hline\", options, ruleThickness);\n    var dashes = buildCommon.makeLineSpan(\"hdashline\", options, ruleThickness);\n    var vListElems = [{\n      type: \"elem\",\n      elem: body,\n      shift: 0\n    }];\n\n    while (hlines.length > 0) {\n      var hline = hlines.pop();\n      var lineShift = hline.pos - offset;\n\n      if (hline.isDashed) {\n        vListElems.push({\n          type: \"elem\",\n          elem: dashes,\n          shift: lineShift\n        });\n      } else {\n        vListElems.push({\n          type: \"elem\",\n          elem: line,\n          shift: lineShift\n        });\n      }\n    }\n\n    body = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: vListElems\n    }, options);\n  }\n\n  if (tagSpans.length === 0) {\n    return buildCommon.makeSpan([\"mord\"], [body], options);\n  } else {\n    var eqnNumCol = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: tagSpans\n    }, options);\n    eqnNumCol = buildCommon.makeSpan([\"tag\"], [eqnNumCol], options);\n    return buildCommon.makeFragment([body, eqnNumCol]);\n  }\n};\n\nvar alignMap = {\n  c: \"center \",\n  l: \"left \",\n  r: \"right \"\n};\n\nvar mathmlBuilder$5 = function mathmlBuilder(group, options) {\n  var tbl = [];\n  var glue = new mathMLTree.MathNode(\"mtd\", [], [\"mtr-glue\"]);\n  var tag = new mathMLTree.MathNode(\"mtd\", [], [\"mml-eqn-num\"]);\n\n  for (var i = 0; i < group.body.length; i++) {\n    var rw = group.body[i];\n    var row = [];\n\n    for (var j = 0; j < rw.length; j++) {\n      row.push(new mathMLTree.MathNode(\"mtd\", [buildGroup(rw[j], options)]));\n    }\n\n    if (group.tags && group.tags[i]) {\n      row.unshift(glue);\n      row.push(glue);\n\n      if (group.leqno) {\n        row.unshift(tag);\n      } else {\n        row.push(tag);\n      }\n    }\n\n    tbl.push(new mathMLTree.MathNode(\"mtr\", row));\n  }\n\n  var table = new mathMLTree.MathNode(\"mtable\", tbl); // Set column alignment, row spacing, column spacing, and\n  // array lines by setting attributes on the table element.\n  // Set the row spacing. In MathML, we specify a gap distance.\n  // We do not use rowGap[] because MathML automatically increases\n  // cell height with the height/depth of the element content.\n  // LaTeX \\arraystretch multiplies the row baseline-to-baseline distance.\n  // We simulate this by adding (arraystretch - 1)em to the gap. This\n  // does a reasonable job of adjusting arrays containing 1 em tall content.\n  // The 0.16 and 0.09 values are found empirically. They produce an array\n  // similar to LaTeX and in which content does not interfere with \\hlines.\n\n  var gap = group.arraystretch === 0.5 ? 0.1 // {smallmatrix}, {subarray}\n  : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);\n  table.setAttribute(\"rowspacing\", makeEm(gap)); // MathML table lines go only between cells.\n  // To place a line on an edge we'll use <menclose>, if necessary.\n\n  var menclose = \"\";\n  var align = \"\";\n\n  if (group.cols && group.cols.length > 0) {\n    // Find column alignment, column spacing, and  vertical lines.\n    var cols = group.cols;\n    var columnLines = \"\";\n    var prevTypeWasAlign = false;\n    var iStart = 0;\n    var iEnd = cols.length;\n\n    if (cols[0].type === \"separator\") {\n      menclose += \"top \";\n      iStart = 1;\n    }\n\n    if (cols[cols.length - 1].type === \"separator\") {\n      menclose += \"bottom \";\n      iEnd -= 1;\n    }\n\n    for (var _i = iStart; _i < iEnd; _i++) {\n      if (cols[_i].type === \"align\") {\n        align += alignMap[cols[_i].align];\n\n        if (prevTypeWasAlign) {\n          columnLines += \"none \";\n        }\n\n        prevTypeWasAlign = true;\n      } else if (cols[_i].type === \"separator\") {\n        // MathML accepts only single lines between cells.\n        // So we read only the first of consecutive separators.\n        if (prevTypeWasAlign) {\n          columnLines += cols[_i].separator === \"|\" ? \"solid \" : \"dashed \";\n          prevTypeWasAlign = false;\n        }\n      }\n    }\n\n    table.setAttribute(\"columnalign\", align.trim());\n\n    if (/[sd]/.test(columnLines)) {\n      table.setAttribute(\"columnlines\", columnLines.trim());\n    }\n  } // Set column spacing.\n\n\n  if (group.colSeparationType === \"align\") {\n    var _cols = group.cols || [];\n\n    var spacing = \"\";\n\n    for (var _i2 = 1; _i2 < _cols.length; _i2++) {\n      spacing += _i2 % 2 ? \"0em \" : \"1em \";\n    }\n\n    table.setAttribute(\"columnspacing\", spacing.trim());\n  } else if (group.colSeparationType === \"alignat\" || group.colSeparationType === \"gather\") {\n    table.setAttribute(\"columnspacing\", \"0em\");\n  } else if (group.colSeparationType === \"small\") {\n    table.setAttribute(\"columnspacing\", \"0.2778em\");\n  } else if (group.colSeparationType === \"CD\") {\n    table.setAttribute(\"columnspacing\", \"0.5em\");\n  } else {\n    table.setAttribute(\"columnspacing\", \"1em\");\n  } // Address \\hline and \\hdashline\n\n\n  var rowLines = \"\";\n  var hlines = group.hLinesBeforeRow;\n  menclose += hlines[0].length > 0 ? \"left \" : \"\";\n  menclose += hlines[hlines.length - 1].length > 0 ? \"right \" : \"\";\n\n  for (var _i3 = 1; _i3 < hlines.length - 1; _i3++) {\n    rowLines += hlines[_i3].length === 0 ? \"none \" // MathML accepts only a single line between rows. Read one element.\n    : hlines[_i3][0] ? \"dashed \" : \"solid \";\n  }\n\n  if (/[sd]/.test(rowLines)) {\n    table.setAttribute(\"rowlines\", rowLines.trim());\n  }\n\n  if (menclose !== \"\") {\n    table = new mathMLTree.MathNode(\"menclose\", [table]);\n    table.setAttribute(\"notation\", menclose.trim());\n  }\n\n  if (group.arraystretch && group.arraystretch < 1) {\n    // A small array. Wrap in scriptstyle so row gap is not too large.\n    table = new mathMLTree.MathNode(\"mstyle\", [table]);\n    table.setAttribute(\"scriptlevel\", \"1\");\n  }\n\n  return table;\n}; // Convenience function for align, align*, aligned, alignat, alignat*, alignedat.\n\n\nvar alignedHandler = function alignedHandler(context, args) {\n  if (context.envName.indexOf(\"ed\") === -1) {\n    validateAmsEnvironmentContext(context);\n  }\n\n  var cols = [];\n  var separationType = context.envName.indexOf(\"at\") > -1 ? \"alignat\" : \"align\";\n  var isSplit = context.envName === \"split\";\n  var res = parseArray(context.parser, {\n    cols,\n    addJot: true,\n    autoTag: isSplit ? undefined : getAutoTag(context.envName),\n    emptySingleRow: true,\n    colSeparationType: separationType,\n    maxNumCols: isSplit ? 2 : undefined,\n    leqno: context.parser.settings.leqno\n  }, \"display\"); // Determining number of columns.\n  // 1. If the first argument is given, we use it as a number of columns,\n  //    and makes sure that each row doesn't exceed that number.\n  // 2. Otherwise, just count number of columns = maximum number\n  //    of cells in each row (\"aligned\" mode -- isAligned will be true).\n  //\n  // At the same time, prepend empty group {} at beginning of every second\n  // cell in each row (starting with second cell) so that operators become\n  // binary.  This behavior is implemented in amsmath's \\start@aligned.\n\n  var numMaths;\n  var numCols = 0;\n  var emptyGroup = {\n    type: \"ordgroup\",\n    mode: context.mode,\n    body: []\n  };\n\n  if (args[0] && args[0].type === \"ordgroup\") {\n    var arg0 = \"\";\n\n    for (var i = 0; i < args[0].body.length; i++) {\n      var textord = assertNodeType(args[0].body[i], \"textord\");\n      arg0 += textord.text;\n    }\n\n    numMaths = Number(arg0);\n    numCols = numMaths * 2;\n  }\n\n  var isAligned = !numCols;\n  res.body.forEach(function (row) {\n    for (var _i4 = 1; _i4 < row.length; _i4 += 2) {\n      // Modify ordgroup node within styling node\n      var styling = assertNodeType(row[_i4], \"styling\");\n      var ordgroup = assertNodeType(styling.body[0], \"ordgroup\");\n      ordgroup.body.unshift(emptyGroup);\n    }\n\n    if (!isAligned) {\n      // Case 1\n      var curMaths = row.length / 2;\n\n      if (numMaths < curMaths) {\n        throw new ParseError(\"Too many math in a row: \" + (\"expected \" + numMaths + \", but got \" + curMaths), row[0]);\n      }\n    } else if (numCols < row.length) {\n      // Case 2\n      numCols = row.length;\n    }\n  }); // Adjusting alignment.\n  // In aligned mode, we add one \\qquad between columns;\n  // otherwise we add nothing.\n\n  for (var _i5 = 0; _i5 < numCols; ++_i5) {\n    var align = \"r\";\n    var pregap = 0;\n\n    if (_i5 % 2 === 1) {\n      align = \"l\";\n    } else if (_i5 > 0 && isAligned) {\n      // \"aligned\" mode.\n      pregap = 1; // add one \\quad\n    }\n\n    cols[_i5] = {\n      type: \"align\",\n      align: align,\n      pregap: pregap,\n      postgap: 0\n    };\n  }\n\n  res.colSeparationType = isAligned ? \"align\" : \"alignat\";\n  return res;\n}; // Arrays are part of LaTeX, defined in lttab.dtx so its documentation\n// is part of the source2e.pdf file of LaTeX2e source documentation.\n// {darray} is an {array} environment where cells are set in \\displaystyle,\n// as defined in nccmath.sty.\n\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"array\", \"darray\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(context, args) {\n    // Since no types are specified above, the two possibilities are\n    // - The argument is wrapped in {} or [], in which case Parser's\n    //   parseGroup() returns an \"ordgroup\" wrapping some symbol node.\n    // - The argument is a bare symbol node.\n    var symNode = checkSymbolNodeType(args[0]);\n    var colalign = symNode ? [args[0]] : assertNodeType(args[0], \"ordgroup\").body;\n    var cols = colalign.map(function (nde) {\n      var node = assertSymbolNodeType(nde);\n      var ca = node.text;\n\n      if (\"lcr\".indexOf(ca) !== -1) {\n        return {\n          type: \"align\",\n          align: ca\n        };\n      } else if (ca === \"|\") {\n        return {\n          type: \"separator\",\n          separator: \"|\"\n        };\n      } else if (ca === \":\") {\n        return {\n          type: \"separator\",\n          separator: \":\"\n        };\n      }\n\n      throw new ParseError(\"Unknown column alignment: \" + ca, nde);\n    });\n    var res = {\n      cols,\n      hskipBeforeAndAfter: true,\n      // \\@preamble in lttab.dtx\n      maxNumCols: cols.length\n    };\n    return parseArray(context.parser, res, dCellStyle(context.envName));\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n}); // The matrix environments of amsmath builds on the array environment\n// of LaTeX, which is discussed above.\n// The mathtools package adds starred versions of the same environments.\n// These have an optional argument to choose left|center|right justification.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"matrix\", \"pmatrix\", \"bmatrix\", \"Bmatrix\", \"vmatrix\", \"Vmatrix\", \"matrix*\", \"pmatrix*\", \"bmatrix*\", \"Bmatrix*\", \"vmatrix*\", \"Vmatrix*\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    var delimiters = {\n      \"matrix\": null,\n      \"pmatrix\": [\"(\", \")\"],\n      \"bmatrix\": [\"[\", \"]\"],\n      \"Bmatrix\": [\"\\\\{\", \"\\\\}\"],\n      \"vmatrix\": [\"|\", \"|\"],\n      \"Vmatrix\": [\"\\\\Vert\", \"\\\\Vert\"]\n    }[context.envName.replace(\"*\", \"\")]; // \\hskip -\\arraycolsep in amsmath\n\n    var colAlign = \"c\";\n    var payload = {\n      hskipBeforeAndAfter: false,\n      cols: [{\n        type: \"align\",\n        align: colAlign\n      }]\n    };\n\n    if (context.envName.charAt(context.envName.length - 1) === \"*\") {\n      // It's one of the mathtools starred functions.\n      // Parse the optional alignment argument.\n      var parser = context.parser;\n      parser.consumeSpaces();\n\n      if (parser.fetch().text === \"[\") {\n        parser.consume();\n        parser.consumeSpaces();\n        colAlign = parser.fetch().text;\n\n        if (\"lcr\".indexOf(colAlign) === -1) {\n          throw new ParseError(\"Expected l or c or r\", parser.nextToken);\n        }\n\n        parser.consume();\n        parser.consumeSpaces();\n        parser.expect(\"]\");\n        parser.consume();\n        payload.cols = [{\n          type: \"align\",\n          align: colAlign\n        }];\n      }\n    }\n\n    var res = parseArray(context.parser, payload, dCellStyle(context.envName)); // Populate cols with the correct number of column alignment specs.\n\n    var numCols = Math.max(0, ...res.body.map(row => row.length));\n    res.cols = new Array(numCols).fill({\n      type: \"align\",\n      align: colAlign\n    });\n    return delimiters ? {\n      type: \"leftright\",\n      mode: context.mode,\n      body: [res],\n      left: delimiters[0],\n      right: delimiters[1],\n      rightColor: undefined // \\right uninfluenced by \\color in array\n\n    } : res;\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"smallmatrix\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    var payload = {\n      arraystretch: 0.5\n    };\n    var res = parseArray(context.parser, payload, \"script\");\n    res.colSeparationType = \"small\";\n    return res;\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"subarray\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(context, args) {\n    // Parsing of {subarray} is similar to {array}\n    var symNode = checkSymbolNodeType(args[0]);\n    var colalign = symNode ? [args[0]] : assertNodeType(args[0], \"ordgroup\").body;\n    var cols = colalign.map(function (nde) {\n      var node = assertSymbolNodeType(nde);\n      var ca = node.text; // {subarray} only recognizes \"l\" & \"c\"\n\n      if (\"lc\".indexOf(ca) !== -1) {\n        return {\n          type: \"align\",\n          align: ca\n        };\n      }\n\n      throw new ParseError(\"Unknown column alignment: \" + ca, nde);\n    });\n\n    if (cols.length > 1) {\n      throw new ParseError(\"{subarray} can contain only one column\");\n    }\n\n    var res = {\n      cols,\n      hskipBeforeAndAfter: false,\n      arraystretch: 0.5\n    };\n    res = parseArray(context.parser, res, \"script\");\n\n    if (res.body.length > 0 && res.body[0].length > 1) {\n      throw new ParseError(\"{subarray} can contain only one column\");\n    }\n\n    return res;\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n}); // A cases environment (in amsmath.sty) is almost equivalent to\n// \\def\\arraystretch{1.2}%\n// \\left\\{\\begin{array}{@{}l@{\\quad}l@{}}  \\end{array}\\right.\n// {dcases} is a {cases} environment where cells are set in \\displaystyle,\n// as defined in mathtools.sty.\n// {rcases} is another mathtools environment. It's brace is on the right side.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"cases\", \"dcases\", \"rcases\", \"drcases\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    var payload = {\n      arraystretch: 1.2,\n      cols: [{\n        type: \"align\",\n        align: \"l\",\n        pregap: 0,\n        // TODO(kevinb) get the current style.\n        // For now we use the metrics for TEXT style which is what we were\n        // doing before.  Before attempting to get the current style we\n        // should look at TeX's behavior especially for \\over and matrices.\n        postgap: 1.0\n        /* 1em quad */\n\n      }, {\n        type: \"align\",\n        align: \"l\",\n        pregap: 0,\n        postgap: 0\n      }]\n    };\n    var res = parseArray(context.parser, payload, dCellStyle(context.envName));\n    return {\n      type: \"leftright\",\n      mode: context.mode,\n      body: [res],\n      left: context.envName.indexOf(\"r\") > -1 ? \".\" : \"\\\\{\",\n      right: context.envName.indexOf(\"r\") > -1 ? \"\\\\}\" : \".\",\n      rightColor: undefined\n    };\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n}); // In the align environment, one uses ampersands, &, to specify number of\n// columns in each row, and to locate spacing between each column.\n// align gets automatic numbering. align* and aligned do not.\n// The alignedat environment can be used in math mode.\n// Note that we assume \\nomallineskiplimit to be zero,\n// so that \\strut@ is the same as \\strut.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"align\", \"align*\", \"aligned\", \"split\"],\n  props: {\n    numArgs: 0\n  },\n  handler: alignedHandler,\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n}); // A gathered environment is like an array environment with one centered\n// column, but where rows are considered lines so get \\jot line spacing\n// and contents are set in \\displaystyle.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"gathered\", \"gather\", \"gather*\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    if ([\"gather\", \"gather*\"].includes(context.envName)) {\n      validateAmsEnvironmentContext(context);\n    }\n\n    var res = {\n      cols: [{\n        type: \"align\",\n        align: \"c\"\n      }],\n      addJot: true,\n      colSeparationType: \"gather\",\n      autoTag: getAutoTag(context.envName),\n      emptySingleRow: true,\n      leqno: context.parser.settings.leqno\n    };\n    return parseArray(context.parser, res, \"display\");\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n}); // alignat environment is like an align environment, but one must explicitly\n// specify maximum number of columns in each row, and can adjust spacing between\n// each columns.\n\ndefineEnvironment({\n  type: \"array\",\n  names: [\"alignat\", \"alignat*\", \"alignedat\"],\n  props: {\n    numArgs: 1\n  },\n  handler: alignedHandler,\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"equation\", \"equation*\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    validateAmsEnvironmentContext(context);\n    var res = {\n      autoTag: getAutoTag(context.envName),\n      emptySingleRow: true,\n      singleRow: true,\n      maxNumCols: 1,\n      leqno: context.parser.settings.leqno\n    };\n    return parseArray(context.parser, res, \"display\");\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n});\ndefineEnvironment({\n  type: \"array\",\n  names: [\"CD\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(context) {\n    validateAmsEnvironmentContext(context);\n    return parseCD(context.parser);\n  },\n\n  htmlBuilder: htmlBuilder$6,\n  mathmlBuilder: mathmlBuilder$5\n});\ndefineMacro(\"\\\\nonumber\", \"\\\\gdef\\\\@eqnsw{0}\");\ndefineMacro(\"\\\\notag\", \"\\\\nonumber\"); // Catch \\hline outside array environment\n\ndefineFunction({\n  type: \"text\",\n  // Doesn't matter what this is.\n  names: [\"\\\\hline\", \"\\\\hdashline\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    allowedInMath: true\n  },\n\n  handler(context, args) {\n    throw new ParseError(context.funcName + \" valid only within array environment\");\n  }\n\n});\n\nvar environments = _environments;\n\n// defineEnvironment definitions.\n\ndefineFunction({\n  type: \"environment\",\n  names: [\"\\\\begin\", \"\\\\end\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"text\"]\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var nameGroup = args[0];\n\n    if (nameGroup.type !== \"ordgroup\") {\n      throw new ParseError(\"Invalid environment name\", nameGroup);\n    }\n\n    var envName = \"\";\n\n    for (var i = 0; i < nameGroup.body.length; ++i) {\n      envName += assertNodeType(nameGroup.body[i], \"textord\").text;\n    }\n\n    if (funcName === \"\\\\begin\") {\n      // begin...end is similar to left...right\n      if (!environments.hasOwnProperty(envName)) {\n        throw new ParseError(\"No such environment: \" + envName, nameGroup);\n      } // Build the environment object. Arguments and other information will\n      // be made available to the begin and end methods using properties.\n\n\n      var env = environments[envName];\n      var {\n        args: _args,\n        optArgs\n      } = parser.parseArguments(\"\\\\begin{\" + envName + \"}\", env);\n      var context = {\n        mode: parser.mode,\n        envName,\n        parser\n      };\n      var result = env.handler(context, _args, optArgs);\n      parser.expect(\"\\\\end\", false);\n      var endNameToken = parser.nextToken;\n      var end = assertNodeType(parser.parseFunction(), \"environment\");\n\n      if (end.name !== envName) {\n        throw new ParseError(\"Mismatch: \\\\begin{\" + envName + \"} matched by \\\\end{\" + end.name + \"}\", endNameToken);\n      } // $FlowFixMe, \"environment\" handler returns an environment ParseNode\n\n\n      return result;\n    }\n\n    return {\n      type: \"environment\",\n      mode: parser.mode,\n      name: envName,\n      nameGroup\n    };\n  }\n\n});\n\n// TODO(kevinb): implement \\\\sl and \\\\sc\n\nvar htmlBuilder$5 = (group, options) => {\n  var font = group.font;\n  var newOptions = options.withFont(font);\n  return buildGroup$1(group.body, newOptions);\n};\n\nvar mathmlBuilder$4 = (group, options) => {\n  var font = group.font;\n  var newOptions = options.withFont(font);\n  return buildGroup(group.body, newOptions);\n};\n\nvar fontAliases = {\n  \"\\\\Bbb\": \"\\\\mathbb\",\n  \"\\\\bold\": \"\\\\mathbf\",\n  \"\\\\frak\": \"\\\\mathfrak\",\n  \"\\\\bm\": \"\\\\boldsymbol\"\n};\ndefineFunction({\n  type: \"font\",\n  names: [// styles, except \\boldsymbol defined below\n  \"\\\\mathrm\", \"\\\\mathit\", \"\\\\mathbf\", \"\\\\mathnormal\", \"\\\\mathsfit\", // families\n  \"\\\\mathbb\", \"\\\\mathcal\", \"\\\\mathfrak\", \"\\\\mathscr\", \"\\\\mathsf\", \"\\\\mathtt\", // aliases, except \\bm defined below\n  \"\\\\Bbb\", \"\\\\bold\", \"\\\\frak\"],\n  props: {\n    numArgs: 1,\n    allowedInArgument: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var body = normalizeArgument(args[0]);\n    var func = funcName;\n\n    if (func in fontAliases) {\n      func = fontAliases[func];\n    }\n\n    return {\n      type: \"font\",\n      mode: parser.mode,\n      font: func.slice(1),\n      body\n    };\n  },\n  htmlBuilder: htmlBuilder$5,\n  mathmlBuilder: mathmlBuilder$4\n});\ndefineFunction({\n  type: \"mclass\",\n  names: [\"\\\\boldsymbol\", \"\\\\bm\"],\n  props: {\n    numArgs: 1\n  },\n  handler: (_ref2, args) => {\n    var {\n      parser\n    } = _ref2;\n    var body = args[0];\n    var isCharacterBox = utils.isCharacterBox(body); // amsbsy.sty's \\boldsymbol uses \\binrel spacing to inherit the\n    // argument's bin|rel|ord status\n\n    return {\n      type: \"mclass\",\n      mode: parser.mode,\n      mclass: binrelClass(body),\n      body: [{\n        type: \"font\",\n        mode: parser.mode,\n        font: \"boldsymbol\",\n        body\n      }],\n      isCharacterBox: isCharacterBox\n    };\n  }\n}); // Old font changing functions\n\ndefineFunction({\n  type: \"font\",\n  names: [\"\\\\rm\", \"\\\\sf\", \"\\\\tt\", \"\\\\bf\", \"\\\\it\", \"\\\\cal\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n  handler: (_ref3, args) => {\n    var {\n      parser,\n      funcName,\n      breakOnTokenText\n    } = _ref3;\n    var {\n      mode\n    } = parser;\n    var body = parser.parseExpression(true, breakOnTokenText);\n    var style = \"math\" + funcName.slice(1);\n    return {\n      type: \"font\",\n      mode: mode,\n      font: style,\n      body: {\n        type: \"ordgroup\",\n        mode: parser.mode,\n        body\n      }\n    };\n  },\n  htmlBuilder: htmlBuilder$5,\n  mathmlBuilder: mathmlBuilder$4\n});\n\nvar adjustStyle = (size, originalStyle) => {\n  // Figure out what style this fraction should be in based on the\n  // function used\n  var style = originalStyle;\n\n  if (size === \"display\") {\n    // Get display style as a default.\n    // If incoming style is sub/sup, use style.text() to get correct size.\n    style = style.id >= Style$1.SCRIPT.id ? style.text() : Style$1.DISPLAY;\n  } else if (size === \"text\" && style.size === Style$1.DISPLAY.size) {\n    // We're in a \\tfrac but incoming style is displaystyle, so:\n    style = Style$1.TEXT;\n  } else if (size === \"script\") {\n    style = Style$1.SCRIPT;\n  } else if (size === \"scriptscript\") {\n    style = Style$1.SCRIPTSCRIPT;\n  }\n\n  return style;\n};\n\nvar htmlBuilder$4 = (group, options) => {\n  // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).\n  var style = adjustStyle(group.size, options.style);\n  var nstyle = style.fracNum();\n  var dstyle = style.fracDen();\n  var newOptions;\n  newOptions = options.havingStyle(nstyle);\n  var numerm = buildGroup$1(group.numer, newOptions, options);\n\n  if (group.continued) {\n    // \\cfrac inserts a \\strut into the numerator.\n    // Get \\strut dimensions from TeXbook page 353.\n    var hStrut = 8.5 / options.fontMetrics().ptPerEm;\n    var dStrut = 3.5 / options.fontMetrics().ptPerEm;\n    numerm.height = numerm.height < hStrut ? hStrut : numerm.height;\n    numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;\n  }\n\n  newOptions = options.havingStyle(dstyle);\n  var denomm = buildGroup$1(group.denom, newOptions, options);\n  var rule;\n  var ruleWidth;\n  var ruleSpacing;\n\n  if (group.hasBarLine) {\n    if (group.barSize) {\n      ruleWidth = calculateSize(group.barSize, options);\n      rule = buildCommon.makeLineSpan(\"frac-line\", options, ruleWidth);\n    } else {\n      rule = buildCommon.makeLineSpan(\"frac-line\", options);\n    }\n\n    ruleWidth = rule.height;\n    ruleSpacing = rule.height;\n  } else {\n    rule = null;\n    ruleWidth = 0;\n    ruleSpacing = options.fontMetrics().defaultRuleThickness;\n  } // Rule 15b\n\n\n  var numShift;\n  var clearance;\n  var denomShift;\n\n  if (style.size === Style$1.DISPLAY.size || group.size === \"display\") {\n    numShift = options.fontMetrics().num1;\n\n    if (ruleWidth > 0) {\n      clearance = 3 * ruleSpacing;\n    } else {\n      clearance = 7 * ruleSpacing;\n    }\n\n    denomShift = options.fontMetrics().denom1;\n  } else {\n    if (ruleWidth > 0) {\n      numShift = options.fontMetrics().num2;\n      clearance = ruleSpacing;\n    } else {\n      numShift = options.fontMetrics().num3;\n      clearance = 3 * ruleSpacing;\n    }\n\n    denomShift = options.fontMetrics().denom2;\n  }\n\n  var frac;\n\n  if (!rule) {\n    // Rule 15c\n    var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);\n\n    if (candidateClearance < clearance) {\n      numShift += 0.5 * (clearance - candidateClearance);\n      denomShift += 0.5 * (clearance - candidateClearance);\n    }\n\n    frac = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [{\n        type: \"elem\",\n        elem: denomm,\n        shift: denomShift\n      }, {\n        type: \"elem\",\n        elem: numerm,\n        shift: -numShift\n      }]\n    }, options);\n  } else {\n    // Rule 15d\n    var axisHeight = options.fontMetrics().axisHeight;\n\n    if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {\n      numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));\n    }\n\n    if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {\n      denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));\n    }\n\n    var midShift = -(axisHeight - 0.5 * ruleWidth);\n    frac = buildCommon.makeVList({\n      positionType: \"individualShift\",\n      children: [{\n        type: \"elem\",\n        elem: denomm,\n        shift: denomShift\n      }, {\n        type: \"elem\",\n        elem: rule,\n        shift: midShift\n      }, {\n        type: \"elem\",\n        elem: numerm,\n        shift: -numShift\n      }]\n    }, options);\n  } // Since we manually change the style sometimes (with \\dfrac or \\tfrac),\n  // account for the possible size change here.\n\n\n  newOptions = options.havingStyle(style);\n  frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;\n  frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier; // Rule 15e\n\n  var delimSize;\n\n  if (style.size === Style$1.DISPLAY.size) {\n    delimSize = options.fontMetrics().delim1;\n  } else if (style.size === Style$1.SCRIPTSCRIPT.size) {\n    delimSize = options.havingStyle(Style$1.SCRIPT).fontMetrics().delim2;\n  } else {\n    delimSize = options.fontMetrics().delim2;\n  }\n\n  var leftDelim;\n  var rightDelim;\n\n  if (group.leftDelim == null) {\n    leftDelim = makeNullDelimiter(options, [\"mopen\"]);\n  } else {\n    leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, [\"mopen\"]);\n  }\n\n  if (group.continued) {\n    rightDelim = buildCommon.makeSpan([]); // zero width for \\cfrac\n  } else if (group.rightDelim == null) {\n    rightDelim = makeNullDelimiter(options, [\"mclose\"]);\n  } else {\n    rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, [\"mclose\"]);\n  }\n\n  return buildCommon.makeSpan([\"mord\"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan([\"mfrac\"], [frac]), rightDelim], options);\n};\n\nvar mathmlBuilder$3 = (group, options) => {\n  var node = new mathMLTree.MathNode(\"mfrac\", [buildGroup(group.numer, options), buildGroup(group.denom, options)]);\n\n  if (!group.hasBarLine) {\n    node.setAttribute(\"linethickness\", \"0px\");\n  } else if (group.barSize) {\n    var ruleWidth = calculateSize(group.barSize, options);\n    node.setAttribute(\"linethickness\", makeEm(ruleWidth));\n  }\n\n  var style = adjustStyle(group.size, options.style);\n\n  if (style.size !== options.style.size) {\n    node = new mathMLTree.MathNode(\"mstyle\", [node]);\n    var isDisplay = style.size === Style$1.DISPLAY.size ? \"true\" : \"false\";\n    node.setAttribute(\"displaystyle\", isDisplay);\n    node.setAttribute(\"scriptlevel\", \"0\");\n  }\n\n  if (group.leftDelim != null || group.rightDelim != null) {\n    var withDelims = [];\n\n    if (group.leftDelim != null) {\n      var leftOp = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(group.leftDelim.replace(\"\\\\\", \"\"))]);\n      leftOp.setAttribute(\"fence\", \"true\");\n      withDelims.push(leftOp);\n    }\n\n    withDelims.push(node);\n\n    if (group.rightDelim != null) {\n      var rightOp = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(group.rightDelim.replace(\"\\\\\", \"\"))]);\n      rightOp.setAttribute(\"fence\", \"true\");\n      withDelims.push(rightOp);\n    }\n\n    return makeRow(withDelims);\n  }\n\n  return node;\n};\n\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\dfrac\", \"\\\\frac\", \"\\\\tfrac\", \"\\\\dbinom\", \"\\\\binom\", \"\\\\tbinom\", \"\\\\\\\\atopfrac\", // cant be entered directly\n  \"\\\\\\\\bracefrac\", \"\\\\\\\\brackfrac\" // ditto\n  ],\n  props: {\n    numArgs: 2,\n    allowedInArgument: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var numer = args[0];\n    var denom = args[1];\n    var hasBarLine;\n    var leftDelim = null;\n    var rightDelim = null;\n    var size = \"auto\";\n\n    switch (funcName) {\n      case \"\\\\dfrac\":\n      case \"\\\\frac\":\n      case \"\\\\tfrac\":\n        hasBarLine = true;\n        break;\n\n      case \"\\\\\\\\atopfrac\":\n        hasBarLine = false;\n        break;\n\n      case \"\\\\dbinom\":\n      case \"\\\\binom\":\n      case \"\\\\tbinom\":\n        hasBarLine = false;\n        leftDelim = \"(\";\n        rightDelim = \")\";\n        break;\n\n      case \"\\\\\\\\bracefrac\":\n        hasBarLine = false;\n        leftDelim = \"\\\\{\";\n        rightDelim = \"\\\\}\";\n        break;\n\n      case \"\\\\\\\\brackfrac\":\n        hasBarLine = false;\n        leftDelim = \"[\";\n        rightDelim = \"]\";\n        break;\n\n      default:\n        throw new Error(\"Unrecognized genfrac command\");\n    }\n\n    switch (funcName) {\n      case \"\\\\dfrac\":\n      case \"\\\\dbinom\":\n        size = \"display\";\n        break;\n\n      case \"\\\\tfrac\":\n      case \"\\\\tbinom\":\n        size = \"text\";\n        break;\n    }\n\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      continued: false,\n      numer,\n      denom,\n      hasBarLine,\n      leftDelim,\n      rightDelim,\n      size,\n      barSize: null\n    };\n  },\n  htmlBuilder: htmlBuilder$4,\n  mathmlBuilder: mathmlBuilder$3\n});\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\cfrac\"],\n  props: {\n    numArgs: 2\n  },\n  handler: (_ref2, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref2;\n    var numer = args[0];\n    var denom = args[1];\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      continued: true,\n      numer,\n      denom,\n      hasBarLine: true,\n      leftDelim: null,\n      rightDelim: null,\n      size: \"display\",\n      barSize: null\n    };\n  }\n}); // Infix generalized fractions -- these are not rendered directly, but replaced\n// immediately by one of the variants above.\n\ndefineFunction({\n  type: \"infix\",\n  names: [\"\\\\over\", \"\\\\choose\", \"\\\\atop\", \"\\\\brace\", \"\\\\brack\"],\n  props: {\n    numArgs: 0,\n    infix: true\n  },\n\n  handler(_ref3) {\n    var {\n      parser,\n      funcName,\n      token\n    } = _ref3;\n    var replaceWith;\n\n    switch (funcName) {\n      case \"\\\\over\":\n        replaceWith = \"\\\\frac\";\n        break;\n\n      case \"\\\\choose\":\n        replaceWith = \"\\\\binom\";\n        break;\n\n      case \"\\\\atop\":\n        replaceWith = \"\\\\\\\\atopfrac\";\n        break;\n\n      case \"\\\\brace\":\n        replaceWith = \"\\\\\\\\bracefrac\";\n        break;\n\n      case \"\\\\brack\":\n        replaceWith = \"\\\\\\\\brackfrac\";\n        break;\n\n      default:\n        throw new Error(\"Unrecognized infix genfrac command\");\n    }\n\n    return {\n      type: \"infix\",\n      mode: parser.mode,\n      replaceWith,\n      token\n    };\n  }\n\n});\nvar stylArray = [\"display\", \"text\", \"script\", \"scriptscript\"];\n\nvar delimFromValue = function delimFromValue(delimString) {\n  var delim = null;\n\n  if (delimString.length > 0) {\n    delim = delimString;\n    delim = delim === \".\" ? null : delim;\n  }\n\n  return delim;\n};\n\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\genfrac\"],\n  props: {\n    numArgs: 6,\n    allowedInArgument: true,\n    argTypes: [\"math\", \"math\", \"size\", \"text\", \"math\", \"math\"]\n  },\n\n  handler(_ref4, args) {\n    var {\n      parser\n    } = _ref4;\n    var numer = args[4];\n    var denom = args[5]; // Look into the parse nodes to get the desired delimiters.\n\n    var leftNode = normalizeArgument(args[0]);\n    var leftDelim = leftNode.type === \"atom\" && leftNode.family === \"open\" ? delimFromValue(leftNode.text) : null;\n    var rightNode = normalizeArgument(args[1]);\n    var rightDelim = rightNode.type === \"atom\" && rightNode.family === \"close\" ? delimFromValue(rightNode.text) : null;\n    var barNode = assertNodeType(args[2], \"size\");\n    var hasBarLine;\n    var barSize = null;\n\n    if (barNode.isBlank) {\n      // \\genfrac acts differently than \\above.\n      // \\genfrac treats an empty size group as a signal to use a\n      // standard bar size. \\above would see size = 0 and omit the bar.\n      hasBarLine = true;\n    } else {\n      barSize = barNode.value;\n      hasBarLine = barSize.number > 0;\n    } // Find out if we want displaystyle, textstyle, etc.\n\n\n    var size = \"auto\";\n    var styl = args[3];\n\n    if (styl.type === \"ordgroup\") {\n      if (styl.body.length > 0) {\n        var textOrd = assertNodeType(styl.body[0], \"textord\");\n        size = stylArray[Number(textOrd.text)];\n      }\n    } else {\n      styl = assertNodeType(styl, \"textord\");\n      size = stylArray[Number(styl.text)];\n    }\n\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      numer,\n      denom,\n      continued: false,\n      hasBarLine,\n      barSize,\n      leftDelim,\n      rightDelim,\n      size\n    };\n  },\n\n  htmlBuilder: htmlBuilder$4,\n  mathmlBuilder: mathmlBuilder$3\n}); // \\above is an infix fraction that also defines a fraction bar size.\n\ndefineFunction({\n  type: \"infix\",\n  names: [\"\\\\above\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"size\"],\n    infix: true\n  },\n\n  handler(_ref5, args) {\n    var {\n      parser,\n      funcName,\n      token\n    } = _ref5;\n    return {\n      type: \"infix\",\n      mode: parser.mode,\n      replaceWith: \"\\\\\\\\abovefrac\",\n      size: assertNodeType(args[0], \"size\").value,\n      token\n    };\n  }\n\n});\ndefineFunction({\n  type: \"genfrac\",\n  names: [\"\\\\\\\\abovefrac\"],\n  props: {\n    numArgs: 3,\n    argTypes: [\"math\", \"size\", \"math\"]\n  },\n  handler: (_ref6, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref6;\n    var numer = args[0];\n    var barSize = assert(assertNodeType(args[1], \"infix\").size);\n    var denom = args[2];\n    var hasBarLine = barSize.number > 0;\n    return {\n      type: \"genfrac\",\n      mode: parser.mode,\n      numer,\n      denom,\n      continued: false,\n      hasBarLine,\n      barSize,\n      leftDelim: null,\n      rightDelim: null,\n      size: \"auto\"\n    };\n  },\n  htmlBuilder: htmlBuilder$4,\n  mathmlBuilder: mathmlBuilder$3\n});\n\n// NOTE: Unlike most `htmlBuilder`s, this one handles not only \"horizBrace\", but\n// also \"supsub\" since an over/underbrace can affect super/subscripting.\nvar htmlBuilder$3 = (grp, options) => {\n  var style = options.style; // Pull out the `ParseNode<\"horizBrace\">` if `grp` is a \"supsub\" node.\n\n  var supSubGroup;\n  var group;\n\n  if (grp.type === \"supsub\") {\n    // Ref: LaTeX source2e: }}}}\\limits}\n    // i.e. LaTeX treats the brace similar to an op and passes it\n    // with \\limits, so we need to assign supsub style.\n    supSubGroup = grp.sup ? buildGroup$1(grp.sup, options.havingStyle(style.sup()), options) : buildGroup$1(grp.sub, options.havingStyle(style.sub()), options);\n    group = assertNodeType(grp.base, \"horizBrace\");\n  } else {\n    group = assertNodeType(grp, \"horizBrace\");\n  } // Build the base group\n\n\n  var body = buildGroup$1(group.base, options.havingBaseStyle(Style$1.DISPLAY)); // Create the stretchy element\n\n  var braceBody = stretchy.svgSpan(group, options); // Generate the vlist, with the appropriate kerns        \n  // This first vlist contains the content and the brace:   equation\n\n  var vlist;\n\n  if (group.isOver) {\n    vlist = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: body\n      }, {\n        type: \"kern\",\n        size: 0.1\n      }, {\n        type: \"elem\",\n        elem: braceBody\n      }]\n    }, options); // $FlowFixMe: Replace this with passing \"svg-align\" into makeVList.\n\n    vlist.children[0].children[0].children[1].classes.push(\"svg-align\");\n  } else {\n    vlist = buildCommon.makeVList({\n      positionType: \"bottom\",\n      positionData: body.depth + 0.1 + braceBody.height,\n      children: [{\n        type: \"elem\",\n        elem: braceBody\n      }, {\n        type: \"kern\",\n        size: 0.1\n      }, {\n        type: \"elem\",\n        elem: body\n      }]\n    }, options); // $FlowFixMe: Replace this with passing \"svg-align\" into makeVList.\n\n    vlist.children[0].children[0].children[0].classes.push(\"svg-align\");\n  }\n\n  if (supSubGroup) {\n    // To write the supsub, wrap the first vlist in another vlist:\n    // They can't all go in the same vlist, because the note might be\n    // wider than the equation. We want the equation to control the\n    // brace width.\n    //      note          long note           long note\n    //      or         not    \n    //    equation           eqn                 eqn\n    var vSpan = buildCommon.makeSpan([\"mord\", group.isOver ? \"mover\" : \"munder\"], [vlist], options);\n\n    if (group.isOver) {\n      vlist = buildCommon.makeVList({\n        positionType: \"firstBaseline\",\n        children: [{\n          type: \"elem\",\n          elem: vSpan\n        }, {\n          type: \"kern\",\n          size: 0.2\n        }, {\n          type: \"elem\",\n          elem: supSubGroup\n        }]\n      }, options);\n    } else {\n      vlist = buildCommon.makeVList({\n        positionType: \"bottom\",\n        positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,\n        children: [{\n          type: \"elem\",\n          elem: supSubGroup\n        }, {\n          type: \"kern\",\n          size: 0.2\n        }, {\n          type: \"elem\",\n          elem: vSpan\n        }]\n      }, options);\n    }\n  }\n\n  return buildCommon.makeSpan([\"mord\", group.isOver ? \"mover\" : \"munder\"], [vlist], options);\n};\n\nvar mathmlBuilder$2 = (group, options) => {\n  var accentNode = stretchy.mathMLnode(group.label);\n  return new mathMLTree.MathNode(group.isOver ? \"mover\" : \"munder\", [buildGroup(group.base, options), accentNode]);\n}; // Horizontal stretchy braces\n\n\ndefineFunction({\n  type: \"horizBrace\",\n  names: [\"\\\\overbrace\", \"\\\\underbrace\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    return {\n      type: \"horizBrace\",\n      mode: parser.mode,\n      label: funcName,\n      isOver: /^\\\\over/.test(funcName),\n      base: args[0]\n    };\n  },\n\n  htmlBuilder: htmlBuilder$3,\n  mathmlBuilder: mathmlBuilder$2\n});\n\ndefineFunction({\n  type: \"href\",\n  names: [\"\\\\href\"],\n  props: {\n    numArgs: 2,\n    argTypes: [\"url\", \"original\"],\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser\n    } = _ref;\n    var body = args[1];\n    var href = assertNodeType(args[0], \"url\").url;\n\n    if (!parser.settings.isTrusted({\n      command: \"\\\\href\",\n      url: href\n    })) {\n      return parser.formatUnsupportedCmd(\"\\\\href\");\n    }\n\n    return {\n      type: \"href\",\n      mode: parser.mode,\n      href,\n      body: ordargument(body)\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var elements = buildExpression$1(group.body, options, false);\n    return buildCommon.makeAnchor(group.href, [], elements, options);\n  },\n  mathmlBuilder: (group, options) => {\n    var math = buildExpressionRow(group.body, options);\n\n    if (!(math instanceof MathNode)) {\n      math = new MathNode(\"mrow\", [math]);\n    }\n\n    math.setAttribute(\"href\", group.href);\n    return math;\n  }\n});\ndefineFunction({\n  type: \"href\",\n  names: [\"\\\\url\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"url\"],\n    allowedInText: true\n  },\n  handler: (_ref2, args) => {\n    var {\n      parser\n    } = _ref2;\n    var href = assertNodeType(args[0], \"url\").url;\n\n    if (!parser.settings.isTrusted({\n      command: \"\\\\url\",\n      url: href\n    })) {\n      return parser.formatUnsupportedCmd(\"\\\\url\");\n    }\n\n    var chars = [];\n\n    for (var i = 0; i < href.length; i++) {\n      var c = href[i];\n\n      if (c === \"~\") {\n        c = \"\\\\textasciitilde\";\n      }\n\n      chars.push({\n        type: \"textord\",\n        mode: \"text\",\n        text: c\n      });\n    }\n\n    var body = {\n      type: \"text\",\n      mode: parser.mode,\n      font: \"\\\\texttt\",\n      body: chars\n    };\n    return {\n      type: \"href\",\n      mode: parser.mode,\n      href,\n      body: ordargument(body)\n    };\n  }\n});\n\n// In LaTeX, \\vcenter can act only on a box, as in\n// \\vcenter{\\hbox{$\\frac{a+b}{\\dfrac{c}{d}}$}}\n// This function by itself doesn't do anything but prevent a soft line break.\n\ndefineFunction({\n  type: \"hbox\",\n  names: [\"\\\\hbox\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"text\"],\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"hbox\",\n      mode: parser.mode,\n      body: ordargument(args[0])\n    };\n  },\n\n  htmlBuilder(group, options) {\n    var elements = buildExpression$1(group.body, options, false);\n    return buildCommon.makeFragment(elements);\n  },\n\n  mathmlBuilder(group, options) {\n    return new mathMLTree.MathNode(\"mrow\", buildExpression(group.body, options));\n  }\n\n});\n\ndefineFunction({\n  type: \"html\",\n  names: [\"\\\\htmlClass\", \"\\\\htmlId\", \"\\\\htmlStyle\", \"\\\\htmlData\"],\n  props: {\n    numArgs: 2,\n    argTypes: [\"raw\", \"original\"],\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName,\n      token\n    } = _ref;\n    var value = assertNodeType(args[0], \"raw\").string;\n    var body = args[1];\n\n    if (parser.settings.strict) {\n      parser.settings.reportNonstrict(\"htmlExtension\", \"HTML extension is disabled on strict mode\");\n    }\n\n    var trustContext;\n    var attributes = {};\n\n    switch (funcName) {\n      case \"\\\\htmlClass\":\n        attributes.class = value;\n        trustContext = {\n          command: \"\\\\htmlClass\",\n          class: value\n        };\n        break;\n\n      case \"\\\\htmlId\":\n        attributes.id = value;\n        trustContext = {\n          command: \"\\\\htmlId\",\n          id: value\n        };\n        break;\n\n      case \"\\\\htmlStyle\":\n        attributes.style = value;\n        trustContext = {\n          command: \"\\\\htmlStyle\",\n          style: value\n        };\n        break;\n\n      case \"\\\\htmlData\":\n        {\n          var data = value.split(\",\");\n\n          for (var i = 0; i < data.length; i++) {\n            var item = data[i];\n            var firstEquals = item.indexOf(\"=\");\n\n            if (firstEquals < 0) {\n              throw new ParseError(\"\\\\htmlData key/value '\" + item + \"'\" + \" missing equals sign\");\n            }\n\n            var key = item.slice(0, firstEquals);\n\n            var _value = item.slice(firstEquals + 1);\n\n            attributes[\"data-\" + key.trim()] = _value;\n          }\n\n          trustContext = {\n            command: \"\\\\htmlData\",\n            attributes\n          };\n          break;\n        }\n\n      default:\n        throw new Error(\"Unrecognized html command\");\n    }\n\n    if (!parser.settings.isTrusted(trustContext)) {\n      return parser.formatUnsupportedCmd(funcName);\n    }\n\n    return {\n      type: \"html\",\n      mode: parser.mode,\n      attributes,\n      body: ordargument(body)\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var elements = buildExpression$1(group.body, options, false);\n    var classes = [\"enclosing\"];\n\n    if (group.attributes.class) {\n      classes.push(...group.attributes.class.trim().split(/\\s+/));\n    }\n\n    var span = buildCommon.makeSpan(classes, elements, options);\n\n    for (var attr in group.attributes) {\n      if (attr !== \"class\" && group.attributes.hasOwnProperty(attr)) {\n        span.setAttribute(attr, group.attributes[attr]);\n      }\n    }\n\n    return span;\n  },\n  mathmlBuilder: (group, options) => {\n    return buildExpressionRow(group.body, options);\n  }\n});\n\ndefineFunction({\n  type: \"htmlmathml\",\n  names: [\"\\\\html@mathml\"],\n  props: {\n    numArgs: 2,\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"htmlmathml\",\n      mode: parser.mode,\n      html: ordargument(args[0]),\n      mathml: ordargument(args[1])\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var elements = buildExpression$1(group.html, options, false);\n    return buildCommon.makeFragment(elements);\n  },\n  mathmlBuilder: (group, options) => {\n    return buildExpressionRow(group.mathml, options);\n  }\n});\n\nvar sizeData = function sizeData(str) {\n  if (/^[-+]? *(\\d+(\\.\\d*)?|\\.\\d+)$/.test(str)) {\n    // str is a number with no unit specified.\n    // default unit is bp, per graphix package.\n    return {\n      number: +str,\n      unit: \"bp\"\n    };\n  } else {\n    var match = /([-+]?) *(\\d+(?:\\.\\d*)?|\\.\\d+) *([a-z]{2})/.exec(str);\n\n    if (!match) {\n      throw new ParseError(\"Invalid size: '\" + str + \"' in \\\\includegraphics\");\n    }\n\n    var data = {\n      number: +(match[1] + match[2]),\n      // sign + magnitude, cast to number\n      unit: match[3]\n    };\n\n    if (!validUnit(data)) {\n      throw new ParseError(\"Invalid unit: '\" + data.unit + \"' in \\\\includegraphics.\");\n    }\n\n    return data;\n  }\n};\n\ndefineFunction({\n  type: \"includegraphics\",\n  names: [\"\\\\includegraphics\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1,\n    argTypes: [\"raw\", \"url\"],\n    allowedInText: false\n  },\n  handler: (_ref, args, optArgs) => {\n    var {\n      parser\n    } = _ref;\n    var width = {\n      number: 0,\n      unit: \"em\"\n    };\n    var height = {\n      number: 0.9,\n      unit: \"em\"\n    }; // sorta character sized.\n\n    var totalheight = {\n      number: 0,\n      unit: \"em\"\n    };\n    var alt = \"\";\n\n    if (optArgs[0]) {\n      var attributeStr = assertNodeType(optArgs[0], \"raw\").string; // Parser.js does not parse key/value pairs. We get a string.\n\n      var attributes = attributeStr.split(\",\");\n\n      for (var i = 0; i < attributes.length; i++) {\n        var keyVal = attributes[i].split(\"=\");\n\n        if (keyVal.length === 2) {\n          var str = keyVal[1].trim();\n\n          switch (keyVal[0].trim()) {\n            case \"alt\":\n              alt = str;\n              break;\n\n            case \"width\":\n              width = sizeData(str);\n              break;\n\n            case \"height\":\n              height = sizeData(str);\n              break;\n\n            case \"totalheight\":\n              totalheight = sizeData(str);\n              break;\n\n            default:\n              throw new ParseError(\"Invalid key: '\" + keyVal[0] + \"' in \\\\includegraphics.\");\n          }\n        }\n      }\n    }\n\n    var src = assertNodeType(args[0], \"url\").url;\n\n    if (alt === \"\") {\n      // No alt given. Use the file name. Strip away the path.\n      alt = src;\n      alt = alt.replace(/^.*[\\\\/]/, '');\n      alt = alt.substring(0, alt.lastIndexOf('.'));\n    }\n\n    if (!parser.settings.isTrusted({\n      command: \"\\\\includegraphics\",\n      url: src\n    })) {\n      return parser.formatUnsupportedCmd(\"\\\\includegraphics\");\n    }\n\n    return {\n      type: \"includegraphics\",\n      mode: parser.mode,\n      alt: alt,\n      width: width,\n      height: height,\n      totalheight: totalheight,\n      src: src\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var height = calculateSize(group.height, options);\n    var depth = 0;\n\n    if (group.totalheight.number > 0) {\n      depth = calculateSize(group.totalheight, options) - height;\n    }\n\n    var width = 0;\n\n    if (group.width.number > 0) {\n      width = calculateSize(group.width, options);\n    }\n\n    var style = {\n      height: makeEm(height + depth)\n    };\n\n    if (width > 0) {\n      style.width = makeEm(width);\n    }\n\n    if (depth > 0) {\n      style.verticalAlign = makeEm(-depth);\n    }\n\n    var node = new Img(group.src, group.alt, style);\n    node.height = height;\n    node.depth = depth;\n    return node;\n  },\n  mathmlBuilder: (group, options) => {\n    var node = new mathMLTree.MathNode(\"mglyph\", []);\n    node.setAttribute(\"alt\", group.alt);\n    var height = calculateSize(group.height, options);\n    var depth = 0;\n\n    if (group.totalheight.number > 0) {\n      depth = calculateSize(group.totalheight, options) - height;\n      node.setAttribute(\"valign\", makeEm(-depth));\n    }\n\n    node.setAttribute(\"height\", makeEm(height + depth));\n\n    if (group.width.number > 0) {\n      var width = calculateSize(group.width, options);\n      node.setAttribute(\"width\", makeEm(width));\n    }\n\n    node.setAttribute(\"src\", group.src);\n    return node;\n  }\n});\n\n// Horizontal spacing commands\n\ndefineFunction({\n  type: \"kern\",\n  names: [\"\\\\kern\", \"\\\\mkern\", \"\\\\hskip\", \"\\\\mskip\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"size\"],\n    primitive: true,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var size = assertNodeType(args[0], \"size\");\n\n    if (parser.settings.strict) {\n      var mathFunction = funcName[1] === 'm'; // \\mkern, \\mskip\n\n      var muUnit = size.value.unit === 'mu';\n\n      if (mathFunction) {\n        if (!muUnit) {\n          parser.settings.reportNonstrict(\"mathVsTextUnits\", \"LaTeX's \" + funcName + \" supports only mu units, \" + (\"not \" + size.value.unit + \" units\"));\n        }\n\n        if (parser.mode !== \"math\") {\n          parser.settings.reportNonstrict(\"mathVsTextUnits\", \"LaTeX's \" + funcName + \" works only in math mode\");\n        }\n      } else {\n        // !mathFunction\n        if (muUnit) {\n          parser.settings.reportNonstrict(\"mathVsTextUnits\", \"LaTeX's \" + funcName + \" doesn't support mu units\");\n        }\n      }\n    }\n\n    return {\n      type: \"kern\",\n      mode: parser.mode,\n      dimension: size.value\n    };\n  },\n\n  htmlBuilder(group, options) {\n    return buildCommon.makeGlue(group.dimension, options);\n  },\n\n  mathmlBuilder(group, options) {\n    var dimension = calculateSize(group.dimension, options);\n    return new mathMLTree.SpaceNode(dimension);\n  }\n\n});\n\n// Horizontal overlap functions\ndefineFunction({\n  type: \"lap\",\n  names: [\"\\\\mathllap\", \"\\\\mathrlap\", \"\\\\mathclap\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"lap\",\n      mode: parser.mode,\n      alignment: funcName.slice(5),\n      body\n    };\n  },\n  htmlBuilder: (group, options) => {\n    // mathllap, mathrlap, mathclap\n    var inner;\n\n    if (group.alignment === \"clap\") {\n      // ref: https://www.math.lsu.edu/~aperlis/publications/mathclap/\n      inner = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]); // wrap, since CSS will center a .clap > .inner > span\n\n      inner = buildCommon.makeSpan([\"inner\"], [inner], options);\n    } else {\n      inner = buildCommon.makeSpan([\"inner\"], [buildGroup$1(group.body, options)]);\n    }\n\n    var fix = buildCommon.makeSpan([\"fix\"], []);\n    var node = buildCommon.makeSpan([group.alignment], [inner, fix], options); // At this point, we have correctly set horizontal alignment of the\n    // two items involved in the lap.\n    // Next, use a strut to set the height of the HTML bounding box.\n    // Otherwise, a tall argument may be misplaced.\n    // This code resolved issue #1153\n\n    var strut = buildCommon.makeSpan([\"strut\"]);\n    strut.style.height = makeEm(node.height + node.depth);\n\n    if (node.depth) {\n      strut.style.verticalAlign = makeEm(-node.depth);\n    }\n\n    node.children.unshift(strut); // Next, prevent vertical misplacement when next to something tall.\n    // This code resolves issue #1234\n\n    node = buildCommon.makeSpan([\"thinbox\"], [node], options);\n    return buildCommon.makeSpan([\"mord\", \"vbox\"], [node], options);\n  },\n  mathmlBuilder: (group, options) => {\n    // mathllap, mathrlap, mathclap\n    var node = new mathMLTree.MathNode(\"mpadded\", [buildGroup(group.body, options)]);\n\n    if (group.alignment !== \"rlap\") {\n      var offset = group.alignment === \"llap\" ? \"-1\" : \"-0.5\";\n      node.setAttribute(\"lspace\", offset + \"width\");\n    }\n\n    node.setAttribute(\"width\", \"0px\");\n    return node;\n  }\n});\n\ndefineFunction({\n  type: \"styling\",\n  names: [\"\\\\(\", \"$\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    allowedInMath: false\n  },\n\n  handler(_ref, args) {\n    var {\n      funcName,\n      parser\n    } = _ref;\n    var outerMode = parser.mode;\n    parser.switchMode(\"math\");\n    var close = funcName === \"\\\\(\" ? \"\\\\)\" : \"$\";\n    var body = parser.parseExpression(false, close);\n    parser.expect(close);\n    parser.switchMode(outerMode);\n    return {\n      type: \"styling\",\n      mode: parser.mode,\n      style: \"text\",\n      body\n    };\n  }\n\n}); // Check for extra closing math delimiters\n\ndefineFunction({\n  type: \"text\",\n  // Doesn't matter what this is.\n  names: [\"\\\\)\", \"\\\\]\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    allowedInMath: false\n  },\n\n  handler(context, args) {\n    throw new ParseError(\"Mismatched \" + context.funcName);\n  }\n\n});\n\nvar chooseMathStyle = (group, options) => {\n  switch (options.style.size) {\n    case Style$1.DISPLAY.size:\n      return group.display;\n\n    case Style$1.TEXT.size:\n      return group.text;\n\n    case Style$1.SCRIPT.size:\n      return group.script;\n\n    case Style$1.SCRIPTSCRIPT.size:\n      return group.scriptscript;\n\n    default:\n      return group.text;\n  }\n};\n\ndefineFunction({\n  type: \"mathchoice\",\n  names: [\"\\\\mathchoice\"],\n  props: {\n    numArgs: 4,\n    primitive: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"mathchoice\",\n      mode: parser.mode,\n      display: ordargument(args[0]),\n      text: ordargument(args[1]),\n      script: ordargument(args[2]),\n      scriptscript: ordargument(args[3])\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var body = chooseMathStyle(group, options);\n    var elements = buildExpression$1(body, options, false);\n    return buildCommon.makeFragment(elements);\n  },\n  mathmlBuilder: (group, options) => {\n    var body = chooseMathStyle(group, options);\n    return buildExpressionRow(body, options);\n  }\n});\n\nvar assembleSupSub = (base, supGroup, subGroup, options, style, slant, baseShift) => {\n  base = buildCommon.makeSpan([], [base]);\n  var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);\n  var sub;\n  var sup; // We manually have to handle the superscripts and subscripts. This,\n  // aside from the kern calculations, is copied from supsub.\n\n  if (supGroup) {\n    var elem = buildGroup$1(supGroup, options.havingStyle(style.sup()), options);\n    sup = {\n      elem,\n      kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)\n    };\n  }\n\n  if (subGroup) {\n    var _elem = buildGroup$1(subGroup, options.havingStyle(style.sub()), options);\n\n    sub = {\n      elem: _elem,\n      kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)\n    };\n  } // Build the final group as a vlist of the possible subscript, base,\n  // and possible superscript.\n\n\n  var finalGroup;\n\n  if (sup && sub) {\n    var bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base.depth + baseShift;\n    finalGroup = buildCommon.makeVList({\n      positionType: \"bottom\",\n      positionData: bottom,\n      children: [{\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }, {\n        type: \"elem\",\n        elem: sub.elem,\n        marginLeft: makeEm(-slant)\n      }, {\n        type: \"kern\",\n        size: sub.kern\n      }, {\n        type: \"elem\",\n        elem: base\n      }, {\n        type: \"kern\",\n        size: sup.kern\n      }, {\n        type: \"elem\",\n        elem: sup.elem,\n        marginLeft: makeEm(slant)\n      }, {\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }]\n    }, options);\n  } else if (sub) {\n    var top = base.height - baseShift; // Shift the limits by the slant of the symbol. Note\n    // that we are supposed to shift the limits by 1/2 of the slant,\n    // but since we are centering the limits adding a full slant of\n    // margin will shift by 1/2 that.\n\n    finalGroup = buildCommon.makeVList({\n      positionType: \"top\",\n      positionData: top,\n      children: [{\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }, {\n        type: \"elem\",\n        elem: sub.elem,\n        marginLeft: makeEm(-slant)\n      }, {\n        type: \"kern\",\n        size: sub.kern\n      }, {\n        type: \"elem\",\n        elem: base\n      }]\n    }, options);\n  } else if (sup) {\n    var _bottom = base.depth + baseShift;\n\n    finalGroup = buildCommon.makeVList({\n      positionType: \"bottom\",\n      positionData: _bottom,\n      children: [{\n        type: \"elem\",\n        elem: base\n      }, {\n        type: \"kern\",\n        size: sup.kern\n      }, {\n        type: \"elem\",\n        elem: sup.elem,\n        marginLeft: makeEm(slant)\n      }, {\n        type: \"kern\",\n        size: options.fontMetrics().bigOpSpacing5\n      }]\n    }, options);\n  } else {\n    // This case probably shouldn't occur (this would mean the\n    // supsub was sending us a group with no superscript or\n    // subscript) but be safe.\n    return base;\n  }\n\n  var parts = [finalGroup];\n\n  if (sub && slant !== 0 && !subIsSingleCharacter) {\n    // A negative margin-left was applied to the lower limit.\n    // Avoid an overlap by placing a spacer on the left on the group.\n    var spacer = buildCommon.makeSpan([\"mspace\"], [], options);\n    spacer.style.marginRight = makeEm(slant);\n    parts.unshift(spacer);\n  }\n\n  return buildCommon.makeSpan([\"mop\", \"op-limits\"], parts, options);\n};\n\n// Limits, symbols\n// Most operators have a large successor symbol, but these don't.\nvar noSuccessor = [\"\\\\smallint\"]; // NOTE: Unlike most `htmlBuilder`s, this one handles not only \"op\", but also\n// \"supsub\" since some of them (like \\int) can affect super/subscripting.\n\nvar htmlBuilder$2 = (grp, options) => {\n  // Operators are handled in the TeXbook pg. 443-444, rule 13(a).\n  var supGroup;\n  var subGroup;\n  var hasLimits = false;\n  var group;\n\n  if (grp.type === \"supsub\") {\n    // If we have limits, supsub will pass us its group to handle. Pull\n    // out the superscript and subscript and set the group to the op in\n    // its base.\n    supGroup = grp.sup;\n    subGroup = grp.sub;\n    group = assertNodeType(grp.base, \"op\");\n    hasLimits = true;\n  } else {\n    group = assertNodeType(grp, \"op\");\n  }\n\n  var style = options.style;\n  var large = false;\n\n  if (style.size === Style$1.DISPLAY.size && group.symbol && !noSuccessor.includes(group.name)) {\n    // Most symbol operators get larger in displaystyle (rule 13)\n    large = true;\n  }\n\n  var base;\n\n  if (group.symbol) {\n    // If this is a symbol, create the symbol.\n    var fontName = large ? \"Size2-Regular\" : \"Size1-Regular\";\n    var stash = \"\";\n\n    if (group.name === \"\\\\oiint\" || group.name === \"\\\\oiiint\") {\n      // No font glyphs yet, so use a glyph w/o the oval.\n      // TODO: When font glyphs are available, delete this code.\n      stash = group.name.slice(1);\n      group.name = stash === \"oiint\" ? \"\\\\iint\" : \"\\\\iiint\";\n    }\n\n    base = buildCommon.makeSymbol(group.name, fontName, \"math\", options, [\"mop\", \"op-symbol\", large ? \"large-op\" : \"small-op\"]);\n\n    if (stash.length > 0) {\n      // We're in \\oiint or \\oiiint. Overlay the oval.\n      // TODO: When font glyphs are available, delete this code.\n      var italic = base.italic;\n      var oval = buildCommon.staticSvg(stash + \"Size\" + (large ? \"2\" : \"1\"), options);\n      base = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: [{\n          type: \"elem\",\n          elem: base,\n          shift: 0\n        }, {\n          type: \"elem\",\n          elem: oval,\n          shift: large ? 0.08 : 0\n        }]\n      }, options);\n      group.name = \"\\\\\" + stash;\n      base.classes.unshift(\"mop\"); // $FlowFixMe\n\n      base.italic = italic;\n    }\n  } else if (group.body) {\n    // If this is a list, compose that list.\n    var inner = buildExpression$1(group.body, options, true);\n\n    if (inner.length === 1 && inner[0] instanceof SymbolNode) {\n      base = inner[0];\n      base.classes[0] = \"mop\"; // replace old mclass\n    } else {\n      base = buildCommon.makeSpan([\"mop\"], inner, options);\n    }\n  } else {\n    // Otherwise, this is a text operator. Build the text from the\n    // operator's name.\n    var output = [];\n\n    for (var i = 1; i < group.name.length; i++) {\n      output.push(buildCommon.mathsym(group.name[i], group.mode, options));\n    }\n\n    base = buildCommon.makeSpan([\"mop\"], output, options);\n  } // If content of op is a single symbol, shift it vertically.\n\n\n  var baseShift = 0;\n  var slant = 0;\n\n  if ((base instanceof SymbolNode || group.name === \"\\\\oiint\" || group.name === \"\\\\oiiint\") && !group.suppressBaseShift) {\n    // We suppress the shift of the base of \\overset and \\underset. Otherwise,\n    // shift the symbol so its center lies on the axis (rule 13). It\n    // appears that our fonts have the centers of the symbols already\n    // almost on the axis, so these numbers are very small. Note we\n    // don't actually apply this here, but instead it is used either in\n    // the vlist creation or separately when there are no limits.\n    baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight; // The slant of the symbol is just its italic correction.\n    // $FlowFixMe\n\n    slant = base.italic;\n  }\n\n  if (hasLimits) {\n    return assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift);\n  } else {\n    if (baseShift) {\n      base.style.position = \"relative\";\n      base.style.top = makeEm(baseShift);\n    }\n\n    return base;\n  }\n};\n\nvar mathmlBuilder$1 = (group, options) => {\n  var node;\n\n  if (group.symbol) {\n    // This is a symbol. Just add the symbol.\n    node = new MathNode(\"mo\", [makeText(group.name, group.mode)]);\n\n    if (noSuccessor.includes(group.name)) {\n      node.setAttribute(\"largeop\", \"false\");\n    }\n  } else if (group.body) {\n    // This is an operator with children. Add them.\n    node = new MathNode(\"mo\", buildExpression(group.body, options));\n  } else {\n    // This is a text operator. Add all of the characters from the\n    // operator's name.\n    node = new MathNode(\"mi\", [new TextNode(group.name.slice(1))]); // Append an <mo>&ApplyFunction;</mo>.\n    // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4\n\n    var operator = new MathNode(\"mo\", [makeText(\"\\u2061\", \"text\")]);\n\n    if (group.parentIsSupSub) {\n      node = new MathNode(\"mrow\", [node, operator]);\n    } else {\n      node = newDocumentFragment([node, operator]);\n    }\n  }\n\n  return node;\n};\n\nvar singleCharBigOps = {\n  \"\\u220F\": \"\\\\prod\",\n  \"\\u2210\": \"\\\\coprod\",\n  \"\\u2211\": \"\\\\sum\",\n  \"\\u22c0\": \"\\\\bigwedge\",\n  \"\\u22c1\": \"\\\\bigvee\",\n  \"\\u22c2\": \"\\\\bigcap\",\n  \"\\u22c3\": \"\\\\bigcup\",\n  \"\\u2a00\": \"\\\\bigodot\",\n  \"\\u2a01\": \"\\\\bigoplus\",\n  \"\\u2a02\": \"\\\\bigotimes\",\n  \"\\u2a04\": \"\\\\biguplus\",\n  \"\\u2a06\": \"\\\\bigsqcup\"\n};\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\coprod\", \"\\\\bigvee\", \"\\\\bigwedge\", \"\\\\biguplus\", \"\\\\bigcap\", \"\\\\bigcup\", \"\\\\intop\", \"\\\\prod\", \"\\\\sum\", \"\\\\bigotimes\", \"\\\\bigoplus\", \"\\\\bigodot\", \"\\\\bigsqcup\", \"\\\\smallint\", \"\\u220F\", \"\\u2210\", \"\\u2211\", \"\\u22c0\", \"\\u22c1\", \"\\u22c2\", \"\\u22c3\", \"\\u2a00\", \"\\u2a01\", \"\\u2a02\", \"\\u2a04\", \"\\u2a06\"],\n  props: {\n    numArgs: 0\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var fName = funcName;\n\n    if (fName.length === 1) {\n      fName = singleCharBigOps[fName];\n    }\n\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: true,\n      parentIsSupSub: false,\n      symbol: true,\n      name: fName\n    };\n  },\n  htmlBuilder: htmlBuilder$2,\n  mathmlBuilder: mathmlBuilder$1\n}); // Note: calling defineFunction with a type that's already been defined only\n// works because the same htmlBuilder and mathmlBuilder are being used.\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\mathop\"],\n  props: {\n    numArgs: 1,\n    primitive: true\n  },\n  handler: (_ref2, args) => {\n    var {\n      parser\n    } = _ref2;\n    var body = args[0];\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: false,\n      parentIsSupSub: false,\n      symbol: false,\n      body: ordargument(body)\n    };\n  },\n  htmlBuilder: htmlBuilder$2,\n  mathmlBuilder: mathmlBuilder$1\n}); // There are 2 flags for operators; whether they produce limits in\n// displaystyle, and whether they are symbols and should grow in\n// displaystyle. These four groups cover the four possible choices.\n\nvar singleCharIntegrals = {\n  \"\\u222b\": \"\\\\int\",\n  \"\\u222c\": \"\\\\iint\",\n  \"\\u222d\": \"\\\\iiint\",\n  \"\\u222e\": \"\\\\oint\",\n  \"\\u222f\": \"\\\\oiint\",\n  \"\\u2230\": \"\\\\oiiint\"\n}; // No limits, not symbols\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\arcsin\", \"\\\\arccos\", \"\\\\arctan\", \"\\\\arctg\", \"\\\\arcctg\", \"\\\\arg\", \"\\\\ch\", \"\\\\cos\", \"\\\\cosec\", \"\\\\cosh\", \"\\\\cot\", \"\\\\cotg\", \"\\\\coth\", \"\\\\csc\", \"\\\\ctg\", \"\\\\cth\", \"\\\\deg\", \"\\\\dim\", \"\\\\exp\", \"\\\\hom\", \"\\\\ker\", \"\\\\lg\", \"\\\\ln\", \"\\\\log\", \"\\\\sec\", \"\\\\sin\", \"\\\\sinh\", \"\\\\sh\", \"\\\\tan\", \"\\\\tanh\", \"\\\\tg\", \"\\\\th\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(_ref3) {\n    var {\n      parser,\n      funcName\n    } = _ref3;\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: false,\n      parentIsSupSub: false,\n      symbol: false,\n      name: funcName\n    };\n  },\n\n  htmlBuilder: htmlBuilder$2,\n  mathmlBuilder: mathmlBuilder$1\n}); // Limits, not symbols\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\det\", \"\\\\gcd\", \"\\\\inf\", \"\\\\lim\", \"\\\\max\", \"\\\\min\", \"\\\\Pr\", \"\\\\sup\"],\n  props: {\n    numArgs: 0\n  },\n\n  handler(_ref4) {\n    var {\n      parser,\n      funcName\n    } = _ref4;\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: true,\n      parentIsSupSub: false,\n      symbol: false,\n      name: funcName\n    };\n  },\n\n  htmlBuilder: htmlBuilder$2,\n  mathmlBuilder: mathmlBuilder$1\n}); // No limits, symbols\n\ndefineFunction({\n  type: \"op\",\n  names: [\"\\\\int\", \"\\\\iint\", \"\\\\iiint\", \"\\\\oint\", \"\\\\oiint\", \"\\\\oiiint\", \"\\u222b\", \"\\u222c\", \"\\u222d\", \"\\u222e\", \"\\u222f\", \"\\u2230\"],\n  props: {\n    numArgs: 0,\n    allowedInArgument: true\n  },\n\n  handler(_ref5) {\n    var {\n      parser,\n      funcName\n    } = _ref5;\n    var fName = funcName;\n\n    if (fName.length === 1) {\n      fName = singleCharIntegrals[fName];\n    }\n\n    return {\n      type: \"op\",\n      mode: parser.mode,\n      limits: false,\n      parentIsSupSub: false,\n      symbol: true,\n      name: fName\n    };\n  },\n\n  htmlBuilder: htmlBuilder$2,\n  mathmlBuilder: mathmlBuilder$1\n});\n\n// NOTE: Unlike most `htmlBuilder`s, this one handles not only\n// \"operatorname\", but also  \"supsub\" since \\operatorname* can\n// affect super/subscripting.\nvar htmlBuilder$1 = (grp, options) => {\n  // Operators are handled in the TeXbook pg. 443-444, rule 13(a).\n  var supGroup;\n  var subGroup;\n  var hasLimits = false;\n  var group;\n\n  if (grp.type === \"supsub\") {\n    // If we have limits, supsub will pass us its group to handle. Pull\n    // out the superscript and subscript and set the group to the op in\n    // its base.\n    supGroup = grp.sup;\n    subGroup = grp.sub;\n    group = assertNodeType(grp.base, \"operatorname\");\n    hasLimits = true;\n  } else {\n    group = assertNodeType(grp, \"operatorname\");\n  }\n\n  var base;\n\n  if (group.body.length > 0) {\n    var body = group.body.map(child => {\n      // $FlowFixMe: Check if the node has a string `text` property.\n      var childText = child.text;\n\n      if (typeof childText === \"string\") {\n        return {\n          type: \"textord\",\n          mode: child.mode,\n          text: childText\n        };\n      } else {\n        return child;\n      }\n    }); // Consolidate function names into symbol characters.\n\n    var expression = buildExpression$1(body, options.withFont(\"mathrm\"), true);\n\n    for (var i = 0; i < expression.length; i++) {\n      var child = expression[i];\n\n      if (child instanceof SymbolNode) {\n        // Per amsopn package,\n        // change minus to hyphen and \\ast to asterisk\n        child.text = child.text.replace(/\\u2212/, \"-\").replace(/\\u2217/, \"*\");\n      }\n    }\n\n    base = buildCommon.makeSpan([\"mop\"], expression, options);\n  } else {\n    base = buildCommon.makeSpan([\"mop\"], [], options);\n  }\n\n  if (hasLimits) {\n    return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);\n  } else {\n    return base;\n  }\n};\n\nvar mathmlBuilder = (group, options) => {\n  // The steps taken here are similar to the html version.\n  var expression = buildExpression(group.body, options.withFont(\"mathrm\")); // Is expression a string or has it something like a fraction?\n\n  var isAllString = true; // default\n\n  for (var i = 0; i < expression.length; i++) {\n    var node = expression[i];\n\n    if (node instanceof mathMLTree.SpaceNode) ; else if (node instanceof mathMLTree.MathNode) {\n      switch (node.type) {\n        case \"mi\":\n        case \"mn\":\n        case \"ms\":\n        case \"mspace\":\n        case \"mtext\":\n          break;\n        // Do nothing yet.\n\n        case \"mo\":\n          {\n            var child = node.children[0];\n\n            if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {\n              child.text = child.text.replace(/\\u2212/, \"-\").replace(/\\u2217/, \"*\");\n            } else {\n              isAllString = false;\n            }\n\n            break;\n          }\n\n        default:\n          isAllString = false;\n      }\n    } else {\n      isAllString = false;\n    }\n  }\n\n  if (isAllString) {\n    // Write a single TextNode instead of multiple nested tags.\n    var word = expression.map(node => node.toText()).join(\"\");\n    expression = [new mathMLTree.TextNode(word)];\n  }\n\n  var identifier = new mathMLTree.MathNode(\"mi\", expression);\n  identifier.setAttribute(\"mathvariant\", \"normal\"); // \\u2061 is the same as &ApplyFunction;\n  // ref: https://www.w3schools.com/charsets/ref_html_entities_a.asp\n\n  var operator = new mathMLTree.MathNode(\"mo\", [makeText(\"\\u2061\", \"text\")]);\n\n  if (group.parentIsSupSub) {\n    return new mathMLTree.MathNode(\"mrow\", [identifier, operator]);\n  } else {\n    return mathMLTree.newDocumentFragment([identifier, operator]);\n  }\n}; // \\operatorname\n// amsopn.dtx: \\mathop{#1\\kern\\z@\\operator@font#3}\\newmcodes@\n\n\ndefineFunction({\n  type: \"operatorname\",\n  names: [\"\\\\operatorname@\", \"\\\\operatornamewithlimits\"],\n  props: {\n    numArgs: 1\n  },\n  handler: (_ref, args) => {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"operatorname\",\n      mode: parser.mode,\n      body: ordargument(body),\n      alwaysHandleSupSub: funcName === \"\\\\operatornamewithlimits\",\n      limits: false,\n      parentIsSupSub: false\n    };\n  },\n  htmlBuilder: htmlBuilder$1,\n  mathmlBuilder\n});\ndefineMacro(\"\\\\operatorname\", \"\\\\@ifstar\\\\operatornamewithlimits\\\\operatorname@\");\n\ndefineFunctionBuilders({\n  type: \"ordgroup\",\n\n  htmlBuilder(group, options) {\n    if (group.semisimple) {\n      return buildCommon.makeFragment(buildExpression$1(group.body, options, false));\n    }\n\n    return buildCommon.makeSpan([\"mord\"], buildExpression$1(group.body, options, true), options);\n  },\n\n  mathmlBuilder(group, options) {\n    return buildExpressionRow(group.body, options, true);\n  }\n\n});\n\ndefineFunction({\n  type: \"overline\",\n  names: [\"\\\\overline\"],\n  props: {\n    numArgs: 1\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"overline\",\n      mode: parser.mode,\n      body\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Overlines are handled in the TeXbook pg 443, Rule 9.\n    // Build the inner group in the cramped style.\n    var innerGroup = buildGroup$1(group.body, options.havingCrampedStyle()); // Create the line above the body\n\n    var line = buildCommon.makeLineSpan(\"overline-line\", options); // Generate the vlist, with the appropriate kerns\n\n    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;\n    var vlist = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: innerGroup\n      }, {\n        type: \"kern\",\n        size: 3 * defaultRuleThickness\n      }, {\n        type: \"elem\",\n        elem: line\n      }, {\n        type: \"kern\",\n        size: defaultRuleThickness\n      }]\n    }, options);\n    return buildCommon.makeSpan([\"mord\", \"overline\"], [vlist], options);\n  },\n\n  mathmlBuilder(group, options) {\n    var operator = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(\"\\u203e\")]);\n    operator.setAttribute(\"stretchy\", \"true\");\n    var node = new mathMLTree.MathNode(\"mover\", [buildGroup(group.body, options), operator]);\n    node.setAttribute(\"accent\", \"true\");\n    return node;\n  }\n\n});\n\ndefineFunction({\n  type: \"phantom\",\n  names: [\"\\\\phantom\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      parser\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"phantom\",\n      mode: parser.mode,\n      body: ordargument(body)\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var elements = buildExpression$1(group.body, options.withPhantom(), false); // \\phantom isn't supposed to affect the elements it contains.\n    // See \"color\" for more details.\n\n    return buildCommon.makeFragment(elements);\n  },\n  mathmlBuilder: (group, options) => {\n    var inner = buildExpression(group.body, options);\n    return new mathMLTree.MathNode(\"mphantom\", inner);\n  }\n});\ndefineFunction({\n  type: \"hphantom\",\n  names: [\"\\\\hphantom\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref2, args) => {\n    var {\n      parser\n    } = _ref2;\n    var body = args[0];\n    return {\n      type: \"hphantom\",\n      mode: parser.mode,\n      body\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options.withPhantom())]);\n    node.height = 0;\n    node.depth = 0;\n\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        node.children[i].height = 0;\n        node.children[i].depth = 0;\n      }\n    } // See smash for comment re: use of makeVList\n\n\n    node = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: node\n      }]\n    }, options); // For spacing, TeX treats \\smash as a math group (same spacing as ord).\n\n    return buildCommon.makeSpan([\"mord\"], [node], options);\n  },\n  mathmlBuilder: (group, options) => {\n    var inner = buildExpression(ordargument(group.body), options);\n    var phantom = new mathMLTree.MathNode(\"mphantom\", inner);\n    var node = new mathMLTree.MathNode(\"mpadded\", [phantom]);\n    node.setAttribute(\"height\", \"0px\");\n    node.setAttribute(\"depth\", \"0px\");\n    return node;\n  }\n});\ndefineFunction({\n  type: \"vphantom\",\n  names: [\"\\\\vphantom\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref3, args) => {\n    var {\n      parser\n    } = _ref3;\n    var body = args[0];\n    return {\n      type: \"vphantom\",\n      mode: parser.mode,\n      body\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var inner = buildCommon.makeSpan([\"inner\"], [buildGroup$1(group.body, options.withPhantom())]);\n    var fix = buildCommon.makeSpan([\"fix\"], []);\n    return buildCommon.makeSpan([\"mord\", \"rlap\"], [inner, fix], options);\n  },\n  mathmlBuilder: (group, options) => {\n    var inner = buildExpression(ordargument(group.body), options);\n    var phantom = new mathMLTree.MathNode(\"mphantom\", inner);\n    var node = new mathMLTree.MathNode(\"mpadded\", [phantom]);\n    node.setAttribute(\"width\", \"0px\");\n    return node;\n  }\n});\n\ndefineFunction({\n  type: \"raisebox\",\n  names: [\"\\\\raisebox\"],\n  props: {\n    numArgs: 2,\n    argTypes: [\"size\", \"hbox\"],\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    var amount = assertNodeType(args[0], \"size\").value;\n    var body = args[1];\n    return {\n      type: \"raisebox\",\n      mode: parser.mode,\n      dy: amount,\n      body\n    };\n  },\n\n  htmlBuilder(group, options) {\n    var body = buildGroup$1(group.body, options);\n    var dy = calculateSize(group.dy, options);\n    return buildCommon.makeVList({\n      positionType: \"shift\",\n      positionData: -dy,\n      children: [{\n        type: \"elem\",\n        elem: body\n      }]\n    }, options);\n  },\n\n  mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mpadded\", [buildGroup(group.body, options)]);\n    var dy = group.dy.number + group.dy.unit;\n    node.setAttribute(\"voffset\", dy);\n    return node;\n  }\n\n});\n\ndefineFunction({\n  type: \"internal\",\n  names: [\"\\\\relax\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    allowedInArgument: true\n  },\n\n  handler(_ref) {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"internal\",\n      mode: parser.mode\n    };\n  }\n\n});\n\ndefineFunction({\n  type: \"rule\",\n  names: [\"\\\\rule\"],\n  props: {\n    numArgs: 2,\n    numOptionalArgs: 1,\n    allowedInText: true,\n    allowedInMath: true,\n    argTypes: [\"size\", \"size\", \"size\"]\n  },\n\n  handler(_ref, args, optArgs) {\n    var {\n      parser\n    } = _ref;\n    var shift = optArgs[0];\n    var width = assertNodeType(args[0], \"size\");\n    var height = assertNodeType(args[1], \"size\");\n    return {\n      type: \"rule\",\n      mode: parser.mode,\n      shift: shift && assertNodeType(shift, \"size\").value,\n      width: width.value,\n      height: height.value\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Make an empty span for the rule\n    var rule = buildCommon.makeSpan([\"mord\", \"rule\"], [], options); // Calculate the shift, width, and height of the rule, and account for units\n\n    var width = calculateSize(group.width, options);\n    var height = calculateSize(group.height, options);\n    var shift = group.shift ? calculateSize(group.shift, options) : 0; // Style the rule to the right size\n\n    rule.style.borderRightWidth = makeEm(width);\n    rule.style.borderTopWidth = makeEm(height);\n    rule.style.bottom = makeEm(shift); // Record the height and width\n\n    rule.width = width;\n    rule.height = height + shift;\n    rule.depth = -shift; // Font size is the number large enough that the browser will\n    // reserve at least `absHeight` space above the baseline.\n    // The 1.125 factor was empirically determined\n\n    rule.maxFontSize = height * 1.125 * options.sizeMultiplier;\n    return rule;\n  },\n\n  mathmlBuilder(group, options) {\n    var width = calculateSize(group.width, options);\n    var height = calculateSize(group.height, options);\n    var shift = group.shift ? calculateSize(group.shift, options) : 0;\n    var color = options.color && options.getColor() || \"black\";\n    var rule = new mathMLTree.MathNode(\"mspace\");\n    rule.setAttribute(\"mathbackground\", color);\n    rule.setAttribute(\"width\", makeEm(width));\n    rule.setAttribute(\"height\", makeEm(height));\n    var wrapper = new mathMLTree.MathNode(\"mpadded\", [rule]);\n\n    if (shift >= 0) {\n      wrapper.setAttribute(\"height\", makeEm(shift));\n    } else {\n      wrapper.setAttribute(\"height\", makeEm(shift));\n      wrapper.setAttribute(\"depth\", makeEm(-shift));\n    }\n\n    wrapper.setAttribute(\"voffset\", makeEm(shift));\n    return wrapper;\n  }\n\n});\n\nfunction sizingGroup(value, options, baseOptions) {\n  var inner = buildExpression$1(value, options, false);\n  var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier; // Add size-resetting classes to the inner list and set maxFontSize\n  // manually. Handle nested size changes.\n\n  for (var i = 0; i < inner.length; i++) {\n    var pos = inner[i].classes.indexOf(\"sizing\");\n\n    if (pos < 0) {\n      Array.prototype.push.apply(inner[i].classes, options.sizingClasses(baseOptions));\n    } else if (inner[i].classes[pos + 1] === \"reset-size\" + options.size) {\n      // This is a nested size change: e.g., inner[i] is the \"b\" in\n      // `\\Huge a \\small b`. Override the old size (the `reset-` class)\n      // but not the new size.\n      inner[i].classes[pos + 1] = \"reset-size\" + baseOptions.size;\n    }\n\n    inner[i].height *= multiplier;\n    inner[i].depth *= multiplier;\n  }\n\n  return buildCommon.makeFragment(inner);\n}\nvar sizeFuncs = [\"\\\\tiny\", \"\\\\sixptsize\", \"\\\\scriptsize\", \"\\\\footnotesize\", \"\\\\small\", \"\\\\normalsize\", \"\\\\large\", \"\\\\Large\", \"\\\\LARGE\", \"\\\\huge\", \"\\\\Huge\"];\nvar htmlBuilder = (group, options) => {\n  // Handle sizing operators like \\Huge. Real TeX doesn't actually allow\n  // these functions inside of math expressions, so we do some special\n  // handling.\n  var newOptions = options.havingSize(group.size);\n  return sizingGroup(group.body, newOptions, options);\n};\ndefineFunction({\n  type: \"sizing\",\n  names: sizeFuncs,\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n  handler: (_ref, args) => {\n    var {\n      breakOnTokenText,\n      funcName,\n      parser\n    } = _ref;\n    var body = parser.parseExpression(false, breakOnTokenText);\n    return {\n      type: \"sizing\",\n      mode: parser.mode,\n      // Figure out what size to use based on the list of functions above\n      size: sizeFuncs.indexOf(funcName) + 1,\n      body\n    };\n  },\n  htmlBuilder,\n  mathmlBuilder: (group, options) => {\n    var newOptions = options.havingSize(group.size);\n    var inner = buildExpression(group.body, newOptions);\n    var node = new mathMLTree.MathNode(\"mstyle\", inner); // TODO(emily): This doesn't produce the correct size for nested size\n    // changes, because we don't keep state of what style we're currently\n    // in, so we can't reset the size to normal before changing it.  Now\n    // that we're passing an options parameter we should be able to fix\n    // this.\n\n    node.setAttribute(\"mathsize\", makeEm(newOptions.sizeMultiplier));\n    return node;\n  }\n});\n\n// smash, with optional [tb], as in AMS\ndefineFunction({\n  type: \"smash\",\n  names: [\"\\\\smash\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1,\n    allowedInText: true\n  },\n  handler: (_ref, args, optArgs) => {\n    var {\n      parser\n    } = _ref;\n    var smashHeight = false;\n    var smashDepth = false;\n    var tbArg = optArgs[0] && assertNodeType(optArgs[0], \"ordgroup\");\n\n    if (tbArg) {\n      // Optional [tb] argument is engaged.\n      // ref: amsmath: \\renewcommand{\\smash}[1][tb]{%\n      //               def\\mb@t{\\ht}\\def\\mb@b{\\dp}\\def\\mb@tb{\\ht\\z@\\z@\\dp}%\n      var letter = \"\";\n\n      for (var i = 0; i < tbArg.body.length; ++i) {\n        var node = tbArg.body[i]; // $FlowFixMe: Not every node type has a `text` property.\n\n        letter = node.text;\n\n        if (letter === \"t\") {\n          smashHeight = true;\n        } else if (letter === \"b\") {\n          smashDepth = true;\n        } else {\n          smashHeight = false;\n          smashDepth = false;\n          break;\n        }\n      }\n    } else {\n      smashHeight = true;\n      smashDepth = true;\n    }\n\n    var body = args[0];\n    return {\n      type: \"smash\",\n      mode: parser.mode,\n      body,\n      smashHeight,\n      smashDepth\n    };\n  },\n  htmlBuilder: (group, options) => {\n    var node = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);\n\n    if (!group.smashHeight && !group.smashDepth) {\n      return node;\n    }\n\n    if (group.smashHeight) {\n      node.height = 0; // In order to influence makeVList, we have to reset the children.\n\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          node.children[i].height = 0;\n        }\n      }\n    }\n\n    if (group.smashDepth) {\n      node.depth = 0;\n\n      if (node.children) {\n        for (var _i = 0; _i < node.children.length; _i++) {\n          node.children[_i].depth = 0;\n        }\n      }\n    } // At this point, we've reset the TeX-like height and depth values.\n    // But the span still has an HTML line height.\n    // makeVList applies \"display: table-cell\", which prevents the browser\n    // from acting on that line height. So we'll call makeVList now.\n\n\n    var smashedNode = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: node\n      }]\n    }, options); // For spacing, TeX treats \\hphantom as a math group (same spacing as ord).\n\n    return buildCommon.makeSpan([\"mord\"], [smashedNode], options);\n  },\n  mathmlBuilder: (group, options) => {\n    var node = new mathMLTree.MathNode(\"mpadded\", [buildGroup(group.body, options)]);\n\n    if (group.smashHeight) {\n      node.setAttribute(\"height\", \"0px\");\n    }\n\n    if (group.smashDepth) {\n      node.setAttribute(\"depth\", \"0px\");\n    }\n\n    return node;\n  }\n});\n\ndefineFunction({\n  type: \"sqrt\",\n  names: [\"\\\\sqrt\"],\n  props: {\n    numArgs: 1,\n    numOptionalArgs: 1\n  },\n\n  handler(_ref, args, optArgs) {\n    var {\n      parser\n    } = _ref;\n    var index = optArgs[0];\n    var body = args[0];\n    return {\n      type: \"sqrt\",\n      mode: parser.mode,\n      body,\n      index\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Square roots are handled in the TeXbook pg. 443, Rule 11.\n    // First, we do the same steps as in overline to build the inner group\n    // and line\n    var inner = buildGroup$1(group.body, options.havingCrampedStyle());\n\n    if (inner.height === 0) {\n      // Render a small surd.\n      inner.height = options.fontMetrics().xHeight;\n    } // Some groups can return document fragments.  Handle those by wrapping\n    // them in a span.\n\n\n    inner = buildCommon.wrapFragment(inner, options); // Calculate the minimum size for the \\surd delimiter\n\n    var metrics = options.fontMetrics();\n    var theta = metrics.defaultRuleThickness;\n    var phi = theta;\n\n    if (options.style.id < Style$1.TEXT.id) {\n      phi = options.fontMetrics().xHeight;\n    } // Calculate the clearance between the body and line\n\n\n    var lineClearance = theta + phi / 4;\n    var minDelimiterHeight = inner.height + inner.depth + lineClearance + theta; // Create a sqrt SVG of the required minimum size\n\n    var {\n      span: img,\n      ruleWidth,\n      advanceWidth\n    } = delimiter.sqrtImage(minDelimiterHeight, options);\n    var delimDepth = img.height - ruleWidth; // Adjust the clearance based on the delimiter size\n\n    if (delimDepth > inner.height + inner.depth + lineClearance) {\n      lineClearance = (lineClearance + delimDepth - inner.height - inner.depth) / 2;\n    } // Shift the sqrt image\n\n\n    var imgShift = img.height - inner.height - lineClearance - ruleWidth;\n    inner.style.paddingLeft = makeEm(advanceWidth); // Overlay the image and the argument.\n\n    var body = buildCommon.makeVList({\n      positionType: \"firstBaseline\",\n      children: [{\n        type: \"elem\",\n        elem: inner,\n        wrapperClasses: [\"svg-align\"]\n      }, {\n        type: \"kern\",\n        size: -(inner.height + imgShift)\n      }, {\n        type: \"elem\",\n        elem: img\n      }, {\n        type: \"kern\",\n        size: ruleWidth\n      }]\n    }, options);\n\n    if (!group.index) {\n      return buildCommon.makeSpan([\"mord\", \"sqrt\"], [body], options);\n    } else {\n      // Handle the optional root index\n      // The index is always in scriptscript style\n      var newOptions = options.havingStyle(Style$1.SCRIPTSCRIPT);\n      var rootm = buildGroup$1(group.index, newOptions, options); // The amount the index is shifted by. This is taken from the TeX\n      // source, in the definition of `\\r@@t`.\n\n      var toShift = 0.6 * (body.height - body.depth); // Build a VList with the superscript shifted up correctly\n\n      var rootVList = buildCommon.makeVList({\n        positionType: \"shift\",\n        positionData: -toShift,\n        children: [{\n          type: \"elem\",\n          elem: rootm\n        }]\n      }, options); // Add a class surrounding it so we can add on the appropriate\n      // kerning\n\n      var rootVListWrap = buildCommon.makeSpan([\"root\"], [rootVList]);\n      return buildCommon.makeSpan([\"mord\", \"sqrt\"], [rootVListWrap, body], options);\n    }\n  },\n\n  mathmlBuilder(group, options) {\n    var {\n      body,\n      index\n    } = group;\n    return index ? new mathMLTree.MathNode(\"mroot\", [buildGroup(body, options), buildGroup(index, options)]) : new mathMLTree.MathNode(\"msqrt\", [buildGroup(body, options)]);\n  }\n\n});\n\nvar styleMap = {\n  \"display\": Style$1.DISPLAY,\n  \"text\": Style$1.TEXT,\n  \"script\": Style$1.SCRIPT,\n  \"scriptscript\": Style$1.SCRIPTSCRIPT\n};\ndefineFunction({\n  type: \"styling\",\n  names: [\"\\\\displaystyle\", \"\\\\textstyle\", \"\\\\scriptstyle\", \"\\\\scriptscriptstyle\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true,\n    primitive: true\n  },\n\n  handler(_ref, args) {\n    var {\n      breakOnTokenText,\n      funcName,\n      parser\n    } = _ref;\n    // parse out the implicit body\n    var body = parser.parseExpression(true, breakOnTokenText); // TODO: Refactor to avoid duplicating styleMap in multiple places (e.g.\n    // here and in buildHTML and de-dupe the enumeration of all the styles).\n    // $FlowFixMe: The names above exactly match the styles.\n\n    var style = funcName.slice(1, funcName.length - 5);\n    return {\n      type: \"styling\",\n      mode: parser.mode,\n      // Figure out what style to use by pulling out the style from\n      // the function name\n      style,\n      body\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Style changes are handled in the TeXbook on pg. 442, Rule 3.\n    var newStyle = styleMap[group.style];\n    var newOptions = options.havingStyle(newStyle).withFont('');\n    return sizingGroup(group.body, newOptions, options);\n  },\n\n  mathmlBuilder(group, options) {\n    // Figure out what style we're changing to.\n    var newStyle = styleMap[group.style];\n    var newOptions = options.havingStyle(newStyle);\n    var inner = buildExpression(group.body, newOptions);\n    var node = new mathMLTree.MathNode(\"mstyle\", inner);\n    var styleAttributes = {\n      \"display\": [\"0\", \"true\"],\n      \"text\": [\"0\", \"false\"],\n      \"script\": [\"1\", \"false\"],\n      \"scriptscript\": [\"2\", \"false\"]\n    };\n    var attr = styleAttributes[group.style];\n    node.setAttribute(\"scriptlevel\", attr[0]);\n    node.setAttribute(\"displaystyle\", attr[1]);\n    return node;\n  }\n\n});\n\n/**\n * Sometimes, groups perform special rules when they have superscripts or\n * subscripts attached to them. This function lets the `supsub` group know that\n * Sometimes, groups perform special rules when they have superscripts or\n * its inner element should handle the superscripts and subscripts instead of\n * handling them itself.\n */\nvar htmlBuilderDelegate = function htmlBuilderDelegate(group, options) {\n  var base = group.base;\n\n  if (!base) {\n    return null;\n  } else if (base.type === \"op\") {\n    // Operators handle supsubs differently when they have limits\n    // (e.g. `\\displaystyle\\sum_2^3`)\n    var delegate = base.limits && (options.style.size === Style$1.DISPLAY.size || base.alwaysHandleSupSub);\n    return delegate ? htmlBuilder$2 : null;\n  } else if (base.type === \"operatorname\") {\n    var _delegate = base.alwaysHandleSupSub && (options.style.size === Style$1.DISPLAY.size || base.limits);\n\n    return _delegate ? htmlBuilder$1 : null;\n  } else if (base.type === \"accent\") {\n    return utils.isCharacterBox(base.base) ? htmlBuilder$a : null;\n  } else if (base.type === \"horizBrace\") {\n    var isSup = !group.sub;\n    return isSup === base.isOver ? htmlBuilder$3 : null;\n  } else {\n    return null;\n  }\n}; // Super scripts and subscripts, whose precise placement can depend on other\n// functions that precede them.\n\n\ndefineFunctionBuilders({\n  type: \"supsub\",\n\n  htmlBuilder(group, options) {\n    // Superscript and subscripts are handled in the TeXbook on page\n    // 445-446, rules 18(a-f).\n    // Here is where we defer to the inner group if it should handle\n    // superscripts and subscripts itself.\n    var builderDelegate = htmlBuilderDelegate(group, options);\n\n    if (builderDelegate) {\n      return builderDelegate(group, options);\n    }\n\n    var {\n      base: valueBase,\n      sup: valueSup,\n      sub: valueSub\n    } = group;\n    var base = buildGroup$1(valueBase, options);\n    var supm;\n    var subm;\n    var metrics = options.fontMetrics(); // Rule 18a\n\n    var supShift = 0;\n    var subShift = 0;\n    var isCharacterBox = valueBase && utils.isCharacterBox(valueBase);\n\n    if (valueSup) {\n      var newOptions = options.havingStyle(options.style.sup());\n      supm = buildGroup$1(valueSup, newOptions, options);\n\n      if (!isCharacterBox) {\n        supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;\n      }\n    }\n\n    if (valueSub) {\n      var _newOptions = options.havingStyle(options.style.sub());\n\n      subm = buildGroup$1(valueSub, _newOptions, options);\n\n      if (!isCharacterBox) {\n        subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;\n      }\n    } // Rule 18c\n\n\n    var minSupShift;\n\n    if (options.style === Style$1.DISPLAY) {\n      minSupShift = metrics.sup1;\n    } else if (options.style.cramped) {\n      minSupShift = metrics.sup3;\n    } else {\n      minSupShift = metrics.sup2;\n    } // scriptspace is a font-size-independent size, so scale it\n    // appropriately for use as the marginRight.\n\n\n    var multiplier = options.sizeMultiplier;\n    var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);\n    var marginLeft = null;\n\n    if (subm) {\n      // Subscripts shouldn't be shifted by the base's italic correction.\n      // Account for that by shifting the subscript back the appropriate\n      // amount. Note we only do this when the base is a single symbol.\n      var isOiint = group.base && group.base.type === \"op\" && group.base.name && (group.base.name === \"\\\\oiint\" || group.base.name === \"\\\\oiiint\");\n\n      if (base instanceof SymbolNode || isOiint) {\n        // $FlowFixMe\n        marginLeft = makeEm(-base.italic);\n      }\n    }\n\n    var supsub;\n\n    if (supm && subm) {\n      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);\n      subShift = Math.max(subShift, metrics.sub2);\n      var ruleWidth = metrics.defaultRuleThickness; // Rule 18e\n\n      var maxWidth = 4 * ruleWidth;\n\n      if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {\n        subShift = maxWidth - (supShift - supm.depth) + subm.height;\n        var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);\n\n        if (psi > 0) {\n          supShift += psi;\n          subShift -= psi;\n        }\n      }\n\n      var vlistElem = [{\n        type: \"elem\",\n        elem: subm,\n        shift: subShift,\n        marginRight,\n        marginLeft\n      }, {\n        type: \"elem\",\n        elem: supm,\n        shift: -supShift,\n        marginRight\n      }];\n      supsub = buildCommon.makeVList({\n        positionType: \"individualShift\",\n        children: vlistElem\n      }, options);\n    } else if (subm) {\n      // Rule 18b\n      subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);\n      var _vlistElem = [{\n        type: \"elem\",\n        elem: subm,\n        marginLeft,\n        marginRight\n      }];\n      supsub = buildCommon.makeVList({\n        positionType: \"shift\",\n        positionData: subShift,\n        children: _vlistElem\n      }, options);\n    } else if (supm) {\n      // Rule 18c, d\n      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);\n      supsub = buildCommon.makeVList({\n        positionType: \"shift\",\n        positionData: -supShift,\n        children: [{\n          type: \"elem\",\n          elem: supm,\n          marginRight\n        }]\n      }, options);\n    } else {\n      throw new Error(\"supsub must have either sup or sub.\");\n    } // Wrap the supsub vlist in a span.msupsub to reset text-align.\n\n\n    var mclass = getTypeOfDomTree(base, \"right\") || \"mord\";\n    return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan([\"msupsub\"], [supsub])], options);\n  },\n\n  mathmlBuilder(group, options) {\n    // Is the inner group a relevant horizontal brace?\n    var isBrace = false;\n    var isOver;\n    var isSup;\n\n    if (group.base && group.base.type === \"horizBrace\") {\n      isSup = !!group.sup;\n\n      if (isSup === group.base.isOver) {\n        isBrace = true;\n        isOver = group.base.isOver;\n      }\n    }\n\n    if (group.base && (group.base.type === \"op\" || group.base.type === \"operatorname\")) {\n      group.base.parentIsSupSub = true;\n    }\n\n    var children = [buildGroup(group.base, options)];\n\n    if (group.sub) {\n      children.push(buildGroup(group.sub, options));\n    }\n\n    if (group.sup) {\n      children.push(buildGroup(group.sup, options));\n    }\n\n    var nodeType;\n\n    if (isBrace) {\n      nodeType = isOver ? \"mover\" : \"munder\";\n    } else if (!group.sub) {\n      var base = group.base;\n\n      if (base && base.type === \"op\" && base.limits && (options.style === Style$1.DISPLAY || base.alwaysHandleSupSub)) {\n        nodeType = \"mover\";\n      } else if (base && base.type === \"operatorname\" && base.alwaysHandleSupSub && (base.limits || options.style === Style$1.DISPLAY)) {\n        nodeType = \"mover\";\n      } else {\n        nodeType = \"msup\";\n      }\n    } else if (!group.sup) {\n      var _base = group.base;\n\n      if (_base && _base.type === \"op\" && _base.limits && (options.style === Style$1.DISPLAY || _base.alwaysHandleSupSub)) {\n        nodeType = \"munder\";\n      } else if (_base && _base.type === \"operatorname\" && _base.alwaysHandleSupSub && (_base.limits || options.style === Style$1.DISPLAY)) {\n        nodeType = \"munder\";\n      } else {\n        nodeType = \"msub\";\n      }\n    } else {\n      var _base2 = group.base;\n\n      if (_base2 && _base2.type === \"op\" && _base2.limits && options.style === Style$1.DISPLAY) {\n        nodeType = \"munderover\";\n      } else if (_base2 && _base2.type === \"operatorname\" && _base2.alwaysHandleSupSub && (options.style === Style$1.DISPLAY || _base2.limits)) {\n        nodeType = \"munderover\";\n      } else {\n        nodeType = \"msubsup\";\n      }\n    }\n\n    return new mathMLTree.MathNode(nodeType, children);\n  }\n\n});\n\ndefineFunctionBuilders({\n  type: \"atom\",\n\n  htmlBuilder(group, options) {\n    return buildCommon.mathsym(group.text, group.mode, options, [\"m\" + group.family]);\n  },\n\n  mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mo\", [makeText(group.text, group.mode)]);\n\n    if (group.family === \"bin\") {\n      var variant = getVariant(group, options);\n\n      if (variant === \"bold-italic\") {\n        node.setAttribute(\"mathvariant\", variant);\n      }\n    } else if (group.family === \"punct\") {\n      node.setAttribute(\"separator\", \"true\");\n    } else if (group.family === \"open\" || group.family === \"close\") {\n      // Delims built here should not stretch vertically.\n      // See delimsizing.js for stretchy delims.\n      node.setAttribute(\"stretchy\", \"false\");\n    }\n\n    return node;\n  }\n\n});\n\n// \"mathord\" and \"textord\" ParseNodes created in Parser.js from symbol Groups in\n// src/symbols.js.\nvar defaultVariant = {\n  \"mi\": \"italic\",\n  \"mn\": \"normal\",\n  \"mtext\": \"normal\"\n};\ndefineFunctionBuilders({\n  type: \"mathord\",\n\n  htmlBuilder(group, options) {\n    return buildCommon.makeOrd(group, options, \"mathord\");\n  },\n\n  mathmlBuilder(group, options) {\n    var node = new mathMLTree.MathNode(\"mi\", [makeText(group.text, group.mode, options)]);\n    var variant = getVariant(group, options) || \"italic\";\n\n    if (variant !== defaultVariant[node.type]) {\n      node.setAttribute(\"mathvariant\", variant);\n    }\n\n    return node;\n  }\n\n});\ndefineFunctionBuilders({\n  type: \"textord\",\n\n  htmlBuilder(group, options) {\n    return buildCommon.makeOrd(group, options, \"textord\");\n  },\n\n  mathmlBuilder(group, options) {\n    var text = makeText(group.text, group.mode, options);\n    var variant = getVariant(group, options) || \"normal\";\n    var node;\n\n    if (group.mode === 'text') {\n      node = new mathMLTree.MathNode(\"mtext\", [text]);\n    } else if (/[0-9]/.test(group.text)) {\n      node = new mathMLTree.MathNode(\"mn\", [text]);\n    } else if (group.text === \"\\\\prime\") {\n      node = new mathMLTree.MathNode(\"mo\", [text]);\n    } else {\n      node = new mathMLTree.MathNode(\"mi\", [text]);\n    }\n\n    if (variant !== defaultVariant[node.type]) {\n      node.setAttribute(\"mathvariant\", variant);\n    }\n\n    return node;\n  }\n\n});\n\nvar cssSpace = {\n  \"\\\\nobreak\": \"nobreak\",\n  \"\\\\allowbreak\": \"allowbreak\"\n}; // A lookup table to determine whether a spacing function/symbol should be\n// treated like a regular space character.  If a symbol or command is a key\n// in this table, then it should be a regular space character.  Furthermore,\n// the associated value may have a `className` specifying an extra CSS class\n// to add to the created `span`.\n\nvar regularSpace = {\n  \" \": {},\n  \"\\\\ \": {},\n  \"~\": {\n    className: \"nobreak\"\n  },\n  \"\\\\space\": {},\n  \"\\\\nobreakspace\": {\n    className: \"nobreak\"\n  }\n}; // ParseNode<\"spacing\"> created in Parser.js from the \"spacing\" symbol Groups in\n// src/symbols.js.\n\ndefineFunctionBuilders({\n  type: \"spacing\",\n\n  htmlBuilder(group, options) {\n    if (regularSpace.hasOwnProperty(group.text)) {\n      var className = regularSpace[group.text].className || \"\"; // Spaces are generated by adding an actual space. Each of these\n      // things has an entry in the symbols table, so these will be turned\n      // into appropriate outputs.\n\n      if (group.mode === \"text\") {\n        var ord = buildCommon.makeOrd(group, options, \"textord\");\n        ord.classes.push(className);\n        return ord;\n      } else {\n        return buildCommon.makeSpan([\"mspace\", className], [buildCommon.mathsym(group.text, group.mode, options)], options);\n      }\n    } else if (cssSpace.hasOwnProperty(group.text)) {\n      // Spaces based on just a CSS class.\n      return buildCommon.makeSpan([\"mspace\", cssSpace[group.text]], [], options);\n    } else {\n      throw new ParseError(\"Unknown type of space \\\"\" + group.text + \"\\\"\");\n    }\n  },\n\n  mathmlBuilder(group, options) {\n    var node;\n\n    if (regularSpace.hasOwnProperty(group.text)) {\n      node = new mathMLTree.MathNode(\"mtext\", [new mathMLTree.TextNode(\"\\u00a0\")]);\n    } else if (cssSpace.hasOwnProperty(group.text)) {\n      // CSS-based MathML spaces (\\nobreak, \\allowbreak) are ignored\n      return new mathMLTree.MathNode(\"mspace\");\n    } else {\n      throw new ParseError(\"Unknown type of space \\\"\" + group.text + \"\\\"\");\n    }\n\n    return node;\n  }\n\n});\n\nvar pad = () => {\n  var padNode = new mathMLTree.MathNode(\"mtd\", []);\n  padNode.setAttribute(\"width\", \"50%\");\n  return padNode;\n};\n\ndefineFunctionBuilders({\n  type: \"tag\",\n\n  mathmlBuilder(group, options) {\n    var table = new mathMLTree.MathNode(\"mtable\", [new mathMLTree.MathNode(\"mtr\", [pad(), new mathMLTree.MathNode(\"mtd\", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode(\"mtd\", [buildExpressionRow(group.tag, options)])])]);\n    table.setAttribute(\"width\", \"100%\");\n    return table; // TODO: Left-aligned tags.\n    // Currently, the group and options passed here do not contain\n    // enough info to set tag alignment. `leqno` is in Settings but it is\n    // not passed to Options. On the HTML side, leqno is\n    // set by a CSS class applied in buildTree.js. That would have worked\n    // in MathML if browsers supported <mlabeledtr>. Since they don't, we\n    // need to rewrite the way this function is called.\n  }\n\n});\n\nvar textFontFamilies = {\n  \"\\\\text\": undefined,\n  \"\\\\textrm\": \"textrm\",\n  \"\\\\textsf\": \"textsf\",\n  \"\\\\texttt\": \"texttt\",\n  \"\\\\textnormal\": \"textrm\"\n};\nvar textFontWeights = {\n  \"\\\\textbf\": \"textbf\",\n  \"\\\\textmd\": \"textmd\"\n};\nvar textFontShapes = {\n  \"\\\\textit\": \"textit\",\n  \"\\\\textup\": \"textup\"\n};\n\nvar optionsWithFont = (group, options) => {\n  var font = group.font; // Checks if the argument is a font family or a font style.\n\n  if (!font) {\n    return options;\n  } else if (textFontFamilies[font]) {\n    return options.withTextFontFamily(textFontFamilies[font]);\n  } else if (textFontWeights[font]) {\n    return options.withTextFontWeight(textFontWeights[font]);\n  } else if (font === \"\\\\emph\") {\n    return options.fontShape === \"textit\" ? options.withTextFontShape(\"textup\") : options.withTextFontShape(\"textit\");\n  }\n\n  return options.withTextFontShape(textFontShapes[font]);\n};\n\ndefineFunction({\n  type: \"text\",\n  names: [// Font families\n  \"\\\\text\", \"\\\\textrm\", \"\\\\textsf\", \"\\\\texttt\", \"\\\\textnormal\", // Font weights\n  \"\\\\textbf\", \"\\\\textmd\", // Font Shapes\n  \"\\\\textit\", \"\\\\textup\", \"\\\\emph\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"text\"],\n    allowedInArgument: true,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser,\n      funcName\n    } = _ref;\n    var body = args[0];\n    return {\n      type: \"text\",\n      mode: parser.mode,\n      body: ordargument(body),\n      font: funcName\n    };\n  },\n\n  htmlBuilder(group, options) {\n    var newOptions = optionsWithFont(group, options);\n    var inner = buildExpression$1(group.body, newOptions, true);\n    return buildCommon.makeSpan([\"mord\", \"text\"], inner, newOptions);\n  },\n\n  mathmlBuilder(group, options) {\n    var newOptions = optionsWithFont(group, options);\n    return buildExpressionRow(group.body, newOptions);\n  }\n\n});\n\ndefineFunction({\n  type: \"underline\",\n  names: [\"\\\\underline\"],\n  props: {\n    numArgs: 1,\n    allowedInText: true\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"underline\",\n      mode: parser.mode,\n      body: args[0]\n    };\n  },\n\n  htmlBuilder(group, options) {\n    // Underlines are handled in the TeXbook pg 443, Rule 10.\n    // Build the inner group.\n    var innerGroup = buildGroup$1(group.body, options); // Create the line to go below the body\n\n    var line = buildCommon.makeLineSpan(\"underline-line\", options); // Generate the vlist, with the appropriate kerns\n\n    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;\n    var vlist = buildCommon.makeVList({\n      positionType: \"top\",\n      positionData: innerGroup.height,\n      children: [{\n        type: \"kern\",\n        size: defaultRuleThickness\n      }, {\n        type: \"elem\",\n        elem: line\n      }, {\n        type: \"kern\",\n        size: 3 * defaultRuleThickness\n      }, {\n        type: \"elem\",\n        elem: innerGroup\n      }]\n    }, options);\n    return buildCommon.makeSpan([\"mord\", \"underline\"], [vlist], options);\n  },\n\n  mathmlBuilder(group, options) {\n    var operator = new mathMLTree.MathNode(\"mo\", [new mathMLTree.TextNode(\"\\u203e\")]);\n    operator.setAttribute(\"stretchy\", \"true\");\n    var node = new mathMLTree.MathNode(\"munder\", [buildGroup(group.body, options), operator]);\n    node.setAttribute(\"accentunder\", \"true\");\n    return node;\n  }\n\n});\n\ndefineFunction({\n  type: \"vcenter\",\n  names: [\"\\\\vcenter\"],\n  props: {\n    numArgs: 1,\n    argTypes: [\"original\"],\n    // In LaTeX, \\vcenter can act only on a box.\n    allowedInText: false\n  },\n\n  handler(_ref, args) {\n    var {\n      parser\n    } = _ref;\n    return {\n      type: \"vcenter\",\n      mode: parser.mode,\n      body: args[0]\n    };\n  },\n\n  htmlBuilder(group, options) {\n    var body = buildGroup$1(group.body, options);\n    var axisHeight = options.fontMetrics().axisHeight;\n    var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));\n    return buildCommon.makeVList({\n      positionType: \"shift\",\n      positionData: dy,\n      children: [{\n        type: \"elem\",\n        elem: body\n      }]\n    }, options);\n  },\n\n  mathmlBuilder(group, options) {\n    // There is no way to do this in MathML.\n    // Write a class as a breadcrumb in case some post-processor wants\n    // to perform a vcenter adjustment.\n    return new mathMLTree.MathNode(\"mpadded\", [buildGroup(group.body, options)], [\"vcenter\"]);\n  }\n\n});\n\ndefineFunction({\n  type: \"verb\",\n  names: [\"\\\\verb\"],\n  props: {\n    numArgs: 0,\n    allowedInText: true\n  },\n\n  handler(context, args, optArgs) {\n    // \\verb and \\verb* are dealt with directly in Parser.js.\n    // If we end up here, it's because of a failure to match the two delimiters\n    // in the regex in Lexer.js.  LaTeX raises the following error when \\verb is\n    // terminated by end of line (or file).\n    throw new ParseError(\"\\\\verb ended by end of line instead of matching delimiter\");\n  },\n\n  htmlBuilder(group, options) {\n    var text = makeVerb(group);\n    var body = []; // \\verb enters text mode and therefore is sized like \\textstyle\n\n    var newOptions = options.havingStyle(options.style.text());\n\n    for (var i = 0; i < text.length; i++) {\n      var c = text[i];\n\n      if (c === '~') {\n        c = '\\\\textasciitilde';\n      }\n\n      body.push(buildCommon.makeSymbol(c, \"Typewriter-Regular\", group.mode, newOptions, [\"mord\", \"texttt\"]));\n    }\n\n    return buildCommon.makeSpan([\"mord\", \"text\"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);\n  },\n\n  mathmlBuilder(group, options) {\n    var text = new mathMLTree.TextNode(makeVerb(group));\n    var node = new mathMLTree.MathNode(\"mtext\", [text]);\n    node.setAttribute(\"mathvariant\", \"monospace\");\n    return node;\n  }\n\n});\n/**\n * Converts verb group into body string.\n *\n * \\verb* replaces each space with an open box \\u2423\n * \\verb replaces each space with a no-break space \\xA0\n */\n\nvar makeVerb = group => group.body.replace(/ /g, group.star ? '\\u2423' : '\\xA0');\n\n/** Include this to ensure that all functions are defined. */\nvar functions = _functions;\n\n/**\n * The Lexer class handles tokenizing the input in various ways. Since our\n * parser expects us to be able to backtrack, the lexer allows lexing from any\n * given starting point.\n *\n * Its main exposed function is the `lex` function, which takes a position to\n * lex from and a type of token to lex. It defers to the appropriate `_innerLex`\n * function.\n *\n * The various `_innerLex` functions perform the actual lexing of different\n * kinds.\n */\n\n/* The following tokenRegex\n * - matches typical whitespace (but not NBSP etc.) using its first group\n * - does not match any control character \\x00-\\x1f except whitespace\n * - does not match a bare backslash\n * - matches any ASCII character except those just mentioned\n * - does not match the BMP private use area \\uE000-\\uF8FF\n * - does not match bare surrogate code units\n * - matches any BMP character except for those just described\n * - matches any valid Unicode surrogate pair\n * - matches a backslash followed by one or more whitespace characters\n * - matches a backslash followed by one or more letters then whitespace\n * - matches a backslash followed by any BMP character\n * Capturing groups:\n *   [1] regular whitespace\n *   [2] backslash followed by whitespace\n *   [3] anything else, which may include:\n *     [4] left character of \\verb*\n *     [5] left character of \\verb\n *     [6] backslash followed by word, excluding any trailing whitespace\n * Just because the Lexer matches something doesn't mean it's valid input:\n * If there is no matching function or symbol definition, the Parser will\n * still reject the input.\n */\nvar spaceRegexString = \"[ \\r\\n\\t]\";\nvar controlWordRegexString = \"\\\\\\\\[a-zA-Z@]+\";\nvar controlSymbolRegexString = \"\\\\\\\\[^\\uD800-\\uDFFF]\";\nvar controlWordWhitespaceRegexString = \"(\" + controlWordRegexString + \")\" + spaceRegexString + \"*\";\nvar controlSpaceRegexString = \"\\\\\\\\(\\n|[ \\r\\t]+\\n?)[ \\r\\t]*\";\nvar combiningDiacriticalMarkString = \"[\\u0300-\\u036f]\";\nvar combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + \"+$\");\nvar tokenRegexString = \"(\" + spaceRegexString + \"+)|\" + ( // whitespace\ncontrolSpaceRegexString + \"|\") + // \\whitespace\n\"([!-\\\\[\\\\]-\\u2027\\u202A-\\uD7FF\\uF900-\\uFFFF]\" + ( // single codepoint\ncombiningDiacriticalMarkString + \"*\") + // ...plus accents\n\"|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]\" + ( // surrogate pair\ncombiningDiacriticalMarkString + \"*\") + // ...plus accents\n\"|\\\\\\\\verb\\\\*([^]).*?\\\\4\" + // \\verb*\n\"|\\\\\\\\verb([^*a-zA-Z]).*?\\\\5\" + ( // \\verb unstarred\n\"|\" + controlWordWhitespaceRegexString) + ( // \\macroName + spaces\n\"|\" + controlSymbolRegexString + \")\"); // \\\\, \\', etc.\n\n/** Main Lexer class */\n\nclass Lexer {\n  // Category codes. The lexer only supports comment characters (14) for now.\n  // MacroExpander additionally distinguishes active (13).\n  constructor(input, settings) {\n    this.input = void 0;\n    this.settings = void 0;\n    this.tokenRegex = void 0;\n    this.catcodes = void 0;\n    // Separate accents from characters\n    this.input = input;\n    this.settings = settings;\n    this.tokenRegex = new RegExp(tokenRegexString, 'g');\n    this.catcodes = {\n      \"%\": 14,\n      // comment character\n      \"~\": 13 // active character\n\n    };\n  }\n\n  setCatcode(char, code) {\n    this.catcodes[char] = code;\n  }\n  /**\n   * This function lexes a single token.\n   */\n\n\n  lex() {\n    var input = this.input;\n    var pos = this.tokenRegex.lastIndex;\n\n    if (pos === input.length) {\n      return new Token(\"EOF\", new SourceLocation(this, pos, pos));\n    }\n\n    var match = this.tokenRegex.exec(input);\n\n    if (match === null || match.index !== pos) {\n      throw new ParseError(\"Unexpected character: '\" + input[pos] + \"'\", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));\n    }\n\n    var text = match[6] || match[3] || (match[2] ? \"\\\\ \" : \" \");\n\n    if (this.catcodes[text] === 14) {\n      // comment character\n      var nlIndex = input.indexOf('\\n', this.tokenRegex.lastIndex);\n\n      if (nlIndex === -1) {\n        this.tokenRegex.lastIndex = input.length; // EOF\n\n        this.settings.reportNonstrict(\"commentAtEnd\", \"% comment has no terminating newline; LaTeX would \" + \"fail because of commenting the end of math mode (e.g. $)\");\n      } else {\n        this.tokenRegex.lastIndex = nlIndex + 1;\n      }\n\n      return this.lex();\n    }\n\n    return new Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));\n  }\n\n}\n\n/**\n * A `Namespace` refers to a space of nameable things like macros or lengths,\n * which can be `set` either globally or local to a nested group, using an\n * undo stack similar to how TeX implements this functionality.\n * Performance-wise, `get` and local `set` take constant time, while global\n * `set` takes time proportional to the depth of group nesting.\n */\nclass Namespace {\n  /**\n   * Both arguments are optional.  The first argument is an object of\n   * built-in mappings which never change.  The second argument is an object\n   * of initial (global-level) mappings, which will constantly change\n   * according to any global/top-level `set`s done.\n   */\n  constructor(builtins, globalMacros) {\n    if (builtins === void 0) {\n      builtins = {};\n    }\n\n    if (globalMacros === void 0) {\n      globalMacros = {};\n    }\n\n    this.current = void 0;\n    this.builtins = void 0;\n    this.undefStack = void 0;\n    this.current = globalMacros;\n    this.builtins = builtins;\n    this.undefStack = [];\n  }\n  /**\n   * Start a new nested group, affecting future local `set`s.\n   */\n\n\n  beginGroup() {\n    this.undefStack.push({});\n  }\n  /**\n   * End current nested group, restoring values before the group began.\n   */\n\n\n  endGroup() {\n    if (this.undefStack.length === 0) {\n      throw new ParseError(\"Unbalanced namespace destruction: attempt \" + \"to pop global namespace; please report this as a bug\");\n    }\n\n    var undefs = this.undefStack.pop();\n\n    for (var undef in undefs) {\n      if (undefs.hasOwnProperty(undef)) {\n        if (undefs[undef] == null) {\n          delete this.current[undef];\n        } else {\n          this.current[undef] = undefs[undef];\n        }\n      }\n    }\n  }\n  /**\n   * Ends all currently nested groups (if any), restoring values before the\n   * groups began.  Useful in case of an error in the middle of parsing.\n   */\n\n\n  endGroups() {\n    while (this.undefStack.length > 0) {\n      this.endGroup();\n    }\n  }\n  /**\n   * Detect whether `name` has a definition.  Equivalent to\n   * `get(name) != null`.\n   */\n\n\n  has(name) {\n    return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);\n  }\n  /**\n   * Get the current value of a name, or `undefined` if there is no value.\n   *\n   * Note: Do not use `if (namespace.get(...))` to detect whether a macro\n   * is defined, as the definition may be the empty string which evaluates\n   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or\n   * `if (namespace.has(...))`.\n   */\n\n\n  get(name) {\n    if (this.current.hasOwnProperty(name)) {\n      return this.current[name];\n    } else {\n      return this.builtins[name];\n    }\n  }\n  /**\n   * Set the current value of a name, and optionally set it globally too.\n   * Local set() sets the current value and (when appropriate) adds an undo\n   * operation to the undo stack.  Global set() may change the undo\n   * operation at every level, so takes time linear in their number.\n   * A value of undefined means to delete existing definitions.\n   */\n\n\n  set(name, value, global) {\n    if (global === void 0) {\n      global = false;\n    }\n\n    if (global) {\n      // Global set is equivalent to setting in all groups.  Simulate this\n      // by destroying any undos currently scheduled for this name,\n      // and adding an undo with the *new* value (in case it later gets\n      // locally reset within this environment).\n      for (var i = 0; i < this.undefStack.length; i++) {\n        delete this.undefStack[i][name];\n      }\n\n      if (this.undefStack.length > 0) {\n        this.undefStack[this.undefStack.length - 1][name] = value;\n      }\n    } else {\n      // Undo this set at end of this group (possibly to `undefined`),\n      // unless an undo is already in place, in which case that older\n      // value is the correct one.\n      var top = this.undefStack[this.undefStack.length - 1];\n\n      if (top && !top.hasOwnProperty(name)) {\n        top[name] = this.current[name];\n      }\n    }\n\n    if (value == null) {\n      delete this.current[name];\n    } else {\n      this.current[name] = value;\n    }\n  }\n\n}\n\n/**\n * Predefined macros for KaTeX.\n * This can be used to define some commands in terms of others.\n */\nvar macros = _macros;\n// macro tools\n\ndefineMacro(\"\\\\noexpand\", function (context) {\n  // The expansion is the token itself; but that token is interpreted\n  // as if its meaning were \\relax if it is a control sequence that\n  // would ordinarily be expanded by TeXs expansion rules.\n  var t = context.popToken();\n\n  if (context.isExpandable(t.text)) {\n    t.noexpand = true;\n    t.treatAsRelax = true;\n  }\n\n  return {\n    tokens: [t],\n    numArgs: 0\n  };\n});\ndefineMacro(\"\\\\expandafter\", function (context) {\n  // TeX first reads the token that comes immediately after \\expandafter,\n  // without expanding it; lets call this token t. Then TeX reads the\n  // token that comes after t (and possibly more tokens, if that token\n  // has an argument), replacing it by its expansion. Finally TeX puts\n  // t back in front of that expansion.\n  var t = context.popToken();\n  context.expandOnce(true); // expand only an expandable token\n\n  return {\n    tokens: [t],\n    numArgs: 0\n  };\n}); // LaTeX's \\@firstoftwo{#1}{#2} expands to #1, skipping #2\n// TeX source: \\long\\def\\@firstoftwo#1#2{#1}\n\ndefineMacro(\"\\\\@firstoftwo\", function (context) {\n  var args = context.consumeArgs(2);\n  return {\n    tokens: args[0],\n    numArgs: 0\n  };\n}); // LaTeX's \\@secondoftwo{#1}{#2} expands to #2, skipping #1\n// TeX source: \\long\\def\\@secondoftwo#1#2{#2}\n\ndefineMacro(\"\\\\@secondoftwo\", function (context) {\n  var args = context.consumeArgs(2);\n  return {\n    tokens: args[1],\n    numArgs: 0\n  };\n}); // LaTeX's \\@ifnextchar{#1}{#2}{#3} looks ahead to the next (unexpanded)\n// symbol that isn't a space, consuming any spaces but not consuming the\n// first nonspace character.  If that nonspace character matches #1, then\n// the macro expands to #2; otherwise, it expands to #3.\n\ndefineMacro(\"\\\\@ifnextchar\", function (context) {\n  var args = context.consumeArgs(3); // symbol, if, else\n\n  context.consumeSpaces();\n  var nextToken = context.future();\n\n  if (args[0].length === 1 && args[0][0].text === nextToken.text) {\n    return {\n      tokens: args[1],\n      numArgs: 0\n    };\n  } else {\n    return {\n      tokens: args[2],\n      numArgs: 0\n    };\n  }\n}); // LaTeX's \\@ifstar{#1}{#2} looks ahead to the next (unexpanded) symbol.\n// If it is `*`, then it consumes the symbol, and the macro expands to #1;\n// otherwise, the macro expands to #2 (without consuming the symbol).\n// TeX source: \\def\\@ifstar#1{\\@ifnextchar *{\\@firstoftwo{#1}}}\n\ndefineMacro(\"\\\\@ifstar\", \"\\\\@ifnextchar *{\\\\@firstoftwo{#1}}\"); // LaTeX's \\TextOrMath{#1}{#2} expands to #1 in text mode, #2 in math mode\n\ndefineMacro(\"\\\\TextOrMath\", function (context) {\n  var args = context.consumeArgs(2);\n\n  if (context.mode === 'text') {\n    return {\n      tokens: args[0],\n      numArgs: 0\n    };\n  } else {\n    return {\n      tokens: args[1],\n      numArgs: 0\n    };\n  }\n}); // Lookup table for parsing numbers in base 8 through 16\n\nvar digitToNumber = {\n  \"0\": 0,\n  \"1\": 1,\n  \"2\": 2,\n  \"3\": 3,\n  \"4\": 4,\n  \"5\": 5,\n  \"6\": 6,\n  \"7\": 7,\n  \"8\": 8,\n  \"9\": 9,\n  \"a\": 10,\n  \"A\": 10,\n  \"b\": 11,\n  \"B\": 11,\n  \"c\": 12,\n  \"C\": 12,\n  \"d\": 13,\n  \"D\": 13,\n  \"e\": 14,\n  \"E\": 14,\n  \"f\": 15,\n  \"F\": 15\n}; // TeX \\char makes a literal character (catcode 12) using the following forms:\n// (see The TeXBook, p. 43)\n//   \\char123  -- decimal\n//   \\char'123 -- octal\n//   \\char\"123 -- hex\n//   \\char`x   -- character that can be written (i.e. isn't active)\n//   \\char`\\x  -- character that cannot be written (e.g. %)\n// These all refer to characters from the font, so we turn them into special\n// calls to a function \\@char dealt with in the Parser.\n\ndefineMacro(\"\\\\char\", function (context) {\n  var token = context.popToken();\n  var base;\n  var number = '';\n\n  if (token.text === \"'\") {\n    base = 8;\n    token = context.popToken();\n  } else if (token.text === '\"') {\n    base = 16;\n    token = context.popToken();\n  } else if (token.text === \"`\") {\n    token = context.popToken();\n\n    if (token.text[0] === \"\\\\\") {\n      number = token.text.charCodeAt(1);\n    } else if (token.text === \"EOF\") {\n      throw new ParseError(\"\\\\char` missing argument\");\n    } else {\n      number = token.text.charCodeAt(0);\n    }\n  } else {\n    base = 10;\n  }\n\n  if (base) {\n    // Parse a number in the given base, starting with first `token`.\n    number = digitToNumber[token.text];\n\n    if (number == null || number >= base) {\n      throw new ParseError(\"Invalid base-\" + base + \" digit \" + token.text);\n    }\n\n    var digit;\n\n    while ((digit = digitToNumber[context.future().text]) != null && digit < base) {\n      number *= base;\n      number += digit;\n      context.popToken();\n    }\n  }\n\n  return \"\\\\@char{\" + number + \"}\";\n}); // \\newcommand{\\macro}[args]{definition}\n// \\renewcommand{\\macro}[args]{definition}\n// TODO: Optional arguments: \\newcommand{\\macro}[args][default]{definition}\n\nvar newcommand = (context, existsOK, nonexistsOK, skipIfExists) => {\n  var arg = context.consumeArg().tokens;\n\n  if (arg.length !== 1) {\n    throw new ParseError(\"\\\\newcommand's first argument must be a macro name\");\n  }\n\n  var name = arg[0].text;\n  var exists = context.isDefined(name);\n\n  if (exists && !existsOK) {\n    throw new ParseError(\"\\\\newcommand{\" + name + \"} attempting to redefine \" + (name + \"; use \\\\renewcommand\"));\n  }\n\n  if (!exists && !nonexistsOK) {\n    throw new ParseError(\"\\\\renewcommand{\" + name + \"} when command \" + name + \" \" + \"does not yet exist; use \\\\newcommand\");\n  }\n\n  var numArgs = 0;\n  arg = context.consumeArg().tokens;\n\n  if (arg.length === 1 && arg[0].text === \"[\") {\n    var argText = '';\n    var token = context.expandNextToken();\n\n    while (token.text !== \"]\" && token.text !== \"EOF\") {\n      // TODO: Should properly expand arg, e.g., ignore {}s\n      argText += token.text;\n      token = context.expandNextToken();\n    }\n\n    if (!argText.match(/^\\s*[0-9]+\\s*$/)) {\n      throw new ParseError(\"Invalid number of arguments: \" + argText);\n    }\n\n    numArgs = parseInt(argText);\n    arg = context.consumeArg().tokens;\n  }\n\n  if (!(exists && skipIfExists)) {\n    // Final arg is the expansion of the macro\n    context.macros.set(name, {\n      tokens: arg,\n      numArgs\n    });\n  }\n\n  return '';\n};\n\ndefineMacro(\"\\\\newcommand\", context => newcommand(context, false, true, false));\ndefineMacro(\"\\\\renewcommand\", context => newcommand(context, true, false, false));\ndefineMacro(\"\\\\providecommand\", context => newcommand(context, true, true, true)); // terminal (console) tools\n\ndefineMacro(\"\\\\message\", context => {\n  var arg = context.consumeArgs(1)[0]; // eslint-disable-next-line no-console\n\n  console.log(arg.reverse().map(token => token.text).join(\"\"));\n  return '';\n});\ndefineMacro(\"\\\\errmessage\", context => {\n  var arg = context.consumeArgs(1)[0]; // eslint-disable-next-line no-console\n\n  console.error(arg.reverse().map(token => token.text).join(\"\"));\n  return '';\n});\ndefineMacro(\"\\\\show\", context => {\n  var tok = context.popToken();\n  var name = tok.text; // eslint-disable-next-line no-console\n\n  console.log(tok, context.macros.get(name), functions[name], symbols.math[name], symbols.text[name]);\n  return '';\n}); //////////////////////////////////////////////////////////////////////\n// Grouping\n// \\let\\bgroup={ \\let\\egroup=}\n\ndefineMacro(\"\\\\bgroup\", \"{\");\ndefineMacro(\"\\\\egroup\", \"}\"); // Symbols from latex.ltx:\n// \\def~{\\nobreakspace{}}\n// \\def\\lq{`}\n// \\def\\rq{'}\n// \\def \\aa {\\r a}\n// \\def \\AA {\\r A}\n\ndefineMacro(\"~\", \"\\\\nobreakspace\");\ndefineMacro(\"\\\\lq\", \"`\");\ndefineMacro(\"\\\\rq\", \"'\");\ndefineMacro(\"\\\\aa\", \"\\\\r a\");\ndefineMacro(\"\\\\AA\", \"\\\\r A\"); // Copyright (C) and registered (R) symbols. Use raw symbol in MathML.\n// \\DeclareTextCommandDefault{\\textcopyright}{\\textcircled{c}}\n// \\DeclareTextCommandDefault{\\textregistered}{\\textcircled{%\n//      \\check@mathfonts\\fontsize\\sf@size\\z@\\math@fontsfalse\\selectfont R}}\n// \\DeclareRobustCommand{\\copyright}{%\n//    \\ifmmode{\\nfss@text{\\textcopyright}}\\else\\textcopyright\\fi}\n\ndefineMacro(\"\\\\textcopyright\", \"\\\\html@mathml{\\\\textcircled{c}}{\\\\char`}\");\ndefineMacro(\"\\\\copyright\", \"\\\\TextOrMath{\\\\textcopyright}{\\\\text{\\\\textcopyright}}\");\ndefineMacro(\"\\\\textregistered\", \"\\\\html@mathml{\\\\textcircled{\\\\scriptsize R}}{\\\\char`}\"); // Characters omitted from Unicode range 1D4001D7FF\n\ndefineMacro(\"\\u212C\", \"\\\\mathscr{B}\"); // script\n\ndefineMacro(\"\\u2130\", \"\\\\mathscr{E}\");\ndefineMacro(\"\\u2131\", \"\\\\mathscr{F}\");\ndefineMacro(\"\\u210B\", \"\\\\mathscr{H}\");\ndefineMacro(\"\\u2110\", \"\\\\mathscr{I}\");\ndefineMacro(\"\\u2112\", \"\\\\mathscr{L}\");\ndefineMacro(\"\\u2133\", \"\\\\mathscr{M}\");\ndefineMacro(\"\\u211B\", \"\\\\mathscr{R}\");\ndefineMacro(\"\\u212D\", \"\\\\mathfrak{C}\"); // Fraktur\n\ndefineMacro(\"\\u210C\", \"\\\\mathfrak{H}\");\ndefineMacro(\"\\u2128\", \"\\\\mathfrak{Z}\"); // Define \\Bbbk with a macro that works in both HTML and MathML.\n\ndefineMacro(\"\\\\Bbbk\", \"\\\\Bbb{k}\"); // Unicode middle dot\n// The KaTeX fonts do not contain U+00B7. Instead, \\cdotp displays\n// the dot at U+22C5 and gives it punct spacing.\n\ndefineMacro(\"\\u00b7\", \"\\\\cdotp\"); // \\llap and \\rlap render their contents in text mode\n\ndefineMacro(\"\\\\llap\", \"\\\\mathllap{\\\\textrm{#1}}\");\ndefineMacro(\"\\\\rlap\", \"\\\\mathrlap{\\\\textrm{#1}}\");\ndefineMacro(\"\\\\clap\", \"\\\\mathclap{\\\\textrm{#1}}\"); // \\mathstrut from the TeXbook, p 360\n\ndefineMacro(\"\\\\mathstrut\", \"\\\\vphantom{(}\"); // \\underbar from TeXbook p 353\n\ndefineMacro(\"\\\\underbar\", \"\\\\underline{\\\\text{#1}}\"); // \\not is defined by base/fontmath.ltx via\n// \\DeclareMathSymbol{\\not}{\\mathrel}{symbols}{\"36}\n// It's thus treated like a \\mathrel, but defined by a symbol that has zero\n// width but extends to the right.  We use \\rlap to get that spacing.\n// For MathML we write U+0338 here. buildMathML.js will then do the overlay.\n\ndefineMacro(\"\\\\not\", '\\\\html@mathml{\\\\mathrel{\\\\mathrlap\\\\@not}}{\\\\char\"338}'); // Negated symbols from base/fontmath.ltx:\n// \\def\\neq{\\not=} \\let\\ne=\\neq\n// \\DeclareRobustCommand\n//   \\notin{\\mathrel{\\m@th\\mathpalette\\c@ncel\\in}}\n// \\def\\c@ncel#1#2{\\m@th\\ooalign{$\\hfil#1\\mkern1mu/\\hfil$\\crcr$#1#2$}}\n\ndefineMacro(\"\\\\neq\", \"\\\\html@mathml{\\\\mathrel{\\\\not=}}{\\\\mathrel{\\\\char`}}\");\ndefineMacro(\"\\\\ne\", \"\\\\neq\");\ndefineMacro(\"\\u2260\", \"\\\\neq\");\ndefineMacro(\"\\\\notin\", \"\\\\html@mathml{\\\\mathrel{{\\\\in}\\\\mathllap{/\\\\mskip1mu}}}\" + \"{\\\\mathrel{\\\\char`}}\");\ndefineMacro(\"\\u2209\", \"\\\\notin\"); // Unicode stacked relations\n\ndefineMacro(\"\\u2258\", \"\\\\html@mathml{\" + \"\\\\mathrel{=\\\\kern{-1em}\\\\raisebox{0.4em}{$\\\\scriptsize\\\\frown$}}\" + \"}{\\\\mathrel{\\\\char`\\u2258}}\");\ndefineMacro(\"\\u2259\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\wedge}{=}}{\\\\mathrel{\\\\char`\\u2258}}\");\ndefineMacro(\"\\u225A\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\vee}{=}}{\\\\mathrel{\\\\char`\\u225A}}\");\ndefineMacro(\"\\u225B\", \"\\\\html@mathml{\\\\stackrel{\\\\scriptsize\\\\star}{=}}\" + \"{\\\\mathrel{\\\\char`\\u225B}}\");\ndefineMacro(\"\\u225D\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\mathrm{def}}{=}}\" + \"{\\\\mathrel{\\\\char`\\u225D}}\");\ndefineMacro(\"\\u225E\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny\\\\mathrm{m}}{=}}\" + \"{\\\\mathrel{\\\\char`\\u225E}}\");\ndefineMacro(\"\\u225F\", \"\\\\html@mathml{\\\\stackrel{\\\\tiny?}{=}}{\\\\mathrel{\\\\char`\\u225F}}\"); // Misc Unicode\n\ndefineMacro(\"\\u27C2\", \"\\\\perp\");\ndefineMacro(\"\\u203C\", \"\\\\mathclose{!\\\\mkern-0.8mu!}\");\ndefineMacro(\"\\u220C\", \"\\\\notni\");\ndefineMacro(\"\\u231C\", \"\\\\ulcorner\");\ndefineMacro(\"\\u231D\", \"\\\\urcorner\");\ndefineMacro(\"\\u231E\", \"\\\\llcorner\");\ndefineMacro(\"\\u231F\", \"\\\\lrcorner\");\ndefineMacro(\"\\u00A9\", \"\\\\copyright\");\ndefineMacro(\"\\u00AE\", \"\\\\textregistered\");\ndefineMacro(\"\\uFE0F\", \"\\\\textregistered\"); // The KaTeX fonts have corners at codepoints that don't match Unicode.\n// For MathML purposes, use the Unicode code point.\n\ndefineMacro(\"\\\\ulcorner\", \"\\\\html@mathml{\\\\@ulcorner}{\\\\mathop{\\\\char\\\"231c}}\");\ndefineMacro(\"\\\\urcorner\", \"\\\\html@mathml{\\\\@urcorner}{\\\\mathop{\\\\char\\\"231d}}\");\ndefineMacro(\"\\\\llcorner\", \"\\\\html@mathml{\\\\@llcorner}{\\\\mathop{\\\\char\\\"231e}}\");\ndefineMacro(\"\\\\lrcorner\", \"\\\\html@mathml{\\\\@lrcorner}{\\\\mathop{\\\\char\\\"231f}}\"); //////////////////////////////////////////////////////////////////////\n// LaTeX_2\n// \\vdots{\\vbox{\\baselineskip4\\p@  \\lineskiplimit\\z@\n// \\kern6\\p@\\hbox{.}\\hbox{.}\\hbox{.}}}\n// We'll call \\varvdots, which gets a glyph from symbols.js.\n// The zero-width rule gets us an equivalent to the vertical 6pt kern.\n\ndefineMacro(\"\\\\vdots\", \"{\\\\varvdots\\\\rule{0pt}{15pt}}\");\ndefineMacro(\"\\u22ee\", \"\\\\vdots\"); //////////////////////////////////////////////////////////////////////\n// amsmath.sty\n// http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf\n// Italic Greek capital letters.  AMS defines these with \\DeclareMathSymbol,\n// but they are equivalent to \\mathit{\\Letter}.\n\ndefineMacro(\"\\\\varGamma\", \"\\\\mathit{\\\\Gamma}\");\ndefineMacro(\"\\\\varDelta\", \"\\\\mathit{\\\\Delta}\");\ndefineMacro(\"\\\\varTheta\", \"\\\\mathit{\\\\Theta}\");\ndefineMacro(\"\\\\varLambda\", \"\\\\mathit{\\\\Lambda}\");\ndefineMacro(\"\\\\varXi\", \"\\\\mathit{\\\\Xi}\");\ndefineMacro(\"\\\\varPi\", \"\\\\mathit{\\\\Pi}\");\ndefineMacro(\"\\\\varSigma\", \"\\\\mathit{\\\\Sigma}\");\ndefineMacro(\"\\\\varUpsilon\", \"\\\\mathit{\\\\Upsilon}\");\ndefineMacro(\"\\\\varPhi\", \"\\\\mathit{\\\\Phi}\");\ndefineMacro(\"\\\\varPsi\", \"\\\\mathit{\\\\Psi}\");\ndefineMacro(\"\\\\varOmega\", \"\\\\mathit{\\\\Omega}\"); //\\newcommand{\\substack}[1]{\\subarray{c}#1\\endsubarray}\n\ndefineMacro(\"\\\\substack\", \"\\\\begin{subarray}{c}#1\\\\end{subarray}\"); // \\renewcommand{\\colon}{\\nobreak\\mskip2mu\\mathpunct{}\\nonscript\n// \\mkern-\\thinmuskip{:}\\mskip6muplus1mu\\relax}\n\ndefineMacro(\"\\\\colon\", \"\\\\nobreak\\\\mskip2mu\\\\mathpunct{}\" + \"\\\\mathchoice{\\\\mkern-3mu}{\\\\mkern-3mu}{}{}{:}\\\\mskip6mu\\\\relax\"); // \\newcommand{\\boxed}[1]{\\fbox{\\m@th$\\displaystyle#1$}}\n\ndefineMacro(\"\\\\boxed\", \"\\\\fbox{$\\\\displaystyle{#1}$}\"); // \\def\\iff{\\DOTSB\\;\\Longleftrightarrow\\;}\n// \\def\\implies{\\DOTSB\\;\\Longrightarrow\\;}\n// \\def\\impliedby{\\DOTSB\\;\\Longleftarrow\\;}\n\ndefineMacro(\"\\\\iff\", \"\\\\DOTSB\\\\;\\\\Longleftrightarrow\\\\;\");\ndefineMacro(\"\\\\implies\", \"\\\\DOTSB\\\\;\\\\Longrightarrow\\\\;\");\ndefineMacro(\"\\\\impliedby\", \"\\\\DOTSB\\\\;\\\\Longleftarrow\\\\;\"); // \\def\\dddot#1{{\\mathop{#1}\\limits^{\\vbox to-1.4\\ex@{\\kern-\\tw@\\ex@\n//  \\hbox{\\normalfont ...}\\vss}}}}\n// We use \\overset which avoids the vertical shift of \\mathop.\n\ndefineMacro(\"\\\\dddot\", \"{\\\\overset{\\\\raisebox{-0.1ex}{\\\\normalsize ...}}{#1}}\");\ndefineMacro(\"\\\\ddddot\", \"{\\\\overset{\\\\raisebox{-0.1ex}{\\\\normalsize ....}}{#1}}\"); // AMSMath's automatic \\dots, based on \\mdots@@ macro.\n\nvar dotsByToken = {\n  ',': '\\\\dotsc',\n  '\\\\not': '\\\\dotsb',\n  // \\keybin@ checks for the following:\n  '+': '\\\\dotsb',\n  '=': '\\\\dotsb',\n  '<': '\\\\dotsb',\n  '>': '\\\\dotsb',\n  '-': '\\\\dotsb',\n  '*': '\\\\dotsb',\n  ':': '\\\\dotsb',\n  // Symbols whose definition starts with \\DOTSB:\n  '\\\\DOTSB': '\\\\dotsb',\n  '\\\\coprod': '\\\\dotsb',\n  '\\\\bigvee': '\\\\dotsb',\n  '\\\\bigwedge': '\\\\dotsb',\n  '\\\\biguplus': '\\\\dotsb',\n  '\\\\bigcap': '\\\\dotsb',\n  '\\\\bigcup': '\\\\dotsb',\n  '\\\\prod': '\\\\dotsb',\n  '\\\\sum': '\\\\dotsb',\n  '\\\\bigotimes': '\\\\dotsb',\n  '\\\\bigoplus': '\\\\dotsb',\n  '\\\\bigodot': '\\\\dotsb',\n  '\\\\bigsqcup': '\\\\dotsb',\n  '\\\\And': '\\\\dotsb',\n  '\\\\longrightarrow': '\\\\dotsb',\n  '\\\\Longrightarrow': '\\\\dotsb',\n  '\\\\longleftarrow': '\\\\dotsb',\n  '\\\\Longleftarrow': '\\\\dotsb',\n  '\\\\longleftrightarrow': '\\\\dotsb',\n  '\\\\Longleftrightarrow': '\\\\dotsb',\n  '\\\\mapsto': '\\\\dotsb',\n  '\\\\longmapsto': '\\\\dotsb',\n  '\\\\hookrightarrow': '\\\\dotsb',\n  '\\\\doteq': '\\\\dotsb',\n  // Symbols whose definition starts with \\mathbin:\n  '\\\\mathbin': '\\\\dotsb',\n  // Symbols whose definition starts with \\mathrel:\n  '\\\\mathrel': '\\\\dotsb',\n  '\\\\relbar': '\\\\dotsb',\n  '\\\\Relbar': '\\\\dotsb',\n  '\\\\xrightarrow': '\\\\dotsb',\n  '\\\\xleftarrow': '\\\\dotsb',\n  // Symbols whose definition starts with \\DOTSI:\n  '\\\\DOTSI': '\\\\dotsi',\n  '\\\\int': '\\\\dotsi',\n  '\\\\oint': '\\\\dotsi',\n  '\\\\iint': '\\\\dotsi',\n  '\\\\iiint': '\\\\dotsi',\n  '\\\\iiiint': '\\\\dotsi',\n  '\\\\idotsint': '\\\\dotsi',\n  // Symbols whose definition starts with \\DOTSX:\n  '\\\\DOTSX': '\\\\dotsx'\n};\ndefineMacro(\"\\\\dots\", function (context) {\n  // TODO: If used in text mode, should expand to \\textellipsis.\n  // However, in KaTeX, \\textellipsis and \\ldots behave the same\n  // (in text mode), and it's unlikely we'd see any of the math commands\n  // that affect the behavior of \\dots when in text mode.  So fine for now\n  // (until we support \\ifmmode ... \\else ... \\fi).\n  var thedots = '\\\\dotso';\n  var next = context.expandAfterFuture().text;\n\n  if (next in dotsByToken) {\n    thedots = dotsByToken[next];\n  } else if (next.slice(0, 4) === '\\\\not') {\n    thedots = '\\\\dotsb';\n  } else if (next in symbols.math) {\n    if (['bin', 'rel'].includes(symbols.math[next].group)) {\n      thedots = '\\\\dotsb';\n    }\n  }\n\n  return thedots;\n});\nvar spaceAfterDots = {\n  // \\rightdelim@ checks for the following:\n  ')': true,\n  ']': true,\n  '\\\\rbrack': true,\n  '\\\\}': true,\n  '\\\\rbrace': true,\n  '\\\\rangle': true,\n  '\\\\rceil': true,\n  '\\\\rfloor': true,\n  '\\\\rgroup': true,\n  '\\\\rmoustache': true,\n  '\\\\right': true,\n  '\\\\bigr': true,\n  '\\\\biggr': true,\n  '\\\\Bigr': true,\n  '\\\\Biggr': true,\n  // \\extra@ also tests for the following:\n  '$': true,\n  // \\extrap@ checks for the following:\n  ';': true,\n  '.': true,\n  ',': true\n};\ndefineMacro(\"\\\\dotso\", function (context) {\n  var next = context.future().text;\n\n  if (next in spaceAfterDots) {\n    return \"\\\\ldots\\\\,\";\n  } else {\n    return \"\\\\ldots\";\n  }\n});\ndefineMacro(\"\\\\dotsc\", function (context) {\n  var next = context.future().text; // \\dotsc uses \\extra@ but not \\extrap@, instead specially checking for\n  // ';' and '.', but doesn't check for ','.\n\n  if (next in spaceAfterDots && next !== ',') {\n    return \"\\\\ldots\\\\,\";\n  } else {\n    return \"\\\\ldots\";\n  }\n});\ndefineMacro(\"\\\\cdots\", function (context) {\n  var next = context.future().text;\n\n  if (next in spaceAfterDots) {\n    return \"\\\\@cdots\\\\,\";\n  } else {\n    return \"\\\\@cdots\";\n  }\n});\ndefineMacro(\"\\\\dotsb\", \"\\\\cdots\");\ndefineMacro(\"\\\\dotsm\", \"\\\\cdots\");\ndefineMacro(\"\\\\dotsi\", \"\\\\!\\\\cdots\"); // amsmath doesn't actually define \\dotsx, but \\dots followed by a macro\n// starting with \\DOTSX implies \\dotso, and then \\extra@ detects this case\n// and forces the added `\\,`.\n\ndefineMacro(\"\\\\dotsx\", \"\\\\ldots\\\\,\"); // \\let\\DOTSI\\relax\n// \\let\\DOTSB\\relax\n// \\let\\DOTSX\\relax\n\ndefineMacro(\"\\\\DOTSI\", \"\\\\relax\");\ndefineMacro(\"\\\\DOTSB\", \"\\\\relax\");\ndefineMacro(\"\\\\DOTSX\", \"\\\\relax\"); // Spacing, based on amsmath.sty's override of LaTeX defaults\n// \\DeclareRobustCommand{\\tmspace}[3]{%\n//   \\ifmmode\\mskip#1#2\\else\\kern#1#3\\fi\\relax}\n\ndefineMacro(\"\\\\tmspace\", \"\\\\TextOrMath{\\\\kern#1#3}{\\\\mskip#1#2}\\\\relax\"); // \\renewcommand{\\,}{\\tmspace+\\thinmuskip{.1667em}}\n// TODO: math mode should use \\thinmuskip\n\ndefineMacro(\"\\\\,\", \"\\\\tmspace+{3mu}{.1667em}\"); // \\let\\thinspace\\,\n\ndefineMacro(\"\\\\thinspace\", \"\\\\,\"); // \\def\\>{\\mskip\\medmuskip}\n// \\renewcommand{\\:}{\\tmspace+\\medmuskip{.2222em}}\n// TODO: \\> and math mode of \\: should use \\medmuskip = 4mu plus 2mu minus 4mu\n\ndefineMacro(\"\\\\>\", \"\\\\mskip{4mu}\");\ndefineMacro(\"\\\\:\", \"\\\\tmspace+{4mu}{.2222em}\"); // \\let\\medspace\\:\n\ndefineMacro(\"\\\\medspace\", \"\\\\:\"); // \\renewcommand{\\;}{\\tmspace+\\thickmuskip{.2777em}}\n// TODO: math mode should use \\thickmuskip = 5mu plus 5mu\n\ndefineMacro(\"\\\\;\", \"\\\\tmspace+{5mu}{.2777em}\"); // \\let\\thickspace\\;\n\ndefineMacro(\"\\\\thickspace\", \"\\\\;\"); // \\renewcommand{\\!}{\\tmspace-\\thinmuskip{.1667em}}\n// TODO: math mode should use \\thinmuskip\n\ndefineMacro(\"\\\\!\", \"\\\\tmspace-{3mu}{.1667em}\"); // \\let\\negthinspace\\!\n\ndefineMacro(\"\\\\negthinspace\", \"\\\\!\"); // \\newcommand{\\negmedspace}{\\tmspace-\\medmuskip{.2222em}}\n// TODO: math mode should use \\medmuskip\n\ndefineMacro(\"\\\\negmedspace\", \"\\\\tmspace-{4mu}{.2222em}\"); // \\newcommand{\\negthickspace}{\\tmspace-\\thickmuskip{.2777em}}\n// TODO: math mode should use \\thickmuskip\n\ndefineMacro(\"\\\\negthickspace\", \"\\\\tmspace-{5mu}{.277em}\"); // \\def\\enspace{\\kern.5em }\n\ndefineMacro(\"\\\\enspace\", \"\\\\kern.5em \"); // \\def\\enskip{\\hskip.5em\\relax}\n\ndefineMacro(\"\\\\enskip\", \"\\\\hskip.5em\\\\relax\"); // \\def\\quad{\\hskip1em\\relax}\n\ndefineMacro(\"\\\\quad\", \"\\\\hskip1em\\\\relax\"); // \\def\\qquad{\\hskip2em\\relax}\n\ndefineMacro(\"\\\\qquad\", \"\\\\hskip2em\\\\relax\"); // \\tag@in@display form of \\tag\n\ndefineMacro(\"\\\\tag\", \"\\\\@ifstar\\\\tag@literal\\\\tag@paren\");\ndefineMacro(\"\\\\tag@paren\", \"\\\\tag@literal{({#1})}\");\ndefineMacro(\"\\\\tag@literal\", context => {\n  if (context.macros.get(\"\\\\df@tag\")) {\n    throw new ParseError(\"Multiple \\\\tag\");\n  }\n\n  return \"\\\\gdef\\\\df@tag{\\\\text{#1}}\";\n}); // \\renewcommand{\\bmod}{\\nonscript\\mskip-\\medmuskip\\mkern5mu\\mathbin\n//   {\\operator@font mod}\\penalty900\n//   \\mkern5mu\\nonscript\\mskip-\\medmuskip}\n// \\newcommand{\\pod}[1]{\\allowbreak\n//   \\if@display\\mkern18mu\\else\\mkern8mu\\fi(#1)}\n// \\renewcommand{\\pmod}[1]{\\pod{{\\operator@font mod}\\mkern6mu#1}}\n// \\newcommand{\\mod}[1]{\\allowbreak\\if@display\\mkern18mu\n//   \\else\\mkern12mu\\fi{\\operator@font mod}\\,\\,#1}\n// TODO: math mode should use \\medmuskip = 4mu plus 2mu minus 4mu\n\ndefineMacro(\"\\\\bmod\", \"\\\\mathchoice{\\\\mskip1mu}{\\\\mskip1mu}{\\\\mskip5mu}{\\\\mskip5mu}\" + \"\\\\mathbin{\\\\rm mod}\" + \"\\\\mathchoice{\\\\mskip1mu}{\\\\mskip1mu}{\\\\mskip5mu}{\\\\mskip5mu}\");\ndefineMacro(\"\\\\pod\", \"\\\\allowbreak\" + \"\\\\mathchoice{\\\\mkern18mu}{\\\\mkern8mu}{\\\\mkern8mu}{\\\\mkern8mu}(#1)\");\ndefineMacro(\"\\\\pmod\", \"\\\\pod{{\\\\rm mod}\\\\mkern6mu#1}\");\ndefineMacro(\"\\\\mod\", \"\\\\allowbreak\" + \"\\\\mathchoice{\\\\mkern18mu}{\\\\mkern12mu}{\\\\mkern12mu}{\\\\mkern12mu}\" + \"{\\\\rm mod}\\\\,\\\\,#1\"); //////////////////////////////////////////////////////////////////////\n// LaTeX source2e\n// \\expandafter\\let\\expandafter\\@normalcr\n//     \\csname\\expandafter\\@gobble\\string\\\\ \\endcsname\n// \\DeclareRobustCommand\\newline{\\@normalcr\\relax}\n\ndefineMacro(\"\\\\newline\", \"\\\\\\\\\\\\relax\"); // \\def\\TeX{T\\kern-.1667em\\lower.5ex\\hbox{E}\\kern-.125emX\\@}\n// TODO: Doesn't normally work in math mode because \\@ fails.  KaTeX doesn't\n// support \\@ yet, so that's omitted, and we add \\text so that the result\n// doesn't look funny in math mode.\n\ndefineMacro(\"\\\\TeX\", \"\\\\textrm{\\\\html@mathml{\" + \"T\\\\kern-.1667em\\\\raisebox{-.5ex}{E}\\\\kern-.125emX\" + \"}{TeX}}\"); // \\DeclareRobustCommand{\\LaTeX}{L\\kern-.36em%\n//         {\\sbox\\z@ T%\n//          \\vbox to\\ht\\z@{\\hbox{\\check@mathfonts\n//                               \\fontsize\\sf@size\\z@\n//                               \\math@fontsfalse\\selectfont\n//                               A}%\n//                         \\vss}%\n//         }%\n//         \\kern-.15em%\n//         \\TeX}\n// This code aligns the top of the A with the T (from the perspective of TeX's\n// boxes, though visually the A appears to extend above slightly).\n// We compute the corresponding \\raisebox when A is rendered in \\normalsize\n// \\scriptstyle, which has a scale factor of 0.7 (see Options.js).\n\nvar latexRaiseA = makeEm(fontMetricsData['Main-Regular'][\"T\".charCodeAt(0)][1] - 0.7 * fontMetricsData['Main-Regular'][\"A\".charCodeAt(0)][1]);\ndefineMacro(\"\\\\LaTeX\", \"\\\\textrm{\\\\html@mathml{\" + (\"L\\\\kern-.36em\\\\raisebox{\" + latexRaiseA + \"}{\\\\scriptstyle A}\") + \"\\\\kern-.15em\\\\TeX}{LaTeX}}\"); // New KaTeX logo based on tweaking LaTeX logo\n\ndefineMacro(\"\\\\KaTeX\", \"\\\\textrm{\\\\html@mathml{\" + (\"K\\\\kern-.17em\\\\raisebox{\" + latexRaiseA + \"}{\\\\scriptstyle A}\") + \"\\\\kern-.15em\\\\TeX}{KaTeX}}\"); // \\DeclareRobustCommand\\hspace{\\@ifstar\\@hspacer\\@hspace}\n// \\def\\@hspace#1{\\hskip  #1\\relax}\n// \\def\\@hspacer#1{\\vrule \\@width\\z@\\nobreak\n//                 \\hskip #1\\hskip \\z@skip}\n\ndefineMacro(\"\\\\hspace\", \"\\\\@ifstar\\\\@hspacer\\\\@hspace\");\ndefineMacro(\"\\\\@hspace\", \"\\\\hskip #1\\\\relax\");\ndefineMacro(\"\\\\@hspacer\", \"\\\\rule{0pt}{0pt}\\\\hskip #1\\\\relax\"); //////////////////////////////////////////////////////////////////////\n// mathtools.sty\n//\\providecommand\\ordinarycolon{:}\n\ndefineMacro(\"\\\\ordinarycolon\", \":\"); //\\def\\vcentcolon{\\mathrel{\\mathop\\ordinarycolon}}\n//TODO(edemaine): Not yet centered. Fix via \\raisebox or #726\n\ndefineMacro(\"\\\\vcentcolon\", \"\\\\mathrel{\\\\mathop\\\\ordinarycolon}\"); // \\providecommand*\\dblcolon{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}\n\ndefineMacro(\"\\\\dblcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-.9mu}\\\\vcentcolon}}\" + \"{\\\\mathop{\\\\char\\\"2237}}\"); // \\providecommand*\\coloneqq{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}\n\ndefineMacro(\"\\\\coloneqq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}=}}\" + \"{\\\\mathop{\\\\char\\\"2254}}\"); // \n// \\providecommand*\\Coloneqq{\\dblcolon\\mathrel{\\mkern-1.2mu}=}\n\ndefineMacro(\"\\\\Coloneqq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}=}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"3d}}\"); // \\providecommand*\\coloneq{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}\n\ndefineMacro(\"\\\\coloneq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\mathrel{-}}}\" + \"{\\\\mathop{\\\\char\\\"3a\\\\char\\\"2212}}\"); // \\providecommand*\\Coloneq{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}\n\ndefineMacro(\"\\\\Coloneq\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\mathrel{-}}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"2212}}\"); // \\providecommand*\\eqqcolon{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}\n\ndefineMacro(\"\\\\eqqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{=\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}}\" + \"{\\\\mathop{\\\\char\\\"2255}}\"); // \n// \\providecommand*\\Eqqcolon{=\\mathrel{\\mkern-1.2mu}\\dblcolon}\n\ndefineMacro(\"\\\\Eqqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{=\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}}\" + \"{\\\\mathop{\\\\char\\\"3d\\\\char\\\"2237}}\"); // \\providecommand*\\eqcolon{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}\n\ndefineMacro(\"\\\\eqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\mathrel{-}\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}}\" + \"{\\\\mathop{\\\\char\\\"2239}}\"); // \\providecommand*\\Eqcolon{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}\n\ndefineMacro(\"\\\\Eqcolon\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\mathrel{-}\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}}\" + \"{\\\\mathop{\\\\char\\\"2212\\\\char\\\"2237}}\"); // \\providecommand*\\colonapprox{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}\n\ndefineMacro(\"\\\\colonapprox\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\approx}}\" + \"{\\\\mathop{\\\\char\\\"3a\\\\char\\\"2248}}\"); // \\providecommand*\\Colonapprox{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}\n\ndefineMacro(\"\\\\Colonapprox\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\approx}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"2248}}\"); // \\providecommand*\\colonsim{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}\n\ndefineMacro(\"\\\\colonsim\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\vcentcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\sim}}\" + \"{\\\\mathop{\\\\char\\\"3a\\\\char\\\"223c}}\"); // \\providecommand*\\Colonsim{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}\n\ndefineMacro(\"\\\\Colonsim\", \"\\\\html@mathml{\" + \"\\\\mathrel{\\\\dblcolon\\\\mathrel{\\\\mkern-1.2mu}\\\\sim}}\" + \"{\\\\mathop{\\\\char\\\"2237\\\\char\\\"223c}}\"); // Some Unicode characters are implemented with macros to mathtools functions.\n\ndefineMacro(\"\\u2237\", \"\\\\dblcolon\"); // ::\n\ndefineMacro(\"\\u2239\", \"\\\\eqcolon\"); // -:\n\ndefineMacro(\"\\u2254\", \"\\\\coloneqq\"); // :=\n\ndefineMacro(\"\\u2255\", \"\\\\eqqcolon\"); // =:\n\ndefineMacro(\"\\u2A74\", \"\\\\Coloneqq\"); // ::=\n//////////////////////////////////////////////////////////////////////\n// colonequals.sty\n// Alternate names for mathtools's macros:\n\ndefineMacro(\"\\\\ratio\", \"\\\\vcentcolon\");\ndefineMacro(\"\\\\coloncolon\", \"\\\\dblcolon\");\ndefineMacro(\"\\\\colonequals\", \"\\\\coloneqq\");\ndefineMacro(\"\\\\coloncolonequals\", \"\\\\Coloneqq\");\ndefineMacro(\"\\\\equalscolon\", \"\\\\eqqcolon\");\ndefineMacro(\"\\\\equalscoloncolon\", \"\\\\Eqqcolon\");\ndefineMacro(\"\\\\colonminus\", \"\\\\coloneq\");\ndefineMacro(\"\\\\coloncolonminus\", \"\\\\Coloneq\");\ndefineMacro(\"\\\\minuscolon\", \"\\\\eqcolon\");\ndefineMacro(\"\\\\minuscoloncolon\", \"\\\\Eqcolon\"); // \\colonapprox name is same in mathtools and colonequals.\n\ndefineMacro(\"\\\\coloncolonapprox\", \"\\\\Colonapprox\"); // \\colonsim name is same in mathtools and colonequals.\n\ndefineMacro(\"\\\\coloncolonsim\", \"\\\\Colonsim\"); // Additional macros, implemented by analogy with mathtools definitions:\n\ndefineMacro(\"\\\\simcolon\", \"\\\\mathrel{\\\\sim\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}\");\ndefineMacro(\"\\\\simcoloncolon\", \"\\\\mathrel{\\\\sim\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}\");\ndefineMacro(\"\\\\approxcolon\", \"\\\\mathrel{\\\\approx\\\\mathrel{\\\\mkern-1.2mu}\\\\vcentcolon}\");\ndefineMacro(\"\\\\approxcoloncolon\", \"\\\\mathrel{\\\\approx\\\\mathrel{\\\\mkern-1.2mu}\\\\dblcolon}\"); // Present in newtxmath, pxfonts and txfonts\n\ndefineMacro(\"\\\\notni\", \"\\\\html@mathml{\\\\not\\\\ni}{\\\\mathrel{\\\\char`\\u220C}}\");\ndefineMacro(\"\\\\limsup\", \"\\\\DOTSB\\\\operatorname*{lim\\\\,sup}\");\ndefineMacro(\"\\\\liminf\", \"\\\\DOTSB\\\\operatorname*{lim\\\\,inf}\"); //////////////////////////////////////////////////////////////////////\n// From amsopn.sty\n\ndefineMacro(\"\\\\injlim\", \"\\\\DOTSB\\\\operatorname*{inj\\\\,lim}\");\ndefineMacro(\"\\\\projlim\", \"\\\\DOTSB\\\\operatorname*{proj\\\\,lim}\");\ndefineMacro(\"\\\\varlimsup\", \"\\\\DOTSB\\\\operatorname*{\\\\overline{lim}}\");\ndefineMacro(\"\\\\varliminf\", \"\\\\DOTSB\\\\operatorname*{\\\\underline{lim}}\");\ndefineMacro(\"\\\\varinjlim\", \"\\\\DOTSB\\\\operatorname*{\\\\underrightarrow{lim}}\");\ndefineMacro(\"\\\\varprojlim\", \"\\\\DOTSB\\\\operatorname*{\\\\underleftarrow{lim}}\"); //////////////////////////////////////////////////////////////////////\n// MathML alternates for KaTeX glyphs in the Unicode private area\n\ndefineMacro(\"\\\\gvertneqq\", \"\\\\html@mathml{\\\\@gvertneqq}{\\u2269}\");\ndefineMacro(\"\\\\lvertneqq\", \"\\\\html@mathml{\\\\@lvertneqq}{\\u2268}\");\ndefineMacro(\"\\\\ngeqq\", \"\\\\html@mathml{\\\\@ngeqq}{\\u2271}\");\ndefineMacro(\"\\\\ngeqslant\", \"\\\\html@mathml{\\\\@ngeqslant}{\\u2271}\");\ndefineMacro(\"\\\\nleqq\", \"\\\\html@mathml{\\\\@nleqq}{\\u2270}\");\ndefineMacro(\"\\\\nleqslant\", \"\\\\html@mathml{\\\\@nleqslant}{\\u2270}\");\ndefineMacro(\"\\\\nshortmid\", \"\\\\html@mathml{\\\\@nshortmid}{}\");\ndefineMacro(\"\\\\nshortparallel\", \"\\\\html@mathml{\\\\@nshortparallel}{}\");\ndefineMacro(\"\\\\nsubseteqq\", \"\\\\html@mathml{\\\\@nsubseteqq}{\\u2288}\");\ndefineMacro(\"\\\\nsupseteqq\", \"\\\\html@mathml{\\\\@nsupseteqq}{\\u2289}\");\ndefineMacro(\"\\\\varsubsetneq\", \"\\\\html@mathml{\\\\@varsubsetneq}{}\");\ndefineMacro(\"\\\\varsubsetneqq\", \"\\\\html@mathml{\\\\@varsubsetneqq}{}\");\ndefineMacro(\"\\\\varsupsetneq\", \"\\\\html@mathml{\\\\@varsupsetneq}{}\");\ndefineMacro(\"\\\\varsupsetneqq\", \"\\\\html@mathml{\\\\@varsupsetneqq}{}\");\ndefineMacro(\"\\\\imath\", \"\\\\html@mathml{\\\\@imath}{\\u0131}\");\ndefineMacro(\"\\\\jmath\", \"\\\\html@mathml{\\\\@jmath}{\\u0237}\"); //////////////////////////////////////////////////////////////////////\n// stmaryrd and semantic\n// The stmaryrd and semantic packages render the next four items by calling a\n// glyph. Those glyphs do not exist in the KaTeX fonts. Hence the macros.\n\ndefineMacro(\"\\\\llbracket\", \"\\\\html@mathml{\" + \"\\\\mathopen{[\\\\mkern-3.2mu[}}\" + \"{\\\\mathopen{\\\\char`\\u27e6}}\");\ndefineMacro(\"\\\\rrbracket\", \"\\\\html@mathml{\" + \"\\\\mathclose{]\\\\mkern-3.2mu]}}\" + \"{\\\\mathclose{\\\\char`\\u27e7}}\");\ndefineMacro(\"\\u27e6\", \"\\\\llbracket\"); // blackboard bold [\n\ndefineMacro(\"\\u27e7\", \"\\\\rrbracket\"); // blackboard bold ]\n\ndefineMacro(\"\\\\lBrace\", \"\\\\html@mathml{\" + \"\\\\mathopen{\\\\{\\\\mkern-3.2mu[}}\" + \"{\\\\mathopen{\\\\char`\\u2983}}\");\ndefineMacro(\"\\\\rBrace\", \"\\\\html@mathml{\" + \"\\\\mathclose{]\\\\mkern-3.2mu\\\\}}}\" + \"{\\\\mathclose{\\\\char`\\u2984}}\");\ndefineMacro(\"\\u2983\", \"\\\\lBrace\"); // blackboard bold {\n\ndefineMacro(\"\\u2984\", \"\\\\rBrace\"); // blackboard bold }\n// TODO: Create variable sized versions of the last two items. I believe that\n// will require new font glyphs.\n// The stmaryrd function `\\minuso` provides a \"Plimsoll\" symbol that\n// superimposes the characters \\circ and \\mathminus. Used in chemistry.\n\ndefineMacro(\"\\\\minuso\", \"\\\\mathbin{\\\\html@mathml{\" + \"{\\\\mathrlap{\\\\mathchoice{\\\\kern{0.145em}}{\\\\kern{0.145em}}\" + \"{\\\\kern{0.1015em}}{\\\\kern{0.0725em}}\\\\circ}{-}}}\" + \"{\\\\char`}}\");\ndefineMacro(\"\", \"\\\\minuso\"); //////////////////////////////////////////////////////////////////////\n// texvc.sty\n// The texvc package contains macros available in mediawiki pages.\n// We omit the functions deprecated at\n// https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax\n// We also omit texvc's \\O, which conflicts with \\text{\\O}\n\ndefineMacro(\"\\\\darr\", \"\\\\downarrow\");\ndefineMacro(\"\\\\dArr\", \"\\\\Downarrow\");\ndefineMacro(\"\\\\Darr\", \"\\\\Downarrow\");\ndefineMacro(\"\\\\lang\", \"\\\\langle\");\ndefineMacro(\"\\\\rang\", \"\\\\rangle\");\ndefineMacro(\"\\\\uarr\", \"\\\\uparrow\");\ndefineMacro(\"\\\\uArr\", \"\\\\Uparrow\");\ndefineMacro(\"\\\\Uarr\", \"\\\\Uparrow\");\ndefineMacro(\"\\\\N\", \"\\\\mathbb{N}\");\ndefineMacro(\"\\\\R\", \"\\\\mathbb{R}\");\ndefineMacro(\"\\\\Z\", \"\\\\mathbb{Z}\");\ndefineMacro(\"\\\\alef\", \"\\\\aleph\");\ndefineMacro(\"\\\\alefsym\", \"\\\\aleph\");\ndefineMacro(\"\\\\Alpha\", \"\\\\mathrm{A}\");\ndefineMacro(\"\\\\Beta\", \"\\\\mathrm{B}\");\ndefineMacro(\"\\\\bull\", \"\\\\bullet\");\ndefineMacro(\"\\\\Chi\", \"\\\\mathrm{X}\");\ndefineMacro(\"\\\\clubs\", \"\\\\clubsuit\");\ndefineMacro(\"\\\\cnums\", \"\\\\mathbb{C}\");\ndefineMacro(\"\\\\Complex\", \"\\\\mathbb{C}\");\ndefineMacro(\"\\\\Dagger\", \"\\\\ddagger\");\ndefineMacro(\"\\\\diamonds\", \"\\\\diamondsuit\");\ndefineMacro(\"\\\\empty\", \"\\\\emptyset\");\ndefineMacro(\"\\\\Epsilon\", \"\\\\mathrm{E}\");\ndefineMacro(\"\\\\Eta\", \"\\\\mathrm{H}\");\ndefineMacro(\"\\\\exist\", \"\\\\exists\");\ndefineMacro(\"\\\\harr\", \"\\\\leftrightarrow\");\ndefineMacro(\"\\\\hArr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\Harr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\hearts\", \"\\\\heartsuit\");\ndefineMacro(\"\\\\image\", \"\\\\Im\");\ndefineMacro(\"\\\\infin\", \"\\\\infty\");\ndefineMacro(\"\\\\Iota\", \"\\\\mathrm{I}\");\ndefineMacro(\"\\\\isin\", \"\\\\in\");\ndefineMacro(\"\\\\Kappa\", \"\\\\mathrm{K}\");\ndefineMacro(\"\\\\larr\", \"\\\\leftarrow\");\ndefineMacro(\"\\\\lArr\", \"\\\\Leftarrow\");\ndefineMacro(\"\\\\Larr\", \"\\\\Leftarrow\");\ndefineMacro(\"\\\\lrarr\", \"\\\\leftrightarrow\");\ndefineMacro(\"\\\\lrArr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\Lrarr\", \"\\\\Leftrightarrow\");\ndefineMacro(\"\\\\Mu\", \"\\\\mathrm{M}\");\ndefineMacro(\"\\\\natnums\", \"\\\\mathbb{N}\");\ndefineMacro(\"\\\\Nu\", \"\\\\mathrm{N}\");\ndefineMacro(\"\\\\Omicron\", \"\\\\mathrm{O}\");\ndefineMacro(\"\\\\plusmn\", \"\\\\pm\");\ndefineMacro(\"\\\\rarr\", \"\\\\rightarrow\");\ndefineMacro(\"\\\\rArr\", \"\\\\Rightarrow\");\ndefineMacro(\"\\\\Rarr\", \"\\\\Rightarrow\");\ndefineMacro(\"\\\\real\", \"\\\\Re\");\ndefineMacro(\"\\\\reals\", \"\\\\mathbb{R}\");\ndefineMacro(\"\\\\Reals\", \"\\\\mathbb{R}\");\ndefineMacro(\"\\\\Rho\", \"\\\\mathrm{P}\");\ndefineMacro(\"\\\\sdot\", \"\\\\cdot\");\ndefineMacro(\"\\\\sect\", \"\\\\S\");\ndefineMacro(\"\\\\spades\", \"\\\\spadesuit\");\ndefineMacro(\"\\\\sub\", \"\\\\subset\");\ndefineMacro(\"\\\\sube\", \"\\\\subseteq\");\ndefineMacro(\"\\\\supe\", \"\\\\supseteq\");\ndefineMacro(\"\\\\Tau\", \"\\\\mathrm{T}\");\ndefineMacro(\"\\\\thetasym\", \"\\\\vartheta\"); // TODO: defineMacro(\"\\\\varcoppa\", \"\\\\\\mbox{\\\\coppa}\");\n\ndefineMacro(\"\\\\weierp\", \"\\\\wp\");\ndefineMacro(\"\\\\Zeta\", \"\\\\mathrm{Z}\"); //////////////////////////////////////////////////////////////////////\n// statmath.sty\n// https://ctan.math.illinois.edu/macros/latex/contrib/statmath/statmath.pdf\n\ndefineMacro(\"\\\\argmin\", \"\\\\DOTSB\\\\operatorname*{arg\\\\,min}\");\ndefineMacro(\"\\\\argmax\", \"\\\\DOTSB\\\\operatorname*{arg\\\\,max}\");\ndefineMacro(\"\\\\plim\", \"\\\\DOTSB\\\\mathop{\\\\operatorname{plim}}\\\\limits\"); //////////////////////////////////////////////////////////////////////\n// braket.sty\n// http://ctan.math.washington.edu/tex-archive/macros/latex/contrib/braket/braket.pdf\n\ndefineMacro(\"\\\\bra\", \"\\\\mathinner{\\\\langle{#1}|}\");\ndefineMacro(\"\\\\ket\", \"\\\\mathinner{|{#1}\\\\rangle}\");\ndefineMacro(\"\\\\braket\", \"\\\\mathinner{\\\\langle{#1}\\\\rangle}\");\ndefineMacro(\"\\\\Bra\", \"\\\\left\\\\langle#1\\\\right|\");\ndefineMacro(\"\\\\Ket\", \"\\\\left|#1\\\\right\\\\rangle\");\n\nvar braketHelper = one => context => {\n  var left = context.consumeArg().tokens;\n  var middle = context.consumeArg().tokens;\n  var middleDouble = context.consumeArg().tokens;\n  var right = context.consumeArg().tokens;\n  var oldMiddle = context.macros.get(\"|\");\n  var oldMiddleDouble = context.macros.get(\"\\\\|\");\n  context.macros.beginGroup();\n\n  var midMacro = double => context => {\n    if (one) {\n      // Only modify the first instance of | or \\|\n      context.macros.set(\"|\", oldMiddle);\n\n      if (middleDouble.length) {\n        context.macros.set(\"\\\\|\", oldMiddleDouble);\n      }\n    }\n\n    var doubled = double;\n\n    if (!double && middleDouble.length) {\n      // Mimic \\@ifnextchar\n      var nextToken = context.future();\n\n      if (nextToken.text === \"|\") {\n        context.popToken();\n        doubled = true;\n      }\n    }\n\n    return {\n      tokens: doubled ? middleDouble : middle,\n      numArgs: 0\n    };\n  };\n\n  context.macros.set(\"|\", midMacro(false));\n\n  if (middleDouble.length) {\n    context.macros.set(\"\\\\|\", midMacro(true));\n  }\n\n  var arg = context.consumeArg().tokens;\n  var expanded = context.expandTokens([...right, ...arg, ...left // reversed\n  ]);\n  context.macros.endGroup();\n  return {\n    tokens: expanded.reverse(),\n    numArgs: 0\n  };\n};\n\ndefineMacro(\"\\\\bra@ket\", braketHelper(false));\ndefineMacro(\"\\\\bra@set\", braketHelper(true));\ndefineMacro(\"\\\\Braket\", \"\\\\bra@ket{\\\\left\\\\langle}\" + \"{\\\\,\\\\middle\\\\vert\\\\,}{\\\\,\\\\middle\\\\vert\\\\,}{\\\\right\\\\rangle}\");\ndefineMacro(\"\\\\Set\", \"\\\\bra@set{\\\\left\\\\{\\\\:}\" + \"{\\\\;\\\\middle\\\\vert\\\\;}{\\\\;\\\\middle\\\\Vert\\\\;}{\\\\:\\\\right\\\\}}\");\ndefineMacro(\"\\\\set\", \"\\\\bra@set{\\\\{\\\\,}{\\\\mid}{}{\\\\,\\\\}}\"); // has no support for special || or \\|\n//////////////////////////////////////////////////////////////////////\n// actuarialangle.dtx\n\ndefineMacro(\"\\\\angln\", \"{\\\\angl n}\"); // Custom Khan Academy colors, should be moved to an optional package\n\ndefineMacro(\"\\\\blue\", \"\\\\textcolor{##6495ed}{#1}\");\ndefineMacro(\"\\\\orange\", \"\\\\textcolor{##ffa500}{#1}\");\ndefineMacro(\"\\\\pink\", \"\\\\textcolor{##ff00af}{#1}\");\ndefineMacro(\"\\\\red\", \"\\\\textcolor{##df0030}{#1}\");\ndefineMacro(\"\\\\green\", \"\\\\textcolor{##28ae7b}{#1}\");\ndefineMacro(\"\\\\gray\", \"\\\\textcolor{gray}{#1}\");\ndefineMacro(\"\\\\purple\", \"\\\\textcolor{##9d38bd}{#1}\");\ndefineMacro(\"\\\\blueA\", \"\\\\textcolor{##ccfaff}{#1}\");\ndefineMacro(\"\\\\blueB\", \"\\\\textcolor{##80f6ff}{#1}\");\ndefineMacro(\"\\\\blueC\", \"\\\\textcolor{##63d9ea}{#1}\");\ndefineMacro(\"\\\\blueD\", \"\\\\textcolor{##11accd}{#1}\");\ndefineMacro(\"\\\\blueE\", \"\\\\textcolor{##0c7f99}{#1}\");\ndefineMacro(\"\\\\tealA\", \"\\\\textcolor{##94fff5}{#1}\");\ndefineMacro(\"\\\\tealB\", \"\\\\textcolor{##26edd5}{#1}\");\ndefineMacro(\"\\\\tealC\", \"\\\\textcolor{##01d1c1}{#1}\");\ndefineMacro(\"\\\\tealD\", \"\\\\textcolor{##01a995}{#1}\");\ndefineMacro(\"\\\\tealE\", \"\\\\textcolor{##208170}{#1}\");\ndefineMacro(\"\\\\greenA\", \"\\\\textcolor{##b6ffb0}{#1}\");\ndefineMacro(\"\\\\greenB\", \"\\\\textcolor{##8af281}{#1}\");\ndefineMacro(\"\\\\greenC\", \"\\\\textcolor{##74cf70}{#1}\");\ndefineMacro(\"\\\\greenD\", \"\\\\textcolor{##1fab54}{#1}\");\ndefineMacro(\"\\\\greenE\", \"\\\\textcolor{##0d923f}{#1}\");\ndefineMacro(\"\\\\goldA\", \"\\\\textcolor{##ffd0a9}{#1}\");\ndefineMacro(\"\\\\goldB\", \"\\\\textcolor{##ffbb71}{#1}\");\ndefineMacro(\"\\\\goldC\", \"\\\\textcolor{##ff9c39}{#1}\");\ndefineMacro(\"\\\\goldD\", \"\\\\textcolor{##e07d10}{#1}\");\ndefineMacro(\"\\\\goldE\", \"\\\\textcolor{##a75a05}{#1}\");\ndefineMacro(\"\\\\redA\", \"\\\\textcolor{##fca9a9}{#1}\");\ndefineMacro(\"\\\\redB\", \"\\\\textcolor{##ff8482}{#1}\");\ndefineMacro(\"\\\\redC\", \"\\\\textcolor{##f9685d}{#1}\");\ndefineMacro(\"\\\\redD\", \"\\\\textcolor{##e84d39}{#1}\");\ndefineMacro(\"\\\\redE\", \"\\\\textcolor{##bc2612}{#1}\");\ndefineMacro(\"\\\\maroonA\", \"\\\\textcolor{##ffbde0}{#1}\");\ndefineMacro(\"\\\\maroonB\", \"\\\\textcolor{##ff92c6}{#1}\");\ndefineMacro(\"\\\\maroonC\", \"\\\\textcolor{##ed5fa6}{#1}\");\ndefineMacro(\"\\\\maroonD\", \"\\\\textcolor{##ca337c}{#1}\");\ndefineMacro(\"\\\\maroonE\", \"\\\\textcolor{##9e034e}{#1}\");\ndefineMacro(\"\\\\purpleA\", \"\\\\textcolor{##ddd7ff}{#1}\");\ndefineMacro(\"\\\\purpleB\", \"\\\\textcolor{##c6b9fc}{#1}\");\ndefineMacro(\"\\\\purpleC\", \"\\\\textcolor{##aa87ff}{#1}\");\ndefineMacro(\"\\\\purpleD\", \"\\\\textcolor{##7854ab}{#1}\");\ndefineMacro(\"\\\\purpleE\", \"\\\\textcolor{##543b78}{#1}\");\ndefineMacro(\"\\\\mintA\", \"\\\\textcolor{##f5f9e8}{#1}\");\ndefineMacro(\"\\\\mintB\", \"\\\\textcolor{##edf2df}{#1}\");\ndefineMacro(\"\\\\mintC\", \"\\\\textcolor{##e0e5cc}{#1}\");\ndefineMacro(\"\\\\grayA\", \"\\\\textcolor{##f6f7f7}{#1}\");\ndefineMacro(\"\\\\grayB\", \"\\\\textcolor{##f0f1f2}{#1}\");\ndefineMacro(\"\\\\grayC\", \"\\\\textcolor{##e3e5e6}{#1}\");\ndefineMacro(\"\\\\grayD\", \"\\\\textcolor{##d6d8da}{#1}\");\ndefineMacro(\"\\\\grayE\", \"\\\\textcolor{##babec2}{#1}\");\ndefineMacro(\"\\\\grayF\", \"\\\\textcolor{##888d93}{#1}\");\ndefineMacro(\"\\\\grayG\", \"\\\\textcolor{##626569}{#1}\");\ndefineMacro(\"\\\\grayH\", \"\\\\textcolor{##3b3e40}{#1}\");\ndefineMacro(\"\\\\grayI\", \"\\\\textcolor{##21242c}{#1}\");\ndefineMacro(\"\\\\kaBlue\", \"\\\\textcolor{##314453}{#1}\");\ndefineMacro(\"\\\\kaGreen\", \"\\\\textcolor{##71B307}{#1}\");\n\n/**\n * This file contains the gullet where macros are expanded\n * until only non-macro tokens remain.\n */\n// List of commands that act like macros but aren't defined as a macro,\n// function, or symbol.  Used in `isDefined`.\nvar implicitCommands = {\n  \"^\": true,\n  // Parser.js\n  \"_\": true,\n  // Parser.js\n  \"\\\\limits\": true,\n  // Parser.js\n  \"\\\\nolimits\": true // Parser.js\n\n};\nclass MacroExpander {\n  constructor(input, settings, mode) {\n    this.settings = void 0;\n    this.expansionCount = void 0;\n    this.lexer = void 0;\n    this.macros = void 0;\n    this.stack = void 0;\n    this.mode = void 0;\n    this.settings = settings;\n    this.expansionCount = 0;\n    this.feed(input); // Make new global namespace\n\n    this.macros = new Namespace(macros, settings.macros);\n    this.mode = mode;\n    this.stack = []; // contains tokens in REVERSE order\n  }\n  /**\n   * Feed a new input string to the same MacroExpander\n   * (with existing macros etc.).\n   */\n\n\n  feed(input) {\n    this.lexer = new Lexer(input, this.settings);\n  }\n  /**\n   * Switches between \"text\" and \"math\" modes.\n   */\n\n\n  switchMode(newMode) {\n    this.mode = newMode;\n  }\n  /**\n   * Start a new group nesting within all namespaces.\n   */\n\n\n  beginGroup() {\n    this.macros.beginGroup();\n  }\n  /**\n   * End current group nesting within all namespaces.\n   */\n\n\n  endGroup() {\n    this.macros.endGroup();\n  }\n  /**\n   * Ends all currently nested groups (if any), restoring values before the\n   * groups began.  Useful in case of an error in the middle of parsing.\n   */\n\n\n  endGroups() {\n    this.macros.endGroups();\n  }\n  /**\n   * Returns the topmost token on the stack, without expanding it.\n   * Similar in behavior to TeX's `\\futurelet`.\n   */\n\n\n  future() {\n    if (this.stack.length === 0) {\n      this.pushToken(this.lexer.lex());\n    }\n\n    return this.stack[this.stack.length - 1];\n  }\n  /**\n   * Remove and return the next unexpanded token.\n   */\n\n\n  popToken() {\n    this.future(); // ensure non-empty stack\n\n    return this.stack.pop();\n  }\n  /**\n   * Add a given token to the token stack.  In particular, this get be used\n   * to put back a token returned from one of the other methods.\n   */\n\n\n  pushToken(token) {\n    this.stack.push(token);\n  }\n  /**\n   * Append an array of tokens to the token stack.\n   */\n\n\n  pushTokens(tokens) {\n    this.stack.push(...tokens);\n  }\n  /**\n   * Find an macro argument without expanding tokens and append the array of\n   * tokens to the token stack. Uses Token as a container for the result.\n   */\n\n\n  scanArgument(isOptional) {\n    var start;\n    var end;\n    var tokens;\n\n    if (isOptional) {\n      this.consumeSpaces(); // \\@ifnextchar gobbles any space following it\n\n      if (this.future().text !== \"[\") {\n        return null;\n      }\n\n      start = this.popToken(); // don't include [ in tokens\n\n      ({\n        tokens,\n        end\n      } = this.consumeArg([\"]\"]));\n    } else {\n      ({\n        tokens,\n        start,\n        end\n      } = this.consumeArg());\n    } // indicate the end of an argument\n\n\n    this.pushToken(new Token(\"EOF\", end.loc));\n    this.pushTokens(tokens);\n    return new Token(\"\", SourceLocation.range(start, end));\n  }\n  /**\n   * Consume all following space tokens, without expansion.\n   */\n\n\n  consumeSpaces() {\n    for (;;) {\n      var token = this.future();\n\n      if (token.text === \" \") {\n        this.stack.pop();\n      } else {\n        break;\n      }\n    }\n  }\n  /**\n   * Consume an argument from the token stream, and return the resulting array\n   * of tokens and start/end token.\n   */\n\n\n  consumeArg(delims) {\n    // The argument for a delimited parameter is the shortest (possibly\n    // empty) sequence of tokens with properly nested {...} groups that is\n    // followed ... by this particular list of non-parameter tokens.\n    // The argument for an undelimited parameter is the next nonblank\n    // token, unless that token is {, when the argument will be the\n    // entire {...} group that follows.\n    var tokens = [];\n    var isDelimited = delims && delims.length > 0;\n\n    if (!isDelimited) {\n      // Ignore spaces between arguments.  As the TeXbook says:\n      // \"After you have said \\def\\row#1#2{...}, you are allowed to\n      //  put spaces between the arguments (e.g., \\row x n), because\n      //  TeX doesnt use single spaces as undelimited arguments.\"\n      this.consumeSpaces();\n    }\n\n    var start = this.future();\n    var tok;\n    var depth = 0;\n    var match = 0;\n\n    do {\n      tok = this.popToken();\n      tokens.push(tok);\n\n      if (tok.text === \"{\") {\n        ++depth;\n      } else if (tok.text === \"}\") {\n        --depth;\n\n        if (depth === -1) {\n          throw new ParseError(\"Extra }\", tok);\n        }\n      } else if (tok.text === \"EOF\") {\n        throw new ParseError(\"Unexpected end of input in a macro argument\" + \", expected '\" + (delims && isDelimited ? delims[match] : \"}\") + \"'\", tok);\n      }\n\n      if (delims && isDelimited) {\n        if ((depth === 0 || depth === 1 && delims[match] === \"{\") && tok.text === delims[match]) {\n          ++match;\n\n          if (match === delims.length) {\n            // don't include delims in tokens\n            tokens.splice(-match, match);\n            break;\n          }\n        } else {\n          match = 0;\n        }\n      }\n    } while (depth !== 0 || isDelimited); // If the argument found ... has the form {<nested tokens>},\n    // ... the outermost braces enclosing the argument are removed\n\n\n    if (start.text === \"{\" && tokens[tokens.length - 1].text === \"}\") {\n      tokens.pop();\n      tokens.shift();\n    }\n\n    tokens.reverse(); // to fit in with stack order\n\n    return {\n      tokens,\n      start,\n      end: tok\n    };\n  }\n  /**\n   * Consume the specified number of (delimited) arguments from the token\n   * stream and return the resulting array of arguments.\n   */\n\n\n  consumeArgs(numArgs, delimiters) {\n    if (delimiters) {\n      if (delimiters.length !== numArgs + 1) {\n        throw new ParseError(\"The length of delimiters doesn't match the number of args!\");\n      }\n\n      var delims = delimiters[0];\n\n      for (var i = 0; i < delims.length; i++) {\n        var tok = this.popToken();\n\n        if (delims[i] !== tok.text) {\n          throw new ParseError(\"Use of the macro doesn't match its definition\", tok);\n        }\n      }\n    }\n\n    var args = [];\n\n    for (var _i = 0; _i < numArgs; _i++) {\n      args.push(this.consumeArg(delimiters && delimiters[_i + 1]).tokens);\n    }\n\n    return args;\n  }\n  /**\n   * Increment `expansionCount` by the specified amount.\n   * Throw an error if it exceeds `maxExpand`.\n   */\n\n\n  countExpansion(amount) {\n    this.expansionCount += amount;\n\n    if (this.expansionCount > this.settings.maxExpand) {\n      throw new ParseError(\"Too many expansions: infinite loop or \" + \"need to increase maxExpand setting\");\n    }\n  }\n  /**\n   * Expand the next token only once if possible.\n   *\n   * If the token is expanded, the resulting tokens will be pushed onto\n   * the stack in reverse order, and the number of such tokens will be\n   * returned.  This number might be zero or positive.\n   *\n   * If not, the return value is `false`, and the next token remains at the\n   * top of the stack.\n   *\n   * In either case, the next token will be on the top of the stack,\n   * or the stack will be empty (in case of empty expansion\n   * and no other tokens).\n   *\n   * Used to implement `expandAfterFuture` and `expandNextToken`.\n   *\n   * If expandableOnly, only expandable tokens are expanded and\n   * an undefined control sequence results in an error.\n   */\n\n\n  expandOnce(expandableOnly) {\n    var topToken = this.popToken();\n    var name = topToken.text;\n    var expansion = !topToken.noexpand ? this._getExpansion(name) : null;\n\n    if (expansion == null || expandableOnly && expansion.unexpandable) {\n      if (expandableOnly && expansion == null && name[0] === \"\\\\\" && !this.isDefined(name)) {\n        throw new ParseError(\"Undefined control sequence: \" + name);\n      }\n\n      this.pushToken(topToken);\n      return false;\n    }\n\n    this.countExpansion(1);\n    var tokens = expansion.tokens;\n    var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);\n\n    if (expansion.numArgs) {\n      // paste arguments in place of the placeholders\n      tokens = tokens.slice(); // make a shallow copy\n\n      for (var i = tokens.length - 1; i >= 0; --i) {\n        var tok = tokens[i];\n\n        if (tok.text === \"#\") {\n          if (i === 0) {\n            throw new ParseError(\"Incomplete placeholder at end of macro body\", tok);\n          }\n\n          tok = tokens[--i]; // next token on stack\n\n          if (tok.text === \"#\") {\n            // ##  #\n            tokens.splice(i + 1, 1); // drop first #\n          } else if (/^[1-9]$/.test(tok.text)) {\n            // replace the placeholder with the indicated argument\n            tokens.splice(i, 2, ...args[+tok.text - 1]);\n          } else {\n            throw new ParseError(\"Not a valid argument number\", tok);\n          }\n        }\n      }\n    } // Concatenate expansion onto top of stack.\n\n\n    this.pushTokens(tokens);\n    return tokens.length;\n  }\n  /**\n   * Expand the next token only once (if possible), and return the resulting\n   * top token on the stack (without removing anything from the stack).\n   * Similar in behavior to TeX's `\\expandafter\\futurelet`.\n   * Equivalent to expandOnce() followed by future().\n   */\n\n\n  expandAfterFuture() {\n    this.expandOnce();\n    return this.future();\n  }\n  /**\n   * Recursively expand first token, then return first non-expandable token.\n   */\n\n\n  expandNextToken() {\n    for (;;) {\n      if (this.expandOnce() === false) {\n        // fully expanded\n        var token = this.stack.pop(); // the token after \\noexpand is interpreted as if its meaning\n        // were \\relax\n\n        if (token.treatAsRelax) {\n          token.text = \"\\\\relax\";\n        }\n\n        return token;\n      }\n    } // Flow unable to figure out that this pathway is impossible.\n    // https://github.com/facebook/flow/issues/4808\n\n\n    throw new Error(); // eslint-disable-line no-unreachable\n  }\n  /**\n   * Fully expand the given macro name and return the resulting list of\n   * tokens, or return `undefined` if no such macro is defined.\n   */\n\n\n  expandMacro(name) {\n    return this.macros.has(name) ? this.expandTokens([new Token(name)]) : undefined;\n  }\n  /**\n   * Fully expand the given token stream and return the resulting list of\n   * tokens.  Note that the input tokens are in reverse order, but the\n   * output tokens are in forward order.\n   */\n\n\n  expandTokens(tokens) {\n    var output = [];\n    var oldStackLength = this.stack.length;\n    this.pushTokens(tokens);\n\n    while (this.stack.length > oldStackLength) {\n      // Expand only expandable tokens\n      if (this.expandOnce(true) === false) {\n        // fully expanded\n        var token = this.stack.pop();\n\n        if (token.treatAsRelax) {\n          // the expansion of \\noexpand is the token itself\n          token.noexpand = false;\n          token.treatAsRelax = false;\n        }\n\n        output.push(token);\n      }\n    } // Count all of these tokens as additional expansions, to prevent\n    // exponential blowup from linearly many \\edef's.\n\n\n    this.countExpansion(output.length);\n    return output;\n  }\n  /**\n   * Fully expand the given macro name and return the result as a string,\n   * or return `undefined` if no such macro is defined.\n   */\n\n\n  expandMacroAsText(name) {\n    var tokens = this.expandMacro(name);\n\n    if (tokens) {\n      return tokens.map(token => token.text).join(\"\");\n    } else {\n      return tokens;\n    }\n  }\n  /**\n   * Returns the expanded macro as a reversed array of tokens and a macro\n   * argument count.  Or returns `null` if no such macro.\n   */\n\n\n  _getExpansion(name) {\n    var definition = this.macros.get(name);\n\n    if (definition == null) {\n      // mainly checking for undefined here\n      return definition;\n    } // If a single character has an associated catcode other than 13\n    // (active character), then don't expand it.\n\n\n    if (name.length === 1) {\n      var catcode = this.lexer.catcodes[name];\n\n      if (catcode != null && catcode !== 13) {\n        return;\n      }\n    }\n\n    var expansion = typeof definition === \"function\" ? definition(this) : definition;\n\n    if (typeof expansion === \"string\") {\n      var numArgs = 0;\n\n      if (expansion.indexOf(\"#\") !== -1) {\n        var stripped = expansion.replace(/##/g, \"\");\n\n        while (stripped.indexOf(\"#\" + (numArgs + 1)) !== -1) {\n          ++numArgs;\n        }\n      }\n\n      var bodyLexer = new Lexer(expansion, this.settings);\n      var tokens = [];\n      var tok = bodyLexer.lex();\n\n      while (tok.text !== \"EOF\") {\n        tokens.push(tok);\n        tok = bodyLexer.lex();\n      }\n\n      tokens.reverse(); // to fit in with stack using push and pop\n\n      var expanded = {\n        tokens,\n        numArgs\n      };\n      return expanded;\n    }\n\n    return expansion;\n  }\n  /**\n   * Determine whether a command is currently \"defined\" (has some\n   * functionality), meaning that it's a macro (in the current group),\n   * a function, a symbol, or one of the special commands listed in\n   * `implicitCommands`.\n   */\n\n\n  isDefined(name) {\n    return this.macros.has(name) || functions.hasOwnProperty(name) || symbols.math.hasOwnProperty(name) || symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);\n  }\n  /**\n   * Determine whether a command is expandable.\n   */\n\n\n  isExpandable(name) {\n    var macro = this.macros.get(name);\n    return macro != null ? typeof macro === \"string\" || typeof macro === \"function\" || !macro.unexpandable : functions.hasOwnProperty(name) && !functions[name].primitive;\n  }\n\n}\n\n// Helpers for Parser.js handling of Unicode (sub|super)script characters.\nvar unicodeSubRegEx = /^[]/;\nvar uSubsAndSups = Object.freeze({\n  '': '+',\n  '': '-',\n  '': '=',\n  '': '(',\n  '': ')',\n  '': '0',\n  '': '1',\n  '': '2',\n  '': '3',\n  '': '4',\n  '': '5',\n  '': '6',\n  '': '7',\n  '': '8',\n  '': '9',\n  '\\u2090': 'a',\n  '\\u2091': 'e',\n  '\\u2095': 'h',\n  '\\u1D62': 'i',\n  '\\u2C7C': 'j',\n  '\\u2096': 'k',\n  '\\u2097': 'l',\n  '\\u2098': 'm',\n  '\\u2099': 'n',\n  '\\u2092': 'o',\n  '\\u209A': 'p',\n  '\\u1D63': 'r',\n  '\\u209B': 's',\n  '\\u209C': 't',\n  '\\u1D64': 'u',\n  '\\u1D65': 'v',\n  '\\u2093': 'x',\n  '\\u1D66': '',\n  '\\u1D67': '',\n  '\\u1D68': '',\n  '\\u1D69': '\\u03d5',\n  '\\u1D6A': '',\n  '': '+',\n  '': '-',\n  '': '=',\n  '': '(',\n  '': ')',\n  '': '0',\n  '': '1',\n  '': '2',\n  '': '3',\n  '': '4',\n  '': '5',\n  '': '6',\n  '': '7',\n  '': '8',\n  '': '9',\n  '\\u1D2C': 'A',\n  '\\u1D2E': 'B',\n  '\\u1D30': 'D',\n  '\\u1D31': 'E',\n  '\\u1D33': 'G',\n  '\\u1D34': 'H',\n  '\\u1D35': 'I',\n  '\\u1D36': 'J',\n  '\\u1D37': 'K',\n  '\\u1D38': 'L',\n  '\\u1D39': 'M',\n  '\\u1D3A': 'N',\n  '\\u1D3C': 'O',\n  '\\u1D3E': 'P',\n  '\\u1D3F': 'R',\n  '\\u1D40': 'T',\n  '\\u1D41': 'U',\n  '\\u2C7D': 'V',\n  '\\u1D42': 'W',\n  '\\u1D43': 'a',\n  '\\u1D47': 'b',\n  '\\u1D9C': 'c',\n  '\\u1D48': 'd',\n  '\\u1D49': 'e',\n  '\\u1DA0': 'f',\n  '\\u1D4D': 'g',\n  '\\u02B0': 'h',\n  '\\u2071': 'i',\n  '\\u02B2': 'j',\n  '\\u1D4F': 'k',\n  '\\u02E1': 'l',\n  '\\u1D50': 'm',\n  '\\u207F': 'n',\n  '\\u1D52': 'o',\n  '\\u1D56': 'p',\n  '\\u02B3': 'r',\n  '\\u02E2': 's',\n  '\\u1D57': 't',\n  '\\u1D58': 'u',\n  '\\u1D5B': 'v',\n  '\\u02B7': 'w',\n  '\\u02E3': 'x',\n  '\\u02B8': 'y',\n  '\\u1DBB': 'z',\n  '\\u1D5D': '',\n  '\\u1D5E': '',\n  '\\u1D5F': '',\n  '\\u1D60': '\\u03d5',\n  '\\u1D61': '',\n  '\\u1DBF': ''\n});\n\n/* eslint no-constant-condition:0 */\n\nvar unicodeAccents = {\n  \"\": {\n    \"text\": \"\\\\'\",\n    \"math\": \"\\\\acute\"\n  },\n  \"\": {\n    \"text\": \"\\\\`\",\n    \"math\": \"\\\\grave\"\n  },\n  \"\": {\n    \"text\": \"\\\\\\\"\",\n    \"math\": \"\\\\ddot\"\n  },\n  \"\": {\n    \"text\": \"\\\\~\",\n    \"math\": \"\\\\tilde\"\n  },\n  \"\": {\n    \"text\": \"\\\\=\",\n    \"math\": \"\\\\bar\"\n  },\n  \"\": {\n    \"text\": \"\\\\u\",\n    \"math\": \"\\\\breve\"\n  },\n  \"\": {\n    \"text\": \"\\\\v\",\n    \"math\": \"\\\\check\"\n  },\n  \"\": {\n    \"text\": \"\\\\^\",\n    \"math\": \"\\\\hat\"\n  },\n  \"\": {\n    \"text\": \"\\\\.\",\n    \"math\": \"\\\\dot\"\n  },\n  \"\": {\n    \"text\": \"\\\\r\",\n    \"math\": \"\\\\mathring\"\n  },\n  \"\": {\n    \"text\": \"\\\\H\"\n  },\n  \"\": {\n    \"text\": \"\\\\c\"\n  }\n};\nvar unicodeSymbols = {\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"a\",\n  \"\": \"b\",\n  \"\": \"c\",\n  \"\": \"c\",\n  \"\": \"c\",\n  \"\": \"c\",\n  \"\": \"c\",\n  \"\": \"c\",\n  \"\": \"d\",\n  \"\": \"d\",\n  \"\": \"d\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"e\",\n  \"\": \"f\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"g\",\n  \"\": \"h\",\n  \"\": \"h\",\n  \"\": \"h\",\n  \"\": \"h\",\n  \"\": \"h\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"i\",\n  \"\": \"j\",\n  \"\": \"j\",\n  \"\": \"k\",\n  \"\": \"k\",\n  \"\": \"k\",\n  \"\": \"l\",\n  \"\": \"l\",\n  \"\": \"l\",\n  \"\": \"m\",\n  \"\": \"m\",\n  \"\": \"n\",\n  \"\": \"n\",\n  \"\": \"n\",\n  \"\": \"n\",\n  \"\": \"n\",\n  \"\": \"n\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"o\",\n  \"\": \"p\",\n  \"\": \"p\",\n  \"\": \"r\",\n  \"\": \"r\",\n  \"\": \"r\",\n  \"\": \"r\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"s\",\n  \"\": \"t\",\n  \"\": \"t\",\n  \"\": \"t\",\n  \"\": \"t\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"u\",\n  \"\": \"v\",\n  \"\": \"w\",\n  \"\": \"w\",\n  \"\": \"w\",\n  \"\": \"w\",\n  \"\": \"w\",\n  \"\": \"w\",\n  \"\": \"x\",\n  \"\": \"x\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"y\",\n  \"\": \"z\",\n  \"\": \"z\",\n  \"\": \"z\",\n  \"\": \"z\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"A\",\n  \"\": \"B\",\n  \"\": \"C\",\n  \"\": \"C\",\n  \"\": \"C\",\n  \"\": \"C\",\n  \"\": \"C\",\n  \"\": \"C\",\n  \"\": \"D\",\n  \"\": \"D\",\n  \"\": \"D\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"E\",\n  \"\": \"F\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"G\",\n  \"\": \"H\",\n  \"\": \"H\",\n  \"\": \"H\",\n  \"\": \"H\",\n  \"\": \"H\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"I\",\n  \"\": \"J\",\n  \"\": \"K\",\n  \"\": \"K\",\n  \"\": \"K\",\n  \"\": \"L\",\n  \"\": \"L\",\n  \"\": \"L\",\n  \"\": \"M\",\n  \"\": \"M\",\n  \"\": \"N\",\n  \"\": \"N\",\n  \"\": \"N\",\n  \"\": \"N\",\n  \"\": \"N\",\n  \"\": \"N\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"O\",\n  \"\": \"P\",\n  \"\": \"P\",\n  \"\": \"R\",\n  \"\": \"R\",\n  \"\": \"R\",\n  \"\": \"R\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"S\",\n  \"\": \"T\",\n  \"\": \"T\",\n  \"\": \"T\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"U\",\n  \"\": \"V\",\n  \"\": \"W\",\n  \"\": \"W\",\n  \"\": \"W\",\n  \"\": \"W\",\n  \"\": \"W\",\n  \"\": \"X\",\n  \"\": \"X\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Y\",\n  \"\": \"Z\",\n  \"\": \"Z\",\n  \"\": \"Z\",\n  \"\": \"Z\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\",\n  \"\": \"\"\n};\n\n/**\n * This file contains the parser used to parse out a TeX expression from the\n * input. Since TeX isn't context-free, standard parsers don't work particularly\n * well.\n *\n * The strategy of this parser is as such:\n *\n * The main functions (the `.parse...` ones) take a position in the current\n * parse string to parse tokens from. The lexer (found in Lexer.js, stored at\n * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When\n * individual tokens are needed at a position, the lexer is called to pull out a\n * token, which is then used.\n *\n * The parser has a property called \"mode\" indicating the mode that\n * the parser is currently in. Currently it has to be one of \"math\" or\n * \"text\", which denotes whether the current environment is a math-y\n * one or a text-y one (e.g. inside \\text). Currently, this serves to\n * limit the functions which can be used in text mode.\n *\n * The main functions then return an object which contains the useful data that\n * was parsed at its given point, and a new position at the end of the parsed\n * data. The main functions can call each other and continue the parsing by\n * using the returned position as a new starting point.\n *\n * There are also extra `.handle...` functions, which pull out some reused\n * functionality into self-contained functions.\n *\n * The functions return ParseNodes.\n */\nclass Parser {\n  constructor(input, settings) {\n    this.mode = void 0;\n    this.gullet = void 0;\n    this.settings = void 0;\n    this.leftrightDepth = void 0;\n    this.nextToken = void 0;\n    // Start in math mode\n    this.mode = \"math\"; // Create a new macro expander (gullet) and (indirectly via that) also a\n    // new lexer (mouth) for this parser (stomach, in the language of TeX)\n\n    this.gullet = new MacroExpander(input, settings, this.mode); // Store the settings for use in parsing\n\n    this.settings = settings; // Count leftright depth (for \\middle errors)\n\n    this.leftrightDepth = 0;\n  }\n  /**\n   * Checks a result to make sure it has the right type, and throws an\n   * appropriate error otherwise.\n   */\n\n\n  expect(text, consume) {\n    if (consume === void 0) {\n      consume = true;\n    }\n\n    if (this.fetch().text !== text) {\n      throw new ParseError(\"Expected '\" + text + \"', got '\" + this.fetch().text + \"'\", this.fetch());\n    }\n\n    if (consume) {\n      this.consume();\n    }\n  }\n  /**\n   * Discards the current lookahead token, considering it consumed.\n   */\n\n\n  consume() {\n    this.nextToken = null;\n  }\n  /**\n   * Return the current lookahead token, or if there isn't one (at the\n   * beginning, or if the previous lookahead token was consume()d),\n   * fetch the next token as the new lookahead token and return it.\n   */\n\n\n  fetch() {\n    if (this.nextToken == null) {\n      this.nextToken = this.gullet.expandNextToken();\n    }\n\n    return this.nextToken;\n  }\n  /**\n   * Switches between \"text\" and \"math\" modes.\n   */\n\n\n  switchMode(newMode) {\n    this.mode = newMode;\n    this.gullet.switchMode(newMode);\n  }\n  /**\n   * Main parsing function, which parses an entire input.\n   */\n\n\n  parse() {\n    if (!this.settings.globalGroup) {\n      // Create a group namespace for the math expression.\n      // (LaTeX creates a new group for every $...$, $$...$$, \\[...\\].)\n      this.gullet.beginGroup();\n    } // Use old \\color behavior (same as LaTeX's \\textcolor) if requested.\n    // We do this within the group for the math expression, so it doesn't\n    // pollute settings.macros.\n\n\n    if (this.settings.colorIsTextColor) {\n      this.gullet.macros.set(\"\\\\color\", \"\\\\textcolor\");\n    }\n\n    try {\n      // Try to parse the input\n      var parse = this.parseExpression(false); // If we succeeded, make sure there's an EOF at the end\n\n      this.expect(\"EOF\"); // End the group namespace for the expression\n\n      if (!this.settings.globalGroup) {\n        this.gullet.endGroup();\n      }\n\n      return parse; // Close any leftover groups in case of a parse error.\n    } finally {\n      this.gullet.endGroups();\n    }\n  }\n  /**\n   * Fully parse a separate sequence of tokens as a separate job.\n   * Tokens should be specified in reverse order, as in a MacroDefinition.\n   */\n\n\n  subparse(tokens) {\n    // Save the next token from the current job.\n    var oldToken = this.nextToken;\n    this.consume(); // Run the new job, terminating it with an excess '}'\n\n    this.gullet.pushToken(new Token(\"}\"));\n    this.gullet.pushTokens(tokens);\n    var parse = this.parseExpression(false);\n    this.expect(\"}\"); // Restore the next token from the current job.\n\n    this.nextToken = oldToken;\n    return parse;\n  }\n\n  /**\n   * Parses an \"expression\", which is a list of atoms.\n   *\n   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This\n   *                 happens when functions have higher precedence han infix\n   *                 nodes in implicit parses.\n   *\n   * `breakOnTokenText`: The text of the token that the expression should end\n   *                     with, or `null` if something else should end the\n   *                     expression.\n   */\n  parseExpression(breakOnInfix, breakOnTokenText) {\n    var body = []; // Keep adding atoms to the body until we can't parse any more atoms (either\n    // we reached the end, a }, or a \\right)\n\n    while (true) {\n      // Ignore spaces in math mode\n      if (this.mode === \"math\") {\n        this.consumeSpaces();\n      }\n\n      var lex = this.fetch();\n\n      if (Parser.endOfExpression.indexOf(lex.text) !== -1) {\n        break;\n      }\n\n      if (breakOnTokenText && lex.text === breakOnTokenText) {\n        break;\n      }\n\n      if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {\n        break;\n      }\n\n      var atom = this.parseAtom(breakOnTokenText);\n\n      if (!atom) {\n        break;\n      } else if (atom.type === \"internal\") {\n        // Internal nodes do not appear in parse tree\n        continue;\n      }\n\n      body.push(atom);\n    }\n\n    if (this.mode === \"text\") {\n      this.formLigatures(body);\n    }\n\n    return this.handleInfixNodes(body);\n  }\n  /**\n   * Rewrites infix operators such as \\over with corresponding commands such\n   * as \\frac.\n   *\n   * There can only be one infix operator per group.  If there's more than one\n   * then the expression is ambiguous.  This can be resolved by adding {}.\n   */\n\n\n  handleInfixNodes(body) {\n    var overIndex = -1;\n    var funcName;\n\n    for (var i = 0; i < body.length; i++) {\n      if (body[i].type === \"infix\") {\n        if (overIndex !== -1) {\n          throw new ParseError(\"only one infix operator per group\", body[i].token);\n        }\n\n        overIndex = i;\n        funcName = body[i].replaceWith;\n      }\n    }\n\n    if (overIndex !== -1 && funcName) {\n      var numerNode;\n      var denomNode;\n      var numerBody = body.slice(0, overIndex);\n      var denomBody = body.slice(overIndex + 1);\n\n      if (numerBody.length === 1 && numerBody[0].type === \"ordgroup\") {\n        numerNode = numerBody[0];\n      } else {\n        numerNode = {\n          type: \"ordgroup\",\n          mode: this.mode,\n          body: numerBody\n        };\n      }\n\n      if (denomBody.length === 1 && denomBody[0].type === \"ordgroup\") {\n        denomNode = denomBody[0];\n      } else {\n        denomNode = {\n          type: \"ordgroup\",\n          mode: this.mode,\n          body: denomBody\n        };\n      }\n\n      var node;\n\n      if (funcName === \"\\\\\\\\abovefrac\") {\n        node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);\n      } else {\n        node = this.callFunction(funcName, [numerNode, denomNode], []);\n      }\n\n      return [node];\n    } else {\n      return body;\n    }\n  }\n  /**\n   * Handle a subscript or superscript with nice errors.\n   */\n\n\n  handleSupSubscript(name // For error reporting.\n  ) {\n    var symbolToken = this.fetch();\n    var symbol = symbolToken.text;\n    this.consume();\n    this.consumeSpaces(); // ignore spaces before sup/subscript argument\n    // Skip over allowed internal nodes such as \\relax\n\n    var group;\n\n    do {\n      var _group;\n\n      group = this.parseGroup(name);\n    } while (((_group = group) == null ? void 0 : _group.type) === \"internal\");\n\n    if (!group) {\n      throw new ParseError(\"Expected group after '\" + symbol + \"'\", symbolToken);\n    }\n\n    return group;\n  }\n  /**\n   * Converts the textual input of an unsupported command into a text node\n   * contained within a color node whose color is determined by errorColor\n   */\n\n\n  formatUnsupportedCmd(text) {\n    var textordArray = [];\n\n    for (var i = 0; i < text.length; i++) {\n      textordArray.push({\n        type: \"textord\",\n        mode: \"text\",\n        text: text[i]\n      });\n    }\n\n    var textNode = {\n      type: \"text\",\n      mode: this.mode,\n      body: textordArray\n    };\n    var colorNode = {\n      type: \"color\",\n      mode: this.mode,\n      color: this.settings.errorColor,\n      body: [textNode]\n    };\n    return colorNode;\n  }\n  /**\n   * Parses a group with optional super/subscripts.\n   */\n\n\n  parseAtom(breakOnTokenText) {\n    // The body of an atom is an implicit group, so that things like\n    // \\left(x\\right)^2 work correctly.\n    var base = this.parseGroup(\"atom\", breakOnTokenText); // Internal nodes (e.g. \\relax) cannot support super/subscripts.\n    // Instead we will pick up super/subscripts with blank base next round.\n\n    if ((base == null ? void 0 : base.type) === \"internal\") {\n      return base;\n    } // In text mode, we don't have superscripts or subscripts\n\n\n    if (this.mode === \"text\") {\n      return base;\n    } // Note that base may be empty (i.e. null) at this point.\n\n\n    var superscript;\n    var subscript;\n\n    while (true) {\n      // Guaranteed in math mode, so eat any spaces first.\n      this.consumeSpaces(); // Lex the first token\n\n      var lex = this.fetch();\n\n      if (lex.text === \"\\\\limits\" || lex.text === \"\\\\nolimits\") {\n        // We got a limit control\n        if (base && base.type === \"op\") {\n          var limits = lex.text === \"\\\\limits\";\n          base.limits = limits;\n          base.alwaysHandleSupSub = true;\n        } else if (base && base.type === \"operatorname\") {\n          if (base.alwaysHandleSupSub) {\n            base.limits = lex.text === \"\\\\limits\";\n          }\n        } else {\n          throw new ParseError(\"Limit controls must follow a math operator\", lex);\n        }\n\n        this.consume();\n      } else if (lex.text === \"^\") {\n        // We got a superscript start\n        if (superscript) {\n          throw new ParseError(\"Double superscript\", lex);\n        }\n\n        superscript = this.handleSupSubscript(\"superscript\");\n      } else if (lex.text === \"_\") {\n        // We got a subscript start\n        if (subscript) {\n          throw new ParseError(\"Double subscript\", lex);\n        }\n\n        subscript = this.handleSupSubscript(\"subscript\");\n      } else if (lex.text === \"'\") {\n        // We got a prime\n        if (superscript) {\n          throw new ParseError(\"Double superscript\", lex);\n        }\n\n        var prime = {\n          type: \"textord\",\n          mode: this.mode,\n          text: \"\\\\prime\"\n        }; // Many primes can be grouped together, so we handle this here\n\n        var primes = [prime];\n        this.consume(); // Keep lexing tokens until we get something that's not a prime\n\n        while (this.fetch().text === \"'\") {\n          // For each one, add another prime to the list\n          primes.push(prime);\n          this.consume();\n        } // If there's a superscript following the primes, combine that\n        // superscript in with the primes.\n\n\n        if (this.fetch().text === \"^\") {\n          primes.push(this.handleSupSubscript(\"superscript\"));\n        } // Put everything into an ordgroup as the superscript\n\n\n        superscript = {\n          type: \"ordgroup\",\n          mode: this.mode,\n          body: primes\n        };\n      } else if (uSubsAndSups[lex.text]) {\n        // A Unicode subscript or superscript character.\n        // We treat these similarly to the unicode-math package.\n        // So we render a string of Unicode (sub|super)scripts the\n        // same as a (sub|super)script of regular characters.\n        var isSub = unicodeSubRegEx.test(lex.text);\n        var subsupTokens = [];\n        subsupTokens.push(new Token(uSubsAndSups[lex.text]));\n        this.consume(); // Continue fetching tokens to fill out the string.\n\n        while (true) {\n          var token = this.fetch().text;\n\n          if (!uSubsAndSups[token]) {\n            break;\n          }\n\n          if (unicodeSubRegEx.test(token) !== isSub) {\n            break;\n          }\n\n          subsupTokens.unshift(new Token(uSubsAndSups[token]));\n          this.consume();\n        } // Now create a (sub|super)script.\n\n\n        var body = this.subparse(subsupTokens);\n\n        if (isSub) {\n          subscript = {\n            type: \"ordgroup\",\n            mode: \"math\",\n            body\n          };\n        } else {\n          superscript = {\n            type: \"ordgroup\",\n            mode: \"math\",\n            body\n          };\n        }\n      } else {\n        // If it wasn't ^, _, or ', stop parsing super/subscripts\n        break;\n      }\n    } // Base must be set if superscript or subscript are set per logic above,\n    // but need to check here for type check to pass.\n\n\n    if (superscript || subscript) {\n      // If we got either a superscript or subscript, create a supsub\n      return {\n        type: \"supsub\",\n        mode: this.mode,\n        base: base,\n        sup: superscript,\n        sub: subscript\n      };\n    } else {\n      // Otherwise return the original body\n      return base;\n    }\n  }\n  /**\n   * Parses an entire function, including its base and all of its arguments.\n   */\n\n\n  parseFunction(breakOnTokenText, name // For determining its context\n  ) {\n    var token = this.fetch();\n    var func = token.text;\n    var funcData = functions[func];\n\n    if (!funcData) {\n      return null;\n    }\n\n    this.consume(); // consume command token\n\n    if (name && name !== \"atom\" && !funcData.allowedInArgument) {\n      throw new ParseError(\"Got function '\" + func + \"' with no arguments\" + (name ? \" as \" + name : \"\"), token);\n    } else if (this.mode === \"text\" && !funcData.allowedInText) {\n      throw new ParseError(\"Can't use function '\" + func + \"' in text mode\", token);\n    } else if (this.mode === \"math\" && funcData.allowedInMath === false) {\n      throw new ParseError(\"Can't use function '\" + func + \"' in math mode\", token);\n    }\n\n    var {\n      args,\n      optArgs\n    } = this.parseArguments(func, funcData);\n    return this.callFunction(func, args, optArgs, token, breakOnTokenText);\n  }\n  /**\n   * Call a function handler with a suitable context and arguments.\n   */\n\n\n  callFunction(name, args, optArgs, token, breakOnTokenText) {\n    var context = {\n      funcName: name,\n      parser: this,\n      token,\n      breakOnTokenText\n    };\n    var func = functions[name];\n\n    if (func && func.handler) {\n      return func.handler(context, args, optArgs);\n    } else {\n      throw new ParseError(\"No function handler for \" + name);\n    }\n  }\n  /**\n   * Parses the arguments of a function or environment\n   */\n\n\n  parseArguments(func, // Should look like \"\\name\" or \"\\begin{name}\".\n  funcData) {\n    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;\n\n    if (totalArgs === 0) {\n      return {\n        args: [],\n        optArgs: []\n      };\n    }\n\n    var args = [];\n    var optArgs = [];\n\n    for (var i = 0; i < totalArgs; i++) {\n      var argType = funcData.argTypes && funcData.argTypes[i];\n      var isOptional = i < funcData.numOptionalArgs;\n\n      if (funcData.primitive && argType == null || // \\sqrt expands into primitive if optional argument doesn't exist\n      funcData.type === \"sqrt\" && i === 1 && optArgs[0] == null) {\n        argType = \"primitive\";\n      }\n\n      var arg = this.parseGroupOfType(\"argument to '\" + func + \"'\", argType, isOptional);\n\n      if (isOptional) {\n        optArgs.push(arg);\n      } else if (arg != null) {\n        args.push(arg);\n      } else {\n        // should be unreachable\n        throw new ParseError(\"Null argument, please report this as a bug\");\n      }\n    }\n\n    return {\n      args,\n      optArgs\n    };\n  }\n  /**\n   * Parses a group when the mode is changing.\n   */\n\n\n  parseGroupOfType(name, type, optional) {\n    switch (type) {\n      case \"color\":\n        return this.parseColorGroup(optional);\n\n      case \"size\":\n        return this.parseSizeGroup(optional);\n\n      case \"url\":\n        return this.parseUrlGroup(optional);\n\n      case \"math\":\n      case \"text\":\n        return this.parseArgumentGroup(optional, type);\n\n      case \"hbox\":\n        {\n          // hbox argument type wraps the argument in the equivalent of\n          // \\hbox, which is like \\text but switching to \\textstyle size.\n          var group = this.parseArgumentGroup(optional, \"text\");\n          return group != null ? {\n            type: \"styling\",\n            mode: group.mode,\n            body: [group],\n            style: \"text\" // simulate \\textstyle\n\n          } : null;\n        }\n\n      case \"raw\":\n        {\n          var token = this.parseStringGroup(\"raw\", optional);\n          return token != null ? {\n            type: \"raw\",\n            mode: \"text\",\n            string: token.text\n          } : null;\n        }\n\n      case \"primitive\":\n        {\n          if (optional) {\n            throw new ParseError(\"A primitive argument cannot be optional\");\n          }\n\n          var _group2 = this.parseGroup(name);\n\n          if (_group2 == null) {\n            throw new ParseError(\"Expected group as \" + name, this.fetch());\n          }\n\n          return _group2;\n        }\n\n      case \"original\":\n      case null:\n      case undefined:\n        return this.parseArgumentGroup(optional);\n\n      default:\n        throw new ParseError(\"Unknown group type as \" + name, this.fetch());\n    }\n  }\n  /**\n   * Discard any space tokens, fetching the next non-space token.\n   */\n\n\n  consumeSpaces() {\n    while (this.fetch().text === \" \") {\n      this.consume();\n    }\n  }\n  /**\n   * Parses a group, essentially returning the string formed by the\n   * brace-enclosed tokens plus some position information.\n   */\n\n\n  parseStringGroup(modeName, // Used to describe the mode in error messages.\n  optional) {\n    var argToken = this.gullet.scanArgument(optional);\n\n    if (argToken == null) {\n      return null;\n    }\n\n    var str = \"\";\n    var nextToken;\n\n    while ((nextToken = this.fetch()).text !== \"EOF\") {\n      str += nextToken.text;\n      this.consume();\n    }\n\n    this.consume(); // consume the end of the argument\n\n    argToken.text = str;\n    return argToken;\n  }\n  /**\n   * Parses a regex-delimited group: the largest sequence of tokens\n   * whose concatenated strings match `regex`. Returns the string\n   * formed by the tokens plus some position information.\n   */\n\n\n  parseRegexGroup(regex, modeName // Used to describe the mode in error messages.\n  ) {\n    var firstToken = this.fetch();\n    var lastToken = firstToken;\n    var str = \"\";\n    var nextToken;\n\n    while ((nextToken = this.fetch()).text !== \"EOF\" && regex.test(str + nextToken.text)) {\n      lastToken = nextToken;\n      str += lastToken.text;\n      this.consume();\n    }\n\n    if (str === \"\") {\n      throw new ParseError(\"Invalid \" + modeName + \": '\" + firstToken.text + \"'\", firstToken);\n    }\n\n    return firstToken.range(lastToken, str);\n  }\n  /**\n   * Parses a color description.\n   */\n\n\n  parseColorGroup(optional) {\n    var res = this.parseStringGroup(\"color\", optional);\n\n    if (res == null) {\n      return null;\n    }\n\n    var match = /^(#[a-f0-9]{3,4}|#[a-f0-9]{6}|#[a-f0-9]{8}|[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);\n\n    if (!match) {\n      throw new ParseError(\"Invalid color: '\" + res.text + \"'\", res);\n    }\n\n    var color = match[0];\n\n    if (/^[0-9a-f]{6}$/i.test(color)) {\n      // We allow a 6-digit HTML color spec without a leading \"#\".\n      // This follows the xcolor package's HTML color model.\n      // Predefined color names are all missed by this RegEx pattern.\n      color = \"#\" + color;\n    }\n\n    return {\n      type: \"color-token\",\n      mode: this.mode,\n      color\n    };\n  }\n  /**\n   * Parses a size specification, consisting of magnitude and unit.\n   */\n\n\n  parseSizeGroup(optional) {\n    var res;\n    var isBlank = false; // don't expand before parseStringGroup\n\n    this.gullet.consumeSpaces();\n\n    if (!optional && this.gullet.future().text !== \"{\") {\n      res = this.parseRegexGroup(/^[-+]? *(?:$|\\d+|\\d+\\.\\d*|\\.\\d*) *[a-z]{0,2} *$/, \"size\");\n    } else {\n      res = this.parseStringGroup(\"size\", optional);\n    }\n\n    if (!res) {\n      return null;\n    }\n\n    if (!optional && res.text.length === 0) {\n      // Because we've tested for what is !optional, this block won't\n      // affect \\kern, \\hspace, etc. It will capture the mandatory arguments\n      // to \\genfrac and \\above.\n      res.text = \"0pt\"; // Enable \\above{}\n\n      isBlank = true; // This is here specifically for \\genfrac\n    }\n\n    var match = /([-+]?) *(\\d+(?:\\.\\d*)?|\\.\\d+) *([a-z]{2})/.exec(res.text);\n\n    if (!match) {\n      throw new ParseError(\"Invalid size: '\" + res.text + \"'\", res);\n    }\n\n    var data = {\n      number: +(match[1] + match[2]),\n      // sign + magnitude, cast to number\n      unit: match[3]\n    };\n\n    if (!validUnit(data)) {\n      throw new ParseError(\"Invalid unit: '\" + data.unit + \"'\", res);\n    }\n\n    return {\n      type: \"size\",\n      mode: this.mode,\n      value: data,\n      isBlank\n    };\n  }\n  /**\n   * Parses an URL, checking escaped letters and allowed protocols,\n   * and setting the catcode of % as an active character (as in \\hyperref).\n   */\n\n\n  parseUrlGroup(optional) {\n    this.gullet.lexer.setCatcode(\"%\", 13); // active character\n\n    this.gullet.lexer.setCatcode(\"~\", 12); // other character\n\n    var res = this.parseStringGroup(\"url\", optional);\n    this.gullet.lexer.setCatcode(\"%\", 14); // comment character\n\n    this.gullet.lexer.setCatcode(\"~\", 13); // active character\n\n    if (res == null) {\n      return null;\n    } // hyperref package allows backslashes alone in href, but doesn't\n    // generate valid links in such cases; we interpret this as\n    // \"undefined\" behaviour, and keep them as-is. Some browser will\n    // replace backslashes with forward slashes.\n\n\n    var url = res.text.replace(/\\\\([#$%&~_^{}])/g, '$1');\n    return {\n      type: \"url\",\n      mode: this.mode,\n      url\n    };\n  }\n  /**\n   * Parses an argument with the mode specified.\n   */\n\n\n  parseArgumentGroup(optional, mode) {\n    var argToken = this.gullet.scanArgument(optional);\n\n    if (argToken == null) {\n      return null;\n    }\n\n    var outerMode = this.mode;\n\n    if (mode) {\n      // Switch to specified mode\n      this.switchMode(mode);\n    }\n\n    this.gullet.beginGroup();\n    var expression = this.parseExpression(false, \"EOF\"); // TODO: find an alternative way to denote the end\n\n    this.expect(\"EOF\"); // expect the end of the argument\n\n    this.gullet.endGroup();\n    var result = {\n      type: \"ordgroup\",\n      mode: this.mode,\n      loc: argToken.loc,\n      body: expression\n    };\n\n    if (mode) {\n      // Switch mode back\n      this.switchMode(outerMode);\n    }\n\n    return result;\n  }\n  /**\n   * Parses an ordinary group, which is either a single nucleus (like \"x\")\n   * or an expression in braces (like \"{x+y}\") or an implicit group, a group\n   * that starts at the current position, and ends right before a higher explicit\n   * group ends, or at EOF.\n   */\n\n\n  parseGroup(name, // For error reporting.\n  breakOnTokenText) {\n    var firstToken = this.fetch();\n    var text = firstToken.text;\n    var result; // Try to parse an open brace or \\begingroup\n\n    if (text === \"{\" || text === \"\\\\begingroup\") {\n      this.consume();\n      var groupEnd = text === \"{\" ? \"}\" : \"\\\\endgroup\";\n      this.gullet.beginGroup(); // If we get a brace, parse an expression\n\n      var expression = this.parseExpression(false, groupEnd);\n      var lastToken = this.fetch();\n      this.expect(groupEnd); // Check that we got a matching closing brace\n\n      this.gullet.endGroup();\n      result = {\n        type: \"ordgroup\",\n        mode: this.mode,\n        loc: SourceLocation.range(firstToken, lastToken),\n        body: expression,\n        // A group formed by \\begingroup...\\endgroup is a semi-simple group\n        // which doesn't affect spacing in math mode, i.e., is transparent.\n        // https://tex.stackexchange.com/questions/1930/when-should-one-\n        // use-begingroup-instead-of-bgroup\n        semisimple: text === \"\\\\begingroup\" || undefined\n      };\n    } else {\n      // If there exists a function with this name, parse the function.\n      // Otherwise, just return a nucleus\n      result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();\n\n      if (result == null && text[0] === \"\\\\\" && !implicitCommands.hasOwnProperty(text)) {\n        if (this.settings.throwOnError) {\n          throw new ParseError(\"Undefined control sequence: \" + text, firstToken);\n        }\n\n        result = this.formatUnsupportedCmd(text);\n        this.consume();\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Form ligature-like combinations of characters for text mode.\n   * This includes inputs like \"--\", \"---\", \"``\" and \"''\".\n   * The result will simply replace multiple textord nodes with a single\n   * character in each value by a single textord node having multiple\n   * characters in its value.  The representation is still ASCII source.\n   * The group will be modified in place.\n   */\n\n\n  formLigatures(group) {\n    var n = group.length - 1;\n\n    for (var i = 0; i < n; ++i) {\n      var a = group[i]; // $FlowFixMe: Not every node type has a `text` property.\n\n      var v = a.text;\n\n      if (v === \"-\" && group[i + 1].text === \"-\") {\n        if (i + 1 < n && group[i + 2].text === \"-\") {\n          group.splice(i, 3, {\n            type: \"textord\",\n            mode: \"text\",\n            loc: SourceLocation.range(a, group[i + 2]),\n            text: \"---\"\n          });\n          n -= 2;\n        } else {\n          group.splice(i, 2, {\n            type: \"textord\",\n            mode: \"text\",\n            loc: SourceLocation.range(a, group[i + 1]),\n            text: \"--\"\n          });\n          n -= 1;\n        }\n      }\n\n      if ((v === \"'\" || v === \"`\") && group[i + 1].text === v) {\n        group.splice(i, 2, {\n          type: \"textord\",\n          mode: \"text\",\n          loc: SourceLocation.range(a, group[i + 1]),\n          text: v + v\n        });\n        n -= 1;\n      }\n    }\n  }\n  /**\n   * Parse a single symbol out of the string. Here, we handle single character\n   * symbols and special functions like \\verb.\n   */\n\n\n  parseSymbol() {\n    var nucleus = this.fetch();\n    var text = nucleus.text;\n\n    if (/^\\\\verb[^a-zA-Z]/.test(text)) {\n      this.consume();\n      var arg = text.slice(5);\n      var star = arg.charAt(0) === \"*\";\n\n      if (star) {\n        arg = arg.slice(1);\n      } // Lexer's tokenRegex is constructed to always have matching\n      // first/last characters.\n\n\n      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {\n        throw new ParseError(\"\\\\verb assertion failed --\\n                    please report what input caused this bug\");\n      }\n\n      arg = arg.slice(1, -1); // remove first and last char\n\n      return {\n        type: \"verb\",\n        mode: \"text\",\n        body: arg,\n        star\n      };\n    } // At this point, we should have a symbol, possibly with accents.\n    // First expand any accented base symbol according to unicodeSymbols.\n\n\n    if (unicodeSymbols.hasOwnProperty(text[0]) && !symbols[this.mode][text[0]]) {\n      // This behavior is not strict (XeTeX-compatible) in math mode.\n      if (this.settings.strict && this.mode === \"math\") {\n        this.settings.reportNonstrict(\"unicodeTextInMathMode\", \"Accented Unicode text character \\\"\" + text[0] + \"\\\" used in \" + \"math mode\", nucleus);\n      }\n\n      text = unicodeSymbols[text[0]] + text.slice(1);\n    } // Strip off any combining characters\n\n\n    var match = combiningDiacriticalMarksEndRegex.exec(text);\n\n    if (match) {\n      text = text.substring(0, match.index);\n\n      if (text === 'i') {\n        text = '\\u0131'; // dotless i, in math and text mode\n      } else if (text === 'j') {\n        text = '\\u0237'; // dotless j, in math and text mode\n      }\n    } // Recognize base symbol\n\n\n    var symbol;\n\n    if (symbols[this.mode][text]) {\n      if (this.settings.strict && this.mode === 'math' && extraLatin.indexOf(text) >= 0) {\n        this.settings.reportNonstrict(\"unicodeTextInMathMode\", \"Latin-1/Unicode text character \\\"\" + text[0] + \"\\\" used in \" + \"math mode\", nucleus);\n      }\n\n      var group = symbols[this.mode][text].group;\n      var loc = SourceLocation.range(nucleus);\n      var s;\n\n      if (ATOMS.hasOwnProperty(group)) {\n        // $FlowFixMe\n        var family = group;\n        s = {\n          type: \"atom\",\n          mode: this.mode,\n          family,\n          loc,\n          text\n        };\n      } else {\n        // $FlowFixMe\n        s = {\n          type: group,\n          mode: this.mode,\n          loc,\n          text\n        };\n      } // $FlowFixMe\n\n\n      symbol = s;\n    } else if (text.charCodeAt(0) >= 0x80) {\n      // no symbol for e.g. ^\n      if (this.settings.strict) {\n        if (!supportedCodepoint(text.charCodeAt(0))) {\n          this.settings.reportNonstrict(\"unknownSymbol\", \"Unrecognized Unicode character \\\"\" + text[0] + \"\\\"\" + (\" (\" + text.charCodeAt(0) + \")\"), nucleus);\n        } else if (this.mode === \"math\") {\n          this.settings.reportNonstrict(\"unicodeTextInMathMode\", \"Unicode text character \\\"\" + text[0] + \"\\\" used in math mode\", nucleus);\n        }\n      } // All nonmathematical Unicode characters are rendered as if they\n      // are in text mode (wrapped in \\text) because that's what it\n      // takes to render them in LaTeX.  Setting `mode: this.mode` is\n      // another natural choice (the user requested math mode), but\n      // this makes it more difficult for getCharacterMetrics() to\n      // distinguish Unicode characters without metrics and those for\n      // which we want to simulate the letter M.\n\n\n      symbol = {\n        type: \"textord\",\n        mode: \"text\",\n        loc: SourceLocation.range(nucleus),\n        text\n      };\n    } else {\n      return null; // EOF, ^, _, {, }, etc.\n    }\n\n    this.consume(); // Transform combining characters into accents\n\n    if (match) {\n      for (var i = 0; i < match[0].length; i++) {\n        var accent = match[0][i];\n\n        if (!unicodeAccents[accent]) {\n          throw new ParseError(\"Unknown accent ' \" + accent + \"'\", nucleus);\n        }\n\n        var command = unicodeAccents[accent][this.mode] || unicodeAccents[accent].text;\n\n        if (!command) {\n          throw new ParseError(\"Accent \" + accent + \" unsupported in \" + this.mode + \" mode\", nucleus);\n        }\n\n        symbol = {\n          type: \"accent\",\n          mode: this.mode,\n          loc: SourceLocation.range(nucleus),\n          label: command,\n          isStretchy: false,\n          isShifty: true,\n          // $FlowFixMe\n          base: symbol\n        };\n      }\n    } // $FlowFixMe\n\n\n    return symbol;\n  }\n\n}\nParser.endOfExpression = [\"}\", \"\\\\endgroup\", \"\\\\end\", \"\\\\right\", \"&\"];\n\n/**\n * Provides a single function for parsing an expression using a Parser\n * TODO(emily): Remove this\n */\n\n/**\n * Parses an expression using a Parser, then returns the parsed result.\n */\nvar parseTree = function parseTree(toParse, settings) {\n  if (!(typeof toParse === 'string' || toParse instanceof String)) {\n    throw new TypeError('KaTeX can only parse string typed expression');\n  }\n\n  var parser = new Parser(toParse, settings); // Blank out any \\df@tag to avoid spurious \"Duplicate \\tag\" errors\n\n  delete parser.gullet.macros.current[\"\\\\df@tag\"];\n  var tree = parser.parse(); // Prevent a color definition from persisting between calls to katex.render().\n\n  delete parser.gullet.macros.current[\"\\\\current@color\"];\n  delete parser.gullet.macros.current[\"\\\\color\"]; // If the input used \\tag, it will set the \\df@tag macro to the tag.\n  // In this case, we separately parse the tag and wrap the tree.\n\n  if (parser.gullet.macros.get(\"\\\\df@tag\")) {\n    if (!settings.displayMode) {\n      throw new ParseError(\"\\\\tag works only in display equations\");\n    }\n\n    tree = [{\n      type: \"tag\",\n      mode: \"text\",\n      body: tree,\n      tag: parser.subparse([new Token(\"\\\\df@tag\")])\n    }];\n  }\n\n  return tree;\n};\n\n/* eslint no-console:0 */\n\n/**\n * Parse and build an expression, and place that expression in the DOM node\n * given.\n */\nvar render = function render(expression, baseNode, options) {\n  baseNode.textContent = \"\";\n  var node = renderToDomTree(expression, options).toNode();\n  baseNode.appendChild(node);\n}; // KaTeX's styles don't work properly in quirks mode. Print out an error, and\n// disable rendering.\n\n\nif (typeof document !== \"undefined\") {\n  if (document.compatMode !== \"CSS1Compat\") {\n    typeof console !== \"undefined\" && console.warn(\"Warning: KaTeX doesn't work in quirks mode. Make sure your \" + \"website has a suitable doctype.\");\n\n    render = function render() {\n      throw new ParseError(\"KaTeX doesn't work in quirks mode.\");\n    };\n  }\n}\n/**\n * Parse and build an expression, and return the markup for that.\n */\n\n\nvar renderToString = function renderToString(expression, options) {\n  var markup = renderToDomTree(expression, options).toMarkup();\n  return markup;\n};\n/**\n * Parse an expression and return the parse tree.\n */\n\n\nvar generateParseTree = function generateParseTree(expression, options) {\n  var settings = new Settings(options);\n  return parseTree(expression, settings);\n};\n/**\n * If the given error is a KaTeX ParseError and options.throwOnError is false,\n * renders the invalid LaTeX as a span with hover title giving the KaTeX\n * error message.  Otherwise, simply throws the error.\n */\n\n\nvar renderError = function renderError(error, expression, options) {\n  if (options.throwOnError || !(error instanceof ParseError)) {\n    throw error;\n  }\n\n  var node = buildCommon.makeSpan([\"katex-error\"], [new SymbolNode(expression)]);\n  node.setAttribute(\"title\", error.toString());\n  node.setAttribute(\"style\", \"color:\" + options.errorColor);\n  return node;\n};\n/**\n * Generates and returns the katex build tree. This is used for advanced\n * use cases (like rendering to custom output).\n */\n\n\nvar renderToDomTree = function renderToDomTree(expression, options) {\n  var settings = new Settings(options);\n\n  try {\n    var tree = parseTree(expression, settings);\n    return buildTree(tree, expression, settings);\n  } catch (error) {\n    return renderError(error, expression, settings);\n  }\n};\n/**\n * Generates and returns the katex build tree, with just HTML (no MathML).\n * This is used for advanced use cases (like rendering to custom output).\n */\n\n\nvar renderToHTMLTree = function renderToHTMLTree(expression, options) {\n  var settings = new Settings(options);\n\n  try {\n    var tree = parseTree(expression, settings);\n    return buildHTMLTree(tree, expression, settings);\n  } catch (error) {\n    return renderError(error, expression, settings);\n  }\n};\n\nvar version = \"0.16.27\";\nvar __domTree = {\n  Span,\n  Anchor,\n  SymbolNode,\n  SvgNode,\n  PathNode,\n  LineNode\n}; // ESM exports\n\nvar katex = {\n  /**\n   * Current KaTeX version\n   */\n  version,\n\n  /**\n   * Renders the given LaTeX into an HTML+MathML combination, and adds\n   * it as a child to the specified DOM node.\n   */\n  render,\n\n  /**\n   * Renders the given LaTeX into an HTML+MathML combination string,\n   * for sending to the client.\n   */\n  renderToString,\n\n  /**\n   * KaTeX error, usually during parsing.\n   */\n  ParseError,\n\n  /**\n   * The schema of Settings\n   */\n  SETTINGS_SCHEMA,\n\n  /**\n   * Parses the given LaTeX into KaTeX's internal parse tree structure,\n   * without rendering to HTML or MathML.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __parse: generateParseTree,\n\n  /**\n   * Renders the given LaTeX into an HTML+MathML internal DOM tree\n   * representation, without flattening that representation to a string.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __renderToDomTree: renderToDomTree,\n\n  /**\n   * Renders the given LaTeX into an HTML internal DOM tree representation,\n   * without MathML and without flattening that representation to a string.\n   *\n   * NOTE: This method is not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __renderToHTMLTree: renderToHTMLTree,\n\n  /**\n   * extends internal font metrics object with a new object\n   * each key in the new object represents a font name\n  */\n  __setFontMetrics: setFontMetrics,\n\n  /**\n   * adds a new symbol to builtin symbols table\n   */\n  __defineSymbol: defineSymbol,\n\n  /**\n   * adds a new function to builtin function list,\n   * which directly produce parse tree elements\n   * and have their own html/mathml builders\n   */\n  __defineFunction: defineFunction,\n\n  /**\n   * adds a new macro to builtin macro list\n   */\n  __defineMacro: defineMacro,\n\n  /**\n   * Expose the dom tree node types, which can be useful for type checking nodes.\n   *\n   * NOTE: These methods are not currently recommended for public use.\n   * The internal tree representation is unstable and is very likely\n   * to change. Use at your own risk.\n   */\n  __domTree\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9rYXRleC9kaXN0L2thdGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7OztBQUdSLDRFQUE0RTs7QUFFNUU7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7OztBQUdGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1osWUFBWTtBQUNaLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdHQUF3RyxNQUFNO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxPQUFPLE1BQU07QUFDMUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViLGlOQUFpTjs7QUFFak47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVEsWUFBWSxRQUFRLE9BQU8sU0FBUztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDhDQUE4Qzs7QUFFOUMsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSixrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakIsa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4R0FBOEc7O0FBRTlHOztBQUVBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFOztBQUV0RSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQSwwREFBMEQ7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBLGtFQUFrRTs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0QsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDLGtDQUFrQzs7QUFFbEM7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFVBQVU7QUFDVixVQUFVO0FBQ1YsV0FBVztBQUNYO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FB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SjtBQUNBO0FBQ0E7OztBQUdBLCtEQUErRDs7QUFFL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBLHNCQUFzQixvQkFBb0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQkFBbUI7QUFDdkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FB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QUM5QztBQUNBLHFDQUFxQztBQUNyQztBQUNBLFVBQVU7QUFDVixxQ0FBcUM7OztBQUdyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU0sbUNBQW1DLFFBQVE7OztBQUdqRDtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7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LENBQUMsR0FBRzs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQSxvRUFBb0U7O0FBRXBFOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQyxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7OztBQUdKLGlGQUFpRjs7QUFFakYsb0RBQW9EO0FBQ3BEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSyxZQUFZOztBQUVqQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssWUFBWTs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLFlBQVksTUFBTSxPQUFPLEtBQUssT0FBTyxHQUFHLEdBQUc7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix3REFBd0QsRUFBRTs7QUFFMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRTs7QUFFbkU7O0FBRUEsc0JBQXNCLHVCQUF1QjtBQUM3Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLDhDQUE4Qzs7QUFFOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkVBQTZFOztBQUU3RTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFP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QUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssWUFBWTs7QUFFakI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxvRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQSx1RUFBdUU7O0FBRXZFO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FB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QSxNQUFNO0FBQ047QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7O0FBRXBEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDs7QUFFbEQsNkZBQTZGO0FBQzdGLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9HQUFvRztBQUNwRzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLHdCQUF3QixJQUFJLElBQUk7QUFDcEMseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUcseUJBQXlCLElBQUksSUFBSTtBQUNyQywwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRyx3QkFBd0IsSUFBSSxJQUFJLElBQUk7QUFDeEM7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtB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O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOzs7QUFHQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsOERBQThELEtBQUs7QUFDbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLElBQUksV0FBVyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUU7O0FBRXZFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsRUFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7O0FBRUEscURBQXFEO0FBQ3JELDBFQUEwRSxLQUFLO0FBQy9FLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEIsc0JBQXNCO0FBQ3RCOztBQUVBLHdEQUF3RCxFQUFFOztBQUUxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSwyQ0FBMkM7O0FBRTNDLDJDQUEyQzs7QUFFM0M7QUFDQSwyQ0FBMkM7O0FBRTNDLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBLE1BQU07QUFDTiwyQ0FBMkM7QUFDM0M7QUFDQTs7O0FBR0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7O0FBRXpELHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixtQkFBbUI7QUFDbkI7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QyxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0Isd0JBQXdCOztBQUV4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIsUUFBUTtBQUNSLHlCQUF5QjtBQUN6QjtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUJBQW1CLGVBQWUsR0FBRztBQUNyQzs7QUFFQSxvQkFBb0I7O0FBRXBCO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7O0FBRTlDO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBLGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVWIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9rYXRleC9kaXN0L2thdGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExleGluZyBvciBwYXJzaW5nIHBvc2l0aW9uYWwgaW5mb3JtYXRpb24gZm9yIGVycm9yIHJlcG9ydGluZy5cbiAqIFRoaXMgb2JqZWN0IGlzIGltbXV0YWJsZS5cbiAqL1xuY2xhc3MgU291cmNlTG9jYXRpb24ge1xuICAvLyBUaGUgKyBwcmVmaXggaW5kaWNhdGVzIHRoYXQgdGhlc2UgZmllbGRzIGFyZW4ndCB3cml0ZWFibGVcbiAgLy8gTGV4ZXIgaG9sZGluZyB0aGUgaW5wdXQgc3RyaW5nLlxuICAvLyBTdGFydCBvZmZzZXQsIHplcm8tYmFzZWQgaW5jbHVzaXZlLlxuICAvLyBFbmQgb2Zmc2V0LCB6ZXJvLWJhc2VkIGV4Y2x1c2l2ZS5cbiAgY29uc3RydWN0b3IobGV4ZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLmxleGVyID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmQgPSB2b2lkIDA7XG4gICAgdGhpcy5sZXhlciA9IGxleGVyO1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZDtcbiAgfVxuICAvKipcbiAgICogTWVyZ2VzIHR3byBgU291cmNlTG9jYXRpb25gcyBmcm9tIGxvY2F0aW9uIHByb3ZpZGVycywgZ2l2ZW4gdGhleSBhcmVcbiAgICogcHJvdmlkZWQgaW4gb3JkZXIgb2YgYXBwZWFyYW5jZS5cbiAgICogLSBSZXR1cm5zIHRoZSBmaXJzdCBvbmUncyBsb2NhdGlvbiBpZiBvbmx5IHRoZSBmaXJzdCBpcyBwcm92aWRlZC5cbiAgICogLSBSZXR1cm5zIGEgbWVyZ2VkIHJhbmdlIG9mIHRoZSBmaXJzdCBhbmQgdGhlIGxhc3QgaWYgYm90aCBhcmUgcHJvdmlkZWRcbiAgICogICBhbmQgdGhlaXIgbGV4ZXJzIG1hdGNoLlxuICAgKiAtIE90aGVyd2lzZSwgcmV0dXJucyBudWxsLlxuICAgKi9cblxuXG4gIHN0YXRpYyByYW5nZShmaXJzdCwgc2Vjb25kKSB7XG4gICAgaWYgKCFzZWNvbmQpIHtcbiAgICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC5sb2M7XG4gICAgfSBlbHNlIGlmICghZmlyc3QgfHwgIWZpcnN0LmxvYyB8fCAhc2Vjb25kLmxvYyB8fCBmaXJzdC5sb2MubGV4ZXIgIT09IHNlY29uZC5sb2MubGV4ZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFNvdXJjZUxvY2F0aW9uKGZpcnN0LmxvYy5sZXhlciwgZmlyc3QubG9jLnN0YXJ0LCBzZWNvbmQubG9jLmVuZCk7XG4gICAgfVxuICB9XG5cbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgcmVxdWlyZWQgdG8gYnJlYWsgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIFRva2VuLCBMZXhlciwgYW5kXG4gKiBQYXJzZUVycm9yLlxuICovXG5cbi8qKlxuICogVGhlIHJlc3VsdGluZyB0b2tlbiByZXR1cm5lZCBmcm9tIGBsZXhgLlxuICpcbiAqIEl0IGNvbnNpc3RzIG9mIHRoZSB0b2tlbiB0ZXh0IHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAqIFRoZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBpcyBlc3NlbnRpYWxseSBhIHJhbmdlIGluIGFuIGlucHV0IHN0cmluZyxcbiAqIGJ1dCBpbnN0ZWFkIG9mIHJlZmVyZW5jaW5nIHRoZSBiYXJlIGlucHV0IHN0cmluZywgd2UgcmVmZXIgdG8gdGhlIGxleGVyLlxuICogVGhhdCB3YXkgaXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGV4dHJhIG1ldGFkYXRhIHRvIHRoZSBpbnB1dCBzdHJpbmcsXG4gKiBsaWtlIGZvciBleGFtcGxlIGEgZmlsZSBuYW1lIG9yIHNpbWlsYXIuXG4gKlxuICogVGhlIHBvc2l0aW9uIGluZm9ybWF0aW9uIGlzIG9wdGlvbmFsLCBzbyBpdCBpcyBPSyB0byBjb25zdHJ1Y3Qgc3ludGhldGljXG4gKiB0b2tlbnMgaWYgYXBwcm9wcmlhdGUuIE5vdCBwcm92aWRpbmcgYXZhaWxhYmxlIHBvc2l0aW9uIGluZm9ybWF0aW9uIG1heVxuICogbGVhZCB0byBkZWdyYWRlZCBlcnJvciByZXBvcnRpbmcsIHRob3VnaC5cbiAqL1xuY2xhc3MgVG9rZW4ge1xuICAvLyBkb24ndCBleHBhbmQgdGhlIHRva2VuXG4gIC8vIHVzZWQgaW4gXFxub2V4cGFuZFxuICBjb25zdHJ1Y3Rvcih0ZXh0LCAvLyB0aGUgdGV4dCBvZiB0aGlzIHRva2VuXG4gIGxvYykge1xuICAgIHRoaXMudGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYyA9IHZvaWQgMDtcbiAgICB0aGlzLm5vZXhwYW5kID0gdm9pZCAwO1xuICAgIHRoaXMudHJlYXRBc1JlbGF4ID0gdm9pZCAwO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5sb2MgPSBsb2M7XG4gIH1cbiAgLyoqXG4gICAqIEdpdmVuIGEgcGFpciBvZiB0b2tlbnMgKHRoaXMgYW5kIGVuZFRva2VuKSwgY29tcHV0ZSBhIGBUb2tlbmAgZW5jb21wYXNzaW5nXG4gICAqIHRoZSB3aG9sZSBpbnB1dCByYW5nZSBlbmNsb3NlZCBieSB0aGVzZSB0d28uXG4gICAqL1xuXG5cbiAgcmFuZ2UoZW5kVG9rZW4sIC8vIGxhc3QgdG9rZW4gb2YgdGhlIHJhbmdlLCBpbmNsdXNpdmVcbiAgdGV4dCAvLyB0aGUgdGV4dCBvZiB0aGUgbmV3bHkgY29uc3RydWN0ZWQgdG9rZW5cbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbih0ZXh0LCBTb3VyY2VMb2NhdGlvbi5yYW5nZSh0aGlzLCBlbmRUb2tlbikpO1xuICB9XG5cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBQYXJzZUVycm9yIGNsYXNzLCB3aGljaCBpcyB0aGUgbWFpbiBlcnJvciB0aHJvd24gYnkgS2FUZVhcbiAqIGZ1bmN0aW9ucyB3aGVuIHNvbWV0aGluZyBoYXMgZ29uZSB3cm9uZy4gVGhpcyBpcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIGludGVybmFsXG4gKiBlcnJvcnMgZnJvbSBlcnJvcnMgaW4gdGhlIGV4cHJlc3Npb24gdGhhdCB0aGUgdXNlciBwcm92aWRlZC5cbiAqXG4gKiBJZiBwb3NzaWJsZSwgYSBjYWxsZXIgc2hvdWxkIHByb3ZpZGUgYSBUb2tlbiBvciBQYXJzZU5vZGUgd2l0aCBpbmZvcm1hdGlvblxuICogYWJvdXQgd2hlcmUgaW4gdGhlIHNvdXJjZSBzdHJpbmcgdGhlIHByb2JsZW0gb2NjdXJyZWQuXG4gKi9cbmNsYXNzIFBhcnNlRXJyb3Ige1xuICAvLyBFcnJvciBzdGFydCBwb3NpdGlvbiBiYXNlZCBvbiBwYXNzZWQtaW4gVG9rZW4gb3IgUGFyc2VOb2RlLlxuICAvLyBMZW5ndGggb2YgYWZmZWN0ZWQgdGV4dCBiYXNlZCBvbiBwYXNzZWQtaW4gVG9rZW4gb3IgUGFyc2VOb2RlLlxuICAvLyBUaGUgdW5kZXJseWluZyBlcnJvciBtZXNzYWdlIHdpdGhvdXQgYW55IGNvbnRleHQgYWRkZWQuXG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIC8vIFRoZSBlcnJvciBtZXNzYWdlXG4gIHRva2VuIC8vIEFuIG9iamVjdCBwcm92aWRpbmcgcG9zaXRpb24gaW5mb3JtYXRpb25cbiAgKSB7XG4gICAgdGhpcy5uYW1lID0gdm9pZCAwO1xuICAgIHRoaXMucG9zaXRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5sZW5ndGggPSB2b2lkIDA7XG4gICAgdGhpcy5yYXdNZXNzYWdlID0gdm9pZCAwO1xuICAgIHZhciBlcnJvciA9IFwiS2FUZVggcGFyc2UgZXJyb3I6IFwiICsgbWVzc2FnZTtcbiAgICB2YXIgc3RhcnQ7XG4gICAgdmFyIGVuZDtcbiAgICB2YXIgbG9jID0gdG9rZW4gJiYgdG9rZW4ubG9jO1xuXG4gICAgaWYgKGxvYyAmJiBsb2Muc3RhcnQgPD0gbG9jLmVuZCkge1xuICAgICAgLy8gSWYgd2UgaGF2ZSB0aGUgaW5wdXQgYW5kIGEgcG9zaXRpb24sIG1ha2UgdGhlIGVycm9yIGEgYml0IGZhbmNpZXJcbiAgICAgIC8vIEdldCB0aGUgaW5wdXRcbiAgICAgIHZhciBpbnB1dCA9IGxvYy5sZXhlci5pbnB1dDsgLy8gUHJlcGVuZCBzb21lIGluZm9ybWF0aW9uXG5cbiAgICAgIHN0YXJ0ID0gbG9jLnN0YXJ0O1xuICAgICAgZW5kID0gbG9jLmVuZDtcblxuICAgICAgaWYgKHN0YXJ0ID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgZXJyb3IgKz0gXCIgYXQgZW5kIG9mIGlucHV0OiBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yICs9IFwiIGF0IHBvc2l0aW9uIFwiICsgKHN0YXJ0ICsgMSkgKyBcIjogXCI7XG4gICAgICB9IC8vIFVuZGVybGluZSB0b2tlbiBpbiBxdWVzdGlvbiB1c2luZyBjb21iaW5pbmcgdW5kZXJzY29yZXNcblxuXG4gICAgICB2YXIgdW5kZXJsaW5lZCA9IGlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpLnJlcGxhY2UoL1teXS9nLCBcIiQmXFx1MDMzMlwiKTsgLy8gRXh0cmFjdCBzb21lIGNvbnRleHQgZnJvbSB0aGUgaW5wdXQgYW5kIGFkZCBpdCB0byB0aGUgZXJyb3JcblxuICAgICAgdmFyIGxlZnQ7XG5cbiAgICAgIGlmIChzdGFydCA+IDE1KSB7XG4gICAgICAgIGxlZnQgPSBcIuKAplwiICsgaW5wdXQuc2xpY2Uoc3RhcnQgLSAxNSwgc3RhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IGlucHV0LnNsaWNlKDAsIHN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJpZ2h0O1xuXG4gICAgICBpZiAoZW5kICsgMTUgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcmlnaHQgPSBpbnB1dC5zbGljZShlbmQsIGVuZCArIDE1KSArIFwi4oCmXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByaWdodCA9IGlucHV0LnNsaWNlKGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGVycm9yICs9IGxlZnQgKyB1bmRlcmxpbmVkICsgcmlnaHQ7XG4gICAgfSAvLyBTb21lIGhhY2tlcnkgdG8gbWFrZSBQYXJzZUVycm9yIGEgcHJvdG90eXBlIG9mIEVycm9yXG4gICAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg0NjA3NTNcbiAgICAvLyAkRmxvd0ZpeE1lXG5cblxuICAgIHZhciBzZWxmID0gbmV3IEVycm9yKGVycm9yKTtcbiAgICBzZWxmLm5hbWUgPSBcIlBhcnNlRXJyb3JcIjsgLy8gJEZsb3dGaXhNZVxuXG4gICAgc2VsZi5fX3Byb3RvX18gPSBQYXJzZUVycm9yLnByb3RvdHlwZTtcbiAgICBzZWxmLnBvc2l0aW9uID0gc3RhcnQ7XG5cbiAgICBpZiAoc3RhcnQgIT0gbnVsbCAmJiBlbmQgIT0gbnVsbCkge1xuICAgICAgc2VsZi5sZW5ndGggPSBlbmQgLSBzdGFydDtcbiAgICB9XG5cbiAgICBzZWxmLnJhd01lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbn0gLy8gJEZsb3dGaXhNZSBNb3JlIGhhY2tlcnlcblxuXG5QYXJzZUVycm9yLnByb3RvdHlwZS5fX3Byb3RvX18gPSBFcnJvci5wcm90b3R5cGU7XG5cbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGEgbGlzdCBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB3aGljaCBhcmUgdXNlZnVsIGluIG90aGVyXG4gKiBmaWxlcy5cbiAqL1xuXG4vKipcbiAqIFByb3ZpZGUgYSBkZWZhdWx0IHZhbHVlIGlmIGEgc2V0dGluZyBpcyB1bmRlZmluZWRcbiAqIE5PVEU6IENvdWxkbid0IHVzZSBgVGAgYXMgdGhlIG91dHB1dCB0eXBlIGR1ZSB0byBmYWNlYm9vay9mbG93IzUwMjIuXG4gKi9cbnZhciBkZWZsdCA9IGZ1bmN0aW9uIGRlZmx0KHNldHRpbmcsIGRlZmF1bHRJZlVuZGVmaW5lZCkge1xuICByZXR1cm4gc2V0dGluZyA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdElmVW5kZWZpbmVkIDogc2V0dGluZztcbn07IC8vIGh5cGhlbmF0ZSBhbmQgZXNjYXBlIGFkYXB0ZWQgZnJvbSBGYWNlYm9vaydzIFJlYWN0IHVuZGVyIEFwYWNoZSAyIGxpY2Vuc2VcblxuXG52YXIgdXBwZXJjYXNlID0gLyhbQS1aXSkvZztcblxudmFyIGh5cGhlbmF0ZSA9IGZ1bmN0aW9uIGh5cGhlbmF0ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHVwcGVyY2FzZSwgXCItJDFcIikudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBFU0NBUEVfTE9PS1VQID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gIFwiPFwiOiBcIiZsdDtcIixcbiAgXCJcXFwiXCI6IFwiJnF1b3Q7XCIsXG4gIFwiJ1wiOiBcIiYjeDI3O1wiXG59O1xudmFyIEVTQ0FQRV9SRUdFWCA9IC9bJj48XCInXS9nO1xuLyoqXG4gKiBFc2NhcGVzIHRleHQgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUodGV4dCkge1xuICByZXR1cm4gU3RyaW5nKHRleHQpLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCBtYXRjaCA9PiBFU0NBUEVfTE9PS1VQW21hdGNoXSk7XG59XG4vKipcbiAqIFNvbWV0aW1lcyB3ZSB3YW50IHRvIHB1bGwgb3V0IHRoZSBpbm5lcm1vc3QgZWxlbWVudCBvZiBhIGdyb3VwLiBJbiBtb3N0XG4gKiBjYXNlcywgdGhpcyB3aWxsIGp1c3QgYmUgdGhlIGdyb3VwIGl0c2VsZiwgYnV0IHdoZW4gb3JkZ3JvdXBzIGFuZCBjb2xvcnMgaGF2ZVxuICogYSBzaW5nbGUgZWxlbWVudCwgd2Ugd2FudCB0byBwdWxsIHRoYXQgb3V0LlxuICovXG5cblxudmFyIGdldEJhc2VFbGVtID0gZnVuY3Rpb24gZ2V0QmFzZUVsZW0oZ3JvdXApIHtcbiAgaWYgKGdyb3VwLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgIGlmIChncm91cC5ib2R5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGdldEJhc2VFbGVtKGdyb3VwLmJvZHlbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiY29sb3JcIikge1xuICAgIGlmIChncm91cC5ib2R5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGdldEJhc2VFbGVtKGdyb3VwLmJvZHlbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiZm9udFwiKSB7XG4gICAgcmV0dXJuIGdldEJhc2VFbGVtKGdyb3VwLmJvZHkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBncm91cDtcbiAgfVxufTtcbi8qKlxuICogVGVYYm9vayBhbGdvcml0aG1zIG9mdGVuIHJlZmVyZW5jZSBcImNoYXJhY3RlciBib3hlc1wiLCB3aGljaCBhcmUgc2ltcGx5IGdyb3Vwc1xuICogd2l0aCBhIHNpbmdsZSBjaGFyYWN0ZXIgaW4gdGhlbS4gVG8gZGVjaWRlIGlmIHNvbWV0aGluZyBpcyBhIGNoYXJhY3RlciBib3gsXG4gKiB3ZSBmaW5kIGl0cyBpbm5lcm1vc3QgZ3JvdXAsIGFuZCBzZWUgaWYgaXQgaXMgYSBzaW5nbGUgY2hhcmFjdGVyLlxuICovXG5cblxudmFyIGlzQ2hhcmFjdGVyQm94ID0gZnVuY3Rpb24gaXNDaGFyYWN0ZXJCb3goZ3JvdXApIHtcbiAgdmFyIGJhc2VFbGVtID0gZ2V0QmFzZUVsZW0oZ3JvdXApOyAvLyBUaGVzZSBhcmUgYWxsIHRoZXkgdHlwZXMgb2YgZ3JvdXBzIHdoaWNoIGhvbGQgc2luZ2xlIGNoYXJhY3RlcnNcblxuICByZXR1cm4gYmFzZUVsZW0udHlwZSA9PT0gXCJtYXRob3JkXCIgfHwgYmFzZUVsZW0udHlwZSA9PT0gXCJ0ZXh0b3JkXCIgfHwgYmFzZUVsZW0udHlwZSA9PT0gXCJhdG9tXCI7XG59O1xuXG52YXIgYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG5vbi1udWxsLCBidXQgZ290ICcgKyBTdHJpbmcodmFsdWUpKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIFJldHVybiB0aGUgcHJvdG9jb2wgb2YgYSBVUkwsIG9yIFwiX3JlbGF0aXZlXCIgaWYgdGhlIFVSTCBkb2VzIG5vdCBzcGVjaWZ5IGFcbiAqIHByb3RvY29sIChhbmQgdGh1cyBpcyByZWxhdGl2ZSksIG9yIGBudWxsYCBpZiBVUkwgaGFzIGludmFsaWQgcHJvdG9jb2xcbiAqIChzbyBzaG91bGQgYmUgb3V0cmlnaHQgcmVqZWN0ZWQpLlxuICovXG5cbnZhciBwcm90b2NvbEZyb21VcmwgPSBmdW5jdGlvbiBwcm90b2NvbEZyb21VcmwodXJsKSB7XG4gIC8vIENoZWNrIGZvciBwb3NzaWJsZSBsZWFkaW5nIHByb3RvY29sLlxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1wYXJzaW5nIHN0cmlwcyBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgLy8gKFUrMjApIG9yIEMwIGNvbnRyb2wgKFUrMDAtVSsxRikgY2hhcmFjdGVycy5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgdmFyIHByb3RvY29sID0gL15bXFx4MDAtXFx4MjBdKihbXlxcXFwvIz9dKj8pKDp8JiMwKjU4fCYjeDAqM2F8JmNvbG9uKS9pLmV4ZWModXJsKTtcblxuICBpZiAoIXByb3RvY29sKSB7XG4gICAgcmV0dXJuIFwiX3JlbGF0aXZlXCI7XG4gIH0gLy8gUmVqZWN0IHdlaXJkIGNvbG9uc1xuXG5cbiAgaWYgKHByb3RvY29sWzJdICE9PSBcIjpcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIFJlamVjdCBpbnZhbGlkIGNoYXJhY3RlcnMgaW4gc2NoZW1lIGFjY29yZGluZyB0b1xuICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjFcblxuXG4gIGlmICghL15bYS16QS1aXVthLXpBLVowLTkrXFwtLl0qJC8udGVzdChwcm90b2NvbFsxXSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBMb3dlcmNhc2UgdGhlIHByb3RvY29sXG5cblxuICByZXR1cm4gcHJvdG9jb2xbMV0udG9Mb3dlckNhc2UoKTtcbn07XG52YXIgdXRpbHMgPSB7XG4gIGRlZmx0LFxuICBlc2NhcGUsXG4gIGh5cGhlbmF0ZSxcbiAgZ2V0QmFzZUVsZW0sXG4gIGlzQ2hhcmFjdGVyQm94LFxuICBwcm90b2NvbEZyb21Vcmxcbn07XG5cbi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cbi8vIFRPRE86IGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgZG9jdW1lbnRhdGlvblxuLy8gVE9ETzogY2hlY2sgYWxsIHByb3BlcnRpZXMgb24gU2V0dGluZ3MgZXhpc3Rcbi8vIFRPRE86IGNoZWNrIHRoZSB0eXBlIG9mIGEgcHJvcGVydHkgb24gU2V0dGluZ3MgbWF0Y2hlc1xudmFyIFNFVFRJTkdTX1NDSEVNQSA9IHtcbiAgZGlzcGxheU1vZGU6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZXNjcmlwdGlvbjogXCJSZW5kZXIgbWF0aCBpbiBkaXNwbGF5IG1vZGUsIHdoaWNoIHB1dHMgdGhlIG1hdGggaW4gXCIgKyBcImRpc3BsYXkgc3R5bGUgKHNvIFxcXFxpbnQgYW5kIFxcXFxzdW0gYXJlIGxhcmdlLCBmb3IgZXhhbXBsZSksIGFuZCBcIiArIFwiY2VudGVycyB0aGUgbWF0aCBvbiB0aGUgcGFnZSBvbiBpdHMgb3duIGxpbmUuXCIsXG4gICAgY2xpOiBcIi1kLCAtLWRpc3BsYXktbW9kZVwiXG4gIH0sXG4gIG91dHB1dDoge1xuICAgIHR5cGU6IHtcbiAgICAgIGVudW06IFtcImh0bWxBbmRNYXRobWxcIiwgXCJodG1sXCIsIFwibWF0aG1sXCJdXG4gICAgfSxcbiAgICBkZXNjcmlwdGlvbjogXCJEZXRlcm1pbmVzIHRoZSBtYXJrdXAgbGFuZ3VhZ2Ugb2YgdGhlIG91dHB1dC5cIixcbiAgICBjbGk6IFwiLUYsIC0tZm9ybWF0IDx0eXBlPlwiXG4gIH0sXG4gIGxlcW5vOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgZGVzY3JpcHRpb246IFwiUmVuZGVyIGRpc3BsYXkgbWF0aCBpbiBsZXFubyBzdHlsZSAobGVmdC1qdXN0aWZpZWQgdGFncykuXCJcbiAgfSxcbiAgZmxlcW46IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBkZXNjcmlwdGlvbjogXCJSZW5kZXIgZGlzcGxheSBtYXRoIGZsdXNoIGxlZnQuXCJcbiAgfSxcbiAgdGhyb3dPbkVycm9yOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICBjbGk6IFwiLXQsIC0tbm8tdGhyb3ctb24tZXJyb3JcIixcbiAgICBjbGlEZXNjcmlwdGlvbjogXCJSZW5kZXIgZXJyb3JzIChpbiB0aGUgY29sb3IgZ2l2ZW4gYnkgLS1lcnJvci1jb2xvcikgaW5zXCIgKyBcInRlYWQgb2YgdGhyb3dpbmcgYSBQYXJzZUVycm9yIGV4Y2VwdGlvbiB3aGVuIGVuY291bnRlcmluZyBhbiBlcnJvci5cIlxuICB9LFxuICBlcnJvckNvbG9yOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBkZWZhdWx0OiBcIiNjYzAwMDBcIixcbiAgICBjbGk6IFwiLWMsIC0tZXJyb3ItY29sb3IgPGNvbG9yPlwiLFxuICAgIGNsaURlc2NyaXB0aW9uOiBcIkEgY29sb3Igc3RyaW5nIGdpdmVuIGluIHRoZSBmb3JtYXQgJ3JnYicgb3IgJ3JyZ2diYicgXCIgKyBcIihubyAjKS4gVGhpcyBvcHRpb24gZGV0ZXJtaW5lcyB0aGUgY29sb3Igb2YgZXJyb3JzIHJlbmRlcmVkIGJ5IHRoZSBcIiArIFwiLXQgb3B0aW9uLlwiLFxuICAgIGNsaVByb2Nlc3NvcjogY29sb3IgPT4gXCIjXCIgKyBjb2xvclxuICB9LFxuICBtYWNyb3M6IHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIGNsaTogXCItbSwgLS1tYWNybyA8ZGVmPlwiLFxuICAgIGNsaURlc2NyaXB0aW9uOiBcIkRlZmluZSBjdXN0b20gbWFjcm8gb2YgdGhlIGZvcm0gJ1xcXFxmb286ZXhwYW5zaW9uJyAodXNlIFwiICsgXCJtdWx0aXBsZSAtbSBhcmd1bWVudHMgZm9yIG11bHRpcGxlIG1hY3JvcykuXCIsXG4gICAgY2xpRGVmYXVsdDogW10sXG4gICAgY2xpUHJvY2Vzc29yOiAoZGVmLCBkZWZzKSA9PiB7XG4gICAgICBkZWZzLnB1c2goZGVmKTtcbiAgICAgIHJldHVybiBkZWZzO1xuICAgIH1cbiAgfSxcbiAgbWluUnVsZVRoaWNrbmVzczoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVzY3JpcHRpb246IFwiU3BlY2lmaWVzIGEgbWluaW11bSB0aGlja25lc3MsIGluIGVtcywgZm9yIGZyYWN0aW9uIGxpbmVzLFwiICsgXCIgYFxcXFxzcXJ0YCB0b3AgbGluZXMsIGB7YXJyYXl9YCB2ZXJ0aWNhbCBsaW5lcywgYFxcXFxobGluZWAsIFwiICsgXCJgXFxcXGhkYXNobGluZWAsIGBcXFxcdW5kZXJsaW5lYCwgYFxcXFxvdmVybGluZWAsIGFuZCB0aGUgYm9yZGVycyBvZiBcIiArIFwiYFxcXFxmYm94YCwgYFxcXFxib3hlZGAsIGFuZCBgXFxcXGZjb2xvcmJveGAuXCIsXG4gICAgcHJvY2Vzc29yOiB0ID0+IE1hdGgubWF4KDAsIHQpLFxuICAgIGNsaTogXCItLW1pbi1ydWxlLXRoaWNrbmVzcyA8c2l6ZT5cIixcbiAgICBjbGlQcm9jZXNzb3I6IHBhcnNlRmxvYXRcbiAgfSxcbiAgY29sb3JJc1RleHRDb2xvcjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk1ha2VzIFxcXFxjb2xvciBiZWhhdmUgbGlrZSBMYVRlWCdzIDItYXJndW1lbnQgXFxcXHRleHRjb2xvciwgXCIgKyBcImluc3RlYWQgb2YgTGFUZVgncyBvbmUtYXJndW1lbnQgXFxcXGNvbG9yIG1vZGUgY2hhbmdlLlwiLFxuICAgIGNsaTogXCItYiwgLS1jb2xvci1pcy10ZXh0LWNvbG9yXCJcbiAgfSxcbiAgc3RyaWN0OiB7XG4gICAgdHlwZTogW3tcbiAgICAgIGVudW06IFtcIndhcm5cIiwgXCJpZ25vcmVcIiwgXCJlcnJvclwiXVxuICAgIH0sIFwiYm9vbGVhblwiLCBcImZ1bmN0aW9uXCJdLFxuICAgIGRlc2NyaXB0aW9uOiBcIlR1cm4gb24gc3RyaWN0IC8gTGFUZVggZmFpdGhmdWxuZXNzIG1vZGUsIHdoaWNoIHRocm93cyBhbiBcIiArIFwiZXJyb3IgaWYgdGhlIGlucHV0IHVzZXMgZmVhdHVyZXMgdGhhdCBhcmUgbm90IHN1cHBvcnRlZCBieSBMYVRlWC5cIixcbiAgICBjbGk6IFwiLVMsIC0tc3RyaWN0XCIsXG4gICAgY2xpRGVmYXVsdDogZmFsc2VcbiAgfSxcbiAgdHJ1c3Q6IHtcbiAgICB0eXBlOiBbXCJib29sZWFuXCIsIFwiZnVuY3Rpb25cIl0sXG4gICAgZGVzY3JpcHRpb246IFwiVHJ1c3QgdGhlIGlucHV0LCBlbmFibGluZyBhbGwgSFRNTCBmZWF0dXJlcyBzdWNoIGFzIFxcXFx1cmwuXCIsXG4gICAgY2xpOiBcIi1ULCAtLXRydXN0XCJcbiAgfSxcbiAgbWF4U2l6ZToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogSW5maW5pdHksXG4gICAgZGVzY3JpcHRpb246IFwiSWYgbm9uLXplcm8sIGFsbCB1c2VyLXNwZWNpZmllZCBzaXplcywgZS5nLiBpbiBcIiArIFwiXFxcXHJ1bGV7NTAwZW19ezUwMGVtfSwgd2lsbCBiZSBjYXBwZWQgdG8gbWF4U2l6ZSBlbXMuIE90aGVyd2lzZSwgXCIgKyBcImVsZW1lbnRzIGFuZCBzcGFjZXMgY2FuIGJlIGFyYml0cmFyaWx5IGxhcmdlXCIsXG4gICAgcHJvY2Vzc29yOiBzID0+IE1hdGgubWF4KDAsIHMpLFxuICAgIGNsaTogXCItcywgLS1tYXgtc2l6ZSA8bj5cIixcbiAgICBjbGlQcm9jZXNzb3I6IHBhcnNlSW50XG4gIH0sXG4gIG1heEV4cGFuZDoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZGVmYXVsdDogMTAwMCxcbiAgICBkZXNjcmlwdGlvbjogXCJMaW1pdCB0aGUgbnVtYmVyIG9mIG1hY3JvIGV4cGFuc2lvbnMgdG8gdGhlIHNwZWNpZmllZCBcIiArIFwibnVtYmVyLCB0byBwcmV2ZW50IGUuZy4gaW5maW5pdGUgbWFjcm8gbG9vcHMuIElmIHNldCB0byBJbmZpbml0eSwgXCIgKyBcInRoZSBtYWNybyBleHBhbmRlciB3aWxsIHRyeSB0byBmdWxseSBleHBhbmQgYXMgaW4gTGFUZVguXCIsXG4gICAgcHJvY2Vzc29yOiBuID0+IE1hdGgubWF4KDAsIG4pLFxuICAgIGNsaTogXCItZSwgLS1tYXgtZXhwYW5kIDxuPlwiLFxuICAgIGNsaVByb2Nlc3NvcjogbiA9PiBuID09PSBcIkluZmluaXR5XCIgPyBJbmZpbml0eSA6IHBhcnNlSW50KG4pXG4gIH0sXG4gIGdsb2JhbEdyb3VwOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgY2xpOiBmYWxzZVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0VmFsdWUoc2NoZW1hKSB7XG4gIGlmIChzY2hlbWEuZGVmYXVsdCkge1xuICAgIHJldHVybiBzY2hlbWEuZGVmYXVsdDtcbiAgfVxuXG4gIHZhciB0eXBlID0gc2NoZW1hLnR5cGU7XG4gIHZhciBkZWZhdWx0VHlwZSA9IEFycmF5LmlzQXJyYXkodHlwZSkgPyB0eXBlWzBdIDogdHlwZTtcblxuICBpZiAodHlwZW9mIGRlZmF1bHRUeXBlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZWZhdWx0VHlwZS5lbnVtWzBdO1xuICB9XG5cbiAgc3dpdGNoIChkZWZhdWx0VHlwZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiAnJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gMDtcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4ge307XG4gIH1cbn1cbi8qKlxuICogVGhlIG1haW4gU2V0dGluZ3Mgb2JqZWN0XG4gKlxuICogVGhlIGN1cnJlbnQgb3B0aW9ucyBzdG9yZWQgYXJlOlxuICogIC0gZGlzcGxheU1vZGU6IFdoZXRoZXIgdGhlIGV4cHJlc3Npb24gc2hvdWxkIGJlIHR5cGVzZXQgYXMgaW5saW5lIG1hdGhcbiAqICAgICAgICAgICAgICAgICAoZmFsc2UsIHRoZSBkZWZhdWx0KSwgbWVhbmluZyB0aGF0IHRoZSBtYXRoIHN0YXJ0cyBpblxuICogICAgICAgICAgICAgICAgIFxcdGV4dHN0eWxlIGFuZCBpcyBwbGFjZWQgaW4gYW4gaW5saW5lLWJsb2NrKTsgb3IgYXMgZGlzcGxheVxuICogICAgICAgICAgICAgICAgIG1hdGggKHRydWUpLCBtZWFuaW5nIHRoYXQgdGhlIG1hdGggc3RhcnRzIGluIFxcZGlzcGxheXN0eWxlXG4gKiAgICAgICAgICAgICAgICAgYW5kIGlzIHBsYWNlZCBpbiBhIGJsb2NrIHdpdGggdmVydGljYWwgbWFyZ2luLlxuICovXG5cblxuY2xhc3MgU2V0dGluZ3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5kaXNwbGF5TW9kZSA9IHZvaWQgMDtcbiAgICB0aGlzLm91dHB1dCA9IHZvaWQgMDtcbiAgICB0aGlzLmxlcW5vID0gdm9pZCAwO1xuICAgIHRoaXMuZmxlcW4gPSB2b2lkIDA7XG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5lcnJvckNvbG9yID0gdm9pZCAwO1xuICAgIHRoaXMubWFjcm9zID0gdm9pZCAwO1xuICAgIHRoaXMubWluUnVsZVRoaWNrbmVzcyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbG9ySXNUZXh0Q29sb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHJpY3QgPSB2b2lkIDA7XG4gICAgdGhpcy50cnVzdCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5tYXhFeHBhbmQgPSB2b2lkIDA7XG4gICAgdGhpcy5nbG9iYWxHcm91cCA9IHZvaWQgMDtcbiAgICAvLyBhbGxvdyBudWxsIG9wdGlvbnNcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gU0VUVElOR1NfU0NIRU1BKSB7XG4gICAgICBpZiAoU0VUVElOR1NfU0NIRU1BLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgdmFyIHNjaGVtYSA9IFNFVFRJTkdTX1NDSEVNQVtwcm9wXTsgLy8gVE9ETzogdmFsaWRhdGUgb3B0aW9uc1xuICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgICAgdGhpc1twcm9wXSA9IG9wdGlvbnNbcHJvcF0gIT09IHVuZGVmaW5lZCA/IHNjaGVtYS5wcm9jZXNzb3IgPyBzY2hlbWEucHJvY2Vzc29yKG9wdGlvbnNbcHJvcF0pIDogb3B0aW9uc1twcm9wXSA6IGdldERlZmF1bHRWYWx1ZShzY2hlbWEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVwb3J0IG5vbnN0cmljdCAobm9uLUxhVGVYLWNvbXBhdGlibGUpIGlucHV0LlxuICAgKiBDYW4gc2FmZWx5IG5vdCBiZSBjYWxsZWQgaWYgYHRoaXMuc3RyaWN0YCBpcyBmYWxzZSBpbiBKYXZhU2NyaXB0LlxuICAgKi9cblxuXG4gIHJlcG9ydE5vbnN0cmljdChlcnJvckNvZGUsIGVycm9yTXNnLCB0b2tlbikge1xuICAgIHZhciBzdHJpY3QgPSB0aGlzLnN0cmljdDtcblxuICAgIGlmICh0eXBlb2Ygc3RyaWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIC8vIEFsbG93IHJldHVybiB2YWx1ZSBvZiBzdHJpY3QgZnVuY3Rpb24gdG8gYmUgYm9vbGVhbiBvciBzdHJpbmdcbiAgICAgIC8vIChvciBudWxsL3VuZGVmaW5lZCwgbWVhbmluZyBubyBmdXJ0aGVyIHByb2Nlc3NpbmcpLlxuICAgICAgc3RyaWN0ID0gc3RyaWN0KGVycm9yQ29kZSwgZXJyb3JNc2csIHRva2VuKTtcbiAgICB9XG5cbiAgICBpZiAoIXN0cmljdCB8fCBzdHJpY3QgPT09IFwiaWdub3JlXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHN0cmljdCA9PT0gdHJ1ZSB8fCBzdHJpY3QgPT09IFwiZXJyb3JcIikge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJMYVRlWC1pbmNvbXBhdGlibGUgaW5wdXQgYW5kIHN0cmljdCBtb2RlIGlzIHNldCB0byAnZXJyb3InOiBcIiArIChlcnJvck1zZyArIFwiIFtcIiArIGVycm9yQ29kZSArIFwiXVwiKSwgdG9rZW4pO1xuICAgIH0gZWxzZSBpZiAoc3RyaWN0ID09PSBcIndhcm5cIikge1xuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gJ3dhcm4nOiBcIiArIChlcnJvck1zZyArIFwiIFtcIiArIGVycm9yQ29kZSArIFwiXVwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdvbid0IGhhcHBlbiBpbiB0eXBlLXNhZmUgY29kZVxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gXCIgKyAoXCJ1bnJlY29nbml6ZWQgJ1wiICsgc3RyaWN0ICsgXCInOiBcIiArIGVycm9yTXNnICsgXCIgW1wiICsgZXJyb3JDb2RlICsgXCJdXCIpKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdG8gYXBwbHkgc3RyaWN0IChMYVRlWC1hZGhlcmluZykgYmVoYXZpb3IgZm9yIHVudXN1YWxcbiAgICogaW5wdXQgKGxpa2UgYFxcXFxgKS4gIFVubGlrZSBgbm9uc3RyaWN0YCwgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3I7XG4gICAqIGluc3RlYWQsIFwiZXJyb3JcIiB0cmFuc2xhdGVzIHRvIGEgcmV0dXJuIHZhbHVlIG9mIGB0cnVlYCwgd2hpbGUgXCJpZ25vcmVcIlxuICAgKiB0cmFuc2xhdGVzIHRvIGEgcmV0dXJuIHZhbHVlIG9mIGBmYWxzZWAuICBNYXkgc3RpbGwgcHJpbnQgYSB3YXJuaW5nOlxuICAgKiBcIndhcm5cIiBwcmludHMgYSB3YXJuaW5nIGFuZCByZXR1cm5zIGBmYWxzZWAuXG4gICAqIFRoaXMgaXMgZm9yIHRoZSBzZWNvbmQgY2F0ZWdvcnkgb2YgYGVycm9yQ29kZWBzIGxpc3RlZCBpbiB0aGUgUkVBRE1FLlxuICAgKi9cblxuXG4gIHVzZVN0cmljdEJlaGF2aW9yKGVycm9yQ29kZSwgZXJyb3JNc2csIHRva2VuKSB7XG4gICAgdmFyIHN0cmljdCA9IHRoaXMuc3RyaWN0O1xuXG4gICAgaWYgKHR5cGVvZiBzdHJpY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLy8gQWxsb3cgcmV0dXJuIHZhbHVlIG9mIHN0cmljdCBmdW5jdGlvbiB0byBiZSBib29sZWFuIG9yIHN0cmluZ1xuICAgICAgLy8gKG9yIG51bGwvdW5kZWZpbmVkLCBtZWFuaW5nIG5vIGZ1cnRoZXIgcHJvY2Vzc2luZykuXG4gICAgICAvLyBCdXQgY2F0Y2ggYW55IGV4Y2VwdGlvbnMgdGhyb3duIGJ5IGZ1bmN0aW9uLCB0cmVhdGluZyB0aGVtXG4gICAgICAvLyBsaWtlIFwiZXJyb3JcIi5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0cmljdCA9IHN0cmljdChlcnJvckNvZGUsIGVycm9yTXNnLCB0b2tlbik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzdHJpY3QgPSBcImVycm9yXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzdHJpY3QgfHwgc3RyaWN0ID09PSBcImlnbm9yZVwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChzdHJpY3QgPT09IHRydWUgfHwgc3RyaWN0ID09PSBcImVycm9yXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc3RyaWN0ID09PSBcIndhcm5cIikge1xuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gJ3dhcm4nOiBcIiArIChlcnJvck1zZyArIFwiIFtcIiArIGVycm9yQ29kZSArIFwiXVwiKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdvbid0IGhhcHBlbiBpbiB0eXBlLXNhZmUgY29kZVxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gXCIgKyAoXCJ1bnJlY29nbml6ZWQgJ1wiICsgc3RyaWN0ICsgXCInOiBcIiArIGVycm9yTXNnICsgXCIgW1wiICsgZXJyb3JDb2RlICsgXCJdXCIpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdG8gdGVzdCBwb3RlbnRpYWxseSBkYW5nZXJvdXMgaW5wdXQsIGFuZCByZXR1cm5cbiAgICogYHRydWVgICh0cnVzdGVkKSBvciBgZmFsc2VgICh1bnRydXN0ZWQpLiAgVGhlIHNvbGUgYXJndW1lbnQgYGNvbnRleHRgXG4gICAqIHNob3VsZCBiZSBhbiBvYmplY3Qgd2l0aCBgY29tbWFuZGAgZmllbGQgc3BlY2lmeWluZyB0aGUgcmVsZXZhbnQgTGFUZVhcbiAgICogY29tbWFuZCAoYXMgYSBzdHJpbmcgc3RhcnRpbmcgd2l0aCBgXFxgKSwgYW5kIGFueSBvdGhlciBhcmd1bWVudHMsIGV0Yy5cbiAgICogSWYgYGNvbnRleHRgIGhhcyBhIGB1cmxgIGZpZWxkLCBhIGBwcm90b2NvbGAgZmllbGQgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAqIGdldCBhZGRlZCBieSB0aGlzIGZ1bmN0aW9uIChjaGFuZ2luZyB0aGUgc3BlY2lmaWVkIG9iamVjdCkuXG4gICAqL1xuXG5cbiAgaXNUcnVzdGVkKGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC51cmwgJiYgIWNvbnRleHQucHJvdG9jb2wpIHtcbiAgICAgIHZhciBwcm90b2NvbCA9IHV0aWxzLnByb3RvY29sRnJvbVVybChjb250ZXh0LnVybCk7XG5cbiAgICAgIGlmIChwcm90b2NvbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5wcm90b2NvbCA9IHByb3RvY29sO1xuICAgIH1cblxuICAgIHZhciB0cnVzdCA9IHR5cGVvZiB0aGlzLnRydXN0ID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLnRydXN0KGNvbnRleHQpIDogdGhpcy50cnVzdDtcbiAgICByZXR1cm4gQm9vbGVhbih0cnVzdCk7XG4gIH1cblxufVxuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBpbmZvcm1hdGlvbiBhbmQgY2xhc3NlcyBmb3IgdGhlIHZhcmlvdXMga2luZHMgb2Ygc3R5bGVzXG4gKiB1c2VkIGluIFRlWC4gSXQgcHJvdmlkZXMgYSBnZW5lcmljIGBTdHlsZWAgY2xhc3MsIHdoaWNoIGhvbGRzIGluZm9ybWF0aW9uXG4gKiBhYm91dCBhIHNwZWNpZmljIHN0eWxlLiBJdCB0aGVuIHByb3ZpZGVzIGluc3RhbmNlcyBvZiBhbGwgdGhlIGRpZmZlcmVudCBraW5kc1xuICogb2Ygc3R5bGVzIHBvc3NpYmxlLCBhbmQgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIG1vdmUgYmV0d2VlbiB0aGVtIGFuZCBnZXRcbiAqIGluZm9ybWF0aW9uIGFib3V0IHRoZW0uXG4gKi9cblxuLyoqXG4gKiBUaGUgbWFpbiBzdHlsZSBjbGFzcy4gQ29udGFpbnMgYSB1bmlxdWUgaWQgZm9yIHRoZSBzdHlsZSwgYSBzaXplICh3aGljaCBpc1xuICogdGhlIHNhbWUgZm9yIGNyYW1wZWQgYW5kIHVuY3JhbXBlZCB2ZXJzaW9uIG9mIGEgc3R5bGUpLCBhbmQgYSBjcmFtcGVkIGZsYWcuXG4gKi9cbmNsYXNzIFN0eWxlIHtcbiAgY29uc3RydWN0b3IoaWQsIHNpemUsIGNyYW1wZWQpIHtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMuc2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNyYW1wZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5jcmFtcGVkID0gY3JhbXBlZDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdHlsZSBvZiBhIHN1cGVyc2NyaXB0IGdpdmVuIGEgYmFzZSBpbiB0aGUgY3VycmVudCBzdHlsZS5cbiAgICovXG5cblxuICBzdXAoKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tzdXBbdGhpcy5pZF1dO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0eWxlIG9mIGEgc3Vic2NyaXB0IGdpdmVuIGEgYmFzZSBpbiB0aGUgY3VycmVudCBzdHlsZS5cbiAgICovXG5cblxuICBzdWIoKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tzdWJbdGhpcy5pZF1dO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0eWxlIG9mIGEgZnJhY3Rpb24gbnVtZXJhdG9yIGdpdmVuIHRoZSBmcmFjdGlvbiBpbiB0aGUgY3VycmVudFxuICAgKiBzdHlsZS5cbiAgICovXG5cblxuICBmcmFjTnVtKCkge1xuICAgIHJldHVybiBzdHlsZXNbZnJhY051bVt0aGlzLmlkXV07XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3R5bGUgb2YgYSBmcmFjdGlvbiBkZW5vbWluYXRvciBnaXZlbiB0aGUgZnJhY3Rpb24gaW4gdGhlIGN1cnJlbnRcbiAgICogc3R5bGUuXG4gICAqL1xuXG5cbiAgZnJhY0RlbigpIHtcbiAgICByZXR1cm4gc3R5bGVzW2ZyYWNEZW5bdGhpcy5pZF1dO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNyYW1wZWQgdmVyc2lvbiBvZiBhIHN0eWxlIChpbiBwYXJ0aWN1bGFyLCBjcmFtcGluZyBhIGNyYW1wZWQgc3R5bGVcbiAgICogZG9lc24ndCBjaGFuZ2UgdGhlIHN0eWxlKS5cbiAgICovXG5cblxuICBjcmFtcCgpIHtcbiAgICByZXR1cm4gc3R5bGVzW2NyYW1wW3RoaXMuaWRdXTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgdGV4dCBvciBkaXNwbGF5IHZlcnNpb24gb2YgdGhpcyBzdHlsZS5cbiAgICovXG5cblxuICB0ZXh0KCkge1xuICAgIHJldHVybiBzdHlsZXNbdGV4dCQxW3RoaXMuaWRdXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgdGhpcyBzdHlsZSBpcyB0aWdodGx5IHNwYWNlZCAoc2NyaXB0c3R5bGUvc2NyaXB0c2NyaXB0c3R5bGUpXG4gICAqL1xuXG5cbiAgaXNUaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplID49IDI7XG4gIH1cblxufSAvLyBFeHBvcnQgYW4gaW50ZXJmYWNlIGZvciB0eXBlIGNoZWNraW5nLCBidXQgZG9uJ3QgZXhwb3NlIHRoZSBpbXBsZW1lbnRhdGlvbi5cbi8vIFRoaXMgd2F5LCBubyBtb3JlIHN0eWxlcyBjYW4gYmUgZ2VuZXJhdGVkLlxuXG5cbi8vIElEcyBvZiB0aGUgZGlmZmVyZW50IHN0eWxlc1xudmFyIEQgPSAwO1xudmFyIERjID0gMTtcbnZhciBUID0gMjtcbnZhciBUYyA9IDM7XG52YXIgUyA9IDQ7XG52YXIgU2MgPSA1O1xudmFyIFNTID0gNjtcbnZhciBTU2MgPSA3OyAvLyBJbnN0YW5jZXMgb2YgdGhlIGRpZmZlcmVudCBzdHlsZXNcblxudmFyIHN0eWxlcyA9IFtuZXcgU3R5bGUoRCwgMCwgZmFsc2UpLCBuZXcgU3R5bGUoRGMsIDAsIHRydWUpLCBuZXcgU3R5bGUoVCwgMSwgZmFsc2UpLCBuZXcgU3R5bGUoVGMsIDEsIHRydWUpLCBuZXcgU3R5bGUoUywgMiwgZmFsc2UpLCBuZXcgU3R5bGUoU2MsIDIsIHRydWUpLCBuZXcgU3R5bGUoU1MsIDMsIGZhbHNlKSwgbmV3IFN0eWxlKFNTYywgMywgdHJ1ZSldOyAvLyBMb29rdXAgdGFibGVzIGZvciBzd2l0Y2hpbmcgZnJvbSBvbmUgc3R5bGUgdG8gYW5vdGhlclxuXG52YXIgc3VwID0gW1MsIFNjLCBTLCBTYywgU1MsIFNTYywgU1MsIFNTY107XG52YXIgc3ViID0gW1NjLCBTYywgU2MsIFNjLCBTU2MsIFNTYywgU1NjLCBTU2NdO1xudmFyIGZyYWNOdW0gPSBbVCwgVGMsIFMsIFNjLCBTUywgU1NjLCBTUywgU1NjXTtcbnZhciBmcmFjRGVuID0gW1RjLCBUYywgU2MsIFNjLCBTU2MsIFNTYywgU1NjLCBTU2NdO1xudmFyIGNyYW1wID0gW0RjLCBEYywgVGMsIFRjLCBTYywgU2MsIFNTYywgU1NjXTtcbnZhciB0ZXh0JDEgPSBbRCwgRGMsIFQsIFRjLCBULCBUYywgVCwgVGNdOyAvLyBXZSBvbmx5IGV4cG9ydCBzb21lIG9mIHRoZSBzdHlsZXMuXG5cbnZhciBTdHlsZSQxID0ge1xuICBESVNQTEFZOiBzdHlsZXNbRF0sXG4gIFRFWFQ6IHN0eWxlc1tUXSxcbiAgU0NSSVBUOiBzdHlsZXNbU10sXG4gIFNDUklQVFNDUklQVDogc3R5bGVzW1NTXVxufTtcblxuLypcbiAqIFRoaXMgZmlsZSBkZWZpbmVzIHRoZSBVbmljb2RlIHNjcmlwdHMgYW5kIHNjcmlwdCBmYW1pbGllcyB0aGF0IHdlXG4gKiBzdXBwb3J0LiBUbyBhZGQgbmV3IHNjcmlwdHMgb3IgZmFtaWxpZXMsIGp1c3QgYWRkIGEgbmV3IGVudHJ5IHRvIHRoZVxuICogc2NyaXB0RGF0YSBhcnJheSBiZWxvdy4gQWRkaW5nIHNjcmlwdHMgdG8gdGhlIHNjcmlwdERhdGEgYXJyYXkgYWxsb3dzXG4gKiBjaGFyYWN0ZXJzIGZyb20gdGhhdCBzY3JpcHQgdG8gYXBwZWFyIGluIFxcdGV4dHt9IGVudmlyb25tZW50cy5cbiAqL1xuXG4vKipcbiAqIEVhY2ggc2NyaXB0IG9yIHNjcmlwdCBmYW1pbHkgaGFzIGEgbmFtZSBhbmQgYW4gYXJyYXkgb2YgYmxvY2tzLlxuICogRWFjaCBibG9jayBpcyBhbiBhcnJheSBvZiB0d28gbnVtYmVycyB3aGljaCBzcGVjaWZ5IHRoZSBzdGFydCBhbmRcbiAqIGVuZCBwb2ludHMgKGluY2x1c2l2ZSkgb2YgYSBibG9jayBvZiBVbmljb2RlIGNvZGVwb2ludHMuXG4gKi9cblxuLyoqXG4gKiBVbmljb2RlIGJsb2NrIGRhdGEgZm9yIHRoZSBmYW1pbGllcyBvZiBzY3JpcHRzIHdlIHN1cHBvcnQgaW4gXFx0ZXh0e30uXG4gKiBTY3JpcHRzIG9ubHkgbmVlZCB0byBhcHBlYXIgaGVyZSBpZiB0aGV5IGRvIG5vdCBoYXZlIGZvbnQgbWV0cmljcy5cbiAqL1xudmFyIHNjcmlwdERhdGEgPSBbe1xuICAvLyBMYXRpbiBjaGFyYWN0ZXJzIGJleW9uZCB0aGUgTGF0aW4tMSBjaGFyYWN0ZXJzIHdlIGhhdmUgbWV0cmljcyBmb3IuXG4gIC8vIE5lZWRlZCBmb3IgQ3plY2gsIEh1bmdhcmlhbiBhbmQgVHVya2lzaCB0ZXh0LCBmb3IgZXhhbXBsZS5cbiAgbmFtZTogJ2xhdGluJyxcbiAgYmxvY2tzOiBbWzB4MDEwMCwgMHgwMjRmXSwgLy8gTGF0aW4gRXh0ZW5kZWQtQSBhbmQgTGF0aW4gRXh0ZW5kZWQtQlxuICBbMHgwMzAwLCAweDAzNmZdIC8vIENvbWJpbmluZyBEaWFjcml0aWNhbCBtYXJrc1xuICBdXG59LCB7XG4gIC8vIFRoZSBDeXJpbGxpYyBzY3JpcHQgdXNlZCBieSBSdXNzaWFuIGFuZCByZWxhdGVkIGxhbmd1YWdlcy5cbiAgLy8gQSBDeXJpbGxpYyBzdWJzZXQgdXNlZCB0byBiZSBzdXBwb3J0ZWQgYXMgZXhwbGljaXRseSBkZWZpbmVkXG4gIC8vIHN5bWJvbHMgaW4gc3ltYm9scy5qc1xuICBuYW1lOiAnY3lyaWxsaWMnLFxuICBibG9ja3M6IFtbMHgwNDAwLCAweDA0ZmZdXVxufSwge1xuICAvLyBBcm1lbmlhblxuICBuYW1lOiAnYXJtZW5pYW4nLFxuICBibG9ja3M6IFtbMHgwNTMwLCAweDA1OEZdXVxufSwge1xuICAvLyBUaGUgQnJhaG1pYyBzY3JpcHRzIG9mIFNvdXRoIGFuZCBTb3V0aGVhc3QgQXNpYVxuICAvLyBEZXZhbmFnYXJpICgwOTAw4oCTMDk3RilcbiAgLy8gQmVuZ2FsaSAoMDk4MOKAkzA5RkYpXG4gIC8vIEd1cm11a2hpICgwQTAw4oCTMEE3RilcbiAgLy8gR3VqYXJhdGkgKDBBODDigJMwQUZGKVxuICAvLyBPcml5YSAoMEIwMOKAkzBCN0YpXG4gIC8vIFRhbWlsICgwQjgw4oCTMEJGRilcbiAgLy8gVGVsdWd1ICgwQzAw4oCTMEM3RilcbiAgLy8gS2FubmFkYSAoMEM4MOKAkzBDRkYpXG4gIC8vIE1hbGF5YWxhbSAoMEQwMOKAkzBEN0YpXG4gIC8vIFNpbmhhbGEgKDBEODDigJMwREZGKVxuICAvLyBUaGFpICgwRTAw4oCTMEU3RilcbiAgLy8gTGFvICgwRTgw4oCTMEVGRilcbiAgLy8gVGliZXRhbiAoMEYwMOKAkzBGRkYpXG4gIC8vIE15YW5tYXIgKDEwMDDigJMxMDlGKVxuICBuYW1lOiAnYnJhaG1pYycsXG4gIGJsb2NrczogW1sweDA5MDAsIDB4MTA5Rl1dXG59LCB7XG4gIG5hbWU6ICdnZW9yZ2lhbicsXG4gIGJsb2NrczogW1sweDEwQTAsIDB4MTBmZl1dXG59LCB7XG4gIC8vIENoaW5lc2UgYW5kIEphcGFuZXNlLlxuICAvLyBUaGUgXCJrXCIgaW4gY2prIGlzIGZvciBLb3JlYW4sIGJ1dCB3ZSd2ZSBzZXBhcmF0ZWQgS29yZWFuIG91dFxuICBuYW1lOiBcImNqa1wiLFxuICBibG9ja3M6IFtbMHgzMDAwLCAweDMwRkZdLCAvLyBDSksgc3ltYm9scyBhbmQgcHVuY3R1YXRpb24sIEhpcmFnYW5hLCBLYXRha2FuYVxuICBbMHg0RTAwLCAweDlGQUZdLCAvLyBDSksgaWRlb2dyYW1zXG4gIFsweEZGMDAsIDB4RkY2MF0gLy8gRnVsbHdpZHRoIHB1bmN0dWF0aW9uXG4gIC8vIFRPRE86IGFkZCBoYWxmd2lkdGggS2F0YWthbmEgYW5kIFJvbWFuamkgZ2x5cGhzXG4gIF1cbn0sIHtcbiAgLy8gS29yZWFuXG4gIG5hbWU6ICdoYW5ndWwnLFxuICBibG9ja3M6IFtbMHhBQzAwLCAweEQ3QUZdXVxufV07XG4vKipcbiAqIEdpdmVuIGEgY29kZXBvaW50LCByZXR1cm4gdGhlIG5hbWUgb2YgdGhlIHNjcmlwdCBvciBzY3JpcHQgZmFtaWx5XG4gKiBpdCBpcyBmcm9tLCBvciBudWxsIGlmIGl0IGlzIG5vdCBwYXJ0IG9mIGEga25vd24gYmxvY2tcbiAqL1xuXG5mdW5jdGlvbiBzY3JpcHRGcm9tQ29kZXBvaW50KGNvZGVwb2ludCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcmlwdERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2NyaXB0ID0gc2NyaXB0RGF0YVtpXTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBzY3JpcHQuYmxvY2tzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGJsb2NrID0gc2NyaXB0LmJsb2Nrc1tfaV07XG5cbiAgICAgIGlmIChjb2RlcG9pbnQgPj0gYmxvY2tbMF0gJiYgY29kZXBvaW50IDw9IGJsb2NrWzFdKSB7XG4gICAgICAgIHJldHVybiBzY3JpcHQubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQSBmbGF0dGVuZWQgdmVyc2lvbiBvZiBhbGwgdGhlIHN1cHBvcnRlZCBibG9ja3MgaW4gYSBzaW5nbGUgYXJyYXkuXG4gKiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiB0byBtYWtlIHN1cHBvcnRlZENvZGVwb2ludCgpIGZhc3QuXG4gKi9cblxudmFyIGFsbEJsb2NrcyA9IFtdO1xuc2NyaXB0RGF0YS5mb3JFYWNoKHMgPT4gcy5ibG9ja3MuZm9yRWFjaChiID0+IGFsbEJsb2Nrcy5wdXNoKC4uLmIpKSk7XG4vKipcbiAqIEdpdmVuIGEgY29kZXBvaW50LCByZXR1cm4gdHJ1ZSBpZiBpdCBmYWxscyB3aXRoaW4gb25lIG9mIHRoZVxuICogc2NyaXB0cyBvciBzY3JpcHQgZmFtaWxpZXMgZGVmaW5lZCBhYm92ZSBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIE1pY3JvIGJlbmNobWFya3Mgc2hvd3MgdGhhdCB0aGlzIGlzIGZhc3RlciB0aGFuXG4gKiAvW1xcdTMwMDAtXFx1MzBGRlxcdTRFMDAtXFx1OUZBRlxcdUZGMDAtXFx1RkY2MFxcdUFDMDAtXFx1RDdBRlxcdTA5MDAtXFx1MTA5Rl0vLnRlc3QoKVxuICogaW4gRmlyZWZveCwgQ2hyb21lIGFuZCBOb2RlLlxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRlZENvZGVwb2ludChjb2RlcG9pbnQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxCbG9ja3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBpZiAoY29kZXBvaW50ID49IGFsbEJsb2Nrc1tpXSAmJiBjb2RlcG9pbnQgPD0gYWxsQmxvY2tzW2kgKyAxXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoaXMgZmlsZSBwcm92aWRlcyBzdXBwb3J0IHRvIGRvbVRyZWUuanMgYW5kIGRlbGltaXRlci5qcy5cbiAqIEl0J3MgYSBzdG9yZWhvdXNlIG9mIHBhdGggZ2VvbWV0cnkgZm9yIFNWRyBpbWFnZXMuXG4gKi9cbi8vIEluIGFsbCBwYXRocyBiZWxvdywgdGhlIHZpZXdCb3gtdG8tZW0gc2NhbGUgaXMgMTAwMDoxLlxudmFyIGhMaW5lUGFkID0gODA7IC8vIHBhZGRpbmcgYWJvdmUgYSBzcXJ0IHZpbmN1bHVtLiBQcmV2ZW50cyBpbWFnZSBjcm9wcGluZy5cbi8vIFRoZSB2aW5jdWx1bSBvZiBhIFxcc3FydCBjYW4gYmUgbWFkZSB0aGlja2VyIGJ5IGEgS2FUZVggcmVuZGVyaW5nIG9wdGlvbi5cbi8vIFRoaW5rIG9mIHZhcmlhYmxlIGV4dHJhVmluY3VsdW0gYXMgdHdvIGRldG91cnMgaW4gdGhlIFNWRyBwYXRoLlxuLy8gVGhlIGRldG91ciBiZWdpbnMgYXQgdGhlIGxvd2VyIGxlZnQgb2YgdGhlIGFyZWEgbGFiZWxlZCBleHRyYVZpbmN1bHVtIGJlbG93LlxuLy8gVGhlIGRldG91ciBwcm9jZWVkcyBvbmUgZXh0cmFWaW5jdWx1bSBkaXN0YW5jZSB1cCBhbmQgc2xpZ2h0bHkgdG8gdGhlIHJpZ2h0LFxuLy8gZGlzcGxhY2luZyB0aGUgcmFkaXVzZWQgY29ybmVyIGJldHdlZW4gc3VyZCBhbmQgdmluY3VsdW0uIFRoZSByYWRpdXMgaXNcbi8vIHRyYXZlcnNlZCBhcyB1c3VhbCwgdGhlbiB0aGUgZGV0b3VyIHJlc3VtZXMuIEl0IGdvZXMgcmlnaHQsIHRvIHRoZSBlbmQgb2Zcbi8vIHRoZSB2ZXJ5IGxvbmcgdmluY3VsdW0sIHRoZW4gZG93biBvbmUgZXh0cmFWaW5jdWx1bSBkaXN0YW5jZSxcbi8vIGFmdGVyIHdoaWNoIGl0IHJlc3VtZXMgcmVndWxhciBwYXRoIGdlb21ldHJ5IGZvciB0aGUgcmFkaWNhbC5cblxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpbmN1bHVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvXG4gICAgICAgICAv4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4paS4oaQZXh0cmFWaW5jdWx1bVxuICAgICAgICAvIOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKWiOKGkDAuMDRlbSAoNDAgdW5pdCkgc3RkIHZpbmN1bHVtIHRoaWNrbmVzc1xuICAgICAgIC8gL1xuICAgICAgLyAvXG4gICAgIC8gL1xcXG4gICAgLyAvIHN1cmRcbiovXG5cbnZhciBzcXJ0TWFpbiA9IGZ1bmN0aW9uIHNxcnRNYWluKGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkKSB7XG4gIC8vIHNxcnRNYWluIHBhdGggZ2VvbWV0cnkgaXMgZnJvbSBnbHlwaCBVMjIxQSBpbiB0aGUgZm9udCBLYVRlWCBNYWluXG4gIHJldHVybiBcIk05NSxcIiArICg2MjIgKyBleHRyYVZpbmN1bHVtICsgaExpbmVQYWQpICsgXCJcXG5jLTIuNywwLC03LjE3LC0yLjcsLTEzLjUsLThjLTUuOCwtNS4zLC05LjUsLTEwLC05LjUsLTE0XFxuYzAsLTIsMC4zLC0zLjMsMSwtNGMxLjMsLTIuNywyMy44MywtMjAuNyw2Ny41LC01NFxcbmM0NC4yLC0zMy4zLDY1LjgsLTUwLjMsNjYuNSwtNTFjMS4zLC0xLjMsMywtMiw1LC0yYzQuNywwLDguNywzLjMsMTIsMTBcXG5zMTczLDM3OCwxNzMsMzc4YzAuNywwLDM1LjMsLTcxLDEwNCwtMjEzYzY4LjcsLTE0MiwxMzcuNSwtMjg1LDIwNi41LC00MjlcXG5jNjksLTE0NCwxMDQuNSwtMjE3LjcsMTA2LjUsLTIyMVxcbmxcIiArIGV4dHJhVmluY3VsdW0gLyAyLjA3NSArIFwiIC1cIiArIGV4dHJhVmluY3VsdW0gKyBcIlxcbmM1LjMsLTkuMywxMiwtMTQsMjAsLTE0XFxuSDQwMDAwMHZcIiArICg0MCArIGV4dHJhVmluY3VsdW0pICsgXCJIODQ1LjI3MjRcXG5zLTIyNS4yNzIsNDY3LC0yMjUuMjcyLDQ2N3MtMjM1LDQ4NiwtMjM1LDQ4NmMtMi43LDQuNywtOSw3LC0xOSw3XFxuYy02LDAsLTEwLC0xLC0xMiwtM3MtMTk0LC00MjIsLTE5NCwtNDIycy02NSw0NywtNjUsNDd6XFxuTVwiICsgKDgzNCArIGV4dHJhVmluY3VsdW0pICsgXCIgXCIgKyBoTGluZVBhZCArIFwiaDQwMDAwMHZcIiArICg0MCArIGV4dHJhVmluY3VsdW0pICsgXCJoLTQwMDAwMHpcIjtcbn07XG5cbnZhciBzcXJ0U2l6ZTEgPSBmdW5jdGlvbiBzcXJ0U2l6ZTEoZXh0cmFWaW5jdWx1bSwgaExpbmVQYWQpIHtcbiAgLy8gc2l6ZTEgaXMgZnJvbSBnbHlwaCBVMjIxQSBpbiB0aGUgZm9udCBLYVRlWF9TaXplMS1SZWd1bGFyXG4gIHJldHVybiBcIk0yNjMsXCIgKyAoNjAxICsgZXh0cmFWaW5jdWx1bSArIGhMaW5lUGFkKSArIFwiYzAuNywwLDE4LDM5LjcsNTIsMTE5XFxuYzM0LDc5LjMsNjguMTY3LDE1OC43LDEwMi41LDIzOGMzNC4zLDc5LjMsNTEuOCwxMTkuMyw1Mi41LDEyMFxcbmMzNDAsLTcwNC43LDUxMC43LC0xMDYwLjMsNTEyLC0xMDY3XFxubFwiICsgZXh0cmFWaW5jdWx1bSAvIDIuMDg0ICsgXCIgLVwiICsgZXh0cmFWaW5jdWx1bSArIFwiXFxuYzQuNywtNy4zLDExLC0xMSwxOSwtMTFcXG5INDAwMDB2XCIgKyAoNDAgKyBleHRyYVZpbmN1bHVtKSArIFwiSDEwMTIuM1xcbnMtMjcxLjMsNTY3LC0yNzEuMyw1NjdjLTM4LjcsODAuNywtODQsMTc1LC0xMzYsMjgzYy01MiwxMDgsLTg5LjE2NywxODUuMywtMTExLjUsMjMyXFxuYy0yMi4zLDQ2LjcsLTMzLjgsNzAuMywtMzQuNSw3MWMtNC43LDQuNywtMTIuMyw3LC0yMyw3cy0xMiwtMSwtMTIsLTFcXG5zLTEwOSwtMjUzLC0xMDksLTI1M2MtNzIuNywtMTY4LC0xMDkuMywtMjUyLC0xMTAsLTI1MmMtMTAuNyw4LC0yMiwxNi43LC0zNCwyNlxcbmMtMjIsMTcuMywtMzMuMywyNiwtMzQsMjZzLTI2LC0yNiwtMjYsLTI2czc2LC01OSw3NiwtNTlzNzYsLTYwLDc2LC02MHpcXG5NXCIgKyAoMTAwMSArIGV4dHJhVmluY3VsdW0pICsgXCIgXCIgKyBoTGluZVBhZCArIFwiaDQwMDAwMHZcIiArICg0MCArIGV4dHJhVmluY3VsdW0pICsgXCJoLTQwMDAwMHpcIjtcbn07XG5cbnZhciBzcXJ0U2l6ZTIgPSBmdW5jdGlvbiBzcXJ0U2l6ZTIoZXh0cmFWaW5jdWx1bSwgaExpbmVQYWQpIHtcbiAgLy8gc2l6ZTIgaXMgZnJvbSBnbHlwaCBVMjIxQSBpbiB0aGUgZm9udCBLYVRlWF9TaXplMi1SZWd1bGFyXG4gIHJldHVybiBcIk05ODMgXCIgKyAoMTAgKyBleHRyYVZpbmN1bHVtICsgaExpbmVQYWQpICsgXCJcXG5sXCIgKyBleHRyYVZpbmN1bHVtIC8gMy4xMyArIFwiIC1cIiArIGV4dHJhVmluY3VsdW0gKyBcIlxcbmM0LC02LjcsMTAsLTEwLDE4LC0xMCBINDAwMDAwdlwiICsgKDQwICsgZXh0cmFWaW5jdWx1bSkgKyBcIlxcbkgxMDEzLjFzLTgzLjQsMjY4LC0yNjQuMSw4NDBjLTE4MC43LDU3MiwtMjc3LDg3Ni4zLC0yODksOTEzYy00LjcsNC43LC0xMi43LDcsLTI0LDdcXG5zLTEyLDAsLTEyLDBjLTEuMywtMy4zLC0zLjcsLTExLjcsLTcsLTI1Yy0zNS4zLC0xMjUuMywtMTA2LjcsLTM3My4zLC0yMTQsLTc0NFxcbmMtMTAsMTIsLTIxLDI1LC0zMywzOXMtMzIsMzksLTMyLDM5Yy02LC01LjMsLTE1LC0xNCwtMjcsLTI2czI1LC0zMCwyNSwtMzBcXG5jMjYuNywtMzIuNyw1MiwtNjMsNzYsLTkxczUyLC02MCw1MiwtNjBzMjA4LDcyMiwyMDgsNzIyXFxuYzU2LC0xNzUuMywxMjYuMywtMzk3LjMsMjExLC02NjZjODQuNywtMjY4LjcsMTUzLjgsLTQ4OC4yLDIwNy41LC02NTguNVxcbmM1My43LC0xNzAuMyw4NC41LC0yNjYuOCw5Mi41LC0yODkuNXpcXG5NXCIgKyAoMTAwMSArIGV4dHJhVmluY3VsdW0pICsgXCIgXCIgKyBoTGluZVBhZCArIFwiaDQwMDAwMHZcIiArICg0MCArIGV4dHJhVmluY3VsdW0pICsgXCJoLTQwMDAwMHpcIjtcbn07XG5cbnZhciBzcXJ0U2l6ZTMgPSBmdW5jdGlvbiBzcXJ0U2l6ZTMoZXh0cmFWaW5jdWx1bSwgaExpbmVQYWQpIHtcbiAgLy8gc2l6ZTMgaXMgZnJvbSBnbHlwaCBVMjIxQSBpbiB0aGUgZm9udCBLYVRlWF9TaXplMy1SZWd1bGFyXG4gIHJldHVybiBcIk00MjQsXCIgKyAoMjM5OCArIGV4dHJhVmluY3VsdW0gKyBoTGluZVBhZCkgKyBcIlxcbmMtMS4zLC0wLjcsLTM4LjUsLTE3MiwtMTExLjUsLTUxNGMtNzMsLTM0MiwtMTA5LjgsLTUxMy4zLC0xMTAuNSwtNTE0XFxuYzAsLTIsLTEwLjcsMTQuMywtMzIsNDljLTQuNyw3LjMsLTkuOCwxNS43LC0xNS41LDI1Yy01LjcsOS4zLC05LjgsMTYsLTEyLjUsMjBcXG5zLTUsNywtNSw3Yy00LC0zLjMsLTguMywtNy43LC0xMywtMTNzLTEzLC0xMywtMTMsLTEzczc2LC0xMjIsNzYsLTEyMnM3NywtMTIxLDc3LC0xMjFcXG5zMjA5LDk2OCwyMDksOTY4YzAsLTIsODQuNywtMzYxLjcsMjU0LC0xMDc5YzE2OS4zLC03MTcuMywyNTQuNywtMTA3Ny43LDI1NiwtMTA4MVxcbmxcIiArIGV4dHJhVmluY3VsdW0gLyA0LjIyMyArIFwiIC1cIiArIGV4dHJhVmluY3VsdW0gKyBcImM0LC02LjcsMTAsLTEwLDE4LC0xMCBINDAwMDAwXFxudlwiICsgKDQwICsgZXh0cmFWaW5jdWx1bSkgKyBcIkgxMDE0LjZcXG5zLTg3LjMsMzc4LjcsLTI3Mi42LDExNjZjLTE4NS4zLDc4Ny4zLC0yNzkuMywxMTgyLjMsLTI4MiwxMTg1XFxuYy0yLDYsLTEwLDksLTI0LDlcXG5jLTgsMCwtMTIsLTAuNywtMTIsLTJ6IE1cIiArICgxMDAxICsgZXh0cmFWaW5jdWx1bSkgKyBcIiBcIiArIGhMaW5lUGFkICsgXCJcXG5oNDAwMDAwdlwiICsgKDQwICsgZXh0cmFWaW5jdWx1bSkgKyBcImgtNDAwMDAwelwiO1xufTtcblxudmFyIHNxcnRTaXplNCA9IGZ1bmN0aW9uIHNxcnRTaXplNChleHRyYVZpbmN1bHVtLCBoTGluZVBhZCkge1xuICAvLyBzaXplNCBpcyBmcm9tIGdseXBoIFUyMjFBIGluIHRoZSBmb250IEthVGVYX1NpemU0LVJlZ3VsYXJcbiAgcmV0dXJuIFwiTTQ3MyxcIiArICgyNzEzICsgZXh0cmFWaW5jdWx1bSArIGhMaW5lUGFkKSArIFwiXFxuYzMzOS4zLC0xNzk5LjMsNTA5LjMsLTI3MDAsNTEwLC0yNzAyIGxcIiArIGV4dHJhVmluY3VsdW0gLyA1LjI5OCArIFwiIC1cIiArIGV4dHJhVmluY3VsdW0gKyBcIlxcbmMzLjMsLTcuMyw5LjMsLTExLDE4LC0xMSBINDAwMDAwdlwiICsgKDQwICsgZXh0cmFWaW5jdWx1bSkgKyBcIkgxMDE3LjdcXG5zLTkwLjUsNDc4LC0yNzYuMiwxNDY2Yy0xODUuNyw5ODgsLTI3OS41LDE0ODMsLTI4MS41LDE0ODVjLTIsNiwtMTAsOSwtMjQsOVxcbmMtOCwwLC0xMiwtMC43LC0xMiwtMmMwLC0xLjMsLTUuMywtMzIsLTE2LC05MmMtNTAuNywtMjkzLjMsLTExOS43LC02OTMuMywtMjA3LC0xMjAwXFxuYzAsLTEuMywtNS4zLDguNywtMTYsMzBjLTEwLjcsMjEuMywtMjEuMyw0Mi43LC0zMiw2NHMtMTYsMzMsLTE2LDMzcy0yNiwtMjYsLTI2LC0yNlxcbnM3NiwtMTUzLDc2LC0xNTNzNzcsLTE1MSw3NywtMTUxYzAuNywwLjcsMzUuNywyMDIsMTA1LDYwNGM2Ny4zLDQwMC43LDEwMiw2MDIuNywxMDQsXFxuNjA2ek1cIiArICgxMDAxICsgZXh0cmFWaW5jdWx1bSkgKyBcIiBcIiArIGhMaW5lUGFkICsgXCJoNDAwMDAwdlwiICsgKDQwICsgZXh0cmFWaW5jdWx1bSkgKyBcIkgxMDE3Ljd6XCI7XG59O1xuXG52YXIgcGhhc2VQYXRoID0gZnVuY3Rpb24gcGhhc2VQYXRoKHkpIHtcbiAgdmFyIHggPSB5IC8gMjsgLy8geCBjb29yZGluYXRlIGF0IHRvcCBvZiBhbmdsZVxuXG4gIHJldHVybiBcIk00MDAwMDAgXCIgKyB5ICsgXCIgSDAgTFwiICsgeCArIFwiIDAgbDY1IDQ1IEwxNDUgXCIgKyAoeSAtIDgwKSArIFwiIEg0MDAwMDB6XCI7XG59O1xuXG52YXIgc3FydFRhbGwgPSBmdW5jdGlvbiBzcXJ0VGFsbChleHRyYVZpbmN1bHVtLCBoTGluZVBhZCwgdmlld0JveEhlaWdodCkge1xuICAvLyBzcXJ0VGFsbCBpcyBmcm9tIGdseXBoIFUyM0I3IGluIHRoZSBmb250IEthVGVYX1NpemU0LVJlZ3VsYXJcbiAgLy8gT25lIHBhdGggZWRnZSBoYXMgYSB2YXJpYWJsZSBsZW5ndGguIEl0IHJ1bnMgdmVydGljYWxseSBmcm9tIHRoZSB2aW5jdWx1bVxuICAvLyB0byBhIHBvaW50IG5lYXIgKDE0IHVuaXRzKSB0aGUgYm90dG9tIG9mIHRoZSBzdXJkLiBUaGUgdmluY3VsdW1cbiAgLy8gaXMgbm9ybWFsbHkgNDAgdW5pdHMgdGhpY2suIFNvIHRoZSBsZW5ndGggb2YgdGhlIGxpbmUgaW4gcXVlc3Rpb24gaXM6XG4gIHZhciB2ZXJ0U2VnbWVudCA9IHZpZXdCb3hIZWlnaHQgLSA1NCAtIGhMaW5lUGFkIC0gZXh0cmFWaW5jdWx1bTtcbiAgcmV0dXJuIFwiTTcwMiBcIiArIChleHRyYVZpbmN1bHVtICsgaExpbmVQYWQpICsgXCJINDAwMDAwXCIgKyAoNDAgKyBleHRyYVZpbmN1bHVtKSArIFwiXFxuSDc0MnZcIiArIHZlcnRTZWdtZW50ICsgXCJsLTQgNC00IDRjLS42NjcuNyAtMiAxLjUtNCAyLjVzLTQuMTY3IDEuODMzLTYuNSAyLjUtNS41IDEtOS41IDFcXG5oLTEybC0yOC04NGMtMTYuNjY3LTUyLTk2LjY2NyAtMjk0LjMzMy0yNDAtNzI3bC0yMTIgLTY0MyAtODUgMTcwXFxuYy00LTMuMzMzLTguMzMzLTcuNjY3LTEzIC0xM2wtMTMtMTNsNzctMTU1IDc3LTE1NmM2NiAxOTkuMzMzIDEzOSA0MTkuNjY3XFxuMjE5IDY2MSBsMjE4IDY2MXpNNzAyIFwiICsgaExpbmVQYWQgKyBcIkg0MDAwMDB2XCIgKyAoNDAgKyBleHRyYVZpbmN1bHVtKSArIFwiSDc0MnpcIjtcbn07XG5cbnZhciBzcXJ0UGF0aCA9IGZ1bmN0aW9uIHNxcnRQYXRoKHNpemUsIGV4dHJhVmluY3VsdW0sIHZpZXdCb3hIZWlnaHQpIHtcbiAgZXh0cmFWaW5jdWx1bSA9IDEwMDAgKiBleHRyYVZpbmN1bHVtOyAvLyBDb252ZXJ0IGZyb20gZG9jdW1lbnQgZW1zIHRvIHZpZXdCb3guXG5cbiAgdmFyIHBhdGggPSBcIlwiO1xuXG4gIHN3aXRjaCAoc2l6ZSkge1xuICAgIGNhc2UgXCJzcXJ0TWFpblwiOlxuICAgICAgcGF0aCA9IHNxcnRNYWluKGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInNxcnRTaXplMVwiOlxuICAgICAgcGF0aCA9IHNxcnRTaXplMShleHRyYVZpbmN1bHVtLCBoTGluZVBhZCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJzcXJ0U2l6ZTJcIjpcbiAgICAgIHBhdGggPSBzcXJ0U2l6ZTIoZXh0cmFWaW5jdWx1bSwgaExpbmVQYWQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwic3FydFNpemUzXCI6XG4gICAgICBwYXRoID0gc3FydFNpemUzKGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInNxcnRTaXplNFwiOlxuICAgICAgcGF0aCA9IHNxcnRTaXplNChleHRyYVZpbmN1bHVtLCBoTGluZVBhZCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJzcXJ0VGFsbFwiOlxuICAgICAgcGF0aCA9IHNxcnRUYWxsKGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkLCB2aWV3Qm94SGVpZ2h0KTtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufTtcbnZhciBpbm5lclBhdGggPSBmdW5jdGlvbiBpbm5lclBhdGgobmFtZSwgaGVpZ2h0KSB7XG4gIC8vIFRoZSBpbm5lciBwYXJ0IG9mIHN0cmV0Y2h5IHRhbGwgZGVsaW1pdGVyc1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlIFwiXFx1MjM5Y1wiOlxuICAgICAgcmV0dXJuIFwiTTI5MSAwIEg0MTcgVlwiICsgaGVpZ2h0ICsgXCIgSDI5MXogTTI5MSAwIEg0MTcgVlwiICsgaGVpZ2h0ICsgXCIgSDI5MXpcIjtcblxuICAgIGNhc2UgXCJcXHUyMjIzXCI6XG4gICAgICByZXR1cm4gXCJNMTQ1IDAgSDE4OCBWXCIgKyBoZWlnaHQgKyBcIiBIMTQ1eiBNMTQ1IDAgSDE4OCBWXCIgKyBoZWlnaHQgKyBcIiBIMTQ1elwiO1xuXG4gICAgY2FzZSBcIlxcdTIyMjVcIjpcbiAgICAgIHJldHVybiBcIk0xNDUgMCBIMTg4IFZcIiArIGhlaWdodCArIFwiIEgxNDV6IE0xNDUgMCBIMTg4IFZcIiArIGhlaWdodCArIFwiIEgxNDV6XCIgKyAoXCJNMzY3IDAgSDQxMCBWXCIgKyBoZWlnaHQgKyBcIiBIMzY3eiBNMzY3IDAgSDQxMCBWXCIgKyBoZWlnaHQgKyBcIiBIMzY3elwiKTtcblxuICAgIGNhc2UgXCJcXHUyMzlmXCI6XG4gICAgICByZXR1cm4gXCJNNDU3IDAgSDU4MyBWXCIgKyBoZWlnaHQgKyBcIiBINDU3eiBNNDU3IDAgSDU4MyBWXCIgKyBoZWlnaHQgKyBcIiBINDU3elwiO1xuXG4gICAgY2FzZSBcIlxcdTIzYTJcIjpcbiAgICAgIHJldHVybiBcIk0zMTkgMCBINDAzIFZcIiArIGhlaWdodCArIFwiIEgzMTl6IE0zMTkgMCBINDAzIFZcIiArIGhlaWdodCArIFwiIEgzMTl6XCI7XG5cbiAgICBjYXNlIFwiXFx1MjNhNVwiOlxuICAgICAgcmV0dXJuIFwiTTI2MyAwIEgzNDcgVlwiICsgaGVpZ2h0ICsgXCIgSDI2M3ogTTI2MyAwIEgzNDcgVlwiICsgaGVpZ2h0ICsgXCIgSDI2M3pcIjtcblxuICAgIGNhc2UgXCJcXHUyM2FhXCI6XG4gICAgICByZXR1cm4gXCJNMzg0IDAgSDUwNCBWXCIgKyBoZWlnaHQgKyBcIiBIMzg0eiBNMzg0IDAgSDUwNCBWXCIgKyBoZWlnaHQgKyBcIiBIMzg0elwiO1xuXG4gICAgY2FzZSBcIlxcdTIzZDBcIjpcbiAgICAgIHJldHVybiBcIk0zMTIgMCBIMzU1IFZcIiArIGhlaWdodCArIFwiIEgzMTJ6IE0zMTIgMCBIMzU1IFZcIiArIGhlaWdodCArIFwiIEgzMTJ6XCI7XG5cbiAgICBjYXNlIFwiXFx1MjAxNlwiOlxuICAgICAgcmV0dXJuIFwiTTI1NyAwIEgzMDAgVlwiICsgaGVpZ2h0ICsgXCIgSDI1N3ogTTI1NyAwIEgzMDAgVlwiICsgaGVpZ2h0ICsgXCIgSDI1N3pcIiArIChcIk00NzggMCBINTIxIFZcIiArIGhlaWdodCArIFwiIEg0Nzh6IE00NzggMCBINTIxIFZcIiArIGhlaWdodCArIFwiIEg0Nzh6XCIpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlwiO1xuICB9XG59O1xudmFyIHBhdGggPSB7XG4gIC8vIFRoZSBkb3VibGVsZWZ0YXJyb3cgZ2VvbWV0cnkgaXMgZnJvbSBnbHlwaCBVKzIxRDAgaW4gdGhlIGZvbnQgS2FUZVggTWFpblxuICBkb3VibGVsZWZ0YXJyb3c6IFwiTTI2MiAxNTdcXG5sMTAtMTBjMzQtMzYgNjIuNy03NyA4Ni0xMjMgMy4zLTggNS0xMy4zIDUtMTYgMC01LjMtNi43LTgtMjAtOC03LjNcXG4gMC0xMi4yLjUtMTQuNSAxLjUtMi4zIDEtNC44IDQuNS03LjUgMTAuNS00OS4zIDk3LjMtMTIxLjcgMTY5LjMtMjE3IDIxNi0yOFxcbiAxNC01Ny4zIDI1LTg4IDMzLTYuNyAyLTExIDMuOC0xMyA1LjUtMiAxLjctMyA0LjItMyA3LjVzMSA1LjggMyA3LjVcXG5jMiAxLjcgNi4zIDMuNSAxMyA1LjUgNjggMTcuMyAxMjguMiA0Ny44IDE4MC41IDkxLjUgNTIuMyA0My43IDkzLjggOTYuMiAxMjQuNVxcbiAxNTcuNSA5LjMgOCAxNS4zIDEyLjMgMTggMTNoNmMxMi0uNyAxOC00IDE4LTEwIDAtMi0xLjctNy01LTE1LTIzLjMtNDYtNTItODdcXG4tODYtMTIzbC0xMC0xMGgzOTk3Mzh2LTQwSDIxOGMzMjggMCAwIDAgMCAwbC0xMC04Yy0yNi43LTIwLTY1LjctNDMtMTE3LTY5IDIuN1xcbi0yIDYtMy43IDEwLTUgMzYuNy0xNiA3Mi4zLTM3LjMgMTA3LTY0bDEwLThoMzk5Nzgydi00MHpcXG5tOCAwdjQwaDM5OTczMHYtNDB6bTAgMTk0djQwaDM5OTczMHYtNDB6XCIsXG4gIC8vIGRvdWJsZXJpZ2h0YXJyb3cgaXMgZnJvbSBnbHlwaCBVKzIxRDIgaW4gZm9udCBLYVRlWCBNYWluXG4gIGRvdWJsZXJpZ2h0YXJyb3c6IFwiTTM5OTczOCAzOTJsXFxuLTEwIDEwYy0zNCAzNi02Mi43IDc3LTg2IDEyMy0zLjMgOC01IDEzLjMtNSAxNiAwIDUuMyA2LjcgOCAyMCA4IDcuMyAwIDEyLjItLjVcXG4gMTQuNS0xLjUgMi4zLTEgNC44LTQuNSA3LjUtMTAuNSA0OS4zLTk3LjMgMTIxLjctMTY5LjMgMjE3LTIxNiAyOC0xNCA1Ny4zLTI1IDg4XFxuLTMzIDYuNy0yIDExLTMuOCAxMy01LjUgMi0xLjcgMy00LjIgMy03LjVzLTEtNS44LTMtNy41Yy0yLTEuNy02LjMtMy41LTEzLTUuNS02OFxcbi0xNy4zLTEyOC4yLTQ3LjgtMTgwLjUtOTEuNS01Mi4zLTQzLjctOTMuOC05Ni4yLTEyNC41LTE1Ny41LTkuMy04LTE1LjMtMTIuMy0xOFxcbi0xM2gtNmMtMTIgLjctMTggNC0xOCAxMCAwIDIgMS43IDcgNSAxNSAyMy4zIDQ2IDUyIDg3IDg2IDEyM2wxMCAxMEgwdjQwaDM5OTc4MlxcbmMtMzI4IDAgMCAwIDAgMGwxMCA4YzI2LjcgMjAgNjUuNyA0MyAxMTcgNjktMi43IDItNiAzLjctMTAgNS0zNi43IDE2LTcyLjMgMzcuM1xcbi0xMDcgNjRsLTEwIDhIMHY0MHpNMCAxNTd2NDBoMzk5NzMwdi00MHptMCAxOTR2NDBoMzk5NzMwdi00MHpcIixcbiAgLy8gbGVmdGFycm93IGlzIGZyb20gZ2x5cGggVSsyMTkwIGluIGZvbnQgS2FUZVggTWFpblxuICBsZWZ0YXJyb3c6IFwiTTQwMDAwMCAyNDFIMTEwbDMtM2M2OC43LTUyLjcgMTEzLjctMTIwXFxuIDEzNS0yMDIgNC0xNC43IDYtMjMgNi0yNSAwLTcuMy03LTExLTIxLTExLTggMC0xMy4yLjgtMTUuNSAyLjUtMi4zIDEuNy00LjIgNS44XFxuLTUuNSAxMi41LTEuMyA0LjctMi43IDEwLjMtNCAxNy0xMiA0OC43LTM0LjggOTItNjguNSAxMzBTNjUuMyAyMjguMyAxOCAyNDdcXG5jLTEwIDQtMTYgNy43LTE4IDExIDAgOC43IDYgMTQuMyAxOCAxNyA0Ny4zIDE4LjcgODcuOCA0NyAxMjEuNSA4NVMxOTYgNDQxLjMgMjA4XFxuIDQ5MGMuNyAyIDEuMyA1IDIgOXMxLjIgNi43IDEuNSA4Yy4zIDEuMyAxIDMuMyAyIDZzMi4yIDQuNSAzLjUgNS41YzEuMyAxIDMuM1xcbiAxLjggNiAyLjVzNiAxIDEwIDFjMTQgMCAyMS0zLjcgMjEtMTEgMC0yLTItMTAuMy02LTI1LTIwLTc5LjMtNjUtMTQ2LjctMTM1LTIwMlxcbiBsLTMtM2gzOTk4OTB6TTEwMCAyNDF2NDBoMzk5OTAwdi00MHpcIixcbiAgLy8gb3ZlcmJyYWNlIGlzIGZyb20gZ2x5cGhzIFUrMjNBOS8yM0E4LzIzQTcgaW4gZm9udCBLYVRlWF9TaXplNC1SZWd1bGFyXG4gIGxlZnRicmFjZTogXCJNNiA1NDhsLTYtNnYtMzVsNi0xMWM1Ni0xMDQgMTM1LjMtMTgxLjMgMjM4LTIzMiA1Ny4zLTI4LjcgMTE3XFxuLTQ1IDE3OS01MGgzOTk1Nzd2MTIwSDQwM2MtNDMuMyA3LTgxIDE1LTExMyAyNi0xMDAuNyAzMy0xNzkuNyA5MS0yMzcgMTc0LTIuN1xcbiA1LTYgOS0xMCAxMy0uNyAxLTcuMyAxLTIwIDFINnpcIixcbiAgbGVmdGJyYWNldW5kZXI6IFwiTTAgNmw2LTZoMTdjMTIuNjg4IDAgMTkuMzEzLjMgMjAgMSA0IDQgNy4zMTMgOC4zIDEwIDEzXFxuIDM1LjMxMyA1MS4zIDgwLjgxMyA5My44IDEzNi41IDEyNy41IDU1LjY4OCAzMy43IDExNy4xODggNTUuOCAxODQuNSA2Ni41LjY4OFxcbiAwIDIgLjMgNCAxIDE4LjY4OCAyLjcgNzYgNC4zIDE3MiA1aDM5OTQ1MHYxMjBINDI5bC02LTFjLTEyNC42ODgtOC0yMzUtNjEuN1xcbi0zMzEtMTYxQzYwLjY4NyAxMzguNyAzMi4zMTIgOTkuMyA3IDU0TDAgNDFWNnpcIixcbiAgLy8gb3Zlcmdyb3VwIGlzIGZyb20gdGhlIE1uU3ltYm9sIHBhY2thZ2UgKHB1YmxpYyBkb21haW4pXG4gIGxlZnRncm91cDogXCJNNDAwMDAwIDgwXFxuSDQzNUM2NCA4MCAxNjguMyAyMjkuNCAyMSAyNjBjLTUuOSAxLjItMTggMC0xOCAwLTIgMC0zLTEtMy0zdi0zOEM3NiA2MSAyNTcgMFxcbiA0MzUgMGgzOTk1NjV6XCIsXG4gIGxlZnRncm91cHVuZGVyOiBcIk00MDAwMDAgMjYyXFxuSDQzNUM2NCAyNjIgMTY4LjMgMTEyLjYgMjEgODJjLTUuOS0xLjItMTggMC0xOCAwLTIgMC0zIDEtMyAzdjM4Yzc2IDE1OCAyNTcgMjE5XFxuIDQzNSAyMTloMzk5NTY1elwiLFxuICAvLyBIYXJwb29ucyBhcmUgZnJvbSBnbHlwaCBVKzIxQkQgaW4gZm9udCBLYVRlWCBNYWluXG4gIGxlZnRoYXJwb29uOiBcIk0wIDI2N2MuNyA1LjMgMyAxMCA3IDE0aDM5OTk5M3YtNDBIOTNjMy4zXFxuLTMuMyAxMC4yLTkuNSAyMC41LTE4LjVzMTcuOC0xNS44IDIyLjUtMjAuNWM1MC43LTUyIDg4LTExMC4zIDExMi0xNzUgNC0xMS4zIDVcXG4tMTguMyAzLTIxLTEuMy00LTcuMy02LTE4LTYtOCAwLTEzIC43LTE1IDJzLTQuNyA2LjctOCAxNmMtNDIgOTguNy0xMDcuMyAxNzQuN1xcbi0xOTYgMjI4LTYuNyA0LjctMTAuNyA4LTEyIDEwLTEuMyAyLTIgNS43LTIgMTF6bTEwMC0yNnY0MGgzOTk5MDB2LTQwelwiLFxuICBsZWZ0aGFycG9vbnBsdXM6IFwiTTAgMjY3Yy43IDUuMyAzIDEwIDcgMTRoMzk5OTkzdi00MEg5M2MzLjMtMy4zIDEwLjItOS41XFxuIDIwLjUtMTguNXMxNy44LTE1LjggMjIuNS0yMC41YzUwLjctNTIgODgtMTEwLjMgMTEyLTE3NSA0LTExLjMgNS0xOC4zIDMtMjEtMS4zXFxuLTQtNy4zLTYtMTgtNi04IDAtMTMgLjctMTUgMnMtNC43IDYuNy04IDE2Yy00MiA5OC43LTEwNy4zIDE3NC43LTE5NiAyMjgtNi43IDQuN1xcbi0xMC43IDgtMTIgMTAtMS4zIDItMiA1LjctMiAxMXptMTAwLTI2djQwaDM5OTkwMHYtNDB6TTAgNDM1djQwaDQwMDAwMHYtNDB6XFxubTAgMHY0MGg0MDAwMDB2LTQwelwiLFxuICBsZWZ0aGFycG9vbmRvd246IFwiTTcgMjQxYy00IDQtNi4zMzMgOC42NjctNyAxNCAwIDUuMzMzLjY2NyA5IDIgMTFzNS4zMzNcXG4gNS4zMzMgMTIgMTBjOTAuNjY3IDU0IDE1NiAxMzAgMTk2IDIyOCAzLjMzMyAxMC42NjcgNi4zMzMgMTYuMzMzIDkgMTcgMiAuNjY3IDVcXG4gMSA5IDFoNWMxMC42NjcgMCAxNi42NjctMiAxOC02IDItMi42NjcgMS05LjY2Ny0zLTIxLTMyLTg3LjMzMy04Mi42NjctMTU3LjY2N1xcbi0xNTItMjExbC0zLTNoMzk5OTA3di00MHpNOTMgMjgxIEg0MDAwMDAgdi00MEw3IDI0MXpcIixcbiAgbGVmdGhhcnBvb25kb3ducGx1czogXCJNNyA0MzVjLTQgNC02LjMgOC43LTcgMTQgMCA1LjMuNyA5IDIgMTFzNS4zIDUuMyAxMlxcbiAxMGM5MC43IDU0IDE1NiAxMzAgMTk2IDIyOCAzLjMgMTAuNyA2LjMgMTYuMyA5IDE3IDIgLjcgNSAxIDkgMWg1YzEwLjcgMCAxNi43XFxuLTIgMTgtNiAyLTIuNyAxLTkuNy0zLTIxLTMyLTg3LjMtODIuNy0xNTcuNy0xNTItMjExbC0zLTNoMzk5OTA3di00MEg3em05MyAwXFxudjQwaDM5OTkwMHYtNDB6TTAgMjQxdjQwaDM5OTkwMHYtNDB6bTAgMHY0MGgzOTk5MDB2LTQwelwiLFxuICAvLyBob29rIGlzIGZyb20gZ2x5cGggVSsyMUE5IGluIGZvbnQgS2FUZVggTWFpblxuICBsZWZ0aG9vazogXCJNNDAwMDAwIDI4MSBIMTAzcy0zMy0xMS4yLTYxLTMzLjVTMCAxOTcuMyAwIDE2NHMxNC4yLTYxLjIgNDIuNVxcbi04My41QzcwLjggNTguMiAxMDQgNDcgMTQyIDQ3IGMxNi43IDAgMjUgNi43IDI1IDIwIDAgMTItOC43IDE4LjctMjYgMjAtNDAgMy4zXFxuLTY4LjcgMTUuNy04NiAzNy0xMCAxMi0xNSAyNS4zLTE1IDQwIDAgMjIuNyA5LjggNDAuNyAyOS41IDU0IDE5LjcgMTMuMyA0My41IDIxXFxuIDcxLjUgMjNoMzk5ODU5ek0xMDMgMjgxdi00MGgzOTk4OTd2NDB6XCIsXG4gIGxlZnRsaW5lc2VnbWVudDogXCJNNDAgMjgxIFY0MjggSDAgVjk0IEg0MCBWMjQxIEg0MDAwMDAgdjQwelxcbk00MCAyODEgVjQyOCBIMCBWOTQgSDQwIFYyNDEgSDQwMDAwMCB2NDB6XCIsXG4gIGxlZnRtYXBzdG86IFwiTTQwIDI4MSBWNDQ4SDBWNzRINDBWMjQxSDQwMDAwMHY0MHpcXG5NNDAgMjgxIFY0NDhIMFY3NEg0MFYyNDFINDAwMDAwdjQwelwiLFxuICAvLyB0b2Zyb20gaXMgZnJvbSBnbHlwaCBVKzIxQzQgaW4gZm9udCBLYVRlWCBBTVMgUmVndWxhclxuICBsZWZ0VG9Gcm9tOiBcIk0wIDE0N2g0MDAwMDB2NDBIMHptMCAyMTRjNjggNDAgMTE1LjcgOTUuNyAxNDMgMTY3aDIyYzE1LjMgMCAyM1xcbi0uMyAyMy0xIDAtMS4zLTUuMy0xMy43LTE2LTM3LTE4LTM1LjMtNDEuMy02OS03MC0xMDFsLTctOGgzOTk5MDV2LTQwSDk1bDctOFxcbmMyOC43LTMyIDUyLTY1LjcgNzAtMTAxIDEwLjctMjMuMyAxNi0zNS43IDE2LTM3IDAtLjctNy43LTEtMjMtMWgtMjJDMTE1LjcgMjY1LjNcXG4gNjggMzIxIDAgMzYxem0wLTE3NHYtNDBoMzk5OTAwdjQwem0xMDAgMTU0djQwaDM5OTkwMHYtNDB6XCIsXG4gIGxvbmdlcXVhbDogXCJNMCA1MCBoNDAwMDAwIHY0MEgweiBtMCAxOTRoNDAwMDB2NDBIMHpcXG5NMCA1MCBoNDAwMDAwIHY0MEgweiBtMCAxOTRoNDAwMDB2NDBIMHpcIixcbiAgbWlkYnJhY2U6IFwiTTIwMDQyOCAzMzRcXG5jLTEwMC43LTguMy0xOTUuMy00NC0yODAtMTA4LTU1LjMtNDItMTAxLjctOTMtMTM5LTE1M2wtOS0xNGMtMi43IDQtNS43IDguNy05IDE0XFxuLTUzLjMgODYuNy0xMjMuNyAxNTMtMjExIDE5OS02Ni43IDM2LTEzNy4zIDU2LjMtMjEyIDYySDBWMjE0aDE5OTU2OGMxNzguMy0xMS43XFxuIDMxMS43LTc4LjMgNDAzLTIwMSA2LTggOS43LTEyIDExLTEyIC43LS43IDYuNy0xIDE4LTFzMTcuMy4zIDE4IDFjMS4zIDAgNSA0IDExXFxuIDEyIDQ0LjcgNTkuMyAxMDEuMyAxMDYuMyAxNzAgMTQxczE0NS4zIDU0LjMgMjI5IDYwaDE5OTU3MnYxMjB6XCIsXG4gIG1pZGJyYWNldW5kZXI6IFwiTTE5OTU3MiAyMTRcXG5jMTAwLjcgOC4zIDE5NS4zIDQ0IDI4MCAxMDggNTUuMyA0MiAxMDEuNyA5MyAxMzkgMTUzbDkgMTRjMi43LTQgNS43LTguNyA5LTE0XFxuIDUzLjMtODYuNyAxMjMuNy0xNTMgMjExLTE5OSA2Ni43LTM2IDEzNy4zLTU2LjMgMjEyLTYyaDE5OTU2OHYxMjBIMjAwNDMyYy0xNzguM1xcbiAxMS43LTMxMS43IDc4LjMtNDAzIDIwMS02IDgtOS43IDEyLTExIDEyLS43LjctNi43IDEtMTggMXMtMTcuMy0uMy0xOC0xYy0xLjMgMFxcbi01LTQtMTEtMTItNDQuNy01OS4zLTEwMS4zLTEwNi4zLTE3MC0xNDFzLTE0NS4zLTU0LjMtMjI5LTYwSDBWMjE0elwiLFxuICBvaWludFNpemUxOiBcIk01MTIuNiA3MS42YzI3Mi42IDAgMzIwLjMgMTA2LjggMzIwLjMgMTc4LjIgMCA3MC44LTQ3LjcgMTc3LjZcXG4tMzIwLjMgMTc3LjZTMTkzLjEgMzIwLjYgMTkzLjEgMjQ5LjhjMC03MS40IDQ2LjktMTc4LjIgMzE5LjUtMTc4LjJ6XFxubTM2OC4xIDE3OC4yYzAtODYuNC02MC45LTIxNS40LTM2OC4xLTIxNS40LTMwNi40IDAtMzY3LjMgMTI5LTM2Ny4zIDIxNS40IDAgODUuOFxcbjYwLjkgMjE0LjggMzY3LjMgMjE0LjggMzA3LjIgMCAzNjguMS0xMjkgMzY4LjEtMjE0Ljh6XCIsXG4gIG9paW50U2l6ZTI6IFwiTTc1Ny44IDEwMC4xYzM4NC43IDAgNDUxLjEgMTM3LjYgNDUxLjEgMjMwIDAgOTEuMy02Ni40IDIyOC44XFxuLTQ1MS4xIDIyOC44LTM4Ni4zIDAtNDUyLjctMTM3LjUtNDUyLjctMjI4LjggMC05Mi40IDY2LjQtMjMwIDQ1Mi43LTIzMHpcXG5tNTAyLjQgMjMwYzAtMTExLjItODIuNC0yNzcuMi01MDIuNC0yNzcuMnMtNTA0IDE2Ni01MDQgMjc3LjJcXG5jMCAxMTAgODQgMjc2IDUwNCAyNzZzNTAyLjQtMTY2IDUwMi40LTI3NnpcIixcbiAgb2lpaW50U2l6ZTE6IFwiTTY4MS40IDcxLjZjNDA4LjkgMCA0ODAuNSAxMDYuOCA0ODAuNSAxNzguMiAwIDcwLjgtNzEuNiAxNzcuNlxcbi00ODAuNSAxNzcuNlMyMDIuMSAzMjAuNiAyMDIuMSAyNDkuOGMwLTcxLjQgNzAuNS0xNzguMiA0NzkuMy0xNzguMnpcXG5tNTI1LjggMTc4LjJjMC04Ni40LTg2LjgtMjE1LjQtNTI1LjctMjE1LjQtNDM3LjkgMC01MjQuNyAxMjktNTI0LjcgMjE1LjQgMFxcbjg1LjggODYuOCAyMTQuOCA1MjQuNyAyMTQuOCA0MzguOSAwIDUyNS43LTEyOSA1MjUuNy0yMTQuOHpcIixcbiAgb2lpaW50U2l6ZTI6IFwiTTEwMjEuMiA1M2M2MDMuNiAwIDcwNy44IDE2NS44IDcwNy44IDI3Ny4yIDAgMTEwLTEwNC4yIDI3NS44XFxuLTcwNy44IDI3NS44LTYwNiAwLTcxMC4yLTE2NS44LTcxMC4yLTI3NS44QzMxMSAyMTguOCA0MTUuMiA1MyAxMDIxLjIgNTN6XFxubTc3MC40IDI3Ny4xYzAtMTMxLjItMTI2LjQtMzI3LjYtNzcwLjUtMzI3LjZTMjQ4LjQgMTk4LjkgMjQ4LjQgMzMwLjFcXG5jMCAxMzAgMTI4LjggMzI2LjQgNzcyLjcgMzI2LjRzNzcwLjUtMTk2LjQgNzcwLjUtMzI2LjR6XCIsXG4gIHJpZ2h0YXJyb3c6IFwiTTAgMjQxdjQwaDM5OTg5MWMtNDcuMyAzNS4zLTg0IDc4LTExMCAxMjhcXG4tMTYuNyAzMi0yNy43IDYzLjctMzMgOTUgMCAxLjMtLjIgMi43LS41IDQtLjMgMS4zLS41IDIuMy0uNSAzIDAgNy4zIDYuNyAxMSAyMFxcbiAxMSA4IDAgMTMuMi0uOCAxNS41LTIuNSAyLjMtMS43IDQuMi01LjUgNS41LTExLjUgMi0xMy4zIDUuNy0yNyAxMS00MSAxNC43LTQ0LjdcXG4gMzktODQuNSA3My0xMTkuNXM3My43LTYwLjIgMTE5LTc1LjVjNi0yIDktNS43IDktMTFzLTMtOS05LTExYy00NS4zLTE1LjMtODVcXG4tNDAuNS0xMTktNzUuNXMtNTguMy03NC44LTczLTExOS41Yy00LjctMTQtOC4zLTI3LjMtMTEtNDAtMS4zLTYuNy0zLjItMTAuOC01LjVcXG4tMTIuNS0yLjMtMS43LTcuNS0yLjUtMTUuNS0yLjUtMTQgMC0yMSAzLjctMjEgMTEgMCAyIDIgMTAuMyA2IDI1IDIwLjcgODMuMyA2N1xcbiAxNTEuNyAxMzkgMjA1em0wIDB2NDBoMzk5OTAwdi00MHpcIixcbiAgcmlnaHRicmFjZTogXCJNNDAwMDAwIDU0MmxcXG4tNiA2aC0xN2MtMTIuNyAwLTE5LjMtLjMtMjAtMS00LTQtNy4zLTguMy0xMC0xMy0zNS4zLTUxLjMtODAuOC05My44LTEzNi41LTEyNy41XFxucy0xMTcuMi01NS44LTE4NC41LTY2LjVjLS43IDAtMi0uMy00LTEtMTguNy0yLjctNzYtNC4zLTE3Mi01SDBWMjE0aDM5OTU3MWw2IDFcXG5jMTI0LjcgOCAyMzUgNjEuNyAzMzEgMTYxIDMxLjMgMzMuMyA1OS43IDcyLjcgODUgMTE4bDcgMTN2MzV6XCIsXG4gIHJpZ2h0YnJhY2V1bmRlcjogXCJNMzk5OTk0IDBsNiA2djM1bC02IDExYy01NiAxMDQtMTM1LjMgMTgxLjMtMjM4IDIzMi01Ny4zXFxuIDI4LjctMTE3IDQ1LTE3OSA1MEgtMzAwVjIxNGgzOTk4OTdjNDMuMy03IDgxLTE1IDExMy0yNiAxMDAuNy0zMyAxNzkuNy05MSAyMzdcXG4tMTc0IDIuNy01IDYtOSAxMC0xMyAuNy0xIDcuMy0xIDIwLTFoMTd6XCIsXG4gIHJpZ2h0Z3JvdXA6IFwiTTAgODBoMzk5NTY1YzM3MSAwIDI2Ni43IDE0OS40IDQxNCAxODAgNS45IDEuMiAxOCAwIDE4IDAgMiAwXFxuIDMtMSAzLTN2LTM4Yy03Ni0xNTgtMjU3LTIxOS00MzUtMjE5SDB6XCIsXG4gIHJpZ2h0Z3JvdXB1bmRlcjogXCJNMCAyNjJoMzk5NTY1YzM3MSAwIDI2Ni43LTE0OS40IDQxNC0xODAgNS45LTEuMiAxOCAwIDE4XFxuIDAgMiAwIDMgMSAzIDN2MzhjLTc2IDE1OC0yNTcgMjE5LTQzNSAyMTlIMHpcIixcbiAgcmlnaHRoYXJwb29uOiBcIk0wIDI0MXY0MGgzOTk5OTNjNC43LTQuNyA3LTkuMyA3LTE0IDAtOS4zXFxuLTMuNy0xNS4zLTExLTE4LTkyLjctNTYuNy0xNTktMTMzLjctMTk5LTIzMS0zLjMtOS4zLTYtMTQuNy04LTE2LTItMS4zLTctMi0xNS0yXFxuLTEwLjcgMC0xNi43IDItMTggNi0yIDIuNy0xIDkuNyAzIDIxIDE1LjMgNDIgMzYuNyA4MS44IDY0IDExOS41IDI3LjMgMzcuNyA1OFxcbiA2OS4yIDkyIDk0LjV6bTAgMHY0MGgzOTk5MDB2LTQwelwiLFxuICByaWdodGhhcnBvb25wbHVzOiBcIk0wIDI0MXY0MGgzOTk5OTNjNC43LTQuNyA3LTkuMyA3LTE0IDAtOS4zLTMuNy0xNS4zLTExXFxuLTE4LTkyLjctNTYuNy0xNTktMTMzLjctMTk5LTIzMS0zLjMtOS4zLTYtMTQuNy04LTE2LTItMS4zLTctMi0xNS0yLTEwLjcgMC0xNi43XFxuIDItMTggNi0yIDIuNy0xIDkuNyAzIDIxIDE1LjMgNDIgMzYuNyA4MS44IDY0IDExOS41IDI3LjMgMzcuNyA1OCA2OS4yIDkyIDk0LjV6XFxubTAgMHY0MGgzOTk5MDB2LTQweiBtMTAwIDE5NHY0MGgzOTk5MDB2LTQwem0wIDB2NDBoMzk5OTAwdi00MHpcIixcbiAgcmlnaHRoYXJwb29uZG93bjogXCJNMzk5NzQ3IDUxMWMwIDcuMyA2LjcgMTEgMjAgMTEgOCAwIDEzLS44IDE1LTIuNXM0LjctNi44XFxuIDgtMTUuNWM0MC05NCA5OS4zLTE2Ni4zIDE3OC0yMTcgMTMuMy04IDIwLjMtMTIuMyAyMS0xMyA1LjMtMy4zIDguNS01LjggOS41XFxuLTcuNSAxLTEuNyAxLjUtNS4yIDEuNS0xMC41cy0yLjMtMTAuMy03LTE1SDB2NDBoMzk5OTA4Yy0zNCAyNS4zLTY0LjcgNTctOTIgOTVcXG4tMjcuMyAzOC00OC43IDc3LjctNjQgMTE5LTMuMyA4LjctNSAxNC01IDE2ek0wIDI0MXY0MGgzOTk5MDB2LTQwelwiLFxuICByaWdodGhhcnBvb25kb3ducGx1czogXCJNMzk5NzQ3IDcwNWMwIDcuMyA2LjcgMTEgMjAgMTEgOCAwIDEzLS44XFxuIDE1LTIuNXM0LjctNi44IDgtMTUuNWM0MC05NCA5OS4zLTE2Ni4zIDE3OC0yMTcgMTMuMy04IDIwLjMtMTIuMyAyMS0xMyA1LjMtMy4zXFxuIDguNS01LjggOS41LTcuNSAxLTEuNyAxLjUtNS4yIDEuNS0xMC41cy0yLjMtMTAuMy03LTE1SDB2NDBoMzk5OTA4Yy0zNCAyNS4zXFxuLTY0LjcgNTctOTIgOTUtMjcuMyAzOC00OC43IDc3LjctNjQgMTE5LTMuMyA4LjctNSAxNC01IDE2ek0wIDQzNXY0MGgzOTk5MDB2LTQwelxcbm0wLTE5NHY0MGg0MDAwMDB2LTQwem0wIDB2NDBoNDAwMDAwdi00MHpcIixcbiAgcmlnaHRob29rOiBcIk0zOTk4NTkgMjQxYy03NjQgMCAwIDAgMCAwIDQwLTMuMyA2OC43LTE1LjcgODYtMzcgMTAtMTIgMTUtMjUuM1xcbiAxNS00MCAwLTIyLjctOS44LTQwLjctMjkuNS01NC0xOS43LTEzLjMtNDMuNS0yMS03MS41LTIzLTE3LjMtMS4zLTI2LTgtMjYtMjAgMFxcbi0xMy4zIDguNy0yMCAyNi0yMCAzOCAwIDcxIDExLjIgOTkgMzMuNSAwIDAgNyA1LjYgMjEgMTYuNyAxNCAxMS4yIDIxIDMzLjUgMjFcXG4gNjYuOHMtMTQgNjEuMi00MiA4My41Yy0yOCAyMi4zLTYxIDMzLjUtOTkgMzMuNUwwIDI0MXogTTAgMjgxdi00MGgzOTk4NTl2NDB6XCIsXG4gIHJpZ2h0bGluZXNlZ21lbnQ6IFwiTTM5OTk2MCAyNDEgVjk0IGg0MCBWNDI4IGgtNDAgVjI4MSBIMCB2LTQwelxcbk0zOTk5NjAgMjQxIFY5NCBoNDAgVjQyOCBoLTQwIFYyODEgSDAgdi00MHpcIixcbiAgcmlnaHRUb0Zyb206IFwiTTQwMDAwMCAxNjdjLTcwLjctNDItMTE4LTk3LjctMTQyLTE2N2gtMjNjLTE1LjMgMC0yMyAuMy0yM1xcbiAxIDAgMS4zIDUuMyAxMy43IDE2IDM3IDE4IDM1LjMgNDEuMyA2OSA3MCAxMDFsNyA4SDB2NDBoMzk5OTA1bC03IDhjLTI4LjcgMzJcXG4tNTIgNjUuNy03MCAxMDEtMTAuNyAyMy4zLTE2IDM1LjctMTYgMzcgMCAuNyA3LjcgMSAyMyAxaDIzYzI0LTY5LjMgNzEuMy0xMjUgMTQyXFxuLTE2N3ogTTEwMCAxNDd2NDBoMzk5OTAwdi00MHpNMCAzNDF2NDBoMzk5OTAwdi00MHpcIixcbiAgLy8gdHdvaGVhZGxlZnRhcnJvdyBpcyBmcm9tIGdseXBoIFUrMjE5RSBpbiBmb250IEthVGVYIEFNUyBSZWd1bGFyXG4gIHR3b2hlYWRsZWZ0YXJyb3c6IFwiTTAgMTY3YzY4IDQwXFxuIDExNS43IDk1LjcgMTQzIDE2N2gyMmMxNS4zIDAgMjMtLjMgMjMtMSAwLTEuMy01LjMtMTMuNy0xNi0zNy0xOC0zNS4zLTQxLjMtNjlcXG4tNzAtMTAxbC03LThoMTI1bDkgN2M1MC43IDM5LjMgODUgODYgMTAzIDE0MGg0NmMwLTQuNy02LjMtMTguNy0xOS00Mi0xOC0zNS4zXFxuLTQwLTY3LjMtNjYtOTZsLTktOWgzOTk3MTZ2LTQwSDI4NGw5LTljMjYtMjguNyA0OC02MC43IDY2LTk2IDEyLjctMjMuMzMzIDE5XFxuLTM3LjMzMyAxOS00MmgtNDZjLTE4IDU0LTUyLjMgMTAwLjctMTAzIDE0MGwtOSA3SDk1bDctOGMyOC43LTMyIDUyLTY1LjcgNzAtMTAxXFxuIDEwLjctMjMuMzMzIDE2LTM1LjcgMTYtMzcgMC0uNy03LjctMS0yMy0xaC0yMkMxMTUuNyA3MS4zIDY4IDEyNyAwIDE2N3pcIixcbiAgdHdvaGVhZHJpZ2h0YXJyb3c6IFwiTTQwMDAwMCAxNjdcXG5jLTY4LTQwLTExNS43LTk1LjctMTQzLTE2N2gtMjJjLTE1LjMgMC0yMyAuMy0yMyAxIDAgMS4zIDUuMyAxMy43IDE2IDM3IDE4IDM1LjNcXG4gNDEuMyA2OSA3MCAxMDFsNyA4aC0xMjVsLTktN2MtNTAuNy0zOS4zLTg1LTg2LTEwMy0xNDBoLTQ2YzAgNC43IDYuMyAxOC43IDE5IDQyXFxuIDE4IDM1LjMgNDAgNjcuMyA2NiA5Nmw5IDlIMHY0MGgzOTk3MTZsLTkgOWMtMjYgMjguNy00OCA2MC43LTY2IDk2LTEyLjcgMjMuMzMzXFxuLTE5IDM3LjMzMy0xOSA0Mmg0NmMxOC01NCA1Mi4zLTEwMC43IDEwMy0xNDBsOS03aDEyNWwtNyA4Yy0yOC43IDMyLTUyIDY1LjctNzBcXG4gMTAxLTEwLjcgMjMuMzMzLTE2IDM1LjctMTYgMzcgMCAuNyA3LjcgMSAyMyAxaDIyYzI3LjMtNzEuMyA3NS0xMjcgMTQzLTE2N3pcIixcbiAgLy8gdGlsZGUxIGlzIGEgbW9kaWZpZWQgdmVyc2lvbiBvZiBhIGdseXBoIGZyb20gdGhlIE1uU3ltYm9sIHBhY2thZ2VcbiAgdGlsZGUxOiBcIk0yMDAgNTUuNTM4Yy03NyAwLTE2OCA3My45NTMtMTc3IDczLjk1My0zIDAtN1xcbi0yLjE3NS05LTUuNDM3TDIgOTdjLTEtMi0yLTQtMi02IDAtNCAyLTcgNS05bDIwLTEyQzExNiAxMiAxNzEgMCAyMDcgMGM4NiAwXFxuIDExNCA2OCAxOTEgNjggNzggMCAxNjgtNjggMTc3LTY4IDQgMCA3IDIgOSA1bDEyIDE5YzEgMi4xNzUgMiA0LjM1IDIgNi41MjUgMFxcbiA0LjM1LTIgNy42MTMtNSA5Ljc4OGwtMTkgMTMuMDVjLTkyIDYzLjA3Ny0xMTYuOTM3IDc1LjMwOC0xODMgNzYuMTI4XFxuLTY4LjI2Ny44NDctMTEzLTczLjk1Mi0xOTEtNzMuOTUyelwiLFxuICAvLyBkaXR0byB0aWxkZTIsIHRpbGRlMywgJiB0aWxkZTRcbiAgdGlsZGUyOiBcIk0zNDQgNTUuMjY2Yy0xNDIgMC0zMDAuNjM4IDgxLjMxNi0zMTEuNSA4Ni40MThcXG4tOC4wMSAzLjc2Mi0yMi41IDEwLjkxLTIzLjUgNS41NjJMMSAxMjBjLTEtMi0xLTMtMS00IDAtNSAzLTkgOC0xMGwxOC40LTlDMTYwLjlcXG4gMzEuOSAyODMgMCAzNTggMGMxNDggMCAxODggMTIyIDMzMSAxMjJzMzE0LTk3IDMyNi05N2M0IDAgOCAyIDEwIDdsNyAyMS4xMTRcXG5jMSAyLjE0IDEgMy4yMSAxIDQuMjggMCA1LjM0Ny0zIDkuNjI2LTcgMTAuNjk2bC0yMi4zIDEyLjYyMkM4NTIuNiAxNTguMzcyIDc1MVxcbiAxODEuNDc2IDY3NiAxODEuNDc2Yy0xNDkgMC0xODktMTI2LjIxLTMzMi0xMjYuMjF6XCIsXG4gIHRpbGRlMzogXCJNNzg2IDU5QzQ1NyA1OSAzMiAxNzUuMjQyIDEzIDE3NS4yNDJjLTYgMC0xMC0zLjQ1N1xcbi0xMS0xMC4zN0wuMTUgMTM4Yy0xLTcgMy0xMiAxMC0xM2wxOS4yLTYuNEMzNzguNCA0MC43IDYzNC4zIDAgODA0LjMgMGMzMzcgMFxcbiA0MTEuOCAxNTcgNzQ2LjggMTU3IDMyOCAwIDc1NC0xMTIgNzczLTExMiA1IDAgMTAgMyAxMSA5bDEgMTQuMDc1YzEgOC4wNjYtLjY5N1xcbiAxNi41OTUtNi42OTcgMTcuNDkybC0yMS4wNTIgNy4zMWMtMzY3LjkgOTguMTQ2LTYwOS4xNSAxMjIuNjk2LTc3OC4xNSAxMjIuNjk2XFxuIC0zMzggMC00MDktMTU2LjU3My03NDQtMTU2LjU3M3pcIixcbiAgdGlsZGU0OiBcIk03ODYgNThDNDU3IDU4IDMyIDE3Ny40ODcgMTMgMTc3LjQ4N2MtNiAwLTEwLTMuMzQ1XFxuLTExLTEwLjAzNUwuMTUgMTQzYy0xLTcgMy0xMiAxMC0xM2wyMi02LjdDMzgxLjIgMzUgNjM3LjE1IDAgODA3LjE1IDBjMzM3IDAgNDA5XFxuIDE3NyA3NDQgMTc3IDMyOCAwIDc1NC0xMjcgNzczLTEyNyA1IDAgMTAgMyAxMSA5bDEgMTQuNzk0YzEgNy44MDUtMyAxMy4zOC05XFxuIDE0LjQ5NWwtMjAuNyA1LjU3NGMtMzY2Ljg1IDk5Ljc5LTYwNy4zIDEzOS4zNzItNzc2LjMgMTM5LjM3Mi0zMzggMC00MDlcXG4gLTE3NS4yMzYtNzQ0LTE3NS4yMzZ6XCIsXG4gIC8vIHZlYyBpcyBmcm9tIGdseXBoIFUrMjBENyBpbiBmb250IEthVGVYIE1haW5cbiAgdmVjOiBcIk0zNzcgMjBjMC01LjMzMyAxLjgzMy0xMCA1LjUtMTRTMzkxIDAgMzk3IDBjNC42NjcgMCA4LjY2NyAxLjY2NyAxMiA1XFxuMy4zMzMgMi42NjcgNi42NjcgOSAxMCAxOSA2LjY2NyAyNC42NjcgMjAuMzMzIDQzLjY2NyA0MSA1NyA3LjMzMyA0LjY2NyAxMVxcbjEwLjY2NyAxMSAxOCAwIDYtMSAxMC0zIDEycy02LjY2NyA1LTE0IDljLTI4LjY2NyAxNC42NjctNTMuNjY3IDM1LjY2Ny03NSA2M1xcbi0xLjMzMyAxLjMzMy0zLjE2NyAzLjUtNS41IDYuNXMtNCA0LjgzMy01IDUuNWMtMSAuNjY3LTIuNSAxLjMzMy00LjUgMnMtNC4zMzMgMVxcbi03IDFjLTQuNjY3IDAtOS4xNjctMS44MzMtMTMuNS01LjVTMzM3IDE4NCAzMzcgMTc4YzAtMTIuNjY3IDE1LjY2Ny0zMi4zMzMgNDctNTlcXG5IMjEzbC0xNzEtMWMtOC42NjctNi0xMy0xMi4zMzMtMTMtMTkgMC00LjY2NyA0LjMzMy0xMS4zMzMgMTMtMjBoMzU5XFxuYy0xNi0yNS4zMzMtMjQtNDUtMjQtNTl6XCIsXG4gIC8vIHdpZGVoYXQxIGlzIGEgbW9kaWZpZWQgdmVyc2lvbiBvZiBhIGdseXBoIGZyb20gdGhlIE1uU3ltYm9sIHBhY2thZ2VcbiAgd2lkZWhhdDE6IFwiTTUyOSAwaDVsNTE5IDExNWM1IDEgOSA1IDkgMTAgMCAxLTEgMi0xIDNsLTQgMjJcXG5jLTEgNS01IDktMTEgOWgtMkw1MzIgNjcgMTkgMTU5aC0yYy01IDAtOS00LTExLTlsLTUtMjJjLTEtNiAyLTEyIDgtMTN6XCIsXG4gIC8vIGRpdHRvIHdpZGVoYXQyLCB3aWRlaGF0MywgJiB3aWRlaGF0NFxuICB3aWRlaGF0MjogXCJNMTE4MSAwaDJsMTE3MSAxNzZjNiAwIDEwIDUgMTAgMTFsLTIgMjNjLTEgNi01IDEwXFxuLTExIDEwaC0xTDExODIgNjcgMTUgMjIwaC0xYy02IDAtMTAtNC0xMS0xMGwtMi0yM2MtMS02IDQtMTEgMTAtMTF6XCIsXG4gIHdpZGVoYXQzOiBcIk0xMTgxIDBoMmwxMTcxIDIzNmM2IDAgMTAgNSAxMCAxMWwtMiAyM2MtMSA2LTUgMTBcXG4tMTEgMTBoLTFMMTE4MiA2NyAxNSAyODBoLTFjLTYgMC0xMC00LTExLTEwbC0yLTIzYy0xLTYgNC0xMSAxMC0xMXpcIixcbiAgd2lkZWhhdDQ6IFwiTTExODEgMGgybDExNzEgMjk2YzYgMCAxMCA1IDEwIDExbC0yIDIzYy0xIDYtNSAxMFxcbi0xMSAxMGgtMUwxMTgyIDY3IDE1IDM0MGgtMWMtNiAwLTEwLTQtMTEtMTBsLTItMjNjLTEtNiA0LTExIDEwLTExelwiLFxuICAvLyB3aWRlY2hlY2sgcGF0aHMgYXJlIGFsbCBpbnZlcnRlZCB2ZXJzaW9ucyBvZiB3aWRlaGF0XG4gIHdpZGVjaGVjazE6IFwiTTUyOSwxNTloNWw1MTksLTExNWM1LC0xLDksLTUsOSwtMTBjMCwtMSwtMSwtMiwtMSwtM2wtNCwtMjJjLTEsXFxuLTUsLTUsLTksLTExLC05aC0ybC01MTIsOTJsLTUxMywtOTJoLTJjLTUsMCwtOSw0LC0xMSw5bC01LDIyYy0xLDYsMiwxMiw4LDEzelwiLFxuICB3aWRlY2hlY2syOiBcIk0xMTgxLDIyMGgybDExNzEsLTE3NmM2LDAsMTAsLTUsMTAsLTExbC0yLC0yM2MtMSwtNiwtNSwtMTAsXFxuLTExLC0xMGgtMWwtMTE2OCwxNTNsLTExNjcsLTE1M2gtMWMtNiwwLC0xMCw0LC0xMSwxMGwtMiwyM2MtMSw2LDQsMTEsMTAsMTF6XCIsXG4gIHdpZGVjaGVjazM6IFwiTTExODEsMjgwaDJsMTE3MSwtMjM2YzYsMCwxMCwtNSwxMCwtMTFsLTIsLTIzYy0xLC02LC01LC0xMCxcXG4tMTEsLTEwaC0xbC0xMTY4LDIxM2wtMTE2NywtMjEzaC0xYy02LDAsLTEwLDQsLTExLDEwbC0yLDIzYy0xLDYsNCwxMSwxMCwxMXpcIixcbiAgd2lkZWNoZWNrNDogXCJNMTE4MSwzNDBoMmwxMTcxLC0yOTZjNiwwLDEwLC01LDEwLC0xMWwtMiwtMjNjLTEsLTYsLTUsLTEwLFxcbi0xMSwtMTBoLTFsLTExNjgsMjczbC0xMTY3LC0yNzNoLTFjLTYsMCwtMTAsNCwtMTEsMTBsLTIsMjNjLTEsNiw0LDExLDEwLDExelwiLFxuICAvLyBUaGUgbmV4dCB0ZW4gcGF0aHMgc3VwcG9ydCByZWFjdGlvbiBhcnJvd3MgZnJvbSB0aGUgbWhjaGVtIHBhY2thZ2UuXG4gIC8vIEFycm93cyBmb3IgXFxjZXs8LS0+fSBhcmUgb2Zmc2V0IGZyb20geEF4aXMgYnkgMC4yMmV4LCBwZXIgbWhjaGVtIGluIExhVGVYXG4gIC8vIGJhcmFib3ZlbGVmdGFycm93IGlzIG1vc3RseSBmcm9tIGdseXBoIFUrMjE5MCBpbiBmb250IEthVGVYIE1haW5cbiAgYmFyYWJvdmVsZWZ0YXJyb3c6IFwiTTQwMDAwMCA2MjBoLTM5OTg5MGwzIC0zYzY4LjcgLTUyLjcgMTEzLjcgLTEyMCAxMzUgLTIwMlxcbmM0IC0xNC43IDYgLTIzIDYgLTI1YzAgLTcuMyAtNyAtMTEgLTIxIC0xMWMtOCAwIC0xMy4yIDAuOCAtMTUuNSAyLjVcXG5jLTIuMyAxLjcgLTQuMiA1LjggLTUuNSAxMi41Yy0xLjMgNC43IC0yLjcgMTAuMyAtNCAxN2MtMTIgNDguNyAtMzQuOCA5MiAtNjguNSAxMzBcXG5zLTc0LjIgNjYuMyAtMTIxLjUgODVjLTEwIDQgLTE2IDcuNyAtMTggMTFjMCA4LjcgNiAxNC4zIDE4IDE3YzQ3LjMgMTguNyA4Ny44IDQ3XFxuMTIxLjUgODVzNTYuNSA4MS4zIDY4LjUgMTMwYzAuNyAyIDEuMyA1IDIgOXMxLjIgNi43IDEuNSA4YzAuMyAxLjMgMSAzLjMgMiA2XFxuczIuMiA0LjUgMy41IDUuNWMxLjMgMSAzLjMgMS44IDYgMi41czYgMSAxMCAxYzE0IDAgMjEgLTMuNyAyMSAtMTFcXG5jMCAtMiAtMiAtMTAuMyAtNiAtMjVjLTIwIC03OS4zIC02NSAtMTQ2LjcgLTEzNSAtMjAybC0zIC0zaDM5OTg5MHpcXG5NMTAwIDYyMHY0MGgzOTk5MDB2LTQweiBNMCAyNDF2NDBoMzk5OTAwdi00MHpNMCAyNDF2NDBoMzk5OTAwdi00MHpcIixcbiAgLy8gcmlnaHRhcnJvd2Fib3ZlYmFyIGlzIG1vc3RseSBmcm9tIGdseXBoIFUrMjE5MiwgS2FUZVggTWFpblxuICByaWdodGFycm93YWJvdmViYXI6IFwiTTAgMjQxdjQwaDM5OTg5MWMtNDcuMyAzNS4zLTg0IDc4LTExMCAxMjgtMTYuNyAzMlxcbi0yNy43IDYzLjctMzMgOTUgMCAxLjMtLjIgMi43LS41IDQtLjMgMS4zLS41IDIuMy0uNSAzIDAgNy4zIDYuNyAxMSAyMCAxMSA4IDBcXG4xMy4yLS44IDE1LjUtMi41IDIuMy0xLjcgNC4yLTUuNSA1LjUtMTEuNSAyLTEzLjMgNS43LTI3IDExLTQxIDE0LjctNDQuNyAzOVxcbi04NC41IDczLTExOS41czczLjctNjAuMiAxMTktNzUuNWM2LTIgOS01LjcgOS0xMXMtMy05LTktMTFjLTQ1LjMtMTUuMy04NS00MC41XFxuLTExOS03NS41cy01OC4zLTc0LjgtNzMtMTE5LjVjLTQuNy0xNC04LjMtMjcuMy0xMS00MC0xLjMtNi43LTMuMi0xMC44LTUuNVxcbi0xMi41LTIuMy0xLjctNy41LTIuNS0xNS41LTIuNS0xNCAwLTIxIDMuNy0yMSAxMSAwIDIgMiAxMC4zIDYgMjUgMjAuNyA4My4zIDY3XFxuMTUxLjcgMTM5IDIwNXptOTYgMzc5aDM5OTg5NHY0MEgwem0wIDBoMzk5OTA0djQwSDB6XCIsXG4gIC8vIFRoZSBzaG9ydCBsZWZ0IGhhcnBvb24gaGFzIDAuNWVtIChpLmUuIDUwMCB1bml0cykga2VybiBvbiB0aGUgbGVmdCBlbmQuXG4gIC8vIFJlZiBmcm9tIG1oY2hlbS5zdHk6IFxccmxhcHtcXHJhaXNlYm94ey0uMjJleH17JFxca2VybjAuNWVtXG4gIGJhcmFib3Zlc2hvcnRsZWZ0aGFycG9vbjogXCJNNTA3LDQzNWMtNCw0LC02LjMsOC43LC03LDE0YzAsNS4zLDAuNyw5LDIsMTFcXG5jMS4zLDIsNS4zLDUuMywxMiwxMGM5MC43LDU0LDE1NiwxMzAsMTk2LDIyOGMzLjMsMTAuNyw2LjMsMTYuMyw5LDE3XFxuYzIsMC43LDUsMSw5LDFjMCwwLDUsMCw1LDBjMTAuNywwLDE2LjcsLTIsMTgsLTZjMiwtMi43LDEsLTkuNywtMywtMjFcXG5jLTMyLC04Ny4zLC04Mi43LC0xNTcuNywtMTUyLC0yMTFjMCwwLC0zLC0zLC0zLC0zbDM5OTM1MSwwbDAsLTQwXFxuYy0zOTg1NzAsMCwtMzk5NDM3LDAsLTM5OTQzNywweiBNNTkzIDQzNSB2NDAgSDM5OTUwMCB2LTQwelxcbk0wIDI4MSB2LTQwIEgzOTk5MDggdjQweiBNMCAyODEgdi00MCBIMzk5OTA4IHY0MHpcIixcbiAgcmlnaHRoYXJwb29uYWJvdmVzaG9ydGJhcjogXCJNMCwyNDEgbDAsNDBjMzk5MTI2LDAsMzk5OTkzLDAsMzk5OTkzLDBcXG5jNC43LC00LjcsNywtOS4zLDcsLTE0YzAsLTkuMywtMy43LC0xNS4zLC0xMSwtMThjLTkyLjcsLTU2LjcsLTE1OSwtMTMzLjcsLTE5OSxcXG4tMjMxYy0zLjMsLTkuMywtNiwtMTQuNywtOCwtMTZjLTIsLTEuMywtNywtMiwtMTUsLTJjLTEwLjcsMCwtMTYuNywyLC0xOCw2XFxuYy0yLDIuNywtMSw5LjcsMywyMWMxNS4zLDQyLDM2LjcsODEuOCw2NCwxMTkuNWMyNy4zLDM3LjcsNTgsNjkuMiw5Miw5NC41elxcbk0wIDI0MSB2NDAgSDM5OTkwOCB2LTQweiBNMCA0NzUgdi00MCBIMzk5NTAwIHY0MHogTTAgNDc1IHYtNDAgSDM5OTUwMCB2NDB6XCIsXG4gIHNob3J0YmFyYWJvdmVsZWZ0aGFycG9vbjogXCJNNyw0MzVjLTQsNCwtNi4zLDguNywtNywxNGMwLDUuMywwLjcsOSwyLDExXFxuYzEuMywyLDUuMyw1LjMsMTIsMTBjOTAuNyw1NCwxNTYsMTMwLDE5NiwyMjhjMy4zLDEwLjcsNi4zLDE2LjMsOSwxN2MyLDAuNyw1LDEsOSxcXG4xYzAsMCw1LDAsNSwwYzEwLjcsMCwxNi43LC0yLDE4LC02YzIsLTIuNywxLC05LjcsLTMsLTIxYy0zMiwtODcuMywtODIuNywtMTU3LjcsXFxuLTE1MiwtMjExYzAsMCwtMywtMywtMywtM2wzOTk5MDcsMGwwLC00MGMtMzk5MTI2LDAsLTM5OTk5MywwLC0zOTk5OTMsMHpcXG5NOTMgNDM1IHY0MCBINDAwMDAwIHYtNDB6IE01MDAgMjQxIHY0MCBINDAwMDAwIHYtNDB6IE01MDAgMjQxIHY0MCBINDAwMDAwIHYtNDB6XCIsXG4gIHNob3J0cmlnaHRoYXJwb29uYWJvdmViYXI6IFwiTTUzLDI0MWwwLDQwYzM5ODU3MCwwLDM5OTQzNywwLDM5OTQzNywwXFxuYzQuNywtNC43LDcsLTkuMyw3LC0xNGMwLC05LjMsLTMuNywtMTUuMywtMTEsLTE4Yy05Mi43LC01Ni43LC0xNTksLTEzMy43LC0xOTksXFxuLTIzMWMtMy4zLC05LjMsLTYsLTE0LjcsLTgsLTE2Yy0yLC0xLjMsLTcsLTIsLTE1LC0yYy0xMC43LDAsLTE2LjcsMiwtMTgsNlxcbmMtMiwyLjcsLTEsOS43LDMsMjFjMTUuMyw0MiwzNi43LDgxLjgsNjQsMTE5LjVjMjcuMywzNy43LDU4LDY5LjIsOTIsOTQuNXpcXG5NNTAwIDI0MSB2NDAgSDM5OTQwOCB2LTQweiBNNTAwIDQzNSB2NDAgSDQwMDAwMCB2LTQwelwiXG59O1xudmFyIHRhbGxEZWxpbSA9IGZ1bmN0aW9uIHRhbGxEZWxpbShsYWJlbCwgbWlkSGVpZ2h0KSB7XG4gIHN3aXRjaCAobGFiZWwpIHtcbiAgICBjYXNlIFwibGJyYWNrXCI6XG4gICAgICByZXR1cm4gXCJNNDAzIDE3NTkgVjg0IEg2NjYgVjAgSDMxOSBWMTc1OSB2XCIgKyBtaWRIZWlnaHQgKyBcIiB2MTc1OSBoMzQ3IHYtODRcXG5INDAzeiBNNDAzIDE3NTkgVjAgSDMxOSBWMTc1OSB2XCIgKyBtaWRIZWlnaHQgKyBcIiB2MTc1OSBoODR6XCI7XG5cbiAgICBjYXNlIFwicmJyYWNrXCI6XG4gICAgICByZXR1cm4gXCJNMzQ3IDE3NTkgVjAgSDAgVjg0IEgyNjMgVjE3NTkgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjE3NTkgSDAgdjg0IEgzNDd6XFxuTTM0NyAxNzU5IFYwIEgyNjMgVjE3NTkgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjE3NTkgaDg0elwiO1xuXG4gICAgY2FzZSBcInZlcnRcIjpcbiAgICAgIHJldHVybiBcIk0xNDUgMTUgdjU4NSB2XCIgKyBtaWRIZWlnaHQgKyBcIiB2NTg1IGMyLjY2NywxMCw5LjY2NywxNSwyMSwxNVxcbmMxMCwwLDE2LjY2NywtNSwyMCwtMTUgdi01ODUgdlwiICsgLW1pZEhlaWdodCArIFwiIHYtNTg1IGMtMi42NjcsLTEwLC05LjY2NywtMTUsLTIxLC0xNVxcbmMtMTAsMCwtMTYuNjY3LDUsLTIwLDE1eiBNMTg4IDE1IEgxNDUgdjU4NSB2XCIgKyBtaWRIZWlnaHQgKyBcIiB2NTg1IGg0M3pcIjtcblxuICAgIGNhc2UgXCJkb3VibGV2ZXJ0XCI6XG4gICAgICByZXR1cm4gXCJNMTQ1IDE1IHY1ODUgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjU4NSBjMi42NjcsMTAsOS42NjcsMTUsMjEsMTVcXG5jMTAsMCwxNi42NjcsLTUsMjAsLTE1IHYtNTg1IHZcIiArIC1taWRIZWlnaHQgKyBcIiB2LTU4NSBjLTIuNjY3LC0xMCwtOS42NjcsLTE1LC0yMSwtMTVcXG5jLTEwLDAsLTE2LjY2Nyw1LC0yMCwxNXogTTE4OCAxNSBIMTQ1IHY1ODUgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjU4NSBoNDN6XFxuTTM2NyAxNSB2NTg1IHZcIiArIG1pZEhlaWdodCArIFwiIHY1ODUgYzIuNjY3LDEwLDkuNjY3LDE1LDIxLDE1XFxuYzEwLDAsMTYuNjY3LC01LDIwLC0xNSB2LTU4NSB2XCIgKyAtbWlkSGVpZ2h0ICsgXCIgdi01ODUgYy0yLjY2NywtMTAsLTkuNjY3LC0xNSwtMjEsLTE1XFxuYy0xMCwwLC0xNi42NjcsNSwtMjAsMTV6IE00MTAgMTUgSDM2NyB2NTg1IHZcIiArIG1pZEhlaWdodCArIFwiIHY1ODUgaDQzelwiO1xuXG4gICAgY2FzZSBcImxmbG9vclwiOlxuICAgICAgcmV0dXJuIFwiTTMxOSA2MDIgVjAgSDQwMyBWNjAyIHZcIiArIG1pZEhlaWdodCArIFwiIHYxNzE1IGgyNjMgdjg0IEgzMTl6XFxuTU0zMTkgNjAyIFYwIEg0MDMgVjYwMiB2XCIgKyBtaWRIZWlnaHQgKyBcIiB2MTcxNSBIMzE5elwiO1xuXG4gICAgY2FzZSBcInJmbG9vclwiOlxuICAgICAgcmV0dXJuIFwiTTMxOSA2MDIgVjAgSDQwMyBWNjAyIHZcIiArIG1pZEhlaWdodCArIFwiIHYxNzk5IEgwIHYtODQgSDMxOXpcXG5NTTMxOSA2MDIgVjAgSDQwMyBWNjAyIHZcIiArIG1pZEhlaWdodCArIFwiIHYxNzE1IEgzMTl6XCI7XG5cbiAgICBjYXNlIFwibGNlaWxcIjpcbiAgICAgIHJldHVybiBcIk00MDMgMTc1OSBWODQgSDY2NiBWMCBIMzE5IFYxNzU5IHZcIiArIG1pZEhlaWdodCArIFwiIHY2MDIgaDg0elxcbk00MDMgMTc1OSBWMCBIMzE5IFYxNzU5IHZcIiArIG1pZEhlaWdodCArIFwiIHY2MDIgaDg0elwiO1xuXG4gICAgY2FzZSBcInJjZWlsXCI6XG4gICAgICByZXR1cm4gXCJNMzQ3IDE3NTkgVjAgSDAgVjg0IEgyNjMgVjE3NTkgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjYwMiBoODR6XFxuTTM0NyAxNzU5IFYwIGgtODQgVjE3NTkgdlwiICsgbWlkSGVpZ2h0ICsgXCIgdjYwMiBoODR6XCI7XG5cbiAgICBjYXNlIFwibHBhcmVuXCI6XG4gICAgICByZXR1cm4gXCJNODYzLDljMCwtMiwtMiwtNSwtNiwtOWMwLDAsLTE3LDAsLTE3LDBjLTEyLjcsMCwtMTkuMywwLjMsLTIwLDFcXG5jLTUuMyw1LjMsLTEwLjMsMTEsLTE1LDE3Yy0yNDIuNywyOTQuNywtMzk1LjMsNjgyLC00NTgsMTE2MmMtMjEuMywxNjMuMywtMzMuMywzNDksXFxuLTM2LDU1NyBsMCxcIiArIChtaWRIZWlnaHQgKyA4NCkgKyBcImMwLjIsNiwwLDI2LDAsNjBjMiwxNTkuMywxMCwzMTAuNywyNCw0NTRjNTMuMyw1MjgsMjEwLFxcbjk0OS43LDQ3MCwxMjY1YzQuNyw2LDkuNywxMS43LDE1LDE3YzAuNywwLjcsNywxLDE5LDFjMCwwLDE4LDAsMTgsMGM0LC00LDYsLTcsNiwtOVxcbmMwLC0yLjcsLTMuMywtOC43LC0xMCwtMThjLTEzNS4zLC0xOTIuNywtMjM1LjUsLTQxNC4zLC0zMDAuNSwtNjY1Yy02NSwtMjUwLjcsLTEwMi41LFxcbi01NDQuNywtMTEyLjUsLTg4MmMtMiwtMTA0LC0zLC0xNjcsLTMsLTE4OVxcbmwwLC1cIiArIChtaWRIZWlnaHQgKyA5MikgKyBcImMwLC0xNjIuNyw1LjcsLTMxNCwxNywtNDU0YzIwLjcsLTI3Miw2My43LC01MTMsMTI5LC03MjNjNjUuMyxcXG4tMjEwLDE1NS4zLC0zOTYuMywyNzAsLTU1OWM2LjcsLTkuMywxMCwtMTUuMywxMCwtMTh6XCI7XG5cbiAgICBjYXNlIFwicnBhcmVuXCI6XG4gICAgICByZXR1cm4gXCJNNzYsMGMtMTYuNywwLC0yNSwzLC0yNSw5YzAsMiwyLDYuMyw2LDEzYzIxLjMsMjguNyw0Mi4zLDYwLjMsXFxuNjMsOTVjOTYuNywxNTYuNywxNzIuOCwzMzIuNSwyMjguNSw1MjcuNWM1NS43LDE5NSw5Mi44LDQxNi41LDExMS41LDY2NC41XFxuYzExLjMsMTM5LjMsMTcsMjkwLjcsMTcsNDU0YzAsMjgsMS43LDQzLDMuMyw0NWwwLFwiICsgKG1pZEhlaWdodCArIDkpICsgXCJcXG5jLTMsNCwtMy4zLDE2LjcsLTMuMywzOGMwLDE2MiwtNS43LDMxMy43LC0xNyw0NTVjLTE4LjcsMjQ4LC01NS44LDQ2OS4zLC0xMTEuNSw2NjRcXG5jLTU1LjcsMTk0LjcsLTEzMS44LDM3MC4zLC0yMjguNSw1MjdjLTIwLjcsMzQuNywtNDEuNyw2Ni4zLC02Myw5NWMtMiwzLjMsLTQsNywtNiwxMVxcbmMwLDcuMyw1LjcsMTEsMTcsMTFjMCwwLDExLDAsMTEsMGM5LjMsMCwxNC4zLC0wLjMsMTUsLTFjNS4zLC01LjMsMTAuMywtMTEsMTUsLTE3XFxuYzI0Mi43LC0yOTQuNywzOTUuMywtNjgxLjcsNDU4LC0xMTYxYzIxLjMsLTE2NC43LDMzLjMsLTM1MC43LDM2LC01NThcXG5sMCwtXCIgKyAobWlkSGVpZ2h0ICsgMTQ0KSArIFwiYy0yLC0xNTkuMywtMTAsLTMxMC43LC0yNCwtNDU0Yy01My4zLC01MjgsLTIxMCwtOTQ5LjcsXFxuLTQ3MCwtMTI2NWMtNC43LC02LC05LjcsLTExLjcsLTE1LC0xN2MtMC43LC0wLjcsLTYuNywtMSwtMTgsLTF6XCI7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBldmVyIGdldCBoZXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzdHJldGNoeSBkZWxpbWl0ZXIuXCIpO1xuICB9XG59O1xuXG4vLyBUbyBlbnN1cmUgdGhhdCBhbGwgbm9kZXMgaGF2ZSBjb21wYXRpYmxlIHNpZ25hdHVyZXMgZm9yIHRoZXNlIG1ldGhvZHMuXG5cbi8qKlxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYSBkb2N1bWVudCBmcmFnbWVudCwgd2hpY2ggY29udGFpbnMgZWxlbWVudHMsIGJ1dCB3aGVuXG4gKiBwbGFjZWQgaW50byB0aGUgRE9NIGRvZXNuJ3QgaGF2ZSBhbnkgcmVwcmVzZW50YXRpb24gaXRzZWxmLiBJdCBvbmx5IGNvbnRhaW5zXG4gKiBjaGlsZHJlbiBhbmQgZG9lc24ndCBoYXZlIGFueSBET00gbm9kZSBwcm9wZXJ0aWVzLlxuICovXG5jbGFzcyBEb2N1bWVudEZyYWdtZW50IHtcbiAgLy8gTmV2ZXIgdXNlZDsgbmVlZGVkIGZvciBzYXRpc2Z5aW5nIGludGVyZmFjZS5cbiAgY29uc3RydWN0b3IoY2hpbGRyZW4pIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gdm9pZCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmhlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmRlcHRoID0gdm9pZCAwO1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHlsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy5jbGFzc2VzID0gW107XG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMuZGVwdGggPSAwO1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSAwO1xuICAgIHRoaXMuc3R5bGUgPSB7fTtcbiAgfVxuXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzZXMuaW5jbHVkZXMoY2xhc3NOYW1lKTtcbiAgfVxuICAvKiogQ29udmVydCB0aGUgZnJhZ21lbnQgaW50byBhIG5vZGUuICovXG5cblxuICB0b05vZGUoKSB7XG4gICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyYWcuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cbiAgLyoqIENvbnZlcnQgdGhlIGZyYWdtZW50IGludG8gSFRNTCBtYXJrdXAuICovXG5cblxuICB0b01hcmt1cCgpIHtcbiAgICB2YXIgbWFya3VwID0gXCJcIjsgLy8gU2ltcGx5IGNvbmNhdGVuYXRlIHRoZSBtYXJrdXAgZm9yIHRoZSBjaGlsZHJlbiB0b2dldGhlci5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbWFya3VwICs9IHRoaXMuY2hpbGRyZW5baV0udG9NYXJrdXAoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBzdHJpbmcsIHNpbWlsYXIgdG8gaW5uZXJUZXh0LiBBcHBsaWVzIHRvXG4gICAqIE1hdGhEb21Ob2RlJ3Mgb25seS5cbiAgICovXG5cblxuICB0b1RleHQoKSB7XG4gICAgLy8gVG8gYXZvaWQgdGhpcywgd2Ugd291bGQgc3ViY2xhc3MgZG9jdW1lbnRGcmFnbWVudCBzZXBhcmF0ZWx5IGZvclxuICAgIC8vIE1hdGhNTCwgYnV0IHBvbHlmaWxscyBmb3Igc3ViY2xhc3NpbmcgaXMgZXhwZW5zaXZlIHBlciBQUiAxNDY5LlxuICAgIC8vICRGbG93Rml4TWU6IE9ubHkgd29ya3MgZm9yIENoaWxkVHlwZSA9IE1hdGhEb21Ob2RlLlxuICAgIHZhciB0b1RleHQgPSBjaGlsZCA9PiBjaGlsZC50b1RleHQoKTtcblxuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLm1hcCh0b1RleHQpLmpvaW4oXCJcIik7XG4gIH1cblxufVxuXG4vLyBUaGlzIGZpbGUgaXMgR0VORVJBVEVEIGJ5IGJ1aWxkTWV0cmljcy5zaC4gRE8gTk9UIE1PRElGWS5cbnZhciBmb250TWV0cmljc0RhdGEgPSB7XG4gIFwiQU1TLVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNjVcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiNjZcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNjdcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiNjhcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiNjlcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiNzBcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiNzFcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNzJcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNzNcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiNzRcIjogWzAuMTY2NjcsIDAuNjg4ODksIDAsIDAsIDAuNV0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI3N1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC45NDQ0NV0sXG4gICAgXCI3OFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI3OVwiOiBbMC4xNjY2NywgMC42ODg4OSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4MFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4MVwiOiBbMC4xNjY2NywgMC42ODg4OSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4MlwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4M1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NVwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NlwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4N1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMS4wXSxcbiAgICBcIjg4XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg5XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjkwXCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMTY1XCI6IFswLCAwLjY3NSwgMC4wMjUsIDAsIDAuNzVdLFxuICAgIFwiMTc0XCI6IFswLjE1NTU5LCAwLjY5MjI0LCAwLCAwLCAwLjk0NjY2XSxcbiAgICBcIjI0MFwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCIyOTVcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTQwMjhdLFxuICAgIFwiNzEwXCI6IFswLCAwLjgyNSwgMCwgMCwgMi4zMzMzNF0sXG4gICAgXCI3MzJcIjogWzAsIDAuOSwgMCwgMCwgMi4zMzMzNF0sXG4gICAgXCI3NzBcIjogWzAsIDAuODI1LCAwLCAwLCAyLjMzMzM0XSxcbiAgICBcIjc3MVwiOiBbMCwgMC45LCAwLCAwLCAyLjMzMzM0XSxcbiAgICBcIjk4OVwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIxMDA4XCI6IFswLCAwLjQzMDU2LCAwLjA0MDI4LCAwLCAwLjY2NjY3XSxcbiAgICBcIjgyNDVcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuMjc1XSxcbiAgICBcIjg0NjNcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTQwMjhdLFxuICAgIFwiODQ4N1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NDk4XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg1MDJcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODUwM1wiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCI4NTA0XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg1MTNcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiODU5MlwiOiBbLTAuMDM1OTgsIDAuNDY0MDIsIDAsIDAsIDAuNV0sXG4gICAgXCI4NTk0XCI6IFstMC4wMzU5OCwgMC40NjQwMiwgMCwgMCwgMC41XSxcbiAgICBcIjg2MDJcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODYwM1wiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjA2XCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwLCAxLjBdLFxuICAgIFwiODYwOFwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MTBcIjogWzAuMDEzNTQsIDAuNTIyMzksIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiODYxMVwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCI4NjE5XCI6IFswLCAwLjU0OTg2LCAwLCAwLCAxLjBdLFxuICAgIFwiODYyMFwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MjFcIjogWy0wLjEzMzEzLCAwLjM3Nzg4LCAwLCAwLCAxLjM4ODg5XSxcbiAgICBcIjg2MjJcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODYyNFwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC41XSxcbiAgICBcIjg2MjVcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNV0sXG4gICAgXCI4NjMwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAxLjBdLFxuICAgIFwiODYzMVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MzRcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODYzNVwiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NjM4XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjQxNjY3XSxcbiAgICBcIjg2MzlcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNDE2NjddLFxuICAgIFwiODY0MlwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC40MTY2N10sXG4gICAgXCI4NjQzXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjQxNjY3XSxcbiAgICBcIjg2NDRcIjogWzAuMTgwOCwgMC42NzUsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjQ2XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiODY0N1wiOiBbMC4xODA4LCAwLjY3NSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2NDhcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiODY0OVwiOiBbMC4xODA4LCAwLjY3NSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2NTBcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiODY1MVwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMCwgMS4wXSxcbiAgICBcIjg2NTJcIjogWzAuMDEzNTQsIDAuNTIyMzksIDAsIDAsIDEuMF0sXG4gICAgXCI4NjUzXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NTRcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY1NVwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjY2XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY2N1wiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NjlcIjogWy0wLjEzMzEzLCAwLjM3Nzg4LCAwLCAwLCAxLjBdLFxuICAgIFwiODY3MlwiOiBbLTAuMDY0LCAwLjQzNywgMCwgMCwgMS4zMzRdLFxuICAgIFwiODY3NFwiOiBbLTAuMDY0LCAwLjQzNywgMCwgMCwgMS4zMzRdLFxuICAgIFwiODcwNVwiOiBbMCwgMC44MjUsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzA4XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg3MDlcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODcxN1wiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC40MjkxN10sXG4gICAgXCI4NzIyXCI6IFstMC4wMzU5OCwgMC40NjQwMiwgMCwgMCwgMC41XSxcbiAgICBcIjg3MjRcIjogWzAuMDgxOTgsIDAuNjkyMjQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODcyNlwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzMzXCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3MzZcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODczN1wiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NzM4XCI6IFswLjAzNTE3LCAwLjUyMjM5LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg3MzlcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuMjIyMjJdLFxuICAgIFwiODc0MFwiOiBbMC4yNTE0MiwgMC43NDExMSwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4NzQxXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjg3NDJcIjogWzAuMjUxNDIsIDAuNzQxMTEsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzU2XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3NTdcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODc2NFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc2NVwiOiBbLTAuMTMzMTMsIDAuMzc3ODgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc2OVwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc3MFwiOiBbLTAuMDM2MjUsIDAuNDYzNzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc3NFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4Nzc2XCI6IFstMC4wMTY4OCwgMC40ODMxMiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4Nzc4XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3ODJcIjogWzAuMDYwNjIsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc4M1wiOiBbMC4wNjA2MiwgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4Nzg1XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3ODZcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc4N1wiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzkwXCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3OTFcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc5NlwiOiBbMC4wODE5OCwgMC45MTY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODA2XCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MDdcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgwOFwiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODA5XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MTJcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDAsIDAuNV0sXG4gICAgXCI4ODE0XCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MTVcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgxNlwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODE3XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MThcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgxOVwiOiBbMC4yMjk1OCwgMC43Mjk1OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODIyXCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MjNcIjogWzAuMTgwOCwgMC42NzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgyOFwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODI5XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MzBcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgzMVwiOiBbMC4yMjk1OCwgMC43Mjk1OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODMyXCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MzNcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg0MFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODQxXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NDJcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg0M1wiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODQ3XCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NDhcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg1OFwiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODU5XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NjFcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg2MlwiOiBbMCwgMC42NzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg2M1wiOiBbMCwgMC42NzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg2NFwiOiBbMCwgMC42NzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg2NVwiOiBbMCwgMC42NzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg3MlwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4ODczXCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjg4NzRcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuODg4ODldLFxuICAgIFwiODg3NlwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4ODc3XCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg4NzhcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODg3OVwiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4ODgyXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4ODNcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg4NFwiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODg1XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4ODhcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiODg5MFwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI4ODkxXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg4OTJcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODkwMVwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4OTAzXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MDVcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkwNlwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTA3XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MDhcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkwOVwiOiBbLTAuMDM1OTgsIDAuNDY0MDIsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkxMFwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC43NjA0Ml0sXG4gICAgXCI4OTExXCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjc2MDQyXSxcbiAgICBcIjg5MTJcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkxM1wiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTE0XCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg5MTVcIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODkxNlwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4OTE4XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTE5XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTIwXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAxLjMzMzM0XSxcbiAgICBcIjg5MjFcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDEuMzMzMzRdLFxuICAgIFwiODkyMlwiOiBbMC4zODU2OSwgMC44ODU2OSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTIzXCI6IFswLjM4NTY5LCAwLjg4NTY5LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MjZcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkyN1wiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTI4XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MjlcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkzNFwiOiBbMC4yMzIyMiwgMC43NDExMSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTM1XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MzZcIjogWzAuMjMyMjIsIDAuNzQxMTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODkzN1wiOiBbMC4yMzIyMiwgMC43NDExMSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTM4XCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5MzlcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODk0MFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4OTQxXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg5OTRcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODk5NVwiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5NDE2XCI6IFswLjE1NTU5LCAwLjY5MjI0LCAwLCAwLCAwLjkwMjIyXSxcbiAgICBcIjk0ODRcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNV0sXG4gICAgXCI5NDg4XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjVdLFxuICAgIFwiOTQ5MlwiOiBbMCwgMC4zNzc4OCwgMCwgMCwgMC41XSxcbiAgICBcIjk0OTZcIjogWzAsIDAuMzc3ODgsIDAsIDAsIDAuNV0sXG4gICAgXCI5NTg1XCI6IFswLjE5NDQ0LCAwLjY4ODg5LCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjk1ODZcIjogWzAuMTk0NDQsIDAuNzQxMTEsIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTYzMlwiOiBbMCwgMC42NzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTYzM1wiOiBbMCwgMC42NzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTY1MFwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI5NjUxXCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjk2NTRcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTY2MFwiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI5NjYxXCI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjk2NjRcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTY3NFwiOiBbMC4xMTExMSwgMC42OTIyNCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5NzMzXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjk0NDQ1XSxcbiAgICBcIjEwMDAzXCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjEwMDE2XCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjEwNzMxXCI6IFswLjExMTExLCAwLjY5MjI0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjEwODQ2XCI6IFswLjE5NDQ0LCAwLjc1NTgzLCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjEwODc3XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODc4XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODg1XCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODg2XCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODg3XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODg4XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODg5XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODkwXCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODkxXCI6IFswLjQ4MjU2LCAwLjk4MjU2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwODkyXCI6IFswLjQ4MjU2LCAwLjk4MjU2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTAxXCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTAyXCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTMzXCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTM0XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTM1XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTM2XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTM3XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTM4XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTQ5XCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTUwXCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTU1XCI6IFswLjI4NDgxLCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTU2XCI6IFswLjI4NDgxLCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzUwXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjIyMjIyXSxcbiAgICBcIjU3MzUxXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjU3MzUyXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzUzXCI6IFswLCAwLjQzMDU2LCAwLjA0MDI4LCAwLCAwLjY2NjY3XSxcbiAgICBcIjU3MzU2XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzU3XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzU4XCI6IFswLjQxOTUxLCAwLjkxOTUxLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzU5XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzYwXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzYxXCI6IFswLjQxOTUxLCAwLjkxOTUxLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzY2XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzY3XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzY4XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzY5XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzcwXCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3MzcxXCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XVxuICB9LFxuICBcIkNhbGlncmFwaGljLVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTk0NDUsIDAuNzk4NDddLFxuICAgIFwiNjZcIjogWzAsIDAuNjgzMzMsIDAuMDMwNDEsIDAuMTM4ODksIDAuNjU2ODFdLFxuICAgIFwiNjdcIjogWzAsIDAuNjgzMzMsIDAuMDU4MzQsIDAuMTM4ODksIDAuNTI2NTNdLFxuICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDgzMzQsIDAuNzcxMzldLFxuICAgIFwiNjlcIjogWzAsIDAuNjgzMzMsIDAuMDg5NDQsIDAuMTExMTEsIDAuNTI3NzhdLFxuICAgIFwiNzBcIjogWzAsIDAuNjgzMzMsIDAuMDk5MzEsIDAuMTExMTEsIDAuNzE4NzVdLFxuICAgIFwiNzFcIjogWzAuMDk3MjIsIDAuNjgzMzMsIDAuMDU5MywgMC4xMTExMSwgMC41OTQ4N10sXG4gICAgXCI3MlwiOiBbMCwgMC42ODMzMywgMC4wMDk2NSwgMC4xMTExMSwgMC44NDQ1Ml0sXG4gICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4wNzM4MiwgMCwgMC41NDQ1Ml0sXG4gICAgXCI3NFwiOiBbMC4wOTcyMiwgMC42ODMzMywgMC4xODQ3MiwgMC4xNjY2NywgMC42Nzc3OF0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODMzMywgMC4wMTQ0NSwgMC4wNTU1NiwgMC43NjE5NV0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMC4xMzg4OSwgMC42ODk3Ml0sXG4gICAgXCI3N1wiOiBbMCwgMC42ODMzMywgMCwgMC4xMzg4OSwgMS4yMDA5XSxcbiAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjE0NzM2LCAwLjA4MzM0LCAwLjgyMDQ5XSxcbiAgICBcIjc5XCI6IFswLCAwLjY4MzMzLCAwLjAyNzc4LCAwLjExMTExLCAwLjc5NjExXSxcbiAgICBcIjgwXCI6IFswLCAwLjY4MzMzLCAwLjA4MjIyLCAwLjA4MzM0LCAwLjY5NTU2XSxcbiAgICBcIjgxXCI6IFswLjA5NzIyLCAwLjY4MzMzLCAwLCAwLjExMTExLCAwLjgxNjY3XSxcbiAgICBcIjgyXCI6IFswLCAwLjY4MzMzLCAwLCAwLjA4MzM0LCAwLjg0NzVdLFxuICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMDc1LCAwLjEzODg5LCAwLjYwNTU2XSxcbiAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjI1NDE3LCAwLCAwLjU0NDY0XSxcbiAgICBcIjg1XCI6IFswLCAwLjY4MzMzLCAwLjA5OTMxLCAwLjA4MzM0LCAwLjYyNTgzXSxcbiAgICBcIjg2XCI6IFswLCAwLjY4MzMzLCAwLjA4MjIyLCAwLCAwLjYxMjc4XSxcbiAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjA4MjIyLCAwLjA4MzM0LCAwLjk4Nzc4XSxcbiAgICBcIjg4XCI6IFswLCAwLjY4MzMzLCAwLjE0NjQzLCAwLjEzODg5LCAwLjcxMzNdLFxuICAgIFwiODlcIjogWzAuMDk3MjIsIDAuNjgzMzMsIDAuMDgyMjIsIDAuMDgzMzQsIDAuNjY4MzRdLFxuICAgIFwiOTBcIjogWzAsIDAuNjgzMzMsIDAuMDc5NDQsIDAuMTM4ODksIDAuNzI0NzNdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XVxuICB9LFxuICBcIkZyYWt0dXItUmVndWxhclwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIzM1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yOTU3NF0sXG4gICAgXCIzNFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yMTQ3MV0sXG4gICAgXCIzOFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC43Mzc4Nl0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yMTIwMV0sXG4gICAgXCI0MFwiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMCwgMC4zODg2NV0sXG4gICAgXCI0MVwiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMCwgMC4zODg2NV0sXG4gICAgXCI0MlwiOiBbMCwgMC42MjExOSwgMCwgMCwgMC4yNzc2NF0sXG4gICAgXCI0M1wiOiBbMC4wODMxOSwgMC41ODI4MywgMCwgMCwgMC43NTYyM10sXG4gICAgXCI0NFwiOiBbMCwgMC4xMDgwMywgMCwgMCwgMC4yNzc2NF0sXG4gICAgXCI0NVwiOiBbMC4wODMxOSwgMC41ODI4MywgMCwgMCwgMC43NTYyM10sXG4gICAgXCI0NlwiOiBbMCwgMC4xMDgwMywgMCwgMCwgMC4yNzc2NF0sXG4gICAgXCI0N1wiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI0OFwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI0OVwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1MFwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1MVwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1MlwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1M1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1NFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1NVwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1NlwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1N1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDE4MV0sXG4gICAgXCI1OFwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC4yMTYwNl0sXG4gICAgXCI1OVwiOiBbMC4xMjYwNCwgMC40NzUzNCwgMCwgMCwgMC4yMTYwNl0sXG4gICAgXCI2MVwiOiBbLTAuMTMwOTksIDAuMzY4NjYsIDAsIDAsIDAuNzU2MjNdLFxuICAgIFwiNjNcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMzYyNDVdLFxuICAgIFwiNjVcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNzE3Nl0sXG4gICAgXCI2NlwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC44ODM5N10sXG4gICAgXCI2N1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC42MTI1NF0sXG4gICAgXCI2OFwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC44MzE1OF0sXG4gICAgXCI2OVwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC42NjI3OF0sXG4gICAgXCI3MFwiOiBbMC4xMjYwNCwgMC42OTE0MSwgMCwgMCwgMC42MTExOV0sXG4gICAgXCI3MVwiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC43ODUzOV0sXG4gICAgXCI3MlwiOiBbMC4wNjMwMiwgMC42OTE0MSwgMCwgMCwgMC43MjAzXSxcbiAgICBcIjczXCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjU1NDQ4XSxcbiAgICBcIjc0XCI6IFswLjEyNjA0LCAwLjY5MTQxLCAwLCAwLCAwLjU1MjMxXSxcbiAgICBcIjc1XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjY2ODQ1XSxcbiAgICBcIjc2XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjY2NjAyXSxcbiAgICBcIjc3XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAxLjA0OTUzXSxcbiAgICBcIjc4XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjgzMjEyXSxcbiAgICBcIjc5XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjgyNjk5XSxcbiAgICBcIjgwXCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwLCAwLjgyNzUzXSxcbiAgICBcIjgxXCI6IFswLjAzNzgxLCAwLjY5MTQxLCAwLCAwLCAwLjgyNjk5XSxcbiAgICBcIjgyXCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjgyODA3XSxcbiAgICBcIjgzXCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjgyODYxXSxcbiAgICBcIjg0XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjY2ODk5XSxcbiAgICBcIjg1XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjY0NTc2XSxcbiAgICBcIjg2XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjgzMTMxXSxcbiAgICBcIjg3XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAxLjA0NjAyXSxcbiAgICBcIjg4XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjcxOTIyXSxcbiAgICBcIjg5XCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwLCAwLjgzMjkzXSxcbiAgICBcIjkwXCI6IFswLjEyNjA0LCAwLjY5MTQxLCAwLCAwLCAwLjYwMjAxXSxcbiAgICBcIjkxXCI6IFswLjI0OTgyLCAwLjc0OTQ3LCAwLCAwLCAwLjI3NzY0XSxcbiAgICBcIjkzXCI6IFswLjI0OTgyLCAwLjc0OTQ3LCAwLCAwLCAwLjI3NzY0XSxcbiAgICBcIjk0XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjQ5OTY1XSxcbiAgICBcIjk3XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjUwMDQ2XSxcbiAgICBcIjk4XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjUxMzE1XSxcbiAgICBcIjk5XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjM4OTQ2XSxcbiAgICBcIjEwMFwiOiBbMCwgMC42MjExOSwgMCwgMCwgMC40OTg1N10sXG4gICAgXCIxMDFcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNDAwNTNdLFxuICAgIFwiMTAyXCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwLCAwLjMyNjI2XSxcbiAgICBcIjEwM1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDM3XSxcbiAgICBcIjEwNFwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMCwgMC41MjEyNl0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjc4OTldLFxuICAgIFwiMTA2XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjI4MDg4XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4zODk0Nl0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjc5NTNdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjc2Njc2XSxcbiAgICBcIjExMFwiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MjY2Nl0sXG4gICAgXCIxMTFcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNDg4ODVdLFxuICAgIFwiMTEyXCI6IFswLjE4OTA2LCAwLjUyMzk2LCAwLCAwLCAwLjUwMDQ2XSxcbiAgICBcIjExM1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC40ODkxMl0sXG4gICAgXCIxMTRcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuMzg5MTldLFxuICAgIFwiMTE1XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjQ0MjY2XSxcbiAgICBcIjExNlwiOiBbMCwgMC42MjExOSwgMCwgMCwgMC4zMzMwMV0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNTE3Ml0sXG4gICAgXCIxMThcIjogWzAsIDAuNTIzOTYsIDAsIDAsIDAuNTExOF0sXG4gICAgXCIxMTlcIjogWzAsIDAuNTIzOTYsIDAsIDAsIDAuNzczNTFdLFxuICAgIFwiMTIwXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjM4ODY1XSxcbiAgICBcIjEyMVwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC40OTg4NF0sXG4gICAgXCIxMjJcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuMzkwNTRdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjE0NzFdLFxuICAgIFwiODIxN1wiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yMTQ3MV0sXG4gICAgXCI1ODExMlwiOiBbMCwgMC42MjExOSwgMCwgMCwgMC40OTc0OV0sXG4gICAgXCI1ODExM1wiOiBbMCwgMC42MjExOSwgMCwgMCwgMC40OTgzXSxcbiAgICBcIjU4MTE0XCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwLCAwLjMzMzI4XSxcbiAgICBcIjU4MTE1XCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwLCAwLjMyOTIzXSxcbiAgICBcIjU4MTE2XCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjUwMzQzXSxcbiAgICBcIjU4MTE3XCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjMzMzAxXSxcbiAgICBcIjU4MTE4XCI6IFswLCAwLjYyMTE5LCAwLCAwLCAwLjMzNDA5XSxcbiAgICBcIjU4MTE5XCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjUwMDczXVxuICB9LFxuICBcIk1haW4tQm9sZFwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIzM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zNV0sXG4gICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MDI3OF0sXG4gICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC45NTgzM10sXG4gICAgXCIzNlwiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuOTU4MzNdLFxuICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiMzlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ3MjJdLFxuICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ3MjJdLFxuICAgIFwiNDJcIjogWzAsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjQzXCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjQ0XCI6IFswLjE5NDQ0LCAwLjE1NTU2LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjQ1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjM4MzMzXSxcbiAgICBcIjQ2XCI6IFswLCAwLjE1NTU2LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI0OFwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNDlcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjUwXCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1MVwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTJcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjUzXCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1NFwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTVcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1N1wiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNThcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiNjBcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiNjFcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjYyXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU0MzA1XSxcbiAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjY1XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg2OTQ0XSxcbiAgICBcIjY2XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgxODA1XSxcbiAgICBcIjY3XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgzMDU1XSxcbiAgICBcIjY4XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg4MTk0XSxcbiAgICBcIjY5XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjc1NTU1XSxcbiAgICBcIjcwXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjcyMzYxXSxcbiAgICBcIjcxXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjkwNDE2XSxcbiAgICBcIjcyXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjldLFxuICAgIFwiNzNcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNDM2MTFdLFxuICAgIFwiNzRcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNTk0NDRdLFxuICAgIFwiNzVcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOTAxMzhdLFxuICAgIFwiNzZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNjkxNjZdLFxuICAgIFwiNzdcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDEuMDkxNjZdLFxuICAgIFwiNzhcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOV0sXG4gICAgXCI3OVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44NjM4OF0sXG4gICAgXCI4MFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC43ODYxMV0sXG4gICAgXCI4MVwiOiBbMC4xOTQ0NCwgMC42ODYxMSwgMCwgMCwgMC44NjM4OF0sXG4gICAgXCI4MlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44NjI1XSxcbiAgICBcIjgzXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjg0XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjhdLFxuICAgIFwiODVcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODg0NzJdLFxuICAgIFwiODZcIjogWzAsIDAuNjg2MTEsIDAuMDE1OTcsIDAsIDAuODY5NDRdLFxuICAgIFwiODdcIjogWzAsIDAuNjg2MTEsIDAuMDE1OTcsIDAsIDEuMTg4ODhdLFxuICAgIFwiODhcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODY5NDRdLFxuICAgIFwiODlcIjogWzAsIDAuNjg2MTEsIDAuMDI4NzUsIDAsIDAuODY5NDRdLFxuICAgIFwiOTBcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNzAyNzddLFxuICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiOTJcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjkzXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjk0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI5NVwiOiBbMC4zMSwgMC4xMzQ0NCwgMC4wMzE5NCwgMCwgMC41NzVdLFxuICAgIFwiOTdcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTU5MDJdLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiOTlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjEwMVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41MjcwOF0sXG4gICAgXCIxMDJcIjogWzAsIDAuNjk0NDQsIDAuMTA5MDMsIDAsIDAuMzUxMzldLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxNTk3LCAwLCAwLjU3NV0sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiMTA1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC4zNTEzOV0sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjA2OTRdLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC45NTgzM10sXG4gICAgXCIxMTBcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiMTExXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjYwNjk0XSxcbiAgICBcIjExNFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40NzM2MV0sXG4gICAgXCIxMTVcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDUzNjFdLFxuICAgIFwiMTE2XCI6IFswLCAwLjYzNDkyLCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCIxMThcIjogWzAsIDAuNDQ0NDQsIDAuMDE1OTcsIDAsIDAuNjA2OTRdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQ0NDQ0LCAwLjAxNTk3LCAwLCAwLjgzMDU1XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42MDY5NF0sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDE1OTcsIDAsIDAuNjA2OTRdLFxuICAgIFwiMTIyXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjEyM1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiMTI0XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjEyNVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiMTI2XCI6IFswLjM1LCAwLjM0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMTYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg2ODUzXSxcbiAgICBcIjE2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiMTcyXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjE3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44Njk0NF0sXG4gICAgXCIxNzdcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiMTg0XCI6IFswLjE3MDE0LCAwLCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjE5OFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMS4wNDE2Nl0sXG4gICAgXCIyMTVcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiMjE2XCI6IFswLjA0ODYxLCAwLjczNDcyLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjIyM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41OTcyMl0sXG4gICAgXCIyMzBcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuODMwNTVdLFxuICAgIFwiMjQ3XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjI0OFwiOiBbMC4wOTcyMiwgMC41NDE2NywgMCwgMCwgMC41NzVdLFxuICAgIFwiMzA1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjMzOFwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMS4xNjk0NF0sXG4gICAgXCIzMzlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjM1MTM5XSxcbiAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNzExXCI6IFswLCAwLjYzMTk0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI3MTNcIjogWzAsIDAuNTk2MTEsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjcxNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjcyOVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI3MzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODY5NDRdLFxuICAgIFwiNzMyXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjkxNVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC42OTE2Nl0sXG4gICAgXCI5MTZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOTU4MzNdLFxuICAgIFwiOTIwXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjkyM1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MDU1NV0sXG4gICAgXCI5MjZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiOTI4XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjldLFxuICAgIFwiOTMxXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgzMDU1XSxcbiAgICBcIjkzM1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODMwNTVdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MzA1NV0sXG4gICAgXCI4MjExXCI6IFswLCAwLjQ0NDQ0LCAwLjAzMTk0LCAwLCAwLjU3NV0sXG4gICAgXCI4MjEyXCI6IFswLCAwLjQ0NDQ0LCAwLjAzMTk0LCAwLCAxLjE0OTk5XSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NF0sXG4gICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYwMjc4XSxcbiAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjAyNzhdLFxuICAgIFwiODIyNFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41MTExMV0sXG4gICAgXCI4MjI1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjgyNDJcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuMzQ0NDRdLFxuICAgIFwiODQwN1wiOiBbMCwgMC43MjQ0NCwgMC4xNTQ4NiwgMCwgMC41NzVdLFxuICAgIFwiODQ2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Njc1OV0sXG4gICAgXCI4NDY1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMDU1XSxcbiAgICBcIjg0NjdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNDczNjFdLFxuICAgIFwiODQ3MlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC43NDAyN10sXG4gICAgXCI4NDc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMDU1XSxcbiAgICBcIjg1MDFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzddLFxuICAgIFwiODU5MlwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODU5M1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiODU5NFwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODU5NVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiODU5NlwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODU5N1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODU5OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NTk5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2MDBcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODYwMVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjM2XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjM3XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjQwXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjQxXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjU2XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4NjU3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjcwMjc3XSxcbiAgICBcIjg2NThcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg2NTlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzddLFxuICAgIFwiODY2MFwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODY2MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC43MDI3N10sXG4gICAgXCI4NzA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjg3MDZcIjogWzAsIDAuNjk0NDQsIDAuMDYzODksIDAsIDAuNjI4NDddLFxuICAgIFwiODcwN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI4NzA5XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NzExXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjk1ODMzXSxcbiAgICBcIjg3MTJcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODcxNVwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4NzIyXCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg3MjNcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODcyNVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODcyNlwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODcyN1wiOiBbLTAuMDI3NzgsIDAuNDcyMjIsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg3MjhcIjogWy0wLjAyNjM5LCAwLjQ3MzYxLCAwLCAwLCAwLjU3NV0sXG4gICAgXCI4NzI5XCI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODczMFwiOiBbMC4xOCwgMC44MiwgMCwgMCwgMC45NTgzM10sXG4gICAgXCI4NzMzXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg3MzRcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODczNlwiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NzM5XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjg3NDFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg3NDNcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODc0NFwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4NzQ1XCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjg3NDZcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODc0N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4xMjc3OCwgMCwgMC41Njg3NV0sXG4gICAgXCI4NzY0XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4NzY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ0XSxcbiAgICBcIjg3NzFcIjogWzAuMDAyMjIsIDAuNTAyMjIsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODc3M1wiOiBbMC4wMjcsIDAuNjM4LCAwLCAwLCAwLjg5NF0sXG4gICAgXCI4Nzc2XCI6IFswLjAyNDQ0LCAwLjUyNDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg3ODFcIjogWzAuMDAyMjIsIDAuNTAyMjIsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgwMVwiOiBbMC4wMDIyMiwgMC41MDIyMiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODA0XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4MDVcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgxMFwiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI4ODExXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAxLjE0OTk5XSxcbiAgICBcIjg4MjZcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgyN1wiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODM0XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4MzVcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODgzOFwiOiBbMC4xOTY2NywgMC42OTY2NywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODM5XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NDZcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODg0OVwiOiBbMC4xOTY2NywgMC42OTY2NywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODUwXCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NTFcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLFxuICAgIFwiODg1MlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC43NjY2Nl0sXG4gICAgXCI4ODUzXCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NTRcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODg1NVwiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4ODU2XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjg4NTdcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODg2NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDI3N10sXG4gICAgXCI4ODY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwMjc3XSxcbiAgICBcIjg4NjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiODg2OVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI4OTAwXCI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMCwgMC41NzVdLFxuICAgIFwiODkwMVwiOiBbLTAuMDI2MzksIDAuNDczNjEsIDAsIDAsIDAuMzE5NDRdLFxuICAgIFwiODkwMlwiOiBbLTAuMDI3NzgsIDAuNDcyMjIsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjg5NjhcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiODk2OVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41MTExMV0sXG4gICAgXCI4OTcwXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjUxMTExXSxcbiAgICBcIjg5NzFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTExMTFdLFxuICAgIFwiODk5NFwiOiBbLTAuMTM4ODksIDAuMzYxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiODk5NVwiOiBbLTAuMTM4ODksIDAuMzYxMTEsIDAsIDAsIDEuMTQ5OTldLFxuICAgIFwiOTY1MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4wMjIyMl0sXG4gICAgXCI5NjU3XCI6IFstMC4wMjc3OCwgMC40NzIyMiwgMCwgMCwgMC41NzVdLFxuICAgIFwiOTY2MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4wMjIyMl0sXG4gICAgXCI5NjY3XCI6IFstMC4wMjc3OCwgMC40NzIyMiwgMCwgMCwgMC41NzVdLFxuICAgIFwiOTcxMVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4xNDk5OV0sXG4gICAgXCI5ODI0XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjk4MjVcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiOTgyNlwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sXG4gICAgXCI5ODI3XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSxcbiAgICBcIjk4MzdcIjogWzAsIDAuNzUsIDAsIDAsIDAuNDQ3MjJdLFxuICAgIFwiOTgzOFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC40NDcyMl0sXG4gICAgXCI5ODM5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjEwMjE2XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjEwMjE3XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NzIyXSxcbiAgICBcIjEwODE1XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjldLFxuICAgIFwiMTA5MjdcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiMTA5MjhcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLFxuICAgIFwiNTczNzZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDBdXG4gIH0sXG4gIFwiTWFpbi1Cb2xkSXRhbGljXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLjExNDE3LCAwLCAwLjM4NjExXSxcbiAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLjA3OTM5LCAwLCAwLjYyMDU1XSxcbiAgICBcIjM1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA2ODMzLCAwLCAwLjk0NDQ0XSxcbiAgICBcIjM3XCI6IFswLjA1NTU2LCAwLjc1LCAwLjEyODYxLCAwLCAwLjk0NDQ0XSxcbiAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLjA4NTI4LCAwLCAwLjg4NTU1XSxcbiAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLjEyOTQ1LCAwLCAwLjM1NTU1XSxcbiAgICBcIjQwXCI6IFswLjI1LCAwLjc1LCAwLjE1ODA2LCAwLCAwLjQ3MzMzXSxcbiAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLjAzMzA2LCAwLCAwLjQ3MzMzXSxcbiAgICBcIjQyXCI6IFswLCAwLjc1LCAwLjE0MzMzLCAwLCAwLjU5MTExXSxcbiAgICBcIjQzXCI6IFswLjEwMzMzLCAwLjYwMzMzLCAwLjAzMzA2LCAwLCAwLjg4NTU1XSxcbiAgICBcIjQ0XCI6IFswLjE5NDQ0LCAwLjE0NzIyLCAwLCAwLCAwLjM1NTU1XSxcbiAgICBcIjQ1XCI6IFswLCAwLjQ0NDQ0LCAwLjAyNjExLCAwLCAwLjQxNDQ0XSxcbiAgICBcIjQ2XCI6IFswLCAwLjE0NzIyLCAwLCAwLCAwLjM1NTU1XSxcbiAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLjE1ODA2LCAwLCAwLjU5MTExXSxcbiAgICBcIjQ4XCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjQ5XCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjUwXCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjUxXCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjUyXCI6IFswLjE5NDQ0LCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjUzXCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjU1XCI6IFswLjE5NDQ0LCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjU3XCI6IFswLCAwLjY0NDQ0LCAwLjEzMTY3LCAwLCAwLjU5MTExXSxcbiAgICBcIjU4XCI6IFswLCAwLjQ0NDQ0LCAwLjA2Njk1LCAwLCAwLjM1NTU1XSxcbiAgICBcIjU5XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA2Njk1LCAwLCAwLjM1NTU1XSxcbiAgICBcIjYxXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMC4wNjgzMywgMCwgMC44ODU1NV0sXG4gICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMC4xMTQ3MiwgMCwgMC41OTExMV0sXG4gICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMC4wOTIwOCwgMCwgMC44ODU1NV0sXG4gICAgXCI2NVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44NjU1NV0sXG4gICAgXCI2NlwiOiBbMCwgMC42ODYxMSwgMC4wOTkyLCAwLCAwLjgxNjY2XSxcbiAgICBcIjY3XCI6IFswLCAwLjY4NjExLCAwLjE0MjA4LCAwLCAwLjgyNjY2XSxcbiAgICBcIjY4XCI6IFswLCAwLjY4NjExLCAwLjA5MDYyLCAwLCAwLjg3NTU1XSxcbiAgICBcIjY5XCI6IFswLCAwLjY4NjExLCAwLjExNDMxLCAwLCAwLjc1NjY2XSxcbiAgICBcIjcwXCI6IFswLCAwLjY4NjExLCAwLjEyOTAzLCAwLCAwLjcyNzIyXSxcbiAgICBcIjcxXCI6IFswLCAwLjY4NjExLCAwLjA3MzQ3LCAwLCAwLjg5NTI3XSxcbiAgICBcIjcyXCI6IFswLCAwLjY4NjExLCAwLjE3MjA4LCAwLCAwLjg5NjFdLFxuICAgIFwiNzNcIjogWzAsIDAuNjg2MTEsIDAuMTU2ODEsIDAsIDAuNDcxNjZdLFxuICAgIFwiNzRcIjogWzAsIDAuNjg2MTEsIDAuMTQ1LCAwLCAwLjYxMDU1XSxcbiAgICBcIjc1XCI6IFswLCAwLjY4NjExLCAwLjE0MjA4LCAwLCAwLjg5NDk5XSxcbiAgICBcIjc2XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjY5Nzc3XSxcbiAgICBcIjc3XCI6IFswLCAwLjY4NjExLCAwLjE3MjA4LCAwLCAxLjA3Mjc3XSxcbiAgICBcIjc4XCI6IFswLCAwLjY4NjExLCAwLjE3MjA4LCAwLCAwLjg5NjFdLFxuICAgIFwiNzlcIjogWzAsIDAuNjg2MTEsIDAuMDkwNjIsIDAsIDAuODU0OTldLFxuICAgIFwiODBcIjogWzAsIDAuNjg2MTEsIDAuMDk5MiwgMCwgMC43ODcyMV0sXG4gICAgXCI4MVwiOiBbMC4xOTQ0NCwgMC42ODYxMSwgMC4wOTA2MiwgMCwgMC44NTQ5OV0sXG4gICAgXCI4MlwiOiBbMCwgMC42ODYxMSwgMC4wMjU1OSwgMCwgMC44NTk0NF0sXG4gICAgXCI4M1wiOiBbMCwgMC42ODYxMSwgMC4xMTI2NCwgMCwgMC42NDk5OV0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODYxMSwgMC4xMjkwMywgMCwgMC43OTYxXSxcbiAgICBcIjg1XCI6IFswLCAwLjY4NjExLCAwLjE3MjA4LCAwLCAwLjg4MDgzXSxcbiAgICBcIjg2XCI6IFswLCAwLjY4NjExLCAwLjE4NjI1LCAwLCAwLjg2NTU1XSxcbiAgICBcIjg3XCI6IFswLCAwLjY4NjExLCAwLjE4NjI1LCAwLCAxLjE1OTk5XSxcbiAgICBcIjg4XCI6IFswLCAwLjY4NjExLCAwLjE1NjgxLCAwLCAwLjg2NTU1XSxcbiAgICBcIjg5XCI6IFswLCAwLjY4NjExLCAwLjE5ODAzLCAwLCAwLjg2NTU1XSxcbiAgICBcIjkwXCI6IFswLCAwLjY4NjExLCAwLjE0MjA4LCAwLCAwLjcwODg4XSxcbiAgICBcIjkxXCI6IFswLjI1LCAwLjc1LCAwLjE4NzUsIDAsIDAuMzU2MTFdLFxuICAgIFwiOTNcIjogWzAuMjUsIDAuNzUsIDAuMDk5NzIsIDAsIDAuMzU2MTFdLFxuICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAuMDY3MDksIDAsIDAuNTkxMTFdLFxuICAgIFwiOTVcIjogWzAuMzEsIDAuMTM0NDQsIDAuMDk4MTEsIDAsIDAuNTkxMTFdLFxuICAgIFwiOTdcIjogWzAsIDAuNDQ0NDQsIDAuMDk0MjYsIDAsIDAuNTkxMTFdLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAuMDc4NjEsIDAsIDAuNTMyMjJdLFxuICAgIFwiOTlcIjogWzAsIDAuNDQ0NDQsIDAuMDUyMjIsIDAsIDAuNTMyMjJdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLjEwODYxLCAwLCAwLjU5MTExXSxcbiAgICBcIjEwMVwiOiBbMCwgMC40NDQ0NCwgMC4wODUsIDAsIDAuNTMyMjJdLFxuICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjIxNzc4LCAwLCAwLjRdLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjEwNSwgMCwgMC41MzIyMl0sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAuMDk0MjYsIDAsIDAuNTkxMTFdLFxuICAgIFwiMTA1XCI6IFswLCAwLjY5MzI2LCAwLjExMzg3LCAwLCAwLjM1NTU1XSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42OTMyNiwgMC4xNjcyLCAwLCAwLjM1NTU1XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4xMTExMSwgMCwgMC41MzIyMl0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMTA4NjEsIDAsIDAuMjk2NjZdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLjA5NDI2LCAwLCAwLjk0NDQ0XSxcbiAgICBcIjExMFwiOiBbMCwgMC40NDQ0NCwgMC4wOTQyNiwgMCwgMC42NDk5OV0sXG4gICAgXCIxMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDc4NjEsIDAsIDAuNTkxMTFdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA3ODYxLCAwLCAwLjU5MTExXSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4xMDUsIDAsIDAuNTMyMjJdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQ0NDQ0LCAwLjExMTExLCAwLCAwLjUwMTY3XSxcbiAgICBcIjExNVwiOiBbMCwgMC40NDQ0NCwgMC4wODE2NywgMCwgMC40ODY5NF0sXG4gICAgXCIxMTZcIjogWzAsIDAuNjM0OTIsIDAuMDk2MzksIDAsIDAuMzg1XSxcbiAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMC4wOTQyNiwgMCwgMC42MjA1NV0sXG4gICAgXCIxMThcIjogWzAsIDAuNDQ0NDQsIDAuMTExMTEsIDAsIDAuNTMyMjJdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQ0NDQ0LCAwLjExMTExLCAwLCAwLjc2Nzc3XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMC4xMjU4MywgMCwgMC41NjA1NV0sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMTA1LCAwLCAwLjU2MTY2XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40NDQ0NCwgMC4xMzg4OSwgMCwgMC40OTA1NV0sXG4gICAgXCIxMjZcIjogWzAuMzUsIDAuMzQ0NDQsIDAuMTE0NzIsIDAsIDAuNTkxMTFdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjE2OFwiOiBbMCwgMC42OTQ0NCwgMC4xMTQ3MywgMCwgMC41OTExMV0sXG4gICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuOTQ4ODhdLFxuICAgIFwiMTg0XCI6IFswLjE3MDE0LCAwLCAwLCAwLCAwLjUzMjIyXSxcbiAgICBcIjE5OFwiOiBbMCwgMC42ODYxMSwgMC4xMTQzMSwgMCwgMS4wMjI3N10sXG4gICAgXCIyMTZcIjogWzAuMDQ4NjEsIDAuNzM0NzIsIDAuMDkwNjIsIDAsIDAuODg1NTVdLFxuICAgIFwiMjIzXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA5NzM2LCAwLCAwLjY2NV0sXG4gICAgXCIyMzBcIjogWzAsIDAuNDQ0NDQsIDAuMDg1LCAwLCAwLjgyNjY2XSxcbiAgICBcIjI0OFwiOiBbMC4wOTcyMiwgMC41NDE2NywgMC4wOTQ1OCwgMCwgMC41OTExMV0sXG4gICAgXCIzMDVcIjogWzAsIDAuNDQ0NDQsIDAuMDk0MjYsIDAsIDAuMzU1NTVdLFxuICAgIFwiMzM4XCI6IFswLCAwLjY4NjExLCAwLjExNDMxLCAwLCAxLjE0MDU0XSxcbiAgICBcIjMzOVwiOiBbMCwgMC40NDQ0NCwgMC4wODUsIDAsIDAuODI2NjZdLFxuICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA0NjExLCAwLCAwLjM4NV0sXG4gICAgXCI3MTBcIjogWzAsIDAuNjk0NDQsIDAuMDY3MDksIDAsIDAuNTkxMTFdLFxuICAgIFwiNzExXCI6IFswLCAwLjYzMTk0LCAwLjA4MjcxLCAwLCAwLjU5MTExXSxcbiAgICBcIjcxM1wiOiBbMCwgMC41OTQ0NCwgMC4xMDQ0NCwgMCwgMC41OTExMV0sXG4gICAgXCI3MTRcIjogWzAsIDAuNjk0NDQsIDAuMDg1MjgsIDAsIDAuNTkxMTFdLFxuICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU5MTExXSxcbiAgICBcIjcyOFwiOiBbMCwgMC42OTQ0NCwgMC4xMDMzMywgMCwgMC41OTExMV0sXG4gICAgXCI3MjlcIjogWzAsIDAuNjk0NDQsIDAuMTI5NDUsIDAsIDAuMzU1NTVdLFxuICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjk0ODg4XSxcbiAgICBcIjczMlwiOiBbMCwgMC42OTQ0NCwgMC4xMTQ3MiwgMCwgMC41OTExMV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAuMTE0NzIsIDAsIDAuNTkxMTFdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY4NjExLCAwLjEyOTAzLCAwLCAwLjY5Nzc3XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC45NDQ0NF0sXG4gICAgXCI5MjBcIjogWzAsIDAuNjg2MTEsIDAuMDkwNjIsIDAsIDAuODg1NTVdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgwNjY2XSxcbiAgICBcIjkyNlwiOiBbMCwgMC42ODYxMSwgMC4xNTA5MiwgMCwgMC43Njc3N10sXG4gICAgXCI5MjhcIjogWzAsIDAuNjg2MTEsIDAuMTcyMDgsIDAsIDAuODk2MV0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjg2MTEsIDAuMTE0MzEsIDAsIDAuODI2NjZdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY4NjExLCAwLjEwNzc4LCAwLCAwLjg4NTU1XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42ODYxMSwgMC4wNTYzMiwgMCwgMC44MjY2Nl0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjg2MTEsIDAuMTA3NzgsIDAsIDAuODg1NTVdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY4NjExLCAwLjA5OTIsIDAsIDAuODI2NjZdLFxuICAgIFwiODIxMVwiOiBbMCwgMC40NDQ0NCwgMC4wOTgxMSwgMCwgMC41OTExMV0sXG4gICAgXCI4MjEyXCI6IFswLCAwLjQ0NDQ0LCAwLjA5ODExLCAwLCAxLjE4MjIxXSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAuMTI5NDUsIDAsIDAuMzU1NTVdLFxuICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMC4xMjk0NSwgMCwgMC4zNTU1NV0sXG4gICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLjE2NzcyLCAwLCAwLjYyMDU1XSxcbiAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAuMDc5MzksIDAsIDAuNjIwNTVdXG4gIH0sXG4gIFwiTWFpbi1JdGFsaWNcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAuMTI0MTcsIDAsIDAuMzA2NjddLFxuICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAuMDY5NjEsIDAsIDAuNTE0NDRdLFxuICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDY2MTYsIDAsIDAuODE3NzddLFxuICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAuMTM2MzksIDAsIDAuODE3NzddLFxuICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAuMDk2OTQsIDAsIDAuNzY2NjZdLFxuICAgIFwiMzlcIjogWzAsIDAuNjk0NDQsIDAuMTI0MTcsIDAsIDAuMzA2NjddLFxuICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAuMTYxOTQsIDAsIDAuNDA4ODldLFxuICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAuMDM2OTQsIDAsIDAuNDA4ODldLFxuICAgIFwiNDJcIjogWzAsIDAuNzUsIDAuMTQ5MTcsIDAsIDAuNTExMTFdLFxuICAgIFwiNDNcIjogWzAuMDU2NjcsIDAuNTYxNjcsIDAuMDM2OTQsIDAsIDAuNzY2NjZdLFxuICAgIFwiNDRcIjogWzAuMTk0NDQsIDAuMTA1NTYsIDAsIDAsIDAuMzA2NjddLFxuICAgIFwiNDVcIjogWzAsIDAuNDMwNTYsIDAuMDI4MjYsIDAsIDAuMzU3NzhdLFxuICAgIFwiNDZcIjogWzAsIDAuMTA1NTYsIDAsIDAsIDAuMzA2NjddLFxuICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAuMTYxOTQsIDAsIDAuNTExMTFdLFxuICAgIFwiNDhcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNDlcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTBcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTFcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTJcIjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTNcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTRcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTVcIjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNTdcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDAsIDAuNTExMTFdLFxuICAgIFwiNThcIjogWzAsIDAuNDMwNTYsIDAuMDU4MiwgMCwgMC4zMDY2N10sXG4gICAgXCI1OVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNTgyLCAwLCAwLjMwNjY3XSxcbiAgICBcIjYxXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMC4wNjYxNiwgMCwgMC43NjY2Nl0sXG4gICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMC4xMjI1LCAwLCAwLjUxMTExXSxcbiAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLjA5NTk3LCAwLCAwLjc2NjY2XSxcbiAgICBcIjY1XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc0MzMzXSxcbiAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjEwMjU3LCAwLCAwLjcwMzg5XSxcbiAgICBcIjY3XCI6IFswLCAwLjY4MzMzLCAwLjE0NTI4LCAwLCAwLjcxNTU1XSxcbiAgICBcIjY4XCI6IFswLCAwLjY4MzMzLCAwLjA5NDAzLCAwLCAwLjc1NV0sXG4gICAgXCI2OVwiOiBbMCwgMC42ODMzMywgMC4xMjAyOCwgMCwgMC42NzgzM10sXG4gICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzMwNSwgMCwgMC42NTI3N10sXG4gICAgXCI3MVwiOiBbMCwgMC42ODMzMywgMC4wODcyMiwgMCwgMC43NzM2MV0sXG4gICAgXCI3MlwiOiBbMCwgMC42ODMzMywgMC4xNjM4OSwgMCwgMC43NDMzM10sXG4gICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4xNTgwNiwgMCwgMC4zODU1NV0sXG4gICAgXCI3NFwiOiBbMCwgMC42ODMzMywgMC4xNDAyOCwgMCwgMC41MjVdLFxuICAgIFwiNzVcIjogWzAsIDAuNjgzMzMsIDAuMTQ1MjgsIDAsIDAuNzY4ODhdLFxuICAgIFwiNzZcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjI3MjJdLFxuICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDAsIDAuODk2NjZdLFxuICAgIFwiNzhcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDAsIDAuNzQzMzNdLFxuICAgIFwiNzlcIjogWzAsIDAuNjgzMzMsIDAuMDk0MDMsIDAsIDAuNzY2NjZdLFxuICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTAyNTcsIDAsIDAuNjc4MzNdLFxuICAgIFwiODFcIjogWzAuMTk0NDQsIDAuNjgzMzMsIDAuMDk0MDMsIDAsIDAuNzY2NjZdLFxuICAgIFwiODJcIjogWzAsIDAuNjgzMzMsIDAuMDM4NjgsIDAsIDAuNzI5NDRdLFxuICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMTE5NzIsIDAsIDAuNTYyMjJdLFxuICAgIFwiODRcIjogWzAsIDAuNjgzMzMsIDAuMTMzMDUsIDAsIDAuNzE1NTVdLFxuICAgIFwiODVcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDAsIDAuNzQzMzNdLFxuICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMTgzNjEsIDAsIDAuNzQzMzNdLFxuICAgIFwiODdcIjogWzAsIDAuNjgzMzMsIDAuMTgzNjEsIDAsIDAuOTk4ODhdLFxuICAgIFwiODhcIjogWzAsIDAuNjgzMzMsIDAuMTU4MDYsIDAsIDAuNzQzMzNdLFxuICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMTkzODMsIDAsIDAuNzQzMzNdLFxuICAgIFwiOTBcIjogWzAsIDAuNjgzMzMsIDAuMTQ1MjgsIDAsIDAuNjEzMzNdLFxuICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAuMTg3NSwgMCwgMC4zMDY2N10sXG4gICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMC4xMDUyOCwgMCwgMC4zMDY2N10sXG4gICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMC4wNjY0NiwgMCwgMC41MTExMV0sXG4gICAgXCI5NVwiOiBbMC4zMSwgMC4xMjA1NiwgMC4wOTIwOCwgMCwgMC41MTExMV0sXG4gICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMCwgMC41MTExMV0sXG4gICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMC4wNjMxMiwgMCwgMC40Nl0sXG4gICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMC4wNTY1MywgMCwgMC40Nl0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAuMTAzMzMsIDAsIDAuNTExMTFdLFxuICAgIFwiMTAxXCI6IFswLCAwLjQzMDU2LCAwLjA3NTE0LCAwLCAwLjQ2XSxcbiAgICBcIjEwMlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4yMTE5NCwgMCwgMC4zMDY2N10sXG4gICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDg4NDcsIDAsIDAuNDZdLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLjA3NjcxLCAwLCAwLjUxMTExXSxcbiAgICBcIjEwNVwiOiBbMCwgMC42NTUzNiwgMC4xMDE5LCAwLCAwLjMwNjY3XSxcbiAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42NTUzNiwgMC4xNDQ2NywgMCwgMC4zMDY2N10sXG4gICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAuMTA3NjQsIDAsIDAuNDZdLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjEwMzMzLCAwLCAwLjI1NTU1XSxcbiAgICBcIjEwOVwiOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMCwgMC44MTc3N10sXG4gICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAuMDc2NzEsIDAsIDAuNTYyMjJdLFxuICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLjA2MzEyLCAwLCAwLjUxMTExXSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNjMxMiwgMCwgMC41MTExMV0sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDg4NDcsIDAsIDAuNDZdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLjEwNzY0LCAwLCAwLjQyMTY2XSxcbiAgICBcIjExNVwiOiBbMCwgMC40MzA1NiwgMC4wODIwOCwgMCwgMC40MDg4OV0sXG4gICAgXCIxMTZcIjogWzAsIDAuNjE1MDgsIDAuMDk0ODYsIDAsIDAuMzMyMjJdLFxuICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLjA3NjcxLCAwLCAwLjUzNjY2XSxcbiAgICBcIjExOFwiOiBbMCwgMC40MzA1NiwgMC4xMDc2NCwgMCwgMC40Nl0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAuMTA3NjQsIDAsIDAuNjY0NDRdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLjEyMDQyLCAwLCAwLjQ2Mzg5XSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wODg0NywgMCwgMC40ODU1NV0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAuMTIyOTIsIDAsIDAuNDA4ODldLFxuICAgIFwiMTI2XCI6IFswLjM1LCAwLjMxNzg2LCAwLjExNTg1LCAwLCAwLjUxMTExXSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIxNjhcIjogWzAsIDAuNjY3ODYsIDAuMTA0NzQsIDAsIDAuNTExMTFdLFxuICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMTI5XSxcbiAgICBcIjE4NFwiOiBbMC4xNzAxNCwgMCwgMCwgMCwgMC40Nl0sXG4gICAgXCIxOThcIjogWzAsIDAuNjgzMzMsIDAuMTIwMjgsIDAsIDAuODgyNzddLFxuICAgIFwiMjE2XCI6IFswLjA0ODYxLCAwLjczMTk0LCAwLjA5NDAzLCAwLCAwLjc2NjY2XSxcbiAgICBcIjIyM1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4xMDUxNCwgMCwgMC41MzY2Nl0sXG4gICAgXCIyMzBcIjogWzAsIDAuNDMwNTYsIDAuMDc1MTQsIDAsIDAuNzE1NTVdLFxuICAgIFwiMjQ4XCI6IFswLjA5NzIyLCAwLjUyNzc4LCAwLjA5MTk0LCAwLCAwLjUxMTExXSxcbiAgICBcIjMzOFwiOiBbMCwgMC42ODMzMywgMC4xMjAyOCwgMCwgMC45ODQ5OV0sXG4gICAgXCIzMzlcIjogWzAsIDAuNDMwNTYsIDAuMDc1MTQsIDAsIDAuNzE1NTVdLFxuICAgIFwiNzEwXCI6IFswLCAwLjY5NDQ0LCAwLjA2NjQ2LCAwLCAwLjUxMTExXSxcbiAgICBcIjcxMVwiOiBbMCwgMC42Mjg0NywgMC4wODI5NSwgMCwgMC41MTExMV0sXG4gICAgXCI3MTNcIjogWzAsIDAuNTYxNjcsIDAuMTAzMzMsIDAsIDAuNTExMTFdLFxuICAgIFwiNzE0XCI6IFswLCAwLjY5NDQ0LCAwLjA5Njk0LCAwLCAwLjUxMTExXSxcbiAgICBcIjcxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41MTExMV0sXG4gICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAuMTA4MDYsIDAsIDAuNTExMTFdLFxuICAgIFwiNzI5XCI6IFswLCAwLjY2Nzg2LCAwLjExNzUyLCAwLCAwLjMwNjY3XSxcbiAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44MzEyOV0sXG4gICAgXCI3MzJcIjogWzAsIDAuNjY3ODYsIDAuMTE1ODUsIDAsIDAuNTExMTFdLFxuICAgIFwiNzMzXCI6IFswLCAwLjY5NDQ0LCAwLjEyMjUsIDAsIDAuNTExMTFdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY4MzMzLCAwLjEzMzA1LCAwLCAwLjYyNzIyXSxcbiAgICBcIjkxNlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC44MTc3N10sXG4gICAgXCI5MjBcIjogWzAsIDAuNjgzMzMsIDAuMDk0MDMsIDAsIDAuNzY2NjZdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjY5MjIyXSxcbiAgICBcIjkyNlwiOiBbMCwgMC42ODMzMywgMC4xNTI5NCwgMCwgMC42NjQ0NF0sXG4gICAgXCI5MjhcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDAsIDAuNzQzMzNdLFxuICAgIFwiOTMxXCI6IFswLCAwLjY4MzMzLCAwLjEyMDI4LCAwLCAwLjcxNTU1XSxcbiAgICBcIjkzM1wiOiBbMCwgMC42ODMzMywgMC4xMTExMSwgMCwgMC43NjY2Nl0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjgzMzMsIDAuMDU5ODYsIDAsIDAuNzE1NTVdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY4MzMzLCAwLjExMTExLCAwLCAwLjc2NjY2XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42ODMzMywgMC4xMDI1NywgMCwgMC43MTU1NV0sXG4gICAgXCI4MjExXCI6IFswLCAwLjQzMDU2LCAwLjA5MjA4LCAwLCAwLjUxMTExXSxcbiAgICBcIjgyMTJcIjogWzAsIDAuNDMwNTYsIDAuMDkyMDgsIDAsIDEuMDIyMjJdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMC4xMjQxNywgMCwgMC4zMDY2N10sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwLCAwLjMwNjY3XSxcbiAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAuMTY4NSwgMCwgMC41MTQ0NF0sXG4gICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLjA2OTYxLCAwLCAwLjUxNDQ0XSxcbiAgICBcIjg0NjNcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTQwMjhdXG4gIH0sXG4gIFwiTWFpbi1SZWd1bGFyXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiMzZcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCIzOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI0MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI0MlwiOiBbMCwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjQzXCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjQ0XCI6IFswLjE5NDQ0LCAwLjEwNTU2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQ1XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjMzMzMzXSxcbiAgICBcIjQ2XCI6IFswLCAwLjEwNTU2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiNDhcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI0OVwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjUwXCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTFcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1MlwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjUzXCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTRcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1NVwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTdcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1OFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI1OVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI2MFwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNjFcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjYyXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI2NVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sXG4gICAgXCI2NlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MDgzNF0sXG4gICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI2OFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NjM4OV0sXG4gICAgXCI2OVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42ODA1Nl0sXG4gICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42NTI3OF0sXG4gICAgXCI3MVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43ODQ3Ml0sXG4gICAgXCI3MlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sXG4gICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMCwgMCwgMC4zNjExMV0sXG4gICAgXCI3NFwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC41MTM4OV0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42MjVdLFxuICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuOTE2NjddLFxuICAgIFwiNzhcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLFxuICAgIFwiNzlcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjgwNTZdLFxuICAgIFwiODFcIjogWzAuMTk0NDQsIDAuNjgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODJcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzM2MTFdLFxuICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODRcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODVcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLFxuICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMDEzODksIDAsIDAuNzVdLFxuICAgIFwiODdcIjogWzAsIDAuNjgzMzMsIDAuMDEzODksIDAsIDEuMDI3NzhdLFxuICAgIFwiODhcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLFxuICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMDI1LCAwLCAwLjc1XSxcbiAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjkxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjkyXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiOTNcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI5NVwiOiBbMC4zMSwgMC4xMjA1NiwgMC4wMjc3OCwgMCwgMC41XSxcbiAgICBcIjk3XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiOTlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIxMDJcIjogWzAsIDAuNjk0NDQsIDAuMDc3NzgsIDAsIDAuMzA1NTZdLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAxMzg5LCAwLCAwLjVdLFxuICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42Njc4NiwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjY3ODYsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNzc4XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjExMVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjM5MTY3XSxcbiAgICBcIjExNVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC4zOTQ0NV0sXG4gICAgXCIxMTZcIjogWzAsIDAuNjE1MDgsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjExOFwiOiBbMCwgMC40MzA1NiwgMC4wMTM4OSwgMCwgMC41Mjc3OF0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAuMDEzODksIDAsIDAuNzIyMjJdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNzc4XSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMTM4OSwgMCwgMC41Mjc3OF0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTIzXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiMTI0XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjEyNVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjEyNlwiOiBbMC4zNSwgMC4zMTc4NiwgMCwgMCwgMC41XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIxNjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzY5MDldLFxuICAgIFwiMTY3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjE2OFwiOiBbMCwgMC42Njc4NiwgMCwgMCwgMC41XSxcbiAgICBcIjE3MlwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzVdLFxuICAgIFwiMTc3XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjE4MlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sXG4gICAgXCIxODRcIjogWzAuMTcwMTQsIDAsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTk4XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjkwMjc4XSxcbiAgICBcIjIxNVwiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIyMTZcIjogWzAuMDQ4NjEsIDAuNzMxOTQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiMjIzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiMjMwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjI0N1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCIyNDhcIjogWzAuMDk3MjIsIDAuNTI3NzgsIDAsIDAsIDAuNV0sXG4gICAgXCIzMDVcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiMzM4XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAxLjAxMzg5XSxcbiAgICBcIjMzOVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiNzEwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzExXCI6IFswLCAwLjYyODQ3LCAwLCAwLCAwLjVdLFxuICAgIFwiNzEzXCI6IFswLCAwLjU2Nzc4LCAwLCAwLCAwLjVdLFxuICAgIFwiNzE0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzI4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzI5XCI6IFswLCAwLjY2Nzg2LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43NV0sXG4gICAgXCI3MzJcIjogWzAsIDAuNjY3ODYsIDAsIDAsIDAuNV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjI1XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI5MjBcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjY5NDQ1XSxcbiAgICBcIjkyNlwiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5MjhcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLFxuICAgIFwiOTMxXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjkzM1wiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4MjExXCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLCAwLjVdLFxuICAgIFwiODIxMlwiOiBbMCwgMC40MzA1NiwgMC4wMjc3OCwgMCwgMS4wXSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiODIyMVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjgyMjRcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiODIyNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCI4MjMwXCI6IFswLCAwLjEyMywgMCwgMCwgMS4xNzJdLFxuICAgIFwiODI0MlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC4yNzVdLFxuICAgIFwiODQwN1wiOiBbMCwgMC43MTQ0NCwgMC4xNTM4MiwgMCwgMC41XSxcbiAgICBcIjg0NjNcIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTQwMjhdLFxuICAgIFwiODQ2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NDY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLjExMTExLCAwLjQxNjY3XSxcbiAgICBcIjg0NzJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMTExMTEsIDAuNjM2NDZdLFxuICAgIFwiODQ3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI4NTAxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg1OTJcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODU5M1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjg1OTRcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODU5NVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41XSxcbiAgICBcIjg1OTZcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODU5N1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjg1OThcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMF0sXG4gICAgXCI4NTk5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjBdLFxuICAgIFwiODYwMFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4wXSxcbiAgICBcIjg2MDFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjE0XCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjE3XCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuMTI2XSxcbiAgICBcIjg2MThcIjogWzAuMDExLCAwLjUxMSwgMCwgMCwgMS4xMjZdLFxuICAgIFwiODYzNlwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjM3XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NDBcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY0MVwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjUyXCI6IFswLjAxMSwgMC42NzEsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjU2XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMS4wXSxcbiAgICBcIjg2NTdcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODY1OFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDEuMF0sXG4gICAgXCI4NjU5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg2NjBcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxLjBdLFxuICAgIFwiODY2MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC42MTExMV0sXG4gICAgXCI4NzA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg3MDZcIjogWzAsIDAuNjk0NDQsIDAuMDU1NTYsIDAuMDgzMzQsIDAuNTMwOV0sXG4gICAgXCI4NzA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjg3MDlcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzExXCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg3MTJcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3MTVcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3MjJcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODcyM1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4NzI1XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiODcyNlwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjg3MjdcIjogWy0wLjAzNDcyLCAwLjQ2NTI4LCAwLCAwLCAwLjVdLFxuICAgIFwiODcyOFwiOiBbLTAuMDU1NTUsIDAuNDQ0NDUsIDAsIDAsIDAuNV0sXG4gICAgXCI4NzI5XCI6IFstMC4wNTU1NSwgMC40NDQ0NSwgMCwgMCwgMC41XSxcbiAgICBcIjg3MzBcIjogWzAuMiwgMC44LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg3MzNcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODczNFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMS4wXSxcbiAgICBcIjg3MzZcIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiODczOVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4NzQxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiODc0M1wiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NzQ0XCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg3NDVcIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODc0NlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NzQ3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjExMTExLCAwLCAwLjQxNjY3XSxcbiAgICBcIjg3NjRcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg3NjhcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiODc3MVwiOiBbLTAuMDM2MjUsIDAuNDYzNzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc3M1wiOiBbLTAuMDIyLCAwLjU4OSwgMCwgMCwgMC43NzhdLFxuICAgIFwiODc3NlwiOiBbLTAuMDE2ODgsIDAuNDgzMTIsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc4MVwiOiBbLTAuMDM2MjUsIDAuNDYzNzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODc4NFwiOiBbLTAuMTMzLCAwLjY3MywgMCwgMCwgMC43NzhdLFxuICAgIFwiODgwMVwiOiBbLTAuMDM2MjUsIDAuNDYzNzUsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODgwNFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODA1XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MTBcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAxLjBdLFxuICAgIFwiODgxMVwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDEuMF0sXG4gICAgXCI4ODI2XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODI3XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODM0XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODM1XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODM4XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4MzlcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg0NlwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4ODQ5XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NTBcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg1MVwiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4ODUyXCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg4NTNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg1NFwiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODU1XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NTZcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODg1N1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODY2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYxMTExXSxcbiAgICBcIjg4NjdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODg2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI4ODY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg4NzJcIjogWzAuMjQ5LCAwLjc1LCAwLCAwLCAwLjg2N10sXG4gICAgXCI4OTAwXCI6IFstMC4wNTU1NSwgMC40NDQ0NSwgMCwgMCwgMC41XSxcbiAgICBcIjg5MDFcIjogWy0wLjA1NTU1LCAwLjQ0NDQ1LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjg5MDJcIjogWy0wLjAzNDcyLCAwLjQ2NTI4LCAwLCAwLCAwLjVdLFxuICAgIFwiODkwNFwiOiBbMC4wMDUsIDAuNTA1LCAwLCAwLCAwLjldLFxuICAgIFwiODk0MlwiOiBbMC4wMywgMC45MDMsIDAsIDAsIDAuMjc4XSxcbiAgICBcIjg5NDNcIjogWy0wLjE5LCAwLjMxMywgMCwgMCwgMS4xNzJdLFxuICAgIFwiODk0NVwiOiBbLTAuMSwgMC44MjMsIDAsIDAsIDEuMjgyXSxcbiAgICBcIjg5NjhcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiODk2OVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCI4OTcwXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjg5NzFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiODk5NFwiOiBbLTAuMTQyMzYsIDAuMzU3NjQsIDAsIDAsIDEuMF0sXG4gICAgXCI4OTk1XCI6IFstMC4xNDIzNiwgMC4zNTc2NCwgMCwgMCwgMS4wXSxcbiAgICBcIjkxMzZcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMCwgMC40MTJdLFxuICAgIFwiOTEzN1wiOiBbMC4yNDQsIDAuNzQ1LCAwLCAwLCAwLjQxMl0sXG4gICAgXCI5NjUxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjk2NTdcIjogWy0wLjAzNDcyLCAwLjQ2NTI4LCAwLCAwLCAwLjVdLFxuICAgIFwiOTY2MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5NjY3XCI6IFstMC4wMzQ3MiwgMC40NjUyOCwgMCwgMCwgMC41XSxcbiAgICBcIjk3MTFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMF0sXG4gICAgXCI5ODI0XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk4MjVcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTgyNlwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5ODI3XCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjk4MzdcIjogWzAsIDAuNzUsIDAsIDAsIDAuMzg4ODldLFxuICAgIFwiOTgzOFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC4zODg4OV0sXG4gICAgXCI5ODM5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjEwMjE2XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjEwMjE3XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjEwMjIyXCI6IFswLjI0NCwgMC43NDQsIDAsIDAsIDAuNDEyXSxcbiAgICBcIjEwMjIzXCI6IFswLjI0NCwgMC43NDUsIDAsIDAsIDAuNDEyXSxcbiAgICBcIjEwMjI5XCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuNjA5XSxcbiAgICBcIjEwMjMwXCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuNjM4XSxcbiAgICBcIjEwMjMxXCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuODU5XSxcbiAgICBcIjEwMjMyXCI6IFswLjAyNCwgMC41MjUsIDAsIDAsIDEuNjA5XSxcbiAgICBcIjEwMjMzXCI6IFswLjAyNCwgMC41MjUsIDAsIDAsIDEuNjM4XSxcbiAgICBcIjEwMjM0XCI6IFswLjAyNCwgMC41MjUsIDAsIDAsIDEuODU4XSxcbiAgICBcIjEwMjM2XCI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuNjM4XSxcbiAgICBcIjEwODE1XCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc1XSxcbiAgICBcIjEwOTI3XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjEwOTI4XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjU3Mzc2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwXVxuICB9LFxuICBcIk1hdGgtQm9sZEl0YWxpY1wiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI0OFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNDlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjUwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1MVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTJcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjUzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1NFwiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNTVcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNTc1XSxcbiAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sXG4gICAgXCI1N1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC41NzVdLFxuICAgIFwiNjVcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODY5NDRdLFxuICAgIFwiNjZcIjogWzAsIDAuNjg2MTEsIDAuMDQ4MzUsIDAsIDAuODY2NF0sXG4gICAgXCI2N1wiOiBbMCwgMC42ODYxMSwgMC4wNjk3OSwgMCwgMC44MTY5NF0sXG4gICAgXCI2OFwiOiBbMCwgMC42ODYxMSwgMC4wMzE5NCwgMCwgMC45MzgxMl0sXG4gICAgXCI2OVwiOiBbMCwgMC42ODYxMSwgMC4wNTQ1MSwgMCwgMC44MTAwN10sXG4gICAgXCI3MFwiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMCwgMC42ODg4OV0sXG4gICAgXCI3MVwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44ODY3M10sXG4gICAgXCI3MlwiOiBbMCwgMC42ODYxMSwgMC4wODIyOSwgMCwgMC45ODIyOV0sXG4gICAgXCI3M1wiOiBbMCwgMC42ODYxMSwgMC4wNzc3OCwgMCwgMC41MTExMV0sXG4gICAgXCI3NFwiOiBbMCwgMC42ODYxMSwgMC4xMDA2OSwgMCwgMC42MzEyNV0sXG4gICAgXCI3NVwiOiBbMCwgMC42ODYxMSwgMC4wNjk3OSwgMCwgMC45NzExOF0sXG4gICAgXCI3NlwiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC43NTU1NV0sXG4gICAgXCI3N1wiOiBbMCwgMC42ODYxMSwgMC4xMTQyNCwgMCwgMS4xNDIwMV0sXG4gICAgXCI3OFwiOiBbMCwgMC42ODYxMSwgMC4xMTQyNCwgMCwgMC45NTAzNF0sXG4gICAgXCI3OVwiOiBbMCwgMC42ODYxMSwgMC4wMzE5NCwgMCwgMC44MzY2Nl0sXG4gICAgXCI4MFwiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMCwgMC43MjMwOV0sXG4gICAgXCI4MVwiOiBbMC4xOTQ0NCwgMC42ODYxMSwgMCwgMCwgMC44Njg2MV0sXG4gICAgXCI4MlwiOiBbMCwgMC42ODYxMSwgMC4wMDQyMSwgMCwgMC44NzIzNV0sXG4gICAgXCI4M1wiOiBbMCwgMC42ODYxMSwgMC4wNTM4MiwgMCwgMC42OTI3MV0sXG4gICAgXCI4NFwiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMCwgMC42MzY2M10sXG4gICAgXCI4NVwiOiBbMCwgMC42ODYxMSwgMC4xMTQyNCwgMCwgMC44MDAyN10sXG4gICAgXCI4NlwiOiBbMCwgMC42ODYxMSwgMC4yNTU1NSwgMCwgMC42Nzc3OF0sXG4gICAgXCI4N1wiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMCwgMS4wOTMwNV0sXG4gICAgXCI4OFwiOiBbMCwgMC42ODYxMSwgMC4wNzc3OCwgMCwgMC45NDcyMl0sXG4gICAgXCI4OVwiOiBbMCwgMC42ODYxMSwgMC4yNTU1NSwgMCwgMC42NzQ1OF0sXG4gICAgXCI5MFwiOiBbMCwgMC42ODYxMSwgMC4wNjk3OSwgMCwgMC43NzI1N10sXG4gICAgXCI5N1wiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42MzI4N10sXG4gICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41MjA4M10sXG4gICAgXCI5OVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41MTM0Ml0sXG4gICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjA5NzJdLFxuICAgIFwiMTAxXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjU1MzYxXSxcbiAgICBcIjEwMlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4xMTA0MiwgMCwgMC41NjgwNl0sXG4gICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNTQ0OV0sXG4gICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY3NTldLFxuICAgIFwiMTA1XCI6IFswLCAwLjY5MzI2LCAwLCAwLCAwLjQwNDhdLFxuICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY5MzI2LCAwLjA2MjIsIDAsIDAuNDcwODNdLFxuICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjAxODUyLCAwLCAwLjYwMzddLFxuICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjAwODgsIDAsIDAuMzQ4MTVdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAxLjAzMjRdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjcxMjk2XSxcbiAgICBcIjExMVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41ODQ3Ml0sXG4gICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNjAwOTJdLFxuICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjU0MjEzXSxcbiAgICBcIjExNFwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMCwgMC41Mjg3XSxcbiAgICBcIjExNVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41MzEyNV0sXG4gICAgXCIxMTZcIjogWzAsIDAuNjM0OTIsIDAsIDAsIDAuNDE1MjhdLFxuICAgIFwiMTE3XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjY4MTAyXSxcbiAgICBcIjExOFwiOiBbMCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC41NjY2Nl0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDAsIDAuODMxNDhdLFxuICAgIFwiMTIwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjY1OTAzXSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC41OTAyOF0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDQ0NDQsIDAuMDQyMTMsIDAsIDAuNTU1MDldLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjkxNVwiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMCwgMC42NTY5NF0sXG4gICAgXCI5MTZcIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOTU4MzNdLFxuICAgIFwiOTIwXCI6IFswLCAwLjY4NjExLCAwLjAzMTk0LCAwLCAwLjg2NzIyXSxcbiAgICBcIjkyM1wiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MDU1NV0sXG4gICAgXCI5MjZcIjogWzAsIDAuNjg2MTEsIDAuMDc0NTgsIDAsIDAuODQxMjVdLFxuICAgIFwiOTI4XCI6IFswLCAwLjY4NjExLCAwLjA4MjI5LCAwLCAwLjk4MjI5XSxcbiAgICBcIjkzMVwiOiBbMCwgMC42ODYxMSwgMC4wNTQ1MSwgMCwgMC44ODUwN10sXG4gICAgXCI5MzNcIjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDAsIDAuNjcwODNdLFxuICAgIFwiOTM0XCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjc2NjY2XSxcbiAgICBcIjkzNlwiOiBbMCwgMC42ODYxMSwgMC4xMTY1MywgMCwgMC43MTQwMl0sXG4gICAgXCI5MzdcIjogWzAsIDAuNjg2MTEsIDAuMDQ4MzUsIDAsIDAuODc4OV0sXG4gICAgXCI5NDVcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNzYwNjRdLFxuICAgIFwiOTQ2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNDAzLCAwLCAwLjY1OTcyXSxcbiAgICBcIjk0N1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wNjM4OSwgMCwgMC41OTAwM10sXG4gICAgXCI5NDhcIjogWzAsIDAuNjk0NDQsIDAuMDM4MTksIDAsIDAuNTIyMjJdLFxuICAgIFwiOTQ5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUyODgyXSxcbiAgICBcIjk1MFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNjIxNSwgMCwgMC41MDgzM10sXG4gICAgXCI5NTFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNl0sXG4gICAgXCI5NTJcIjogWzAsIDAuNjk0NDQsIDAuMDMxOTQsIDAsIDAuNTYxOF0sXG4gICAgXCI5NTNcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDEyMDRdLFxuICAgIFwiOTU0XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjY2NzU5XSxcbiAgICBcIjk1NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NzA4M10sXG4gICAgXCI5NTZcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNzA3ODddLFxuICAgIFwiOTU3XCI6IFswLCAwLjQ0NDQ0LCAwLjA2ODk4LCAwLCAwLjU3Njg1XSxcbiAgICBcIjk1OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzAyMSwgMCwgMC41MDgzM10sXG4gICAgXCI5NTlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTg0NzJdLFxuICAgIFwiOTYwXCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjY4MjQxXSxcbiAgICBcIjk2MVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC42MTE4XSxcbiAgICBcIjk2MlwiOiBbMC4wOTcyMiwgMC40NDQ0NCwgMC4wNzkxNywgMCwgMC40MjM2MV0sXG4gICAgXCI5NjNcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNjg1ODhdLFxuICAgIFwiOTY0XCI6IFswLCAwLjQ0NDQ0LCAwLjEzNDcyLCAwLCAwLjUyMDgzXSxcbiAgICBcIjk2NVwiOiBbMCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC42MzA1NV0sXG4gICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNzQ3MjJdLFxuICAgIFwiOTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjcxODA1XSxcbiAgICBcIjk2OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzcwNCwgMCwgMC43NTgzM10sXG4gICAgXCI5NjlcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNzE3ODJdLFxuICAgIFwiOTc3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY5MTU1XSxcbiAgICBcIjk4MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC43MTI1XSxcbiAgICBcIjk4MlwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMCwgMC45NzVdLFxuICAgIFwiMTAwOVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC42MTE4XSxcbiAgICBcIjEwMTNcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDgzMzNdLFxuICAgIFwiNTc2NDlcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMzkzNTJdLFxuICAgIFwiNTc5MTFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNDM4ODldXG4gIH0sXG4gIFwiTWF0aC1JdGFsaWNcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNDhcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI0OVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjUwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1MlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjUzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTRcIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI1NVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41XSxcbiAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNTdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNV0sXG4gICAgXCI2NVwiOiBbMCwgMC42ODMzMywgMCwgMC4xMzg4OSwgMC43NV0sXG4gICAgXCI2NlwiOiBbMCwgMC42ODMzMywgMC4wNTAxNywgMC4wODMzNCwgMC43NTg1MV0sXG4gICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wODMzNCwgMC43MTQ3Ml0sXG4gICAgXCI2OFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wNTU1NiwgMC44Mjc5Ml0sXG4gICAgXCI2OVwiOiBbMCwgMC42ODMzMywgMC4wNTc2NCwgMC4wODMzNCwgMC43MzgyXSxcbiAgICBcIjcwXCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0LCAwLjY0MzA2XSxcbiAgICBcIjcxXCI6IFswLCAwLjY4MzMzLCAwLCAwLjA4MzM0LCAwLjc4NjI1XSxcbiAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLjA4MTI1LCAwLjA1NTU2LCAwLjgzMTI1XSxcbiAgICBcIjczXCI6IFswLCAwLjY4MzMzLCAwLjA3ODQ3LCAwLjExMTExLCAwLjQzOTU4XSxcbiAgICBcIjc0XCI6IFswLCAwLjY4MzMzLCAwLjA5NjE4LCAwLjE2NjY3LCAwLjU1NDUxXSxcbiAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA1NTU2LCAwLjg0OTMxXSxcbiAgICBcIjc2XCI6IFswLCAwLjY4MzMzLCAwLCAwLjAyNzc4LCAwLjY4MDU2XSxcbiAgICBcIjc3XCI6IFswLCAwLjY4MzMzLCAwLjEwOTAzLCAwLjA4MzM0LCAwLjk3MDE0XSxcbiAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjEwOTAzLCAwLjA4MzM0LCAwLjgwMzQ3XSxcbiAgICBcIjc5XCI6IFswLCAwLjY4MzMzLCAwLjAyNzc4LCAwLjA4MzM0LCAwLjc2Mjc4XSxcbiAgICBcIjgwXCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0LCAwLjY0MjAxXSxcbiAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLCAwLjA4MzM0LCAwLjc5MDU2XSxcbiAgICBcIjgyXCI6IFswLCAwLjY4MzMzLCAwLjAwNzczLCAwLjA4MzM0LCAwLjc1OTI5XSxcbiAgICBcIjgzXCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0LCAwLjYxMzJdLFxuICAgIFwiODRcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzQsIDAuNTg0MzhdLFxuICAgIFwiODVcIjogWzAsIDAuNjgzMzMsIDAuMTA5MDMsIDAuMDI3NzgsIDAuNjgyNzhdLFxuICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDAsIDAuNTgzMzNdLFxuICAgIFwiODdcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAsIDAuOTQ0NDVdLFxuICAgIFwiODhcIjogWzAsIDAuNjgzMzMsIDAuMDc4NDcsIDAuMDgzMzQsIDAuODI4NDddLFxuICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDAsIDAuNTgwNTZdLFxuICAgIFwiOTBcIjogWzAsIDAuNjgzMzMsIDAuMDcxNTMsIDAuMDgzMzQsIDAuNjgyNjRdLFxuICAgIFwiOTdcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI4NTldLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNDI5MTddLFxuICAgIFwiOTlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDMyNzZdLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLjE2NjY3LCAwLjUyMDQ5XSxcbiAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC40NjU2M10sXG4gICAgXCIxMDJcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMTA3NjQsIDAuMTY2NjcsIDAuNDg5NTldLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjAyNzc4LCAwLjQ3Njk3XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzYxNl0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjU5NTIsIDAsIDAsIDAuMzQ0NTFdLFxuICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY1OTUyLCAwLjA1NzI0LCAwLCAwLjQxMTgxXSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4wMzE0OCwgMCwgMC41MjA2XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMC4wMTk2OCwgMC4wODMzNCwgMC4yOTgzOF0sXG4gICAgXCIxMDlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuODc4MDFdLFxuICAgIFwiMTEwXCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjYwMDIzXSxcbiAgICBcIjExMVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC40ODQ3Ml0sXG4gICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzQsIDAuNTAzMTNdLFxuICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjA4MzM0LCAwLjQ0NjQxXSxcbiAgICBcIjExNFwiOiBbMCwgMC40MzA1NiwgMC4wMjc3OCwgMC4wNTU1NiwgMC40NTExNl0sXG4gICAgXCIxMTVcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDY4NzVdLFxuICAgIFwiMTE2XCI6IFswLCAwLjYxNTA4LCAwLCAwLjA4MzM0LCAwLjM2MTExXSxcbiAgICBcIjExN1wiOiBbMCwgMC40MzA1NiwgMCwgMC4wMjc3OCwgMC41NzI0Nl0sXG4gICAgXCIxMThcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzgsIDAuNDg0NzJdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQzMDU2LCAwLjAyNjkxLCAwLjA4MzM0LCAwLjcxNTkyXSxcbiAgICBcIjEyMFwiOiBbMCwgMC40MzA1NiwgMCwgMC4wMjc3OCwgMC41NzE1M10sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDU1NTYsIDAuNDkwMjhdLFxuICAgIFwiMTIyXCI6IFswLCAwLjQzMDU2LCAwLjA0Mzk4LCAwLjA1NTU2LCAwLjQ2NTA1XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzQsIDAuNjE1MjhdLFxuICAgIFwiOTE2XCI6IFswLCAwLjY4MzMzLCAwLCAwLjE2NjY3LCAwLjgzMzM0XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNCwgMC43NjI3OF0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTY2NjcsIDAuNjk0NDVdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY4MzMzLCAwLjA3NTY5LCAwLjA4MzM0LCAwLjc0MjM2XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42ODMzMywgMC4wODEyNSwgMC4wNTU1NiwgMC44MzEyNV0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzQsIDAuNzc5ODZdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA1NTU2LCAwLjU4MzMzXSxcbiAgICBcIjkzNFwiOiBbMCwgMC42ODMzMywgMCwgMC4wODMzNCwgMC42NjY2N10sXG4gICAgXCI5MzZcIjogWzAsIDAuNjgzMzMsIDAuMTEsIDAuMDU1NTYsIDAuNjEyMjJdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY4MzMzLCAwLjA1MDE3LCAwLjA4MzM0LCAwLjc3MjRdLFxuICAgIFwiOTQ1XCI6IFswLCAwLjQzMDU2LCAwLjAwMzcsIDAuMDI3NzgsIDAuNjM5N10sXG4gICAgXCI5NDZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDUyNzgsIDAuMDgzMzQsIDAuNTY1NjNdLFxuICAgIFwiOTQ3XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjA1NTU2LCAwLCAwLjUxNzczXSxcbiAgICBcIjk0OFwiOiBbMCwgMC42OTQ0NCwgMC4wMzc4NSwgMC4wNTU1NiwgMC40NDQ0NF0sXG4gICAgXCI5NDlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDgzMzQsIDAuNDY2MzJdLFxuICAgIFwiOTUwXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA3Mzc4LCAwLjA4MzM0LCAwLjQzNzVdLFxuICAgIFwiOTUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjA1NTU2LCAwLjQ5NjUzXSxcbiAgICBcIjk1MlwiOiBbMCwgMC42OTQ0NCwgMC4wMjc3OCwgMC4wODMzNCwgMC40Njk0NF0sXG4gICAgXCI5NTNcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuMzUzOTRdLFxuICAgIFwiOTU0XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjU3NjE2XSxcbiAgICBcIjk1NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCI5NTZcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDI3NzgsIDAuNjAyNTVdLFxuICAgIFwiOTU3XCI6IFswLCAwLjQzMDU2LCAwLjA2MzY2LCAwLjAyNzc4LCAwLjQ5Mzk4XSxcbiAgICBcIjk1OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNDYwMSwgMC4xMTExMSwgMC40Mzc1XSxcbiAgICBcIjk1OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC40ODQ3Ml0sXG4gICAgXCI5NjBcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAsIDAuNTcwMDNdLFxuICAgIFwiOTYxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjA4MzM0LCAwLjUxNzAyXSxcbiAgICBcIjk2MlwiOiBbMC4wOTcyMiwgMC40MzA1NiwgMC4wNzk4NiwgMC4wODMzNCwgMC4zNjI4NV0sXG4gICAgXCI5NjNcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAsIDAuNTcxNDFdLFxuICAgIFwiOTY0XCI6IFswLCAwLjQzMDU2LCAwLjExMzIsIDAuMDI3NzgsIDAuNDM3MTVdLFxuICAgIFwiOTY1XCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLjAyNzc4LCAwLjU0MDI4XSxcbiAgICBcIjk2NlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC42NTQxN10sXG4gICAgXCI5NjdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNjI1NjldLFxuICAgIFwiOTY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNTg4LCAwLjExMTExLCAwLjY1MTM5XSxcbiAgICBcIjk2OVwiOiBbMCwgMC40MzA1NiwgMC4wMzU4OCwgMCwgMC42MjI0NV0sXG4gICAgXCI5NzdcIjogWzAsIDAuNjk0NDQsIDAsIDAuMDgzMzQsIDAuNTkxNDRdLFxuICAgIFwiOTgxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLjA4MzM0LCAwLjU5NTgzXSxcbiAgICBcIjk4MlwiOiBbMCwgMC40MzA1NiwgMC4wMjc3OCwgMCwgMC44MjgxM10sXG4gICAgXCIxMDA5XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjA4MzM0LCAwLjUxNzAyXSxcbiAgICBcIjEwMTNcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDA1OV0sXG4gICAgXCI1NzY0OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wMjc3OCwgMC4zMjI0Nl0sXG4gICAgXCI1NzkxMVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC4zODQwM11cbiAgfSxcbiAgXCJTYW5zU2VyaWYtQm9sZFwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIzM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zNjY2N10sXG4gICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTgzNF0sXG4gICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC45MTY2N10sXG4gICAgXCIzNlwiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC41NV0sXG4gICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMS4wMjkxMl0sXG4gICAgXCIzOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44MzA1Nl0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40Mjc3OF0sXG4gICAgXCI0MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40Mjc3OF0sXG4gICAgXCI0MlwiOiBbMCwgMC43NSwgMCwgMCwgMC41NV0sXG4gICAgXCI0M1wiOiBbMC4xMTY2NywgMC42MTY2NywgMCwgMCwgMC44NTU1Nl0sXG4gICAgXCI0NFwiOiBbMC4xMDU1NiwgMC4xMzA1NiwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI0NVwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC4zNjY2N10sXG4gICAgXCI0NlwiOiBbMCwgMC4xMzA1NiwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NV0sXG4gICAgXCI0OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI0OVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1MFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1MVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1MlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1M1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1N1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI1OFwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI1OVwiOiBbMC4xMDU1NiwgMC40NTgzMywgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI2MVwiOiBbLTAuMDkzNzUsIDAuNDA2MjUsIDAsIDAsIDAuODU1NTZdLFxuICAgIFwiNjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTE5NDVdLFxuICAgIFwiNjRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiNjVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiNjZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiNjdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzhdLFxuICAgIFwiNjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiNjlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjQxNjddLFxuICAgIFwiNzBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiNzFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiNzJcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiNzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzMwNTZdLFxuICAgIFwiNzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTE5NDVdLFxuICAgIFwiNzVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzYzODldLFxuICAgIFwiNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTgwNTZdLFxuICAgIFwiNzdcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuOTc3NzhdLFxuICAgIFwiNzhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiNzlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiODBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzhdLFxuICAgIFwiODFcIjogWzAuMTA1NTYsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiODJcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzhdLFxuICAgIFwiODNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiODRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiODVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzYzODldLFxuICAgIFwiODZcIjogWzAsIDAuNjk0NDQsIDAuMDE1MjgsIDAsIDAuNzMzMzRdLFxuICAgIFwiODdcIjogWzAsIDAuNjk0NDQsIDAuMDE1MjgsIDAsIDEuMDM4ODldLFxuICAgIFwiODhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiODlcIjogWzAsIDAuNjk0NDQsIDAuMDI3NSwgMCwgMC43MzMzNF0sXG4gICAgXCI5MFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NzIyM10sXG4gICAgXCI5MVwiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zNDMwNl0sXG4gICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zNDMwNl0sXG4gICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI5NVwiOiBbMC4zNSwgMC4xMDgzMywgMC4wMzA1NiwgMCwgMC41NV0sXG4gICAgXCI5N1wiOiBbMCwgMC40NTgzMywgMCwgMCwgMC41MjVdLFxuICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTYxMTFdLFxuICAgIFwiOTlcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNDg4ODldLFxuICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU2MTExXSxcbiAgICBcIjEwMVwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC41MTExMV0sXG4gICAgXCIxMDJcIjogWzAsIDAuNjk0NDQsIDAuMDc2MzksIDAsIDAuMzM2MTFdLFxuICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ1ODMzLCAwLjAxNTI4LCAwLCAwLjU1XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NjExMV0sXG4gICAgXCIxMDVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjU1NTZdLFxuICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjI4NjExXSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41MzA1Nl0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjU1NTZdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjg2NjY3XSxcbiAgICBcIjExMFwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC41NjExMV0sXG4gICAgXCIxMTFcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNTVdLFxuICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ1ODMzLCAwLCAwLCAwLjU2MTExXSxcbiAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40NTgzMywgMCwgMCwgMC41NjExMV0sXG4gICAgXCIxMTRcIjogWzAsIDAuNDU4MzMsIDAuMDE1MjgsIDAsIDAuMzcyMjJdLFxuICAgIFwiMTE1XCI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjQyMTY3XSxcbiAgICBcIjExNlwiOiBbMCwgMC41ODkyOSwgMCwgMCwgMC40MDQxN10sXG4gICAgXCIxMTdcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNTYxMTFdLFxuICAgIFwiMTE4XCI6IFswLCAwLjQ1ODMzLCAwLjAxNTI4LCAwLCAwLjVdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQ1ODMzLCAwLjAxNTI4LCAwLCAwLjc0NDQ1XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC41XSxcbiAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40NTgzMywgMC4wMTUyOCwgMCwgMC41XSxcbiAgICBcIjEyMlwiOiBbMCwgMC40NTgzMywgMCwgMCwgMC40NzYzOV0sXG4gICAgXCIxMjZcIjogWzAuMzUsIDAuMzQ0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjE2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLFxuICAgIFwiMTgwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSxcbiAgICBcIjE4NFwiOiBbMC4xNzAxNCwgMCwgMCwgMCwgMC40ODg4OV0sXG4gICAgXCIzMDVcIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuMjU1NTZdLFxuICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ1ODMzLCAwLCAwLCAwLjI4NjExXSxcbiAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI3MTFcIjogWzAsIDAuNjM1NDIsIDAsIDAsIDAuNTVdLFxuICAgIFwiNzEzXCI6IFswLCAwLjYzNzc4LCAwLCAwLCAwLjU1XSxcbiAgICBcIjcyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI3MjlcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzA1NTZdLFxuICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSxcbiAgICBcIjczMlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLFxuICAgIFwiOTE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU4MDU2XSxcbiAgICBcIjkxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC45MTY2N10sXG4gICAgXCI5MjBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODU1NTZdLFxuICAgIFwiOTIzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY3MjIzXSxcbiAgICBcIjkyNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MzMzNF0sXG4gICAgXCI5MjhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiOTMxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjkzM1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44NTU1Nl0sXG4gICAgXCI5MzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLFxuICAgIFwiOTM2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg1NTU2XSxcbiAgICBcIjkzN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43OTQ0NV0sXG4gICAgXCI4MjExXCI6IFswLCAwLjQ1ODMzLCAwLjAzMDU2LCAwLCAwLjU1XSxcbiAgICBcIjgyMTJcIjogWzAsIDAuNDU4MzMsIDAuMDMwNTYsIDAsIDEuMTAwMDFdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMDU1Nl0sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMwNTU2XSxcbiAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU4MzRdLFxuICAgIFwiODIyMVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTgzNF1cbiAgfSxcbiAgXCJTYW5zU2VyaWYtSXRhbGljXCI6IHtcbiAgICBcIjMyXCI6IFswLCAwLCAwLCAwLCAwLjI1XSxcbiAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLjA1NzMzLCAwLCAwLjMxOTQ1XSxcbiAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLjAwMzE2LCAwLCAwLjVdLFxuICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDUwODcsIDAsIDAuODMzMzRdLFxuICAgIFwiMzZcIjogWzAuMDU1NTYsIDAuNzUsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMC4wMzEyNiwgMCwgMC44MzMzNF0sXG4gICAgXCIzOFwiOiBbMCwgMC42OTQ0NCwgMC4wMzA1OCwgMCwgMC43NTgzNF0sXG4gICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMC4wNzgxNiwgMCwgMC4yNzc3OF0sXG4gICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMC4xMzE2NCwgMCwgMC4zODg4OV0sXG4gICAgXCI0MVwiOiBbMC4yNSwgMC43NSwgMC4wMjUzNiwgMCwgMC4zODg4OV0sXG4gICAgXCI0MlwiOiBbMCwgMC43NSwgMC4xMTc3NSwgMCwgMC41XSxcbiAgICBcIjQzXCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLjAyNTM2LCAwLCAwLjc3Nzc4XSxcbiAgICBcIjQ0XCI6IFswLjEyNSwgMC4wODMzMywgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI0NVwiOiBbMCwgMC40NDQ0NCwgMC4wMTk0NiwgMCwgMC4zMzMzM10sXG4gICAgXCI0NlwiOiBbMCwgMC4wODMzMywgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMC4xMzE2NCwgMCwgMC41XSxcbiAgICBcIjQ4XCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNDlcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1MFwiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjUxXCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNTJcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1M1wiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjU0XCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNTVcIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sXG4gICAgXCI1NlwiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSxcbiAgICBcIjU3XCI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLFxuICAgIFwiNThcIjogWzAsIDAuNDQ0NDQsIDAuMDI1MDIsIDAsIDAuMjc3NzhdLFxuICAgIFwiNTlcIjogWzAuMTI1LCAwLjQ0NDQ0LCAwLjAyNTAyLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjYxXCI6IFstMC4xMywgMC4zNywgMC4wNTA4NywgMCwgMC43Nzc3OF0sXG4gICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMC4xMTgwOSwgMCwgMC40NzIyMl0sXG4gICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMC4wNzU1NSwgMCwgMC42NjY2N10sXG4gICAgXCI2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI2NlwiOiBbMCwgMC42OTQ0NCwgMC4wODI5MywgMCwgMC42NjY2N10sXG4gICAgXCI2N1wiOiBbMCwgMC42OTQ0NCwgMC4xMTk4MywgMCwgMC42Mzg4OV0sXG4gICAgXCI2OFwiOiBbMCwgMC42OTQ0NCwgMC4wNzU1NSwgMCwgMC43MjIyM10sXG4gICAgXCI2OVwiOiBbMCwgMC42OTQ0NCwgMC4xMTk4MywgMCwgMC41OTcyMl0sXG4gICAgXCI3MFwiOiBbMCwgMC42OTQ0NCwgMC4xMzM3MiwgMCwgMC41Njk0NV0sXG4gICAgXCI3MVwiOiBbMCwgMC42OTQ0NCwgMC4xMTk4MywgMCwgMC42NjY2N10sXG4gICAgXCI3MlwiOiBbMCwgMC42OTQ0NCwgMC4wODA5NCwgMCwgMC43MDgzNF0sXG4gICAgXCI3M1wiOiBbMCwgMC42OTQ0NCwgMC4xMzM3MiwgMCwgMC4yNzc3OF0sXG4gICAgXCI3NFwiOiBbMCwgMC42OTQ0NCwgMC4wODA5NCwgMCwgMC40NzIyMl0sXG4gICAgXCI3NVwiOiBbMCwgMC42OTQ0NCwgMC4xMTk4MywgMCwgMC42OTQ0NV0sXG4gICAgXCI3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NDE2N10sXG4gICAgXCI3N1wiOiBbMCwgMC42OTQ0NCwgMC4wODA5NCwgMCwgMC44NzVdLFxuICAgIFwiNzhcIjogWzAsIDAuNjk0NDQsIDAuMDgwOTQsIDAsIDAuNzA4MzRdLFxuICAgIFwiNzlcIjogWzAsIDAuNjk0NDQsIDAuMDc1NTUsIDAsIDAuNzM2MTFdLFxuICAgIFwiODBcIjogWzAsIDAuNjk0NDQsIDAuMDgyOTMsIDAsIDAuNjM4ODldLFxuICAgIFwiODFcIjogWzAuMTI1LCAwLjY5NDQ0LCAwLjA3NTU1LCAwLCAwLjczNjExXSxcbiAgICBcIjgyXCI6IFswLCAwLjY5NDQ0LCAwLjA4MjkzLCAwLCAwLjY0NTg0XSxcbiAgICBcIjgzXCI6IFswLCAwLjY5NDQ0LCAwLjA5MjA1LCAwLCAwLjU1NTU2XSxcbiAgICBcIjg0XCI6IFswLCAwLjY5NDQ0LCAwLjEzMzcyLCAwLCAwLjY4MDU2XSxcbiAgICBcIjg1XCI6IFswLCAwLjY5NDQ0LCAwLjA4MDk0LCAwLCAwLjY4NzVdLFxuICAgIFwiODZcIjogWzAsIDAuNjk0NDQsIDAuMTYxNSwgMCwgMC42NjY2N10sXG4gICAgXCI4N1wiOiBbMCwgMC42OTQ0NCwgMC4xNjE1LCAwLCAwLjk0NDQ1XSxcbiAgICBcIjg4XCI6IFswLCAwLjY5NDQ0LCAwLjEzMzcyLCAwLCAwLjY2NjY3XSxcbiAgICBcIjg5XCI6IFswLCAwLjY5NDQ0LCAwLjE3MjYxLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkwXCI6IFswLCAwLjY5NDQ0LCAwLjExOTgzLCAwLCAwLjYxMTExXSxcbiAgICBcIjkxXCI6IFswLjI1LCAwLjc1LCAwLjE1OTQyLCAwLCAwLjI4ODg5XSxcbiAgICBcIjkzXCI6IFswLjI1LCAwLjc1LCAwLjA4NzE5LCAwLCAwLjI4ODg5XSxcbiAgICBcIjk0XCI6IFswLCAwLjY5NDQ0LCAwLjA3OTksIDAsIDAuNV0sXG4gICAgXCI5NVwiOiBbMC4zNSwgMC4wOTQ0NCwgMC4wODYxNiwgMCwgMC41XSxcbiAgICBcIjk3XCI6IFswLCAwLjQ0NDQ0LCAwLjAwOTgxLCAwLCAwLjQ4MDU2XSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLjAzMDU3LCAwLCAwLjUxNjY3XSxcbiAgICBcIjk5XCI6IFswLCAwLjQ0NDQ0LCAwLjA4MzM2LCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMC4wOTQ4MywgMCwgMC41MTY2N10sXG4gICAgXCIxMDFcIjogWzAsIDAuNDQ0NDQsIDAuMDY3NzgsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTAyXCI6IFswLCAwLjY5NDQ0LCAwLjIxNzA1LCAwLCAwLjMwNTU2XSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4xMDgzNiwgMCwgMC41XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMC4wMTc3OCwgMCwgMC41MTY2N10sXG4gICAgXCIxMDVcIjogWzAsIDAuNjc5MzcsIDAuMDk3MTgsIDAsIDAuMjM4ODldLFxuICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY3OTM3LCAwLjA5MTYyLCAwLCAwLjI2NjY3XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4wODMzNiwgMCwgMC40ODg4OV0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMDk0ODMsIDAsIDAuMjM4ODldLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLjAxNzc4LCAwLCAwLjc5NDQ1XSxcbiAgICBcIjExMFwiOiBbMCwgMC40NDQ0NCwgMC4wMTc3OCwgMCwgMC41MTY2N10sXG4gICAgXCIxMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDY2MTMsIDAsIDAuNV0sXG4gICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM4OSwgMCwgMC41MTY2N10sXG4gICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDQxNjksIDAsIDAuNTE2NjddLFxuICAgIFwiMTE0XCI6IFswLCAwLjQ0NDQ0LCAwLjEwODM2LCAwLCAwLjM0MTY3XSxcbiAgICBcIjExNVwiOiBbMCwgMC40NDQ0NCwgMC4wNzc4LCAwLCAwLjM4MzMzXSxcbiAgICBcIjExNlwiOiBbMCwgMC41NzE0MywgMC4wNzIyNSwgMCwgMC4zNjExMV0sXG4gICAgXCIxMTdcIjogWzAsIDAuNDQ0NDQsIDAuMDQxNjksIDAsIDAuNTE2NjddLFxuICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjEwODM2LCAwLCAwLjQ2MTExXSxcbiAgICBcIjExOVwiOiBbMCwgMC40NDQ0NCwgMC4xMDgzNiwgMCwgMC42ODMzNF0sXG4gICAgXCIxMjBcIjogWzAsIDAuNDQ0NDQsIDAuMDkxNjksIDAsIDAuNDYxMTFdLFxuICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjEwODM2LCAwLCAwLjQ2MTExXSxcbiAgICBcIjEyMlwiOiBbMCwgMC40NDQ0NCwgMC4wODc1MiwgMCwgMC40MzQ3Ml0sXG4gICAgXCIxMjZcIjogWzAuMzUsIDAuMzI2NTksIDAuMDg4MjYsIDAsIDAuNV0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMTY4XCI6IFswLCAwLjY3OTM3LCAwLjA2Mzg1LCAwLCAwLjVdLFxuICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczNzUyXSxcbiAgICBcIjE4NFwiOiBbMC4xNzAxNCwgMCwgMCwgMCwgMC40NDQ0NV0sXG4gICAgXCIzMDVcIjogWzAsIDAuNDQ0NDQsIDAuMDQxNjksIDAsIDAuMjM4ODldLFxuICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA0MTY5LCAwLCAwLjI2NjY3XSxcbiAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMC4wNzk5LCAwLCAwLjVdLFxuICAgIFwiNzExXCI6IFswLCAwLjYzMTk0LCAwLjA4NDMyLCAwLCAwLjVdLFxuICAgIFwiNzEzXCI6IFswLCAwLjYwODg5LCAwLjA4Nzc2LCAwLCAwLjVdLFxuICAgIFwiNzE0XCI6IFswLCAwLjY5NDQ0LCAwLjA5MjA1LCAwLCAwLjVdLFxuICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzI4XCI6IFswLCAwLjY5NDQ0LCAwLjA5NDgzLCAwLCAwLjVdLFxuICAgIFwiNzI5XCI6IFswLCAwLjY3OTM3LCAwLjA3Nzc0LCAwLCAwLjI3Nzc4XSxcbiAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Mzc1Ml0sXG4gICAgXCI3MzJcIjogWzAsIDAuNjc2NTksIDAuMDg4MjYsIDAsIDAuNV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAuMDkyMDUsIDAsIDAuNV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjk0NDQsIDAuMTMzNzIsIDAsIDAuNTQxNjddLFxuICAgIFwiOTE2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42OTQ0NCwgMC4wNzU1NSwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY5NDQ0LCAwLjEyODE2LCAwLCAwLjY2NjY3XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42OTQ0NCwgMC4wODA5NCwgMCwgMC43MDgzNF0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjk0NDQsIDAuMTE5ODMsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY5NDQ0LCAwLjA5MDMxLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42OTQ0NCwgMC4wNDYwMywgMCwgMC43MjIyMl0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjk0NDQsIDAuMDkwMzEsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY5NDQ0LCAwLjA4MjkzLCAwLCAwLjcyMjIyXSxcbiAgICBcIjgyMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDg2MTYsIDAsIDAuNV0sXG4gICAgXCI4MjEyXCI6IFswLCAwLjQ0NDQ0LCAwLjA4NjE2LCAwLCAxLjBdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMC4wNzgxNiwgMCwgMC4yNzc3OF0sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLjA3ODE2LCAwLCAwLjI3Nzc4XSxcbiAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAuMTQyMDUsIDAsIDAuNV0sXG4gICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLjAwMzE2LCAwLCAwLjVdXG4gIH0sXG4gIFwiU2Fuc1NlcmlmLVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzE5NDVdLFxuICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCIzNlwiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC41XSxcbiAgICBcIjM3XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc1ODM0XSxcbiAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQwXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjM4ODg5XSxcbiAgICBcIjQyXCI6IFswLCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiNDNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiNDRcIjogWzAuMTI1LCAwLjA4MzMzLCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQ1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjMzMzMzXSxcbiAgICBcIjQ2XCI6IFswLCAwLjA4MzMzLCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLFxuICAgIFwiNDhcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI0OVwiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjUwXCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTFcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1MlwiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjUzXCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTRcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1NVwiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSxcbiAgICBcIjU2XCI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLFxuICAgIFwiNTdcIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sXG4gICAgXCI1OFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI1OVwiOiBbMC4xMjUsIDAuNDQ0NDQsIDAsIDAsIDAuMjc3NzhdLFxuICAgIFwiNjFcIjogWy0wLjEzLCAwLjM3LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjY1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjY2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcyMjIzXSxcbiAgICBcIjY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU5NzIyXSxcbiAgICBcIjcwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU2OTQ1XSxcbiAgICBcIjcxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjcyXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwODM0XSxcbiAgICBcIjczXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjc0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjc1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY5NDQ1XSxcbiAgICBcIjc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU0MTY3XSxcbiAgICBcIjc3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg3NV0sXG4gICAgXCI3OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDgzNF0sXG4gICAgXCI3OVwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MzYxMV0sXG4gICAgXCI4MFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI4MVwiOiBbMC4xMjUsIDAuNjk0NDQsIDAsIDAsIDAuNzM2MTFdLFxuICAgIFwiODJcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjQ1ODRdLFxuICAgIFwiODNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjgwNTZdLFxuICAgIFwiODVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjg3NV0sXG4gICAgXCI4NlwiOiBbMCwgMC42OTQ0NCwgMC4wMTM4OSwgMCwgMC42NjY2N10sXG4gICAgXCI4N1wiOiBbMCwgMC42OTQ0NCwgMC4wMTM4OSwgMCwgMC45NDQ0NV0sXG4gICAgXCI4OFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4OVwiOiBbMCwgMC42OTQ0NCwgMC4wMjUsIDAsIDAuNjY2NjddLFxuICAgIFwiOTBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMjg4ODldLFxuICAgIFwiOTNcIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMjg4ODldLFxuICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI5NVwiOiBbMC4zNSwgMC4wOTQ0NCwgMC4wMjc3OCwgMCwgMC41XSxcbiAgICBcIjk3XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQ4MDU2XSxcbiAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUxNjY3XSxcbiAgICBcIjk5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41MTY2N10sXG4gICAgXCIxMDFcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDQ0NDVdLFxuICAgIFwiMTAyXCI6IFswLCAwLjY5NDQ0LCAwLjA2OTQ0LCAwLCAwLjMwNTU2XSxcbiAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMTM4OSwgMCwgMC41XSxcbiAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41MTY2N10sXG4gICAgXCIxMDVcIjogWzAsIDAuNjc5MzcsIDAsIDAsIDAuMjM4ODldLFxuICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY3OTM3LCAwLCAwLCAwLjI2NjY3XSxcbiAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC40ODg4OV0sXG4gICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjM4ODldLFxuICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjc5NDQ1XSxcbiAgICBcIjExMFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41MTY2N10sXG4gICAgXCIxMTFcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNTE2NjddLFxuICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjUxNjY3XSxcbiAgICBcIjExNFwiOiBbMCwgMC40NDQ0NCwgMC4wMTM4OSwgMCwgMC4zNDE2N10sXG4gICAgXCIxMTVcIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMzgzMzNdLFxuICAgIFwiMTE2XCI6IFswLCAwLjU3MTQzLCAwLCAwLCAwLjM2MTExXSxcbiAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41MTY2N10sXG4gICAgXCIxMThcIjogWzAsIDAuNDQ0NDQsIDAuMDEzODksIDAsIDAuNDYxMTFdLFxuICAgIFwiMTE5XCI6IFswLCAwLjQ0NDQ0LCAwLjAxMzg5LCAwLCAwLjY4MzM0XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40NjExMV0sXG4gICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDEzODksIDAsIDAuNDYxMTFdLFxuICAgIFwiMTIyXCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQzNDcyXSxcbiAgICBcIjEyNlwiOiBbMC4zNSwgMC4zMjY1OSwgMCwgMCwgMC41XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCIxNjhcIjogWzAsIDAuNjc5MzcsIDAsIDAsIDAuNV0sXG4gICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiMTg0XCI6IFswLjE3MDE0LCAwLCAwLCAwLCAwLjQ0NDQ1XSxcbiAgICBcIjMwNVwiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC4yMzg4OV0sXG4gICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuMjY2NjddLFxuICAgIFwiNzEwXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzExXCI6IFswLCAwLjYzMTk0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzEzXCI6IFswLCAwLjYwODg5LCAwLCAwLCAwLjVdLFxuICAgIFwiNzE0XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzI4XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLFxuICAgIFwiNzI5XCI6IFswLCAwLjY3OTM3LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI3MzJcIjogWzAsIDAuNjc2NTksIDAsIDAsIDAuNV0sXG4gICAgXCI3MzNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI5MTVcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTQxNjddLFxuICAgIFwiOTE2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sXG4gICAgXCI5MjNcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiOTI2XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDgzNF0sXG4gICAgXCI5MzFcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzIyMjJdLFxuICAgIFwiOTMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MjIyMl0sXG4gICAgXCI5MzZcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiOTM3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcyMjIyXSxcbiAgICBcIjgyMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDAsIDAuNV0sXG4gICAgXCI4MjEyXCI6IFswLCAwLjQ0NDQ0LCAwLjAyNzc4LCAwLCAxLjBdLFxuICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sXG4gICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSxcbiAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sXG4gICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdXG4gIH0sXG4gIFwiU2NyaXB0LVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNjVcIjogWzAsIDAuNywgMC4yMjkyNSwgMCwgMC44MDI1M10sXG4gICAgXCI2NlwiOiBbMCwgMC43LCAwLjA0MDg3LCAwLCAwLjkwNzU3XSxcbiAgICBcIjY3XCI6IFswLCAwLjcsIDAuMTY4OSwgMCwgMC42NjYxOV0sXG4gICAgXCI2OFwiOiBbMCwgMC43LCAwLjA5MzcxLCAwLCAwLjc3NDQzXSxcbiAgICBcIjY5XCI6IFswLCAwLjcsIDAuMTg1ODMsIDAsIDAuNTYxNjJdLFxuICAgIFwiNzBcIjogWzAsIDAuNywgMC4xMzYzNCwgMCwgMC44OTU0NF0sXG4gICAgXCI3MVwiOiBbMCwgMC43LCAwLjE3MzIyLCAwLCAwLjYwOTYxXSxcbiAgICBcIjcyXCI6IFswLCAwLjcsIDAuMjk2OTQsIDAsIDAuOTY5MTldLFxuICAgIFwiNzNcIjogWzAsIDAuNywgMC4xOTE4OSwgMCwgMC44MDkwN10sXG4gICAgXCI3NFwiOiBbMC4yNzc3OCwgMC43LCAwLjE5MTg5LCAwLCAxLjA1MTU5XSxcbiAgICBcIjc1XCI6IFswLCAwLjcsIDAuMzEyNTksIDAsIDAuOTEzNjRdLFxuICAgIFwiNzZcIjogWzAsIDAuNywgMC4xOTE4OSwgMCwgMC44NzM3M10sXG4gICAgXCI3N1wiOiBbMCwgMC43LCAwLjE1OTgxLCAwLCAxLjA4MDMxXSxcbiAgICBcIjc4XCI6IFswLCAwLjcsIDAuMzUyNSwgMCwgMC45MDE1XSxcbiAgICBcIjc5XCI6IFswLCAwLjcsIDAuMDgwNzgsIDAsIDAuNzM3ODddLFxuICAgIFwiODBcIjogWzAsIDAuNywgMC4wODA3OCwgMCwgMS4wMTI2Ml0sXG4gICAgXCI4MVwiOiBbMCwgMC43LCAwLjAzMzA1LCAwLCAwLjg4MjgyXSxcbiAgICBcIjgyXCI6IFswLCAwLjcsIDAuMDYyNTksIDAsIDAuODVdLFxuICAgIFwiODNcIjogWzAsIDAuNywgMC4xOTE4OSwgMCwgMC44Njc2N10sXG4gICAgXCI4NFwiOiBbMCwgMC43LCAwLjI5MDg3LCAwLCAwLjc0Njk3XSxcbiAgICBcIjg1XCI6IFswLCAwLjcsIDAuMjU4MTUsIDAsIDAuNzk5OTZdLFxuICAgIFwiODZcIjogWzAsIDAuNywgMC4yNzUyMywgMCwgMC42MjIwNF0sXG4gICAgXCI4N1wiOiBbMCwgMC43LCAwLjI3NTIzLCAwLCAwLjgwNTMyXSxcbiAgICBcIjg4XCI6IFswLCAwLjcsIDAuMjYwMDYsIDAsIDAuOTQ0NDVdLFxuICAgIFwiODlcIjogWzAsIDAuNywgMC4yOTM5LCAwLCAwLjcwOTYxXSxcbiAgICBcIjkwXCI6IFswLCAwLjcsIDAuMjQwMzcsIDAsIDAuODIxMl0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdXG4gIH0sXG4gIFwiU2l6ZTEtUmVndWxhclwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI0MFwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NTgzNF0sXG4gICAgXCI0MVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NTgzNF0sXG4gICAgXCI0N1wiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC41Nzc3OF0sXG4gICAgXCI5MVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40MTY2N10sXG4gICAgXCI5MlwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC41Nzc3OF0sXG4gICAgXCI5M1wiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40MTY2N10sXG4gICAgXCIxMjNcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiMTI1XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjU4MzM0XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI3MTBcIjogWzAsIDAuNzIyMjIsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiNzMyXCI6IFswLCAwLjcyMjIyLCAwLCAwLCAwLjU1NTU2XSxcbiAgICBcIjc3MFwiOiBbMCwgMC43MjIyMiwgMCwgMCwgMC41NTU1Nl0sXG4gICAgXCI3NzFcIjogWzAsIDAuNzIyMjIsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODIxNFwiOiBbLTAuMDAwOTksIDAuNjAxLCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg1OTNcIjogWzFlLTA1LCAwLjYsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiODU5NVwiOiBbMWUtMDUsIDAuNiwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI4NjU3XCI6IFsxZS0wNSwgMC42LCAwLCAwLCAwLjc3Nzc4XSxcbiAgICBcIjg2NTlcIjogWzFlLTA1LCAwLjYsIDAsIDAsIDAuNzc3NzhdLFxuICAgIFwiODcxOVwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC45NDQ0NV0sXG4gICAgXCI4NzIwXCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjk0NDQ1XSxcbiAgICBcIjg3MjFcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDEuMDU1NTZdLFxuICAgIFwiODczMFwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMS4wXSxcbiAgICBcIjg3MzlcIjogWy0wLjAwNTk5LCAwLjYwNiwgMCwgMCwgMC4zMzMzM10sXG4gICAgXCI4NzQxXCI6IFstMC4wMDU5OSwgMC42MDYsIDAsIDAsIDAuNTU1NTZdLFxuICAgIFwiODc0N1wiOiBbMC4zMDYxMiwgMC44MDUsIDAuMTk0NDUsIDAsIDAuNDcyMjJdLFxuICAgIFwiODc0OFwiOiBbMC4zMDYsIDAuODA1LCAwLjE5NDQ1LCAwLCAwLjQ3MjIyXSxcbiAgICBcIjg3NDlcIjogWzAuMzA2LCAwLjgwNSwgMC4xOTQ0NSwgMCwgMC40NzIyMl0sXG4gICAgXCI4NzUwXCI6IFswLjMwNjEyLCAwLjgwNSwgMC4xOTQ0NSwgMCwgMC40NzIyMl0sXG4gICAgXCI4ODk2XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg4OTdcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuODMzMzRdLFxuICAgIFwiODg5OFwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC44MzMzNF0sXG4gICAgXCI4ODk5XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjg5NjhcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiODk2OVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NzIyMl0sXG4gICAgXCI4OTcwXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjg5NzFcIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiOTE2OFwiOiBbLTAuMDAwOTksIDAuNjAxLCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjEwMjE2XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjEwMjE3XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQ3MjIyXSxcbiAgICBcIjEwNzUyXCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjEwNzUzXCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjEwNzU0XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjEwNzU2XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjgzMzM0XSxcbiAgICBcIjEwNzU4XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjgzMzM0XVxuICB9LFxuICBcIlNpemUyLVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNDBcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNTk3MjJdLFxuICAgIFwiNDFcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNTk3MjJdLFxuICAgIFwiNDdcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuODExMTFdLFxuICAgIFwiOTFcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiOTJcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuODExMTFdLFxuICAgIFwiOTNcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNDcyMjJdLFxuICAgIFwiMTIzXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjEyNVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuMjVdLFxuICAgIFwiNzEwXCI6IFswLCAwLjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiNzMyXCI6IFswLCAwLjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiNzcwXCI6IFswLCAwLjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiNzcxXCI6IFswLCAwLjc1LCAwLCAwLCAxLjBdLFxuICAgIFwiODcxOVwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4yNzc3OF0sXG4gICAgXCI4NzIwXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjI3Nzc4XSxcbiAgICBcIjg3MjFcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuNDQ0NDVdLFxuICAgIFwiODczMFwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMS4wXSxcbiAgICBcIjg3NDdcIjogWzAuODYyMjUsIDEuMzYsIDAuNDQ0NDUsIDAsIDAuNTU1NTZdLFxuICAgIFwiODc0OFwiOiBbMC44NjIsIDEuMzYsIDAuNDQ0NDUsIDAsIDAuNTU1NTZdLFxuICAgIFwiODc0OVwiOiBbMC44NjIsIDEuMzYsIDAuNDQ0NDUsIDAsIDAuNTU1NTZdLFxuICAgIFwiODc1MFwiOiBbMC44NjIyNSwgMS4zNiwgMC40NDQ0NSwgMCwgMC41NTU1Nl0sXG4gICAgXCI4ODk2XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjg4OTdcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiODg5OFwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4xMTExMV0sXG4gICAgXCI4ODk5XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjExMTExXSxcbiAgICBcIjg5NjhcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiODk2OVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC41Mjc3OF0sXG4gICAgXCI4OTcwXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjUyNzc4XSxcbiAgICBcIjg5NzFcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNTI3NzhdLFxuICAgIFwiMTAyMTZcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiMTAyMTdcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNjExMTFdLFxuICAgIFwiMTA3NTJcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuNTExMTJdLFxuICAgIFwiMTA3NTNcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuNTExMTJdLFxuICAgIFwiMTA3NTRcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuNTExMTJdLFxuICAgIFwiMTA3NTZcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMTExMTFdLFxuICAgIFwiMTA3NThcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMTExMTFdXG4gIH0sXG4gIFwiU2l6ZTMtUmVndWxhclwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI0MFwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC43MzYxMV0sXG4gICAgXCI0MVwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC43MzYxMV0sXG4gICAgXCI0N1wiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMS4wNDQ0NV0sXG4gICAgXCI5MVwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC41Mjc3OF0sXG4gICAgXCI5MlwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMS4wNDQ0NV0sXG4gICAgXCI5M1wiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC41Mjc3OF0sXG4gICAgXCIxMjNcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNzVdLFxuICAgIFwiMTI1XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjc1XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI3MTBcIjogWzAsIDAuNzUsIDAsIDAsIDEuNDQ0NDVdLFxuICAgIFwiNzMyXCI6IFswLCAwLjc1LCAwLCAwLCAxLjQ0NDQ1XSxcbiAgICBcIjc3MFwiOiBbMCwgMC43NSwgMCwgMCwgMS40NDQ0NV0sXG4gICAgXCI3NzFcIjogWzAsIDAuNzUsIDAsIDAsIDEuNDQ0NDVdLFxuICAgIFwiODczMFwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMS4wXSxcbiAgICBcIjg5NjhcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiODk2OVwiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCI4OTcwXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjU4MzM0XSxcbiAgICBcIjg5NzFcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNTgzMzRdLFxuICAgIFwiMTAyMTZcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNzVdLFxuICAgIFwiMTAyMTdcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNzVdXG4gIH0sXG4gIFwiU2l6ZTQtUmVndWxhclwiOiB7XG4gICAgXCIzMlwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI0MFwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC43OTE2N10sXG4gICAgXCI0MVwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC43OTE2N10sXG4gICAgXCI0N1wiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMS4yNzc3OF0sXG4gICAgXCI5MVwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCI5MlwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMS4yNzc3OF0sXG4gICAgXCI5M1wiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC41ODMzNF0sXG4gICAgXCIxMjNcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuODA1NTZdLFxuICAgIFwiMTI1XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjgwNTU2XSxcbiAgICBcIjE2MFwiOiBbMCwgMCwgMCwgMCwgMC4yNV0sXG4gICAgXCI3MTBcIjogWzAsIDAuODI1LCAwLCAwLCAxLjg4ODldLFxuICAgIFwiNzMyXCI6IFswLCAwLjgyNSwgMCwgMCwgMS44ODg5XSxcbiAgICBcIjc3MFwiOiBbMCwgMC44MjUsIDAsIDAsIDEuODg4OV0sXG4gICAgXCI3NzFcIjogWzAsIDAuODI1LCAwLCAwLCAxLjg4ODldLFxuICAgIFwiODczMFwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMS4wXSxcbiAgICBcIjg5NjhcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiODk2OVwiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC42Mzg4OV0sXG4gICAgXCI4OTcwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjYzODg5XSxcbiAgICBcIjg5NzFcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuNjM4ODldLFxuICAgIFwiOTExNVwiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuODc1XSxcbiAgICBcIjkxMTZcIjogWzFlLTA1LCAwLjYsIDAsIDAsIDAuODc1XSxcbiAgICBcIjkxMTdcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwLCAwLjg3NV0sXG4gICAgXCI5MTE4XCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC44NzVdLFxuICAgIFwiOTExOVwiOiBbMWUtMDUsIDAuNiwgMCwgMCwgMC44NzVdLFxuICAgIFwiOTEyMFwiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuODc1XSxcbiAgICBcIjkxMjFcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwLCAwLjY2NjY3XSxcbiAgICBcIjkxMjJcIjogWy0wLjAwMDk5LCAwLjYwMSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5MTIzXCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5MTI0XCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC42NjY2N10sXG4gICAgXCI5MTI1XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiOTEyNlwiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuNjY2NjddLFxuICAgIFwiOTEyN1wiOiBbMWUtMDUsIDAuOSwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5MTI4XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjkxMjlcIjogWzAuOTAwMDEsIDAsIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTEzMFwiOiBbMCwgMC4zLCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjkxMzFcIjogWzFlLTA1LCAwLjksIDAsIDAsIDAuODg4ODldLFxuICAgIFwiOTEzMlwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC44ODg4OV0sXG4gICAgXCI5MTMzXCI6IFswLjkwMDAxLCAwLCAwLCAwLCAwLjg4ODg5XSxcbiAgICBcIjkxNDNcIjogWzAuODg1MDIsIDAuOTE1LCAwLCAwLCAxLjA1NTU2XSxcbiAgICBcIjEwMjE2XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjgwNTU2XSxcbiAgICBcIjEwMjE3XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjgwNTU2XSxcbiAgICBcIjU3MzQ0XCI6IFstMC4wMDQ5OSwgMC42MDUsIDAsIDAsIDEuMDU1NTZdLFxuICAgIFwiNTczNDVcIjogWy0wLjAwNDk5LCAwLjYwNSwgMCwgMCwgMS4wNTU1Nl0sXG4gICAgXCI1NzY4MFwiOiBbMCwgMC4xMiwgMCwgMCwgMC40NV0sXG4gICAgXCI1NzY4MVwiOiBbMCwgMC4xMiwgMCwgMCwgMC40NV0sXG4gICAgXCI1NzY4MlwiOiBbMCwgMC4xMiwgMCwgMCwgMC40NV0sXG4gICAgXCI1NzY4M1wiOiBbMCwgMC4xMiwgMCwgMCwgMC40NV1cbiAgfSxcbiAgXCJUeXBld3JpdGVyLVJlZ3VsYXJcIjoge1xuICAgIFwiMzJcIjogWzAsIDAsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjMzXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIzNFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMzVcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjM2XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIzN1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMzhcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjM5XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0MFwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDFcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQyXCI6IFswLCAwLjUyMDgzLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0M1wiOiBbLTAuMDgwNTYsIDAuNTMwNTUsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQ0XCI6IFswLjEzODg5LCAwLjEyNSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDVcIjogWy0wLjA4MDU2LCAwLjUzMDU1LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0NlwiOiBbMCwgMC4xMjUsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjQ3XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI0OFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNDlcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjUwXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1MVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTJcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjUzXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1NFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNTVcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjU2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI1N1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNThcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjU5XCI6IFswLjEzODg5LCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2MFwiOiBbLTAuMDU1NTYsIDAuNTU1NTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjYxXCI6IFstMC4xOTU0OSwgMC40MTU2MiwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjJcIjogWy0wLjA1NTU2LCAwLjU1NTU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2M1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjY1XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2NlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNjdcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjY4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI2OVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzBcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjcxXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzNcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc0XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3NVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc3XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3OFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzlcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjgwXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4MVwiOiBbMC4xMzg4OSwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODJcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjgzXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4NFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODVcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjg2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI4N1wiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiODhcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjg5XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTFcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkyXCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5M1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjk1XCI6IFswLjA5NTE0LCAwLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5NlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTdcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjk4XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTAwXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDFcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwMlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTAzXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDRcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwNVwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTA2XCI6IFswLjIyMjIyLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMDdcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEwOFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTA5XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExMVwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTEyXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTNcIjogWzAuMjIyMjIsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExNFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTE1XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTZcIjogWzAsIDAuNTUzNTgsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjExN1wiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTE4XCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEyMFwiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTIxXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEyM1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTI0XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxMjVcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjEyNlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTI3XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIxNjBcIjogWzAsIDAsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjE3NlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiMTg0XCI6IFswLjE5NDQ1LCAwLCAwLCAwLCAwLjUyNV0sXG4gICAgXCIzMDVcIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjU2N1wiOiBbMC4yMjIyMiwgMC40MzA1NiwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzExXCI6IFswLCAwLjU2NTk3LCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MTNcIjogWzAsIDAuNTY1NTUsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjcxNFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzE1XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3MjhcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjczMFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiNzcwXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI3NzFcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjc3NlwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTE1XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MTZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkyMFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTIzXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MjZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkyOFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTMxXCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MzNcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkzNFwiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLFxuICAgIFwiOTM2XCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sXG4gICAgXCI5MzdcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjgyMTZcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjgyMTdcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjgyNDJcIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSxcbiAgICBcIjkyNTFcIjogWzAuMTExMTEsIDAuMjE5NDQsIDAsIDAsIDAuNTI1XVxuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBtZXRyaWNzIHJlZ2FyZGluZyBmb250cyBhbmQgaW5kaXZpZHVhbCBzeW1ib2xzLiBUaGUgc2lnbWFcbiAqIGFuZCB4aSB2YXJpYWJsZXMsIGFzIHdlbGwgYXMgdGhlIG1ldHJpY01hcCBtYXAgY29udGFpbiBkYXRhIGV4dHJhY3RlZCBmcm9tXG4gKiBUZVgsIFRlWCBmb250IG1ldHJpY3MsIGFuZCB0aGUgVFRGIGZpbGVzLiBUaGVzZSBkYXRhIGFyZSB0aGVuIGV4cG9zZWQgdmlhIHRoZVxuICogYG1ldHJpY3NgIHZhcmlhYmxlIGFuZCB0aGUgZ2V0Q2hhcmFjdGVyTWV0cmljcyBmdW5jdGlvbi5cbiAqL1xuLy8gSW4gVGVYLCB0aGVyZSBhcmUgYWN0dWFsbHkgdGhyZWUgc2V0cyBvZiBkaW1lbnNpb25zLCBvbmUgZm9yIGVhY2ggb2Zcbi8vIHRleHRzdHlsZSAoc2l6ZSBpbmRleCA1IGFuZCBoaWdoZXI6ID49OXB0KSwgc2NyaXB0c3R5bGUgKHNpemUgaW5kZXggMyBhbmQgNDpcbi8vIDctOHB0KSwgYW5kIHNjcmlwdHNjcmlwdHN0eWxlIChzaXplIGluZGV4IDEgYW5kIDI6IDUtNnB0KS4gIFRoZXNlIGFyZVxuLy8gcHJvdmlkZWQgaW4gdGhlIGFycmF5cyBiZWxvdywgaW4gdGhhdCBvcmRlci5cbi8vXG4vLyBUaGUgZm9udCBtZXRyaWNzIGFyZSBzdG9yZWQgaW4gZm9udHMgY21zeTEwLCBjbXN5NywgYW5kIGNtc3k1IHJlc3BlY3RpdmVseS5cbi8vIFRoaXMgd2FzIGRldGVybWluZWQgYnkgcnVubmluZyB0aGUgZm9sbG93aW5nIHNjcmlwdDpcbi8vXG4vLyAgICAgbGF0ZXggLWludGVyYWN0aW9uPW5vbnN0b3Btb2RlIFxcXG4vLyAgICAgJ1xcZG9jdW1lbnRjbGFzc3thcnRpY2xlfVxcdXNlcGFja2FnZXthbXNtYXRofVxcYmVnaW57ZG9jdW1lbnR9JyBcXFxuLy8gICAgICckYSQgXFxleHBhbmRhZnRlclxcc2hvd1xcdGhlXFx0ZXh0Zm9udDInIFxcXG4vLyAgICAgJ1xcZXhwYW5kYWZ0ZXJcXHNob3dcXHRoZVxcc2NyaXB0Zm9udDInIFxcXG4vLyAgICAgJ1xcZXhwYW5kYWZ0ZXJcXHNob3dcXHRoZVxcc2NyaXB0c2NyaXB0Zm9udDInIFxcXG4vLyAgICAgJ1xcc3RvcCdcbi8vXG4vLyBUaGUgbWV0cmljcyB0aGVtc2VsdmVzIHdlcmUgcmV0cmlldmVkIHVzaW5nIHRoZSBmb2xsb3dpbmcgY29tbWFuZHM6XG4vL1xuLy8gICAgIHRmdG9wbCBjbXN5MTBcbi8vICAgICB0ZnRvcGwgY21zeTdcbi8vICAgICB0ZnRvcGwgY21zeTVcbi8vXG4vLyBUaGUgb3V0cHV0IG9mIGVhY2ggb2YgdGhlc2UgY29tbWFuZHMgaXMgcXVpdGUgbGVuZ3RoeS4gIFRoZSBvbmx5IHBhcnQgd2Vcbi8vIGNhcmUgYWJvdXQgaXMgdGhlIEZPTlRESU1FTiBzZWN0aW9uLiBFYWNoIHZhbHVlIGlzIG1lYXN1cmVkIGluIEVNcy5cbnZhciBzaWdtYXNBbmRYaXMgPSB7XG4gIHNsYW50OiBbMC4yNTAsIDAuMjUwLCAwLjI1MF0sXG4gIC8vIHNpZ21hMVxuICBzcGFjZTogWzAuMDAwLCAwLjAwMCwgMC4wMDBdLFxuICAvLyBzaWdtYTJcbiAgc3RyZXRjaDogWzAuMDAwLCAwLjAwMCwgMC4wMDBdLFxuICAvLyBzaWdtYTNcbiAgc2hyaW5rOiBbMC4wMDAsIDAuMDAwLCAwLjAwMF0sXG4gIC8vIHNpZ21hNFxuICB4SGVpZ2h0OiBbMC40MzEsIDAuNDMxLCAwLjQzMV0sXG4gIC8vIHNpZ21hNVxuICBxdWFkOiBbMS4wMDAsIDEuMTcxLCAxLjQ3Ml0sXG4gIC8vIHNpZ21hNlxuICBleHRyYVNwYWNlOiBbMC4wMDAsIDAuMDAwLCAwLjAwMF0sXG4gIC8vIHNpZ21hN1xuICBudW0xOiBbMC42NzcsIDAuNzMyLCAwLjkyNV0sXG4gIC8vIHNpZ21hOFxuICBudW0yOiBbMC4zOTQsIDAuMzg0LCAwLjM4N10sXG4gIC8vIHNpZ21hOVxuICBudW0zOiBbMC40NDQsIDAuNDcxLCAwLjUwNF0sXG4gIC8vIHNpZ21hMTBcbiAgZGVub20xOiBbMC42ODYsIDAuNzUyLCAxLjAyNV0sXG4gIC8vIHNpZ21hMTFcbiAgZGVub20yOiBbMC4zNDUsIDAuMzQ0LCAwLjUzMl0sXG4gIC8vIHNpZ21hMTJcbiAgc3VwMTogWzAuNDEzLCAwLjUwMywgMC41MDRdLFxuICAvLyBzaWdtYTEzXG4gIHN1cDI6IFswLjM2MywgMC40MzEsIDAuNDA0XSxcbiAgLy8gc2lnbWExNFxuICBzdXAzOiBbMC4yODksIDAuMjg2LCAwLjI5NF0sXG4gIC8vIHNpZ21hMTVcbiAgc3ViMTogWzAuMTUwLCAwLjE0MywgMC4yMDBdLFxuICAvLyBzaWdtYTE2XG4gIHN1YjI6IFswLjI0NywgMC4yODYsIDAuNDAwXSxcbiAgLy8gc2lnbWExN1xuICBzdXBEcm9wOiBbMC4zODYsIDAuMzUzLCAwLjQ5NF0sXG4gIC8vIHNpZ21hMThcbiAgc3ViRHJvcDogWzAuMDUwLCAwLjA3MSwgMC4xMDBdLFxuICAvLyBzaWdtYTE5XG4gIGRlbGltMTogWzIuMzkwLCAxLjcwMCwgMS45ODBdLFxuICAvLyBzaWdtYTIwXG4gIGRlbGltMjogWzEuMDEwLCAxLjE1NywgMS40MjBdLFxuICAvLyBzaWdtYTIxXG4gIGF4aXNIZWlnaHQ6IFswLjI1MCwgMC4yNTAsIDAuMjUwXSxcbiAgLy8gc2lnbWEyMlxuICAvLyBUaGVzZSBmb250IG1ldHJpY3MgYXJlIGV4dHJhY3RlZCBmcm9tIFRlWCBieSB1c2luZyB0ZnRvcGwgb24gY21leDEwLnRmbTtcbiAgLy8gdGhleSBjb3JyZXNwb25kIHRvIHRoZSBmb250IHBhcmFtZXRlcnMgb2YgdGhlIGV4dGVuc2lvbiBmb250cyAoZmFtaWx5IDMpLlxuICAvLyBTZWUgdGhlIFRlWGJvb2ssIHBhZ2UgNDQxLiBJbiBBTVNUZVgsIHRoZSBleHRlbnNpb24gZm9udHMgc2NhbGU7IHRvXG4gIC8vIG1hdGNoIGNtZXg3LCB3ZSdkIHVzZSBjbWV4Ny50Zm0gdmFsdWVzIGZvciBzY3JpcHQgYW5kIHNjcmlwdHNjcmlwdFxuICAvLyB2YWx1ZXMuXG4gIGRlZmF1bHRSdWxlVGhpY2tuZXNzOiBbMC4wNCwgMC4wNDksIDAuMDQ5XSxcbiAgLy8geGk4OyBjbWV4NzogMC4wNDlcbiAgYmlnT3BTcGFjaW5nMTogWzAuMTExLCAwLjExMSwgMC4xMTFdLFxuICAvLyB4aTlcbiAgYmlnT3BTcGFjaW5nMjogWzAuMTY2LCAwLjE2NiwgMC4xNjZdLFxuICAvLyB4aTEwXG4gIGJpZ09wU3BhY2luZzM6IFswLjIsIDAuMiwgMC4yXSxcbiAgLy8geGkxMVxuICBiaWdPcFNwYWNpbmc0OiBbMC42LCAwLjYxMSwgMC42MTFdLFxuICAvLyB4aTEyOyBjbWV4NzogMC42MTFcbiAgYmlnT3BTcGFjaW5nNTogWzAuMSwgMC4xNDMsIDAuMTQzXSxcbiAgLy8geGkxMzsgY21leDc6IDAuMTQzXG4gIC8vIFRoZSBcXHNxcnQgcnVsZSB3aWR0aCBpcyB0YWtlbiBmcm9tIHRoZSBoZWlnaHQgb2YgdGhlIHN1cmQgY2hhcmFjdGVyLlxuICAvLyBTaW5jZSB3ZSB1c2UgdGhlIHNhbWUgZm9udCBhdCBhbGwgc2l6ZXMsIHRoaXMgdGhpY2tuZXNzIGRvZXNuJ3Qgc2NhbGUuXG4gIHNxcnRSdWxlVGhpY2tuZXNzOiBbMC4wNCwgMC4wNCwgMC4wNF0sXG4gIC8vIFRoaXMgdmFsdWUgZGV0ZXJtaW5lcyBob3cgbGFyZ2UgYSBwdCBpcywgZm9yIG1ldHJpY3Mgd2hpY2ggYXJlIGRlZmluZWRcbiAgLy8gaW4gdGVybXMgb2YgcHRzLlxuICAvLyBUaGlzIHZhbHVlIGlzIGFsc28gdXNlZCBpbiBrYXRleC5zY3NzOyBpZiB5b3UgY2hhbmdlIGl0IG1ha2Ugc3VyZSB0aGVcbiAgLy8gdmFsdWVzIG1hdGNoLlxuICBwdFBlckVtOiBbMTAuMCwgMTAuMCwgMTAuMF0sXG4gIC8vIFRoZSBzcGFjZSBiZXR3ZWVuIGFkamFjZW50IGB8YCBjb2x1bW5zIGluIGFuIGFycmF5IGRlZmluaXRpb24uIEZyb21cbiAgLy8gYFxcc2hvd3RoZVxcZG91YmxlcnVsZXNlcGAgaW4gTGFUZVguIEVxdWFscyAyLjAgLyBwdFBlckVtLlxuICBkb3VibGVSdWxlU2VwOiBbMC4yLCAwLjIsIDAuMl0sXG4gIC8vIFRoZSB3aWR0aCBvZiBzZXBhcmF0b3IgbGluZXMgaW4ge2FycmF5fSBlbnZpcm9ubWVudHMuIEZyb21cbiAgLy8gYFxcc2hvd3RoZVxcYXJyYXlydWxld2lkdGhgIGluIExhVGVYLiBFcXVhbHMgMC40IC8gcHRQZXJFbS5cbiAgYXJyYXlSdWxlV2lkdGg6IFswLjA0LCAwLjA0LCAwLjA0XSxcbiAgLy8gVHdvIHZhbHVlcyBmcm9tIExhVGVYIHNvdXJjZTJlOlxuICBmYm94c2VwOiBbMC4zLCAwLjMsIDAuM10sXG4gIC8vICAgICAgICAzIHB0IC8gcHRQZXJFbVxuICBmYm94cnVsZTogWzAuMDQsIDAuMDQsIDAuMDRdIC8vIDAuNCBwdCAvIHB0UGVyRW1cblxufTsgLy8gVGhpcyBtYXAgY29udGFpbnMgYSBtYXBwaW5nIGZyb20gZm9udCBuYW1lIGFuZCBjaGFyYWN0ZXIgY29kZSB0byBjaGFyYWN0ZXJcbi8vIHNob3VsZCBoYXZlIExhdGluLTEgYW5kIEN5cmlsbGljIGNoYXJhY3RlcnMsIGJ1dCBtYXkgbm90IGRlcGVuZGluZyBvbiB0aGVcbi8vIG9wZXJhdGluZyBzeXN0ZW0uICBUaGUgbWV0cmljcyBkbyBub3QgYWNjb3VudCBmb3IgZXh0cmEgaGVpZ2h0IGZyb20gdGhlXG4vLyBhY2NlbnRzLiAgSW4gdGhlIGNhc2Ugb2YgQ3lyaWxsaWMgY2hhcmFjdGVycyB3aGljaCBoYXZlIGJvdGggYXNjZW5kZXJzIGFuZFxuLy8gZGVzY2VuZGVycyB3ZSBwcmVmZXIgYXBwcm94aW1hdGlvbnMgd2l0aCBhc2NlbmRlcnMsIHByaW1hcmlseSB0byBwcmV2ZW50XG4vLyB0aGUgZnJhY3Rpb24gYmFyIG9yIHJvb3QgbGluZSBmcm9tIGludGVyc2VjdGluZyB0aGUgZ2x5cGguXG4vLyBUT0RPKGtldmluYikgYWxsb3cgdW5pb24gb2YgbXVsdGlwbGUgZ2x5cGggbWV0cmljcyBmb3IgYmV0dGVyIGFjY3VyYWN5LlxuXG52YXIgZXh0cmFDaGFyYWN0ZXJNYXAgPSB7XG4gIC8vIExhdGluLTFcbiAgJ8OFJzogJ0EnLFxuICAnw5AnOiAnRCcsXG4gICfDnic6ICdvJyxcbiAgJ8OlJzogJ2EnLFxuICAnw7AnOiAnZCcsXG4gICfDvic6ICdvJyxcbiAgLy8gQ3lyaWxsaWNcbiAgJ9CQJzogJ0EnLFxuICAn0JEnOiAnQicsXG4gICfQkic6ICdCJyxcbiAgJ9CTJzogJ0YnLFxuICAn0JQnOiAnQScsXG4gICfQlSc6ICdFJyxcbiAgJ9CWJzogJ0snLFxuICAn0JcnOiAnMycsXG4gICfQmCc6ICdOJyxcbiAgJ9CZJzogJ04nLFxuICAn0JonOiAnSycsXG4gICfQmyc6ICdOJyxcbiAgJ9CcJzogJ00nLFxuICAn0J0nOiAnSCcsXG4gICfQnic6ICdPJyxcbiAgJ9CfJzogJ04nLFxuICAn0KAnOiAnUCcsXG4gICfQoSc6ICdDJyxcbiAgJ9CiJzogJ1QnLFxuICAn0KMnOiAneScsXG4gICfQpCc6ICdPJyxcbiAgJ9ClJzogJ1gnLFxuICAn0KYnOiAnVScsXG4gICfQpyc6ICdoJyxcbiAgJ9CoJzogJ1cnLFxuICAn0KknOiAnVycsXG4gICfQqic6ICdCJyxcbiAgJ9CrJzogJ1gnLFxuICAn0KwnOiAnQicsXG4gICfQrSc6ICczJyxcbiAgJ9CuJzogJ1gnLFxuICAn0K8nOiAnUicsXG4gICfQsCc6ICdhJyxcbiAgJ9CxJzogJ2InLFxuICAn0LInOiAnYScsXG4gICfQsyc6ICdyJyxcbiAgJ9C0JzogJ3knLFxuICAn0LUnOiAnZScsXG4gICfQtic6ICdtJyxcbiAgJ9C3JzogJ2UnLFxuICAn0LgnOiAnbicsXG4gICfQuSc6ICduJyxcbiAgJ9C6JzogJ24nLFxuICAn0LsnOiAnbicsXG4gICfQvCc6ICdtJyxcbiAgJ9C9JzogJ24nLFxuICAn0L4nOiAnbycsXG4gICfQvyc6ICduJyxcbiAgJ9GAJzogJ3AnLFxuICAn0YEnOiAnYycsXG4gICfRgic6ICdvJyxcbiAgJ9GDJzogJ3knLFxuICAn0YQnOiAnYicsXG4gICfRhSc6ICd4JyxcbiAgJ9GGJzogJ24nLFxuICAn0YcnOiAnbicsXG4gICfRiCc6ICd3JyxcbiAgJ9GJJzogJ3cnLFxuICAn0YonOiAnYScsXG4gICfRiyc6ICdtJyxcbiAgJ9GMJzogJ2EnLFxuICAn0Y0nOiAnZScsXG4gICfRjic6ICdtJyxcbiAgJ9GPJzogJ3InXG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWRkcyBuZXcgZm9udCBtZXRyaWNzIHRvIGRlZmF1bHQgbWV0cmljTWFwXG4gKiBJdCBjYW4gYWxzbyBvdmVycmlkZSBleGlzdGluZyBtZXRyaWNzXG4gKi9cbmZ1bmN0aW9uIHNldEZvbnRNZXRyaWNzKGZvbnROYW1lLCBtZXRyaWNzKSB7XG4gIGZvbnRNZXRyaWNzRGF0YVtmb250TmFtZV0gPSBtZXRyaWNzO1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGxvb2tpbmcgdXAgaW5mb3JtYXRpb24gaW4gdGhlXG4gKiBtZXRyaWNNYXAgdGFibGUuIEl0IHRha2VzIGEgY2hhcmFjdGVyIGFzIGEgc3RyaW5nLCBhbmQgYSBmb250LlxuICpcbiAqIE5vdGU6IHRoZSBgd2lkdGhgIHByb3BlcnR5IG1heSBiZSB1bmRlZmluZWQgaWYgZm9udE1ldHJpY3NEYXRhLmpzIHdhc24ndFxuICogYnVpbHQgdXNpbmcgYE1ha2UgZXh0ZW5kZWRfbWV0cmljc2AuXG4gKi9cblxuZnVuY3Rpb24gZ2V0Q2hhcmFjdGVyTWV0cmljcyhjaGFyYWN0ZXIsIGZvbnQsIG1vZGUpIHtcbiAgaWYgKCFmb250TWV0cmljc0RhdGFbZm9udF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb250IG1ldHJpY3Mgbm90IGZvdW5kIGZvciBmb250OiBcIiArIGZvbnQgKyBcIi5cIik7XG4gIH1cblxuICB2YXIgY2ggPSBjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKTtcbiAgdmFyIG1ldHJpY3MgPSBmb250TWV0cmljc0RhdGFbZm9udF1bY2hdO1xuXG4gIGlmICghbWV0cmljcyAmJiBjaGFyYWN0ZXJbMF0gaW4gZXh0cmFDaGFyYWN0ZXJNYXApIHtcbiAgICBjaCA9IGV4dHJhQ2hhcmFjdGVyTWFwW2NoYXJhY3RlclswXV0uY2hhckNvZGVBdCgwKTtcbiAgICBtZXRyaWNzID0gZm9udE1ldHJpY3NEYXRhW2ZvbnRdW2NoXTtcbiAgfVxuXG4gIGlmICghbWV0cmljcyAmJiBtb2RlID09PSAndGV4dCcpIHtcbiAgICAvLyBXZSBkb24ndCB0eXBpY2FsbHkgaGF2ZSBmb250IG1ldHJpY3MgZm9yIEFzaWFuIHNjcmlwdHMuXG4gICAgLy8gQnV0IHNpbmNlIHdlIHN1cHBvcnQgdGhlbSBpbiB0ZXh0IG1vZGUsIHdlIG5lZWQgdG8gcmV0dXJuXG4gICAgLy8gc29tZSBzb3J0IG9mIG1ldHJpY3MuXG4gICAgLy8gU28gaWYgdGhlIGNoYXJhY3RlciBpcyBpbiBhIHNjcmlwdCB3ZSBzdXBwb3J0IGJ1dCB3ZVxuICAgIC8vIGRvbid0IGhhdmUgbWV0cmljcyBmb3IgaXQsIGp1c3QgdXNlIHRoZSBtZXRyaWNzIGZvclxuICAgIC8vIHRoZSBMYXRpbiBjYXBpdGFsIGxldHRlciBNLiBUaGlzIGlzIGNsb3NlIGVub3VnaCBiZWNhdXNlXG4gICAgLy8gd2UgKGN1cnJlbnRseSkgb25seSBjYXJlIGFib3V0IHRoZSBoZWlnaHQgb2YgdGhlIGdseXBoXG4gICAgLy8gbm90IGl0cyB3aWR0aC5cbiAgICBpZiAoc3VwcG9ydGVkQ29kZXBvaW50KGNoKSkge1xuICAgICAgbWV0cmljcyA9IGZvbnRNZXRyaWNzRGF0YVtmb250XVs3N107IC8vIDc3IGlzIHRoZSBjaGFyY29kZSBmb3IgJ00nXG4gICAgfVxuICB9XG5cbiAgaWYgKG1ldHJpY3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVwdGg6IG1ldHJpY3NbMF0sXG4gICAgICBoZWlnaHQ6IG1ldHJpY3NbMV0sXG4gICAgICBpdGFsaWM6IG1ldHJpY3NbMl0sXG4gICAgICBza2V3OiBtZXRyaWNzWzNdLFxuICAgICAgd2lkdGg6IG1ldHJpY3NbNF1cbiAgICB9O1xuICB9XG59XG52YXIgZm9udE1ldHJpY3NCeVNpemVJbmRleCA9IHt9O1xuLyoqXG4gKiBHZXQgdGhlIGZvbnQgbWV0cmljcyBmb3IgYSBnaXZlbiBzaXplLlxuICovXG5cbmZ1bmN0aW9uIGdldEdsb2JhbE1ldHJpY3Moc2l6ZSkge1xuICB2YXIgc2l6ZUluZGV4O1xuXG4gIGlmIChzaXplID49IDUpIHtcbiAgICBzaXplSW5kZXggPSAwO1xuICB9IGVsc2UgaWYgKHNpemUgPj0gMykge1xuICAgIHNpemVJbmRleCA9IDE7XG4gIH0gZWxzZSB7XG4gICAgc2l6ZUluZGV4ID0gMjtcbiAgfVxuXG4gIGlmICghZm9udE1ldHJpY3NCeVNpemVJbmRleFtzaXplSW5kZXhdKSB7XG4gICAgdmFyIG1ldHJpY3MgPSBmb250TWV0cmljc0J5U2l6ZUluZGV4W3NpemVJbmRleF0gPSB7XG4gICAgICBjc3NFbVBlck11OiBzaWdtYXNBbmRYaXMucXVhZFtzaXplSW5kZXhdIC8gMThcbiAgICB9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNpZ21hc0FuZFhpcykge1xuICAgICAgaWYgKHNpZ21hc0FuZFhpcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIG1ldHJpY3Nba2V5XSA9IHNpZ21hc0FuZFhpc1trZXldW3NpemVJbmRleF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvbnRNZXRyaWNzQnlTaXplSW5kZXhbc2l6ZUluZGV4XTtcbn1cblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9wdGlvbnMgdGhhdCB0aGUgUGFyc2VyIGNhcnJpZXNcbiAqIGFyb3VuZCB3aXRoIGl0IHdoaWxlIHBhcnNpbmcuIERhdGEgaXMgaGVsZCBpbiBhbiBgT3B0aW9uc2Agb2JqZWN0LCBhbmQgd2hlblxuICogcmVjdXJzaW5nLCBhIG5ldyBgT3B0aW9uc2Agb2JqZWN0IGNhbiBiZSBjcmVhdGVkIHdpdGggdGhlIGAud2l0aCpgIGFuZFxuICogYC5yZXNldGAgZnVuY3Rpb25zLlxuICovXG52YXIgc2l6ZVN0eWxlTWFwID0gWy8vIEVhY2ggZWxlbWVudCBjb250YWlucyBbdGV4dHNpemUsIHNjcmlwdHNpemUsIHNjcmlwdHNjcmlwdHNpemVdLlxuLy8gVGhlIHNpemUgbWFwcGluZ3MgYXJlIHRha2VuIGZyb20gVGVYIHdpdGggXFxub3JtYWxzaXplPTEwcHQuXG5bMSwgMSwgMV0sIC8vIHNpemUxOiBbNSwgNSwgNV0gICAgICAgICAgICAgIFxcdGlueVxuWzIsIDEsIDFdLCAvLyBzaXplMjogWzYsIDUsIDVdXG5bMywgMSwgMV0sIC8vIHNpemUzOiBbNywgNSwgNV0gICAgICAgICAgICAgIFxcc2NyaXB0c2l6ZVxuWzQsIDIsIDFdLCAvLyBzaXplNDogWzgsIDYsIDVdICAgICAgICAgICAgICBcXGZvb3Rub3Rlc2l6ZVxuWzUsIDIsIDFdLCAvLyBzaXplNTogWzksIDYsIDVdICAgICAgICAgICAgICBcXHNtYWxsXG5bNiwgMywgMV0sIC8vIHNpemU2OiBbMTAsIDcsIDVdICAgICAgICAgICAgIFxcbm9ybWFsc2l6ZVxuWzcsIDQsIDJdLCAvLyBzaXplNzogWzEyLCA4LCA2XSAgICAgICAgICAgICBcXGxhcmdlXG5bOCwgNiwgM10sIC8vIHNpemU4OiBbMTQuNCwgMTAsIDddICAgICAgICAgIFxcTGFyZ2Vcbls5LCA3LCA2XSwgLy8gc2l6ZTk6IFsxNy4yOCwgMTIsIDEwXSAgICAgICAgXFxMQVJHRVxuWzEwLCA4LCA3XSwgLy8gc2l6ZTEwOiBbMjAuNzQsIDE0LjQsIDEyXSAgICAgXFxodWdlXG5bMTEsIDEwLCA5XSAvLyBzaXplMTE6IFsyNC44OCwgMjAuNzQsIDE3LjI4XSBcXEhVR0Vcbl07XG52YXIgc2l6ZU11bHRpcGxpZXJzID0gWy8vIGZvbnRNZXRyaWNzLmpzOmdldEdsb2JhbE1ldHJpY3MgYWxzbyB1c2VzIHNpemUgaW5kZXhlcywgc28gaWZcbi8vIHlvdSBjaGFuZ2Ugc2l6ZSBpbmRleGVzLCBjaGFuZ2UgdGhhdCBmdW5jdGlvbi5cbjAuNSwgMC42LCAwLjcsIDAuOCwgMC45LCAxLjAsIDEuMiwgMS40NCwgMS43MjgsIDIuMDc0LCAyLjQ4OF07XG5cbnZhciBzaXplQXRTdHlsZSA9IGZ1bmN0aW9uIHNpemVBdFN0eWxlKHNpemUsIHN0eWxlKSB7XG4gIHJldHVybiBzdHlsZS5zaXplIDwgMiA/IHNpemUgOiBzaXplU3R5bGVNYXBbc2l6ZSAtIDFdW3N0eWxlLnNpemUgLSAxXTtcbn07IC8vIEluIHRoZXNlIHR5cGVzLCBcIlwiIChlbXB0eSBzdHJpbmcpIG1lYW5zIFwibm8gY2hhbmdlXCIuXG5cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWluIG9wdGlvbnMgY2xhc3MuIEl0IGNvbnRhaW5zIHRoZSBjdXJyZW50IHN0eWxlLCBzaXplLCBjb2xvcixcbiAqIGFuZCBmb250LlxuICpcbiAqIE9wdGlvbnMgb2JqZWN0cyBzaG91bGQgbm90IGJlIG1vZGlmaWVkLiBUbyBjcmVhdGUgYSBuZXcgT3B0aW9ucyB3aXRoXG4gKiBkaWZmZXJlbnQgcHJvcGVydGllcywgY2FsbCBhIGAuaGF2aW5nKmAgbWV0aG9kLlxuICovXG5jbGFzcyBPcHRpb25zIHtcbiAgLy8gQSBmb250IGZhbWlseSBhcHBsaWVzIHRvIGEgZ3JvdXAgb2YgZm9udHMgKGkuZS4gU2Fuc1NlcmlmKSwgd2hpbGUgYSBmb250XG4gIC8vIHJlcHJlc2VudHMgYSBzcGVjaWZpYyBmb250IChpLmUuIFNhbnNTZXJpZiBCb2xkKS5cbiAgLy8gU2VlOiBodHRwczovL3RleC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMjIzNTAvZGlmZmVyZW5jZS1iZXR3ZWVuLXRleHRybS1hbmQtbWF0aHJtXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIHNpemUgaW5kZXguXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5zdHlsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbG9yID0gdm9pZCAwO1xuICAgIHRoaXMuc2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnRleHRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMucGhhbnRvbSA9IHZvaWQgMDtcbiAgICB0aGlzLmZvbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udFdlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmZvbnRTaGFwZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNpemVNdWx0aXBsaWVyID0gdm9pZCAwO1xuICAgIHRoaXMubWF4U2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLm1pblJ1bGVUaGlja25lc3MgPSB2b2lkIDA7XG4gICAgdGhpcy5fZm9udE1ldHJpY3MgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHlsZSA9IGRhdGEuc3R5bGU7XG4gICAgdGhpcy5jb2xvciA9IGRhdGEuY29sb3I7XG4gICAgdGhpcy5zaXplID0gZGF0YS5zaXplIHx8IE9wdGlvbnMuQkFTRVNJWkU7XG4gICAgdGhpcy50ZXh0U2l6ZSA9IGRhdGEudGV4dFNpemUgfHwgdGhpcy5zaXplO1xuICAgIHRoaXMucGhhbnRvbSA9ICEhZGF0YS5waGFudG9tO1xuICAgIHRoaXMuZm9udCA9IGRhdGEuZm9udCB8fCBcIlwiO1xuICAgIHRoaXMuZm9udEZhbWlseSA9IGRhdGEuZm9udEZhbWlseSB8fCBcIlwiO1xuICAgIHRoaXMuZm9udFdlaWdodCA9IGRhdGEuZm9udFdlaWdodCB8fCAnJztcbiAgICB0aGlzLmZvbnRTaGFwZSA9IGRhdGEuZm9udFNoYXBlIHx8ICcnO1xuICAgIHRoaXMuc2l6ZU11bHRpcGxpZXIgPSBzaXplTXVsdGlwbGllcnNbdGhpcy5zaXplIC0gMV07XG4gICAgdGhpcy5tYXhTaXplID0gZGF0YS5tYXhTaXplO1xuICAgIHRoaXMubWluUnVsZVRoaWNrbmVzcyA9IGRhdGEubWluUnVsZVRoaWNrbmVzcztcbiAgICB0aGlzLl9mb250TWV0cmljcyA9IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgXCJ0aGlzXCIuICBQcm9wZXJ0aWVzXG4gICAqIGZyb20gXCJleHRlbnNpb25cIiB3aWxsIGJlIGNvcGllZCB0byB0aGUgbmV3IG9wdGlvbnMgb2JqZWN0LlxuICAgKi9cblxuXG4gIGV4dGVuZChleHRlbnNpb24pIHtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIHN0eWxlOiB0aGlzLnN0eWxlLFxuICAgICAgc2l6ZTogdGhpcy5zaXplLFxuICAgICAgdGV4dFNpemU6IHRoaXMudGV4dFNpemUsXG4gICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgIHBoYW50b206IHRoaXMucGhhbnRvbSxcbiAgICAgIGZvbnQ6IHRoaXMuZm9udCxcbiAgICAgIGZvbnRGYW1pbHk6IHRoaXMuZm9udEZhbWlseSxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoaXMuZm9udFdlaWdodCxcbiAgICAgIGZvbnRTaGFwZTogdGhpcy5mb250U2hhcGUsXG4gICAgICBtYXhTaXplOiB0aGlzLm1heFNpemUsXG4gICAgICBtaW5SdWxlVGhpY2tuZXNzOiB0aGlzLm1pblJ1bGVUaGlja25lc3NcbiAgICB9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGV4dGVuc2lvbikge1xuICAgICAgaWYgKGV4dGVuc2lvbi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IGV4dGVuc2lvbltrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgT3B0aW9ucyhkYXRhKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIHN0eWxlLiBJZiBgdGhpcy5zdHlsZSA9PT0gc3R5bGVgLFxuICAgKiByZXR1cm5zIGB0aGlzYC5cbiAgICovXG5cblxuICBoYXZpbmdTdHlsZShzdHlsZSkge1xuICAgIGlmICh0aGlzLnN0eWxlID09PSBzdHlsZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgc2l6ZTogc2l6ZUF0U3R5bGUodGhpcy50ZXh0U2l6ZSwgc3R5bGUpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhbiBvcHRpb25zIG9iamVjdCB3aXRoIGEgY3JhbXBlZCB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IHN0eWxlLiBJZlxuICAgKiB0aGUgY3VycmVudCBzdHlsZSBpcyBjcmFtcGVkLCByZXR1cm5zIGB0aGlzYC5cbiAgICovXG5cblxuICBoYXZpbmdDcmFtcGVkU3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGF2aW5nU3R5bGUodGhpcy5zdHlsZS5jcmFtcCgpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFuIG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIHNpemUgYW5kIGluIGF0IGxlYXN0IGBcXHRleHRzdHlsZWAuXG4gICAqIFJldHVybnMgYHRoaXNgIGlmIGFwcHJvcHJpYXRlLlxuICAgKi9cblxuXG4gIGhhdmluZ1NpemUoc2l6ZSkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IHNpemUgJiYgdGhpcy50ZXh0U2l6ZSA9PT0gc2l6ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICAgIHN0eWxlOiB0aGlzLnN0eWxlLnRleHQoKSxcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgdGV4dFNpemU6IHNpemUsXG4gICAgICAgIHNpemVNdWx0aXBsaWVyOiBzaXplTXVsdGlwbGllcnNbc2l6ZSAtIDFdXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIExpa2UgYHRoaXMuaGF2aW5nU2l6ZShCQVNFU0laRSkuaGF2aW5nU3R5bGUoc3R5bGUpYC4gSWYgYHN0eWxlYCBpcyBvbWl0dGVkLFxuICAgKiBjaGFuZ2VzIHRvIGF0IGxlYXN0IGBcXHRleHRzdHlsZWAuXG4gICAqL1xuXG5cbiAgaGF2aW5nQmFzZVN0eWxlKHN0eWxlKSB7XG4gICAgc3R5bGUgPSBzdHlsZSB8fCB0aGlzLnN0eWxlLnRleHQoKTtcbiAgICB2YXIgd2FudFNpemUgPSBzaXplQXRTdHlsZShPcHRpb25zLkJBU0VTSVpFLCBzdHlsZSk7XG5cbiAgICBpZiAodGhpcy5zaXplID09PSB3YW50U2l6ZSAmJiB0aGlzLnRleHRTaXplID09PSBPcHRpb25zLkJBU0VTSVpFICYmIHRoaXMuc3R5bGUgPT09IHN0eWxlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBzaXplOiB3YW50U2l6ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGVmZmVjdCBvZiBzaXppbmcgY2hhbmdlcyBzdWNoIGFzIFxcSHVnZS5cbiAgICogS2VlcCB0aGUgZWZmZWN0IG9mIHRoZSBjdXJyZW50IHN0eWxlLCBzdWNoIGFzIFxcc2NyaXB0c3R5bGUuXG4gICAqL1xuXG5cbiAgaGF2aW5nQmFzZVNpemluZygpIHtcbiAgICB2YXIgc2l6ZTtcblxuICAgIHN3aXRjaCAodGhpcy5zdHlsZS5pZCkge1xuICAgICAgY2FzZSA0OlxuICAgICAgY2FzZSA1OlxuICAgICAgICBzaXplID0gMzsgLy8gbm9ybWFsc2l6ZSBpbiBzY3JpcHRzdHlsZVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDY6XG4gICAgICBjYXNlIDc6XG4gICAgICAgIHNpemUgPSAxOyAvLyBub3JtYWxzaXplIGluIHNjcmlwdHNjcmlwdHN0eWxlXG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHNpemUgPSA2O1xuICAgICAgLy8gbm9ybWFsc2l6ZSBpbiB0ZXh0c3R5bGUgb3IgZGlzcGxheXN0eWxlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIHN0eWxlOiB0aGlzLnN0eWxlLnRleHQoKSxcbiAgICAgIHNpemU6IHNpemVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvbG9yLlxuICAgKi9cblxuXG4gIHdpdGhDb2xvcihjb2xvcikge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBjb2xvcjogY29sb3JcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggXCJwaGFudG9tXCIgc2V0IHRvIHRydWUuXG4gICAqL1xuXG5cbiAgd2l0aFBoYW50b20oKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIHBoYW50b206IHRydWVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBtYXRoIGZvbnQgb3Igb2xkIHRleHQgZm9udC5cbiAgICogQHR5cGUge1t0eXBlXX1cbiAgICovXG5cblxuICB3aXRoRm9udChmb250KSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGZvbnRcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IG9wdGlvbnMgb2JqZWN0cyB3aXRoIHRoZSBnaXZlbiBmb250RmFtaWx5LlxuICAgKi9cblxuXG4gIHdpdGhUZXh0Rm9udEZhbWlseShmb250RmFtaWx5KSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGZvbnRGYW1pbHksXG4gICAgICBmb250OiBcIlwiXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gZm9udCB3ZWlnaHRcbiAgICovXG5cblxuICB3aXRoVGV4dEZvbnRXZWlnaHQoZm9udFdlaWdodCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBmb250V2VpZ2h0LFxuICAgICAgZm9udDogXCJcIlxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGZvbnQgd2VpZ2h0XG4gICAqL1xuXG5cbiAgd2l0aFRleHRGb250U2hhcGUoZm9udFNoYXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGZvbnRTaGFwZSxcbiAgICAgIGZvbnQ6IFwiXCJcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBDU1Mgc2l6aW5nIGNsYXNzZXMgcmVxdWlyZWQgdG8gc3dpdGNoIGZyb20gZW5jbG9zaW5nIG9wdGlvbnNcbiAgICogYG9sZE9wdGlvbnNgIHRvIGB0aGlzYC4gUmV0dXJucyBhbiBhcnJheSBvZiBjbGFzc2VzLlxuICAgKi9cblxuXG4gIHNpemluZ0NsYXNzZXMob2xkT3B0aW9ucykge1xuICAgIGlmIChvbGRPcHRpb25zLnNpemUgIT09IHRoaXMuc2l6ZSkge1xuICAgICAgcmV0dXJuIFtcInNpemluZ1wiLCBcInJlc2V0LXNpemVcIiArIG9sZE9wdGlvbnMuc2l6ZSwgXCJzaXplXCIgKyB0aGlzLnNpemVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIENTUyBzaXppbmcgY2xhc3NlcyByZXF1aXJlZCB0byBzd2l0Y2ggdG8gdGhlIGJhc2Ugc2l6ZS4gTGlrZVxuICAgKiBgdGhpcy5oYXZpbmdTaXplKEJBU0VTSVpFKS5zaXppbmdDbGFzc2VzKHRoaXMpYC5cbiAgICovXG5cblxuICBiYXNlU2l6aW5nQ2xhc3NlcygpIHtcbiAgICBpZiAodGhpcy5zaXplICE9PSBPcHRpb25zLkJBU0VTSVpFKSB7XG4gICAgICByZXR1cm4gW1wic2l6aW5nXCIsIFwicmVzZXQtc2l6ZVwiICsgdGhpcy5zaXplLCBcInNpemVcIiArIE9wdGlvbnMuQkFTRVNJWkVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGZvbnQgbWV0cmljcyBmb3IgdGhpcyBzaXplLlxuICAgKi9cblxuXG4gIGZvbnRNZXRyaWNzKCkge1xuICAgIGlmICghdGhpcy5fZm9udE1ldHJpY3MpIHtcbiAgICAgIHRoaXMuX2ZvbnRNZXRyaWNzID0gZ2V0R2xvYmFsTWV0cmljcyh0aGlzLnNpemUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9mb250TWV0cmljcztcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgQ1NTIGNvbG9yIG9mIHRoZSBjdXJyZW50IG9wdGlvbnMgb2JqZWN0XG4gICAqL1xuXG5cbiAgZ2V0Q29sb3IoKSB7XG4gICAgaWYgKHRoaXMucGhhbnRvbSkge1xuICAgICAgcmV0dXJuIFwidHJhbnNwYXJlbnRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY29sb3I7XG4gICAgfVxuICB9XG5cbn1cblxuT3B0aW9ucy5CQVNFU0laRSA9IDY7XG5cbi8qKlxuICogVGhpcyBmaWxlIGRvZXMgY29udmVyc2lvbiBiZXR3ZWVuIHVuaXRzLiAgSW4gcGFydGljdWxhciwgaXQgcHJvdmlkZXNcbiAqIGNhbGN1bGF0ZVNpemUgdG8gY29udmVydCBvdGhlciB1bml0cyBpbnRvIGVtcy5cbiAqL1xuLy8gVGh1cywgbXVsdGlwbHlpbmcgYSBsZW5ndGggYnkgdGhpcyBudW1iZXIgY29udmVydHMgdGhlIGxlbmd0aCBmcm9tIHVuaXRzXG4vLyBpbnRvIHB0cy4gIERpdmlkaW5nIHRoZSByZXN1bHQgYnkgcHRQZXJFbSBnaXZlcyB0aGUgbnVtYmVyIG9mIGVtc1xuLy8gKmFzc3VtaW5nKiBhIGZvbnQgc2l6ZSBvZiBwdFBlckVtIChub3JtYWwgc2l6ZSwgbm9ybWFsIHN0eWxlKS5cblxudmFyIHB0UGVyVW5pdCA9IHtcbiAgLy8gaHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvTGFUZVgvTGVuZ3RocyBhbmRcbiAgLy8gaHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vYS84MjYzXG4gIFwicHRcIjogMSxcbiAgLy8gVGVYIHBvaW50XG4gIFwibW1cIjogNzIyNyAvIDI1NDAsXG4gIC8vIG1pbGxpbWV0ZXJcbiAgXCJjbVwiOiA3MjI3IC8gMjU0LFxuICAvLyBjZW50aW1ldGVyXG4gIFwiaW5cIjogNzIuMjcsXG4gIC8vIGluY2hcbiAgXCJicFwiOiA4MDMgLyA4MDAsXG4gIC8vIGJpZyAoUG9zdFNjcmlwdCkgcG9pbnRzXG4gIFwicGNcIjogMTIsXG4gIC8vIHBpY2FcbiAgXCJkZFwiOiAxMjM4IC8gMTE1NyxcbiAgLy8gZGlkb3RcbiAgXCJjY1wiOiAxNDg1NiAvIDExNTcsXG4gIC8vIGNpY2VybyAoMTIgZGlkb3QpXG4gIFwibmRcIjogNjg1IC8gNjQyLFxuICAvLyBuZXcgZGlkb3RcbiAgXCJuY1wiOiAxMzcwIC8gMTA3LFxuICAvLyBuZXcgY2ljZXJvICgxMiBuZXcgZGlkb3QpXG4gIFwic3BcIjogMSAvIDY1NTM2LFxuICAvLyBzY2FsZWQgcG9pbnQgKFRlWCdzIGludGVybmFsIHNtYWxsZXN0IHVuaXQpXG4gIC8vIGh0dHBzOi8vdGV4LnN0YWNrZXhjaGFuZ2UuY29tL2EvNDEzNzFcbiAgXCJweFwiOiA4MDMgLyA4MDAgLy8gXFxwZGZweGRpbWVuIGRlZmF1bHRzIHRvIDEgYnAgaW4gcGRmVGVYIGFuZCBMdWFUZVhcblxufTsgLy8gRGljdGlvbmFyeSBvZiByZWxhdGl2ZSB1bml0cywgZm9yIGZhc3QgdmFsaWRpdHkgdGVzdGluZy5cblxudmFyIHJlbGF0aXZlVW5pdCA9IHtcbiAgXCJleFwiOiB0cnVlLFxuICBcImVtXCI6IHRydWUsXG4gIFwibXVcIjogdHJ1ZVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgc3BlY2lmaWVkIHVuaXQgKGVpdGhlciBhIHN0cmluZyBkZWZpbmluZyB0aGUgdW5pdFxuICogb3IgYSBcInNpemVcIiBwYXJzZSBub2RlIGNvbnRhaW5pbmcgYSB1bml0IGZpZWxkKSBpcyB2YWxpZC5cbiAqL1xudmFyIHZhbGlkVW5pdCA9IGZ1bmN0aW9uIHZhbGlkVW5pdCh1bml0KSB7XG4gIGlmICh0eXBlb2YgdW5pdCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHVuaXQgPSB1bml0LnVuaXQ7XG4gIH1cblxuICByZXR1cm4gdW5pdCBpbiBwdFBlclVuaXQgfHwgdW5pdCBpbiByZWxhdGl2ZVVuaXQgfHwgdW5pdCA9PT0gXCJleFwiO1xufTtcbi8qXG4gKiBDb252ZXJ0IGEgXCJzaXplXCIgcGFyc2Ugbm9kZSAod2l0aCBudW1lcmljIFwibnVtYmVyXCIgYW5kIHN0cmluZyBcInVuaXRcIiBmaWVsZHMsXG4gKiBhcyBwYXJzZWQgYnkgZnVuY3Rpb25zLmpzIGFyZ1R5cGUgXCJzaXplXCIpIGludG8gYSBDU1MgZW0gdmFsdWUgZm9yIHRoZVxuICogY3VycmVudCBzdHlsZS9zY2FsZS4gIGBvcHRpb25zYCBnaXZlcyB0aGUgY3VycmVudCBvcHRpb25zLlxuICovXG5cbnZhciBjYWxjdWxhdGVTaXplID0gZnVuY3Rpb24gY2FsY3VsYXRlU2l6ZShzaXplVmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHNjYWxlO1xuXG4gIGlmIChzaXplVmFsdWUudW5pdCBpbiBwdFBlclVuaXQpIHtcbiAgICAvLyBBYnNvbHV0ZSB1bml0c1xuICAgIHNjYWxlID0gcHRQZXJVbml0W3NpemVWYWx1ZS51bml0XSAvLyBDb252ZXJ0IHVuaXQgdG8gcHRcbiAgICAvIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5wdFBlckVtIC8vIENvbnZlcnQgcHQgdG8gQ1NTIGVtXG4gICAgLyBvcHRpb25zLnNpemVNdWx0aXBsaWVyOyAvLyBVbnNjYWxlIHRvIG1ha2UgYWJzb2x1dGUgdW5pdHNcbiAgfSBlbHNlIGlmIChzaXplVmFsdWUudW5pdCA9PT0gXCJtdVwiKSB7XG4gICAgLy8gYG11YCB1bml0cyBzY2FsZSB3aXRoIHNjcmlwdHN0eWxlL3NjcmlwdHNjcmlwdHN0eWxlLlxuICAgIHNjYWxlID0gb3B0aW9ucy5mb250TWV0cmljcygpLmNzc0VtUGVyTXU7XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXIgcmVsYXRpdmUgdW5pdHMgYWx3YXlzIHJlZmVyIHRvIHRoZSAqdGV4dHN0eWxlKiBmb250XG4gICAgLy8gaW4gdGhlIGN1cnJlbnQgc2l6ZS5cbiAgICB2YXIgdW5pdE9wdGlvbnM7XG5cbiAgICBpZiAob3B0aW9ucy5zdHlsZS5pc1RpZ2h0KCkpIHtcbiAgICAgIC8vIGlzVGlnaHQoKSBtZWFucyBjdXJyZW50IHN0eWxlIGlzIHNjcmlwdC9zY3JpcHRzY3JpcHQuXG4gICAgICB1bml0T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUob3B0aW9ucy5zdHlsZS50ZXh0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bml0T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfSAvLyBUT0RPOiBJbiBUZVggdGhlc2UgdW5pdHMgYXJlIHJlbGF0aXZlIHRvIHRoZSBxdWFkIG9mIHRoZSBjdXJyZW50XG4gICAgLy8gKnRleHQqIGZvbnQsIGUuZy4gY21yMTAuIEthVGVYIGluc3RlYWQgdXNlcyB2YWx1ZXMgZnJvbSB0aGVcbiAgICAvLyBjb21wYXJhYmx5LXNpemVkICpDb21wdXRlciBNb2Rlcm4gc3ltYm9sKiBmb250LiBBdCAxMHB0LCB0aGVzZVxuICAgIC8vIG1hdGNoLiBBdCA3cHQgYW5kIDVwdCwgdGhleSBkaWZmZXI6IGNtcjc9MS4xMzg4OTQsIGNtc3k3PTEuMTcwNjQxO1xuICAgIC8vIGNtcjU9MS4zNjExMzMsIGNtc3k1PTEuNDcyMjQxLiBDb25zaWRlciAkXFxzY3JpcHRzaXplIGFcXGtlcm4xZW1iJC5cbiAgICAvLyBUZVggXFxzaG93bGlzdHMgc2hvd3MgYSBrZXJuIG9mIDEuMTM4ODkgKiBmb250c2l6ZTtcbiAgICAvLyBLYVRlWCBzaG93cyBhIGtlcm4gb2YgMS4xNzEgKiBmb250c2l6ZS5cblxuXG4gICAgaWYgKHNpemVWYWx1ZS51bml0ID09PSBcImV4XCIpIHtcbiAgICAgIHNjYWxlID0gdW5pdE9wdGlvbnMuZm9udE1ldHJpY3MoKS54SGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoc2l6ZVZhbHVlLnVuaXQgPT09IFwiZW1cIikge1xuICAgICAgc2NhbGUgPSB1bml0T3B0aW9ucy5mb250TWV0cmljcygpLnF1YWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCB1bml0OiAnXCIgKyBzaXplVmFsdWUudW5pdCArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICBpZiAodW5pdE9wdGlvbnMgIT09IG9wdGlvbnMpIHtcbiAgICAgIHNjYWxlICo9IHVuaXRPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTWF0aC5taW4oc2l6ZVZhbHVlLm51bWJlciAqIHNjYWxlLCBvcHRpb25zLm1heFNpemUpO1xufTtcbi8qKlxuICogUm91bmQgYG5gIHRvIDQgZGVjaW1hbCBwbGFjZXMsIG9yIHRvIHRoZSBuZWFyZXN0IDEvMTAsMDAwdGggZW0uIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL0thVGVYL0thVGVYL3B1bGwvMjQ2MC5cbiAqL1xuXG52YXIgbWFrZUVtID0gZnVuY3Rpb24gbWFrZUVtKG4pIHtcbiAgcmV0dXJuICtuLnRvRml4ZWQoNCkgKyBcImVtXCI7XG59O1xuXG4vKipcbiAqIFRoZXNlIG9iamVjdHMgc3RvcmUgdGhlIGRhdGEgYWJvdXQgdGhlIERPTSBub2RlcyB3ZSBjcmVhdGUsIGFzIHdlbGwgYXMgc29tZVxuICogZXh0cmEgZGF0YS4gVGhleSBjYW4gdGhlbiBiZSB0cmFuc2Zvcm1lZCBpbnRvIHJlYWwgRE9NIG5vZGVzIHdpdGggdGhlXG4gKiBgdG9Ob2RlYCBmdW5jdGlvbiBvciBIVE1MIG1hcmt1cCB1c2luZyBgdG9NYXJrdXBgLiBUaGV5IGFyZSB1c2VmdWwgZm9yIGJvdGhcbiAqIHN0b3JpbmcgZXh0cmEgcHJvcGVydGllcyBvbiB0aGUgbm9kZXMsIGFzIHdlbGwgYXMgcHJvdmlkaW5nIGEgd2F5IHRvIGVhc2lseVxuICogd29yayB3aXRoIHRoZSBET00uXG4gKlxuICogU2ltaWxhciBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBNYXRoTUwgbm9kZXMgZXhpc3QgaW4gbWF0aE1MVHJlZS5qcy5cbiAqXG4gKiBUT0RPOiByZWZhY3RvciBgc3BhbmAgYW5kIGBhbmNob3JgIGludG8gY29tbW9uIHN1cGVyY2xhc3Mgd2hlblxuICogdGFyZ2V0IGVudmlyb25tZW50cyBzdXBwb3J0IGNsYXNzIGluaGVyaXRhbmNlXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYW4gSFRNTCBjbGFzc05hbWUgYmFzZWQgb24gYSBsaXN0IG9mIGNsYXNzZXMuIEluIGFkZGl0aW9uIHRvIGpvaW5pbmdcbiAqIHdpdGggc3BhY2VzLCB3ZSBhbHNvIHJlbW92ZSBlbXB0eSBjbGFzc2VzLlxuICovXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiBjcmVhdGVDbGFzcyhjbGFzc2VzKSB7XG4gIHJldHVybiBjbGFzc2VzLmZpbHRlcihjbHMgPT4gY2xzKS5qb2luKFwiIFwiKTtcbn07XG5cbnZhciBpbml0Tm9kZSA9IGZ1bmN0aW9uIGluaXROb2RlKGNsYXNzZXMsIG9wdGlvbnMsIHN0eWxlKSB7XG4gIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG4gIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICB0aGlzLmhlaWdodCA9IDA7XG4gIHRoaXMuZGVwdGggPSAwO1xuICB0aGlzLm1heEZvbnRTaXplID0gMDtcbiAgdGhpcy5zdHlsZSA9IHN0eWxlIHx8IHt9O1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuc3R5bGUuaXNUaWdodCgpKSB7XG4gICAgICB0aGlzLmNsYXNzZXMucHVzaChcIm10aWdodFwiKTtcbiAgICB9XG5cbiAgICB2YXIgY29sb3IgPSBvcHRpb25zLmdldENvbG9yKCk7XG5cbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIHRoaXMuc3R5bGUuY29sb3IgPSBjb2xvcjtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIENvbnZlcnQgaW50byBhbiBIVE1MIG5vZGVcbiAqL1xuXG5cbnZhciB0b05vZGUgPSBmdW5jdGlvbiB0b05vZGUodGFnTmFtZSkge1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7IC8vIEFwcGx5IHRoZSBjbGFzc1xuXG4gIG5vZGUuY2xhc3NOYW1lID0gY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKTsgLy8gQXBwbHkgaW5saW5lIHN0eWxlc1xuXG4gIGZvciAodmFyIHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgIC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IHNlZW0gdG8gdW5kZXJzdGFuZCBzcGFuLnN0eWxlJ3MgdHlwZS5cbiAgICAgIG5vZGUuc3R5bGVbc3R5bGVdID0gdGhpcy5zdHlsZVtzdHlsZV07XG4gICAgfVxuICB9IC8vIEFwcGx5IGF0dHJpYnV0ZXNcblxuXG4gIGZvciAodmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgaWYgKHRoaXMuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICB9XG4gIH0gLy8gQXBwZW5kIHRoZSBjaGlsZHJlbiwgYWxzbyBhcyBIVE1MIG5vZGVzXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuLyoqXG4gKiBodHRwczovL3czYy5naXRodWIuaW8vaHRtbC1yZWZlcmVuY2Uvc3ludGF4Lmh0bWwjc3ludGF4LWF0dHJpYnV0ZXNcbiAqXG4gKiA+IEF0dHJpYnV0ZSBOYW1lcyBtdXN0IGNvbnNpc3Qgb2Ygb25lIG9yIG1vcmUgY2hhcmFjdGVyc1xuICogb3RoZXIgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVycywgVSswMDAwIE5VTEwsXG4gKiAnXCInLCBcIidcIiwgXCI+XCIsIFwiL1wiLCBcIj1cIiwgdGhlIGNvbnRyb2wgY2hhcmFjdGVycyxcbiAqIGFuZCBhbnkgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgZGVmaW5lZCBieSBVbmljb2RlLlxuICovXG5cblxudmFyIGludmFsaWRBdHRyaWJ1dGVOYW1lUmVnZXggPSAvW1xcc1wiJz4vPVxceDAwLVxceDFmXS87XG4vKipcbiAqIENvbnZlcnQgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmdcbiAqL1xuXG52YXIgdG9NYXJrdXAgPSBmdW5jdGlvbiB0b01hcmt1cCh0YWdOYW1lKSB7XG4gIHZhciBtYXJrdXAgPSBcIjxcIiArIHRhZ05hbWU7IC8vIEFkZCB0aGUgY2xhc3NcblxuICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCkge1xuICAgIG1hcmt1cCArPSBcIiBjbGFzcz1cXFwiXCIgKyB1dGlscy5lc2NhcGUoY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSkgKyBcIlxcXCJcIjtcbiAgfVxuXG4gIHZhciBzdHlsZXMgPSBcIlwiOyAvLyBBZGQgdGhlIHN0eWxlcywgYWZ0ZXIgaHlwaGVuYXRpb25cblxuICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgaWYgKHRoaXMuc3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICBzdHlsZXMgKz0gdXRpbHMuaHlwaGVuYXRlKHN0eWxlKSArIFwiOlwiICsgdGhpcy5zdHlsZVtzdHlsZV0gKyBcIjtcIjtcbiAgICB9XG4gIH1cblxuICBpZiAoc3R5bGVzKSB7XG4gICAgbWFya3VwICs9IFwiIHN0eWxlPVxcXCJcIiArIHV0aWxzLmVzY2FwZShzdHlsZXMpICsgXCJcXFwiXCI7XG4gIH0gLy8gQWRkIHRoZSBhdHRyaWJ1dGVzXG5cblxuICBmb3IgKHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlTmFtZVJlZ2V4LnRlc3QoYXR0cikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lICdcIiArIGF0dHIgKyBcIidcIik7XG4gICAgICB9XG5cbiAgICAgIG1hcmt1cCArPSBcIiBcIiArIGF0dHIgKyBcIj1cXFwiXCIgKyB1dGlscy5lc2NhcGUodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKSArIFwiXFxcIlwiO1xuICAgIH1cbiAgfVxuXG4gIG1hcmt1cCArPSBcIj5cIjsgLy8gQWRkIHRoZSBtYXJrdXAgb2YgdGhlIGNoaWxkcmVuLCBhbHNvIGFzIG1hcmt1cFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIG1hcmt1cCArPSB0aGlzLmNoaWxkcmVuW2ldLnRvTWFya3VwKCk7XG4gIH1cblxuICBtYXJrdXAgKz0gXCI8L1wiICsgdGFnTmFtZSArIFwiPlwiO1xuICByZXR1cm4gbWFya3VwO1xufTsgLy8gTWFraW5nIHRoZSB0eXBlIGJlbG93IGV4YWN0IHdpdGggYWxsIG9wdGlvbmFsIGZpZWxkcyBkb2Vzbid0IHdvcmsgZHVlIHRvXG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy80NTgyXG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy81Njg4XG4vLyBIb3dldmVyLCBzaW5jZSAqYWxsKiBmaWVsZHMgYXJlIG9wdGlvbmFsLCAkU2hhcGU8PiB3b3JrcyBhcyBzdWdnZXN0ZWQgaW4gNTY4OFxuLy8gYWJvdmUuXG4vLyBUaGlzIHR5cGUgZG9lcyBub3QgaW5jbHVkZSBhbGwgQ1NTIHByb3BlcnRpZXMuIEFkZGl0aW9uYWwgcHJvcGVydGllcyBzaG91bGRcbi8vIGJlIGFkZGVkIGFzIG5lZWRlZC5cblxuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgc3BhbiBub2RlLCB3aXRoIGEgY2xhc3NOYW1lLCBhIGxpc3Qgb2YgY2hpbGRyZW4sIGFuZFxuICogYW4gaW5saW5lIHN0eWxlLiBJdCBhbHNvIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGl0cyBoZWlnaHQsIGRlcHRoLCBhbmRcbiAqIG1heEZvbnRTaXplLlxuICpcbiAqIFJlcHJlc2VudHMgdHdvIHR5cGVzIHdpdGggZGlmZmVyZW50IHVzZXM6IFN2Z1NwYW4gdG8gd3JhcCBhbiBTVkcgYW5kIERvbVNwYW5cbiAqIG90aGVyd2lzZS4gVGhpcyB0eXBlc2FmZXR5IGlzIGltcG9ydGFudCB3aGVuIEhUTUwgYnVpbGRlcnMgYWNjZXNzIGEgc3BhbidzXG4gKiBjaGlsZHJlbi5cbiAqL1xuY2xhc3MgU3BhbiB7XG4gIGNvbnN0cnVjdG9yKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zLCBzdHlsZSkge1xuICAgIHRoaXMuY2hpbGRyZW4gPSB2b2lkIDA7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gdm9pZCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmhlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmRlcHRoID0gdm9pZCAwO1xuICAgIHRoaXMud2lkdGggPSB2b2lkIDA7XG4gICAgdGhpcy5tYXhGb250U2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0eWxlID0gdm9pZCAwO1xuICAgIGluaXROb2RlLmNhbGwodGhpcywgY2xhc3Nlcywgb3B0aW9ucywgc3R5bGUpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhbiBhcmJpdHJhcnkgYXR0cmlidXRlIG9uIHRoZSBzcGFuLiBXYXJuaW5nOiB1c2UgdGhpcyB3aXNlbHkuIE5vdFxuICAgKiBhbGwgYnJvd3NlcnMgc3VwcG9ydCBhdHRyaWJ1dGVzIHRoZSBzYW1lLCBhbmQgaGF2aW5nIHRvbyBtYW55IGN1c3RvbVxuICAgKiBhdHRyaWJ1dGVzIGlzIHByb2JhYmx5IGJhZC5cbiAgICovXG5cblxuICBzZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gdmFsdWU7XG4gIH1cblxuICBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc2VzLmluY2x1ZGVzKGNsYXNzTmFtZSk7XG4gIH1cblxuICB0b05vZGUoKSB7XG4gICAgcmV0dXJuIHRvTm9kZS5jYWxsKHRoaXMsIFwic3BhblwiKTtcbiAgfVxuXG4gIHRvTWFya3VwKCkge1xuICAgIHJldHVybiB0b01hcmt1cC5jYWxsKHRoaXMsIFwic3BhblwiKTtcbiAgfVxuXG59XG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGFuIGFuY2hvciAoPGE+KSBlbGVtZW50IHdpdGggYSBoeXBlcmxpbmsuICBTZWUgYHNwYW5gXG4gKiBmb3IgZnVydGhlciBkZXRhaWxzLlxuICovXG5cbmNsYXNzIEFuY2hvciB7XG4gIGNvbnN0cnVjdG9yKGhyZWYsIGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGFzc2VzID0gdm9pZCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMuZGVwdGggPSB2b2lkIDA7XG4gICAgdGhpcy5tYXhGb250U2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0eWxlID0gdm9pZCAwO1xuICAgIGluaXROb2RlLmNhbGwodGhpcywgY2xhc3Nlcywgb3B0aW9ucyk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IFtdO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gIH1cblxuICBzZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gdmFsdWU7XG4gIH1cblxuICBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc2VzLmluY2x1ZGVzKGNsYXNzTmFtZSk7XG4gIH1cblxuICB0b05vZGUoKSB7XG4gICAgcmV0dXJuIHRvTm9kZS5jYWxsKHRoaXMsIFwiYVwiKTtcbiAgfVxuXG4gIHRvTWFya3VwKCkge1xuICAgIHJldHVybiB0b01hcmt1cC5jYWxsKHRoaXMsIFwiYVwiKTtcbiAgfVxuXG59XG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGFuIGltYWdlIGVtYmVkICg8aW1nPikgZWxlbWVudC5cbiAqL1xuXG5jbGFzcyBJbWcge1xuICBjb25zdHJ1Y3RvcihzcmMsIGFsdCwgc3R5bGUpIHtcbiAgICB0aGlzLnNyYyA9IHZvaWQgMDtcbiAgICB0aGlzLmFsdCA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXB0aCA9IHZvaWQgMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5hbHQgPSBhbHQ7XG4gICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgdGhpcy5jbGFzc2VzID0gW1wibW9yZFwiXTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gIH1cblxuICBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc2VzLmluY2x1ZGVzKGNsYXNzTmFtZSk7XG4gIH1cblxuICB0b05vZGUoKSB7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgIG5vZGUuc3JjID0gdGhpcy5zcmM7XG4gICAgbm9kZS5hbHQgPSB0aGlzLmFsdDtcbiAgICBub2RlLmNsYXNzTmFtZSA9IFwibW9yZFwiOyAvLyBBcHBseSBpbmxpbmUgc3R5bGVzXG5cbiAgICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICBub2RlLnN0eWxlW3N0eWxlXSA9IHRoaXMuc3R5bGVbc3R5bGVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgdmFyIG1hcmt1cCA9IFwiPGltZyBzcmM9XFxcIlwiICsgdXRpbHMuZXNjYXBlKHRoaXMuc3JjKSArIFwiXFxcIlwiICsgKFwiIGFsdD1cXFwiXCIgKyB1dGlscy5lc2NhcGUodGhpcy5hbHQpICsgXCJcXFwiXCIpOyAvLyBBZGQgdGhlIHN0eWxlcywgYWZ0ZXIgaHlwaGVuYXRpb25cblxuICAgIHZhciBzdHlsZXMgPSBcIlwiO1xuXG4gICAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgaWYgKHRoaXMuc3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgIHN0eWxlcyArPSB1dGlscy5oeXBoZW5hdGUoc3R5bGUpICsgXCI6XCIgKyB0aGlzLnN0eWxlW3N0eWxlXSArIFwiO1wiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHlsZXMpIHtcbiAgICAgIG1hcmt1cCArPSBcIiBzdHlsZT1cXFwiXCIgKyB1dGlscy5lc2NhcGUoc3R5bGVzKSArIFwiXFxcIlwiO1xuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIicvPlwiO1xuICAgIHJldHVybiBtYXJrdXA7XG4gIH1cblxufVxudmFyIGlDb21iaW5hdGlvbnMgPSB7XG4gICfDric6ICdcXHUwMTMxXFx1MDMwMicsXG4gICfDryc6ICdcXHUwMTMxXFx1MDMwOCcsXG4gICfDrSc6ICdcXHUwMTMxXFx1MDMwMScsXG4gIC8vICfEqyc6ICdcXHUwMTMxXFx1MDMwNCcsIC8vIGVuYWJsZSB3aGVuIHdlIGFkZCBFeHRlbmRlZCBMYXRpblxuICAnw6wnOiAnXFx1MDEzMVxcdTAzMDAnXG59O1xuLyoqXG4gKiBBIHN5bWJvbCBub2RlIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGEgc2luZ2xlIHN5bWJvbC4gSXQgZWl0aGVyIHJlbmRlcnNcbiAqIHRvIGEgc2luZ2xlIHRleHQgbm9kZSwgb3IgYSBzcGFuIHdpdGggYSBzaW5nbGUgdGV4dCBub2RlIGluIGl0LCBkZXBlbmRpbmcgb25cbiAqIHdoZXRoZXIgaXQgaGFzIENTUyBjbGFzc2VzLCBzdHlsZXMsIG9yIG5lZWRzIGl0YWxpYyBjb3JyZWN0aW9uLlxuICovXG5cbmNsYXNzIFN5bWJvbE5vZGUge1xuICBjb25zdHJ1Y3Rvcih0ZXh0LCBoZWlnaHQsIGRlcHRoLCBpdGFsaWMsIHNrZXcsIHdpZHRoLCBjbGFzc2VzLCBzdHlsZSkge1xuICAgIHRoaXMudGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLmhlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmRlcHRoID0gdm9pZCAwO1xuICAgIHRoaXMuaXRhbGljID0gdm9pZCAwO1xuICAgIHRoaXMuc2tldyA9IHZvaWQgMDtcbiAgICB0aGlzLndpZHRoID0gdm9pZCAwO1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5jbGFzc2VzID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAwO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aCB8fCAwO1xuICAgIHRoaXMuaXRhbGljID0gaXRhbGljIHx8IDA7XG4gICAgdGhpcy5za2V3ID0gc2tldyB8fCAwO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlIHx8IHt9O1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSAwOyAvLyBNYXJrIHRleHQgZnJvbSBub24tTGF0aW4gc2NyaXB0cyB3aXRoIHNwZWNpZmljIGNsYXNzZXMgc28gdGhhdCB3ZVxuICAgIC8vIGNhbiBzcGVjaWZ5IHdoaWNoIGZvbnRzIHRvIHVzZS4gIFRoaXMgYWxsb3dzIHVzIHRvIHJlbmRlciB0aGVzZVxuICAgIC8vIGNoYXJhY3RlcnMgd2l0aCBhIHNlcmlmIGZvbnQgaW4gc2l0dWF0aW9ucyB3aGVyZSB0aGUgYnJvd3NlciB3b3VsZFxuICAgIC8vIGVpdGhlciBkZWZhdWx0IHRvIGEgc2FucyBzZXJpZiBvciByZW5kZXIgYSBwbGFjZWhvbGRlciBjaGFyYWN0ZXIuXG4gICAgLy8gV2UgdXNlIENTUyBjbGFzcyBuYW1lcyBsaWtlIGNqa19mYWxsYmFjaywgaGFuZ3VsX2ZhbGxiYWNrIGFuZFxuICAgIC8vIGJyYWhtaWNfZmFsbGJhY2suIFNlZSAuL3VuaWNvZGVTY3JpcHRzLmpzIGZvciB0aGUgc2V0IG9mIHBvc3NpYmxlXG4gICAgLy8gc2NyaXB0IG5hbWVzXG5cbiAgICB2YXIgc2NyaXB0ID0gc2NyaXB0RnJvbUNvZGVwb2ludCh0aGlzLnRleHQuY2hhckNvZGVBdCgwKSk7XG5cbiAgICBpZiAoc2NyaXB0KSB7XG4gICAgICB0aGlzLmNsYXNzZXMucHVzaChzY3JpcHQgKyBcIl9mYWxsYmFja1wiKTtcbiAgICB9XG5cbiAgICBpZiAoL1vDrsOvw63DrF0vLnRlc3QodGhpcy50ZXh0KSkge1xuICAgICAgLy8gYWRkIMSrIHdoZW4gd2UgYWRkIEV4dGVuZGVkIExhdGluXG4gICAgICB0aGlzLnRleHQgPSBpQ29tYmluYXRpb25zW3RoaXMudGV4dF07XG4gICAgfVxuICB9XG5cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xhc3Nlcy5pbmNsdWRlcyhjbGFzc05hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdGV4dCBub2RlIG9yIHNwYW4gZnJvbSBhIHN5bWJvbCBub2RlLiBOb3RlIHRoYXQgYSBzcGFuIGlzIG9ubHlcbiAgICogY3JlYXRlZCBpZiBpdCBpcyBuZWVkZWQuXG4gICAqL1xuXG5cbiAgdG9Ob2RlKCkge1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy50ZXh0KTtcbiAgICB2YXIgc3BhbiA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5pdGFsaWMgPiAwKSB7XG4gICAgICBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBzcGFuLnN0eWxlLm1hcmdpblJpZ2h0ID0gbWFrZUVtKHRoaXMuaXRhbGljKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIHNwYW4gPSBzcGFuIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgc3Bhbi5jbGFzc05hbWUgPSBjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICBzcGFuID0gc3BhbiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTsgLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qgc2VlbSB0byB1bmRlcnN0YW5kIHNwYW4uc3R5bGUncyB0eXBlLlxuXG4gICAgICAgIHNwYW4uc3R5bGVbc3R5bGVdID0gdGhpcy5zdHlsZVtzdHlsZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNwYW4pIHtcbiAgICAgIHNwYW4uYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICByZXR1cm4gc3BhbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBzeW1ib2wgbm9kZS5cbiAgICovXG5cblxuICB0b01hcmt1cCgpIHtcbiAgICAvLyBUT0RPKGFscGVydCk6IE1vcmUgZHVwbGljYXRpb24gdGhhbiBJJ2QgbGlrZSBmcm9tXG4gICAgLy8gc3Bhbi5wcm90b3R5cGUudG9NYXJrdXAgYW5kIHN5bWJvbE5vZGUucHJvdG90eXBlLnRvTm9kZS4uLlxuICAgIHZhciBuZWVkc1NwYW4gPSBmYWxzZTtcbiAgICB2YXIgbWFya3VwID0gXCI8c3BhblwiO1xuXG4gICAgaWYgKHRoaXMuY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgIG5lZWRzU3BhbiA9IHRydWU7XG4gICAgICBtYXJrdXAgKz0gXCIgY2xhc3M9XFxcIlwiO1xuICAgICAgbWFya3VwICs9IHV0aWxzLmVzY2FwZShjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpKTtcbiAgICAgIG1hcmt1cCArPSBcIlxcXCJcIjtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVzID0gXCJcIjtcblxuICAgIGlmICh0aGlzLml0YWxpYyA+IDApIHtcbiAgICAgIHN0eWxlcyArPSBcIm1hcmdpbi1yaWdodDpcIiArIHRoaXMuaXRhbGljICsgXCJlbTtcIjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgc3R5bGVzICs9IHV0aWxzLmh5cGhlbmF0ZShzdHlsZSkgKyBcIjpcIiArIHRoaXMuc3R5bGVbc3R5bGVdICsgXCI7XCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgbmVlZHNTcGFuID0gdHJ1ZTtcbiAgICAgIG1hcmt1cCArPSBcIiBzdHlsZT1cXFwiXCIgKyB1dGlscy5lc2NhcGUoc3R5bGVzKSArIFwiXFxcIlwiO1xuICAgIH1cblxuICAgIHZhciBlc2NhcGVkID0gdXRpbHMuZXNjYXBlKHRoaXMudGV4dCk7XG5cbiAgICBpZiAobmVlZHNTcGFuKSB7XG4gICAgICBtYXJrdXAgKz0gXCI+XCI7XG4gICAgICBtYXJrdXAgKz0gZXNjYXBlZDtcbiAgICAgIG1hcmt1cCArPSBcIjwvc3Bhbj5cIjtcbiAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlc2NhcGVkO1xuICAgIH1cbiAgfVxuXG59XG4vKipcbiAqIFNWRyBub2RlcyBhcmUgdXNlZCB0byByZW5kZXIgc3RyZXRjaHkgd2lkZSBlbGVtZW50cy5cbiAqL1xuXG5jbGFzcyBTdmdOb2RlIHtcbiAgY29uc3RydWN0b3IoY2hpbGRyZW4sIGF0dHJpYnV0ZXMpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgfVxuXG4gIHRvTm9kZSgpIHtcbiAgICB2YXIgc3ZnTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIFwic3ZnXCIpOyAvLyBBcHBseSBhdHRyaWJ1dGVzXG5cbiAgICBmb3IgKHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgdmFyIG1hcmt1cCA9IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiXCI7IC8vIEFwcGx5IGF0dHJpYnV0ZXNcblxuICAgIGZvciAodmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbWFya3VwICs9IFwiIFwiICsgYXR0ciArIFwiPVxcXCJcIiArIHV0aWxzLmVzY2FwZSh0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pICsgXCJcXFwiXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiPlwiO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIjwvc3ZnPlwiO1xuICAgIHJldHVybiBtYXJrdXA7XG4gIH1cblxufVxuY2xhc3MgUGF0aE5vZGUge1xuICBjb25zdHJ1Y3RvcihwYXRoTmFtZSwgYWx0ZXJuYXRlKSB7XG4gICAgdGhpcy5wYXRoTmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLmFsdGVybmF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBhdGhOYW1lID0gcGF0aE5hbWU7XG4gICAgdGhpcy5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7IC8vIFVzZWQgb25seSBmb3IgXFxzcXJ0LCBcXHBoYXNlLCAmIHRhbGwgZGVsaW1zXG4gIH1cblxuICB0b05vZGUoKSB7XG4gICAgdmFyIHN2Z05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCBcInBhdGhcIik7XG5cbiAgICBpZiAodGhpcy5hbHRlcm5hdGUpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZFwiLCB0aGlzLmFsdGVybmF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZFwiLCBwYXRoW3RoaXMucGF0aE5hbWVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHRvTWFya3VwKCkge1xuICAgIGlmICh0aGlzLmFsdGVybmF0ZSkge1xuICAgICAgcmV0dXJuIFwiPHBhdGggZD1cXFwiXCIgKyB1dGlscy5lc2NhcGUodGhpcy5hbHRlcm5hdGUpICsgXCJcXFwiLz5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiPHBhdGggZD1cXFwiXCIgKyB1dGlscy5lc2NhcGUocGF0aFt0aGlzLnBhdGhOYW1lXSkgKyBcIlxcXCIvPlwiO1xuICAgIH1cbiAgfVxuXG59XG5jbGFzcyBMaW5lTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGF0dHJpYnV0ZXMpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgfVxuXG4gIHRvTm9kZSgpIHtcbiAgICB2YXIgc3ZnTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIFwibGluZVwiKTsgLy8gQXBwbHkgYXR0cmlidXRlc1xuXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgdmFyIG1hcmt1cCA9IFwiPGxpbmVcIjtcblxuICAgIGZvciAodmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbWFya3VwICs9IFwiIFwiICsgYXR0ciArIFwiPVxcXCJcIiArIHV0aWxzLmVzY2FwZSh0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pICsgXCJcXFwiXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiLz5cIjtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9XG5cbn1cbmZ1bmN0aW9uIGFzc2VydFN5bWJvbERvbU5vZGUoZ3JvdXApIHtcbiAgaWYgKGdyb3VwIGluc3RhbmNlb2YgU3ltYm9sTm9kZSkge1xuICAgIHJldHVybiBncm91cDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzeW1ib2xOb2RlIGJ1dCBnb3QgXCIgKyBTdHJpbmcoZ3JvdXApICsgXCIuXCIpO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRTcGFuKGdyb3VwKSB7XG4gIGlmIChncm91cCBpbnN0YW5jZW9mIFNwYW4pIHtcbiAgICByZXR1cm4gZ3JvdXA7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3BhbjxIdG1sRG9tTm9kZT4gYnV0IGdvdCBcIiArIFN0cmluZyhncm91cCkgKyBcIi5cIik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZpbGUgaG9sZHMgYSBsaXN0IG9mIGFsbCBuby1hcmd1bWVudCBmdW5jdGlvbnMgYW5kIHNpbmdsZS1jaGFyYWN0ZXJcbiAqIHN5bWJvbHMgKGxpa2UgJ2EnIG9yICc7JykuXG4gKlxuICogRm9yIGVhY2ggb2YgdGhlIHN5bWJvbHMsIHRoZXJlIGFyZSB0aHJlZSBwcm9wZXJ0aWVzIHRoZXkgY2FuIGhhdmU6XG4gKiAtIGZvbnQgKHJlcXVpcmVkKTogdGhlIGZvbnQgdG8gYmUgdXNlZCBmb3IgdGhpcyBzeW1ib2wuIEVpdGhlciBcIm1haW5cIiAodGhlXG4gICAgIG5vcm1hbCBmb250KSwgb3IgXCJhbXNcIiAodGhlIGFtcyBmb250cykuXG4gKiAtIGdyb3VwIChyZXF1aXJlZCk6IHRoZSBQYXJzZU5vZGUgZ3JvdXAgdHlwZSB0aGUgc3ltYm9sIHNob3VsZCBoYXZlIChpLmUuXG4gICAgIFwidGV4dG9yZFwiLCBcIm1hdGhvcmRcIiwgZXRjKS5cbiAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9LYVRlWC9LYVRlWC93aWtpL0V4YW1pbmluZy1UZVgjZ3JvdXAtdHlwZXNcbiAqIC0gcmVwbGFjZTogdGhlIGNoYXJhY3RlciB0aGF0IHRoaXMgc3ltYm9sIG9yIGZ1bmN0aW9uIHNob3VsZCBiZVxuICogICByZXBsYWNlZCB3aXRoIChpLmUuIFwiXFxwaGlcIiBoYXMgYSByZXBsYWNlIHZhbHVlIG9mIFwiXFx1MDNkNVwiLCB0aGUgcGhpXG4gKiAgIGNoYXJhY3RlciBpbiB0aGUgbWFpbiBmb250KS5cbiAqXG4gKiBUaGUgb3V0ZXJtb3N0IG1hcCBpbiB0aGUgdGFibGUgaW5kaWNhdGVzIHdoYXQgbW9kZSB0aGUgc3ltYm9scyBzaG91bGQgYmVcbiAqIGFjY2VwdGVkIGluIChlLmcuIFwibWF0aFwiIG9yIFwidGV4dFwiKS5cbiAqL1xuLy8gU29tZSBvZiB0aGVzZSBoYXZlIGEgXCItdG9rZW5cIiBzdWZmaXggc2luY2UgdGhlc2UgYXJlIGFsc28gdXNlZCBhcyBgUGFyc2VOb2RlYFxuLy8gdHlwZXMgZm9yIHJhdyB0ZXh0IHRva2VucywgYW5kIHdlIHdhbnQgdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggaGlnaGVyLWxldmVsXG4vLyBgUGFyc2VOb2RlYCB0eXBlcy4gVGhlc2UgYFBhcnNlTm9kZWBzIGFyZSBjb25zdHJ1Y3RlZCB3aXRoaW4gYFBhcnNlcmAgYnlcbi8vIGxvb2tpbmcgdXAgdGhlIGBzeW1ib2xzYCBtYXAuXG52YXIgQVRPTVMgPSB7XG4gIFwiYmluXCI6IDEsXG4gIFwiY2xvc2VcIjogMSxcbiAgXCJpbm5lclwiOiAxLFxuICBcIm9wZW5cIjogMSxcbiAgXCJwdW5jdFwiOiAxLFxuICBcInJlbFwiOiAxXG59O1xudmFyIE5PTl9BVE9NUyA9IHtcbiAgXCJhY2NlbnQtdG9rZW5cIjogMSxcbiAgXCJtYXRob3JkXCI6IDEsXG4gIFwib3AtdG9rZW5cIjogMSxcbiAgXCJzcGFjaW5nXCI6IDEsXG4gIFwidGV4dG9yZFwiOiAxXG59O1xudmFyIHN5bWJvbHMgPSB7XG4gIFwibWF0aFwiOiB7fSxcbiAgXCJ0ZXh0XCI6IHt9XG59O1xuLyoqIGBhY2NlcHRVbmljb2RlQ2hhciA9IHRydWVgIGlzIG9ubHkgYXBwbGljYWJsZSBpZiBgcmVwbGFjZWAgaXMgc2V0LiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVTeW1ib2wobW9kZSwgZm9udCwgZ3JvdXAsIHJlcGxhY2UsIG5hbWUsIGFjY2VwdFVuaWNvZGVDaGFyKSB7XG4gIHN5bWJvbHNbbW9kZV1bbmFtZV0gPSB7XG4gICAgZm9udCxcbiAgICBncm91cCxcbiAgICByZXBsYWNlXG4gIH07XG5cbiAgaWYgKGFjY2VwdFVuaWNvZGVDaGFyICYmIHJlcGxhY2UpIHtcbiAgICBzeW1ib2xzW21vZGVdW3JlcGxhY2VdID0gc3ltYm9sc1ttb2RlXVtuYW1lXTtcbiAgfVxufSAvLyBTb21lIGFiYnJldmlhdGlvbnMgZm9yIGNvbW1vbmx5IHVzZWQgc3RyaW5ncy5cbi8vIFRoaXMgaGVscHMgbWluaWZ5IHRoZSBjb2RlLCBhbmQgYWxzbyBzcG90dGluZyB0eXBvcyB1c2luZyBqc2hpbnQuXG4vLyBtb2RlczpcblxudmFyIG1hdGggPSBcIm1hdGhcIjtcbnZhciB0ZXh0ID0gXCJ0ZXh0XCI7IC8vIGZvbnRzOlxuXG52YXIgbWFpbiA9IFwibWFpblwiO1xudmFyIGFtcyA9IFwiYW1zXCI7IC8vIGdyb3VwczpcblxudmFyIGFjY2VudCA9IFwiYWNjZW50LXRva2VuXCI7XG52YXIgYmluID0gXCJiaW5cIjtcbnZhciBjbG9zZSA9IFwiY2xvc2VcIjtcbnZhciBpbm5lciA9IFwiaW5uZXJcIjtcbnZhciBtYXRob3JkID0gXCJtYXRob3JkXCI7XG52YXIgb3AgPSBcIm9wLXRva2VuXCI7XG52YXIgb3BlbiA9IFwib3BlblwiO1xudmFyIHB1bmN0ID0gXCJwdW5jdFwiO1xudmFyIHJlbCA9IFwicmVsXCI7XG52YXIgc3BhY2luZyA9IFwic3BhY2luZ1wiO1xudmFyIHRleHRvcmQgPSBcInRleHRvcmRcIjsgLy8gTm93IGNvbWVzIHRoZSBzeW1ib2wgdGFibGVcbi8vIFJlbGF0aW9uIFN5bWJvbHNcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjYxXCIsIFwiXFxcXGVxdWl2XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjdhXCIsIFwiXFxcXHByZWNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyN2JcIiwgXCJcXFxcc3VjY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIzY1wiLCBcIlxcXFxzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYTVcIiwgXCJcXFxccGVycFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MmFhZlwiLCBcIlxcXFxwcmVjZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTJhYjBcIiwgXCJcXFxcc3VjY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjQzXCIsIFwiXFxcXHNpbWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjIzXCIsIFwiXFxcXG1pZFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2YVwiLCBcIlxcXFxsbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2YlwiLCBcIlxcXFxnZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI0ZFwiLCBcIlxcXFxhc3ltcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIyNVwiLCBcIlxcXFxwYXJhbGxlbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjJjOFwiLCBcIlxcXFxib3d0aWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIzMjNcIiwgXCJcXFxcc21pbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyOTFcIiwgXCJcXFxcc3FzdWJzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI5MlwiLCBcIlxcXFxzcXN1cHNldGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjUwXCIsIFwiXFxcXGRvdGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMzIyXCIsIFwiXFxcXGZyb3duXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjBiXCIsIFwiXFxcXG5pXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjFkXCIsIFwiXFxcXHByb3B0b1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjJhMlwiLCBcIlxcXFx2ZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjJhM1wiLCBcIlxcXFxkYXNodlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIwYlwiLCBcIlxcXFxvd25zXCIpOyAvLyBQdW5jdHVhdGlvblxuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsIFwiXFx1MDAyZVwiLCBcIlxcXFxsZG90cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBwdW5jdCwgXCJcXHUyMmM1XCIsIFwiXFxcXGNkb3RwXCIpOyAvLyBNaXNjIFN5bWJvbHNcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyM1wiLCBcIlxcXFwjXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyM1wiLCBcIlxcXFwjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyNlwiLCBcIlxcXFwmXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyNlwiLCBcIlxcXFwmXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjEzNVwiLCBcIlxcXFxhbGVwaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMDBcIiwgXCJcXFxcZm9yYWxsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjEwZlwiLCBcIlxcXFxoYmFyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIwM1wiLCBcIlxcXFxleGlzdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjA3XCIsIFwiXFxcXG5hYmxhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjY2ZFwiLCBcIlxcXFxmbGF0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExM1wiLCBcIlxcXFxlbGxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjZlXCIsIFwiXFxcXG5hdHVyYWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjYzXCIsIFwiXFxcXGNsdWJzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExOFwiLCBcIlxcXFx3cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NmZcIiwgXCJcXFxcc2hhcnBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjYyXCIsIFwiXFxcXGRpYW1vbmRzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExY1wiLCBcIlxcXFxSZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NjFcIiwgXCJcXFxcaGVhcnRzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExMVwiLCBcIlxcXFxJbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NjBcIiwgXCJcXFxcc3BhZGVzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBhN1wiLCBcIlxcXFxTXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBhN1wiLCBcIlxcXFxTXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBiNlwiLCBcIlxcXFxQXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBiNlwiLCBcIlxcXFxQXCIpOyAvLyBNYXRoIGFuZCBUZXh0XG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMjBcIiwgXCJcXFxcZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAyMFwiLCBcIlxcXFxkYWdcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDIwXCIsIFwiXFxcXHRleHRkYWdnZXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDIxXCIsIFwiXFxcXGRkYWdcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDIxXCIsIFwiXFxcXGRkYWdcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDIxXCIsIFwiXFxcXHRleHRkYWdnZXJkYmxcIik7IC8vIExhcmdlIERlbGltaXRlcnNcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIlxcdTIzYjFcIiwgXCJcXFxccm1vdXN0YWNoZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTIzYjBcIiwgXCJcXFxcbG1vdXN0YWNoZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJcXHUyN2VmXCIsIFwiXFxcXHJncm91cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTI3ZWVcIiwgXCJcXFxcbGdyb3VwXCIsIHRydWUpOyAvLyBCaW5hcnkgT3BlcmF0b3JzXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIxM1wiLCBcIlxcXFxtcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5NlwiLCBcIlxcXFxvbWludXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOGVcIiwgXCJcXFxcdXBsdXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTNcIiwgXCJcXFxcc3FjYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTdcIiwgXCJcXFxcYXN0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjk0XCIsIFwiXFxcXHNxY3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyNWVmXCIsIFwiXFxcXGJpZ2NpcmNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTlcIiwgXCJcXFxcYnVsbGV0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMDIxXCIsIFwiXFxcXGRkYWdnZXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyNDBcIiwgXCJcXFxcd3JcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTJhM2ZcIiwgXCJcXFxcYW1hbGdcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTAwMjZcIiwgXCJcXFxcQW5kXCIpOyAvLyBmcm9tIGFtc21hdGhcbi8vIEFycm93IFN5bWJvbHNcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2Y1XCIsIFwiXFxcXGxvbmdsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxZDBcIiwgXCJcXFxcTGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2Y4XCIsIFwiXFxcXExvbmdsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3ZjZcIiwgXCJcXFxcbG9uZ3JpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxZDJcIiwgXCJcXFxcUmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjdmOVwiLCBcIlxcXFxMb25ncmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5NFwiLCBcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjdmN1wiLCBcIlxcXFxsb25nbGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxZDRcIiwgXCJcXFxcTGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3ZmFcIiwgXCJcXFxcTG9uZ2xlZnRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWE2XCIsIFwiXFxcXG1hcHN0b1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjdmY1wiLCBcIlxcXFxsb25nbWFwc3RvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk3XCIsIFwiXFxcXG5lYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxYTlcIiwgXCJcXFxcaG9va2xlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFhYVwiLCBcIlxcXFxob29rcmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5OFwiLCBcIlxcXFxzZWFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWJjXCIsIFwiXFxcXGxlZnRoYXJwb29udXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxYzBcIiwgXCJcXFxccmlnaHRoYXJwb29udXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTlcIiwgXCJcXFxcc3dhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFiZFwiLCBcIlxcXFxsZWZ0aGFycG9vbmRvd25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxYzFcIiwgXCJcXFxccmlnaHRoYXJwb29uZG93blwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5NlwiLCBcIlxcXFxud2Fycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWNjXCIsIFwiXFxcXHJpZ2h0bGVmdGhhcnBvb25zXCIsIHRydWUpOyAvLyBBTVMgTmVnYXRlZCBCaW5hcnkgUmVsYXRpb25zXG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjZlXCIsIFwiXFxcXG5sZXNzXCIsIHRydWUpOyAvLyBTeW1ib2wgbmFtZXMgcHJlY2VkZWQgYnkgXCJAXCIgZWFjaCBoYXZlIGEgY29ycmVzcG9uZGluZyBtYWNyby5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMTBcIiwgXCJcXFxcQG5sZXFzbGFudFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDExXCIsIFwiXFxcXEBubGVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYTg3XCIsIFwiXFxcXGxuZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2OFwiLCBcIlxcXFxsbmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDBjXCIsIFwiXFxcXEBsdmVydG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlNlwiLCBcIlxcXFxsbnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYTg5XCIsIFwiXFxcXGxuYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyODBcIiwgXCJcXFxcbnByZWNcIiwgdHJ1ZSk7IC8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIyZTAgdG8gXFxucHJlY2N1cmx5ZXEuIFdlJ2xsIHVzZSB0aGUgQU1TIHN5bm9ueW0uXG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmUwXCIsIFwiXFxcXG5wcmVjZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlOFwiLCBcIlxcXFxwcmVjbnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWI5XCIsIFwiXFxcXHByZWNuYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNDFcIiwgXCJcXFxcbnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDA2XCIsIFwiXFxcXEBuc2hvcnRtaWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIyNFwiLCBcIlxcXFxubWlkXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWNcIiwgXCJcXFxcbnZkYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWRcIiwgXCJcXFxcbnZEYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZWFcIiwgXCJcXFxcbnRyaWFuZ2xlbGVmdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmVjXCIsIFwiXFxcXG50cmlhbmdsZWxlZnRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjhhXCIsIFwiXFxcXHN1YnNldG5lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDFhXCIsIFwiXFxcXEB2YXJzdWJzZXRuZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmFjYlwiLCBcIlxcXFxzdWJzZXRuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMTdcIiwgXCJcXFxcQHZhcnN1YnNldG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2ZlwiLCBcIlxcXFxuZ3RyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMGZcIiwgXCJcXFxcQG5nZXFzbGFudFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDBlXCIsIFwiXFxcXEBuZ2VxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYTg4XCIsIFwiXFxcXGduZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2OVwiLCBcIlxcXFxnbmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDBkXCIsIFwiXFxcXEBndmVydG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlN1wiLCBcIlxcXFxnbnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYThhXCIsIFwiXFxcXGduYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyODFcIiwgXCJcXFxcbnN1Y2NcIiwgdHJ1ZSk7IC8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIyZTEgdG8gXFxuc3VjY2N1cmx5ZXEuIFdlJ2xsIHVzZSB0aGUgQU1TIHN5bm9ueW0uXG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmUxXCIsIFwiXFxcXG5zdWNjZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlOVwiLCBcIlxcXFxzdWNjbnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWJhXCIsIFwiXFxcXHN1Y2NuYXBwcm94XCIsIHRydWUpOyAvLyB1bmljb2RlLW1hdGggbWFwcyBcXHUyMjQ2IHRvIFxcc2ltbmVxcS4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNDZcIiwgXCJcXFxcbmNvbmdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAwN1wiLCBcIlxcXFxAbnNob3J0cGFyYWxsZWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIyNlwiLCBcIlxcXFxucGFyYWxsZWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJhZlwiLCBcIlxcXFxuVkRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlYlwiLCBcIlxcXFxudHJpYW5nbGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmVkXCIsIFwiXFxcXG50cmlhbmdsZXJpZ2h0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxOFwiLCBcIlxcXFxAbnN1cHNldGVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjhiXCIsIFwiXFxcXHN1cHNldG5lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDFiXCIsIFwiXFxcXEB2YXJzdXBzZXRuZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmFjY1wiLCBcIlxcXFxzdXBzZXRuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMTlcIiwgXCJcXFxcQHZhcnN1cHNldG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJhZVwiLCBcIlxcXFxuVmRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmFiNVwiLCBcIlxcXFxwcmVjbmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWI2XCIsIFwiXFxcXHN1Y2NuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMTZcIiwgXCJcXFxcQG5zdWJzZXRlcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJiNFwiLCBcIlxcXFx1bmxoZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmI1XCIsIFwiXFxcXHVucmhkXCIpOyAvLyBBTVMgTmVnYXRlZCBBcnJvd3NcblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxOWFcIiwgXCJcXFxcbmxlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMTliXCIsIFwiXFxcXG5yaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxY2RcIiwgXCJcXFxcbkxlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWNmXCIsIFwiXFxcXG5SaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYWVcIiwgXCJcXFxcbmxlZnRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxY2VcIiwgXCJcXFxcbkxlZnRyaWdodGFycm93XCIsIHRydWUpOyAvLyBBTVMgTWlzY1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjViM1wiLCBcIlxcXFx2YXJ0cmlhbmdsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjEwZlwiLCBcIlxcXFxoc2xhc2hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1YmRcIiwgXCJcXFxcdHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWNhXCIsIFwiXFxcXGxvemVuZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI0YzhcIiwgXCJcXFxcY2lyY2xlZFNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTAwYWVcIiwgXCJcXFxcY2lyY2xlZFJcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTAwYWVcIiwgXCJcXFxcY2lyY2xlZFJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIyMjFcIiwgXCJcXFxcbWVhc3VyZWRhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjIwNFwiLCBcIlxcXFxuZXhpc3RzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTI3XCIsIFwiXFxcXG1ob1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjEzMlwiLCBcIlxcXFxGaW52XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTQxXCIsIFwiXFxcXEdhbWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIwMzVcIiwgXCJcXFxcYmFja3ByaW1lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWIyXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1YmNcIiwgXCJcXFxcYmxhY2t0cmlhbmdsZWRvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1YTBcIiwgXCJcXFxcYmxhY2tzcXVhcmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI5ZWJcIiwgXCJcXFxcYmxhY2tsb3plbmdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNjA1XCIsIFwiXFxcXGJpZ3N0YXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIyMjJcIiwgXCJcXFxcc3BoZXJpY2FsYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIyMDFcIiwgXCJcXFxcY29tcGxlbWVudFwiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgVStGMCB0byBcXG1hdGhldGguIFdlIG1hcCB0byBBTVMgZnVuY3Rpb24gXFxldGhcblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUwMGYwXCIsIFwiXFxcXGV0aFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwZjBcIiwgXCJcXHUwMGYwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNTcxXCIsIFwiXFxcXGRpYWd1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjU3MlwiLCBcIlxcXFxkaWFnZG93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjVhMVwiLCBcIlxcXFxzcXVhcmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1YTFcIiwgXCJcXFxcQm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWNhXCIsIFwiXFxcXERpYW1vbmRcIik7IC8vIHVuaWNvZGUtbWF0aCBtYXBzIFUrQTUgdG8gXFxtYXRoeWVuLiBXZSBtYXAgdG8gQU1TIGZ1bmN0aW9uIFxceWVuXG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDBhNVwiLCBcIlxcXFx5ZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTAwYTVcIiwgXCJcXFxceWVuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNzEzXCIsIFwiXFxcXGNoZWNrbWFya1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBhbXMsIHRleHRvcmQsIFwiXFx1MjcxM1wiLCBcIlxcXFxjaGVja21hcmtcIik7IC8vIEFNUyBIZWJyZXdcblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTM2XCIsIFwiXFxcXGJldGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxMzhcIiwgXCJcXFxcZGFsZXRoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTM3XCIsIFwiXFxcXGdpbWVsXCIsIHRydWUpOyAvLyBBTVMgR3JlZWtcblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUwM2RkXCIsIFwiXFxcXGRpZ2FtbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTAzZjBcIiwgXCJcXFxcdmFya2FwcGFcIik7IC8vIEFNUyBEZWxpbWl0ZXJzXG5cbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIG9wZW4sIFwiXFx1MjUwY1wiLCBcIlxcXFxAdWxjb3JuZXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBjbG9zZSwgXCJcXHUyNTEwXCIsIFwiXFxcXEB1cmNvcm5lclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIG9wZW4sIFwiXFx1MjUxNFwiLCBcIlxcXFxAbGxjb3JuZXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBjbG9zZSwgXCJcXHUyNTE4XCIsIFwiXFxcXEBscmNvcm5lclwiLCB0cnVlKTsgLy8gQU1TIEJpbmFyeSBSZWxhdGlvbnNcblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNjZcIiwgXCJcXFxcbGVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYTdkXCIsIFwiXFxcXGxlcXNsYW50XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhOTVcIiwgXCJcXFxcZXFzbGFudGxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3MlwiLCBcIlxcXFxsZXNzc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODVcIiwgXCJcXFxcbGVzc2FwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjRhXCIsIFwiXFxcXGFwcHJveGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDZcIiwgXCJcXFxcbGVzc2RvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQ4XCIsIFwiXFxcXGxsbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjc2XCIsIFwiXFxcXGxlc3NndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkYVwiLCBcIlxcXFxsZXNzZXFndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4YlwiLCBcIlxcXFxsZXNzZXFxZ3RyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTFcIiwgXCJcXFxcZG90ZXFkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1M1wiLCBcIlxcXFxyaXNpbmdkb3RzZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1MlwiLCBcIlxcXFxmYWxsaW5nZG90c2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyM2RcIiwgXCJcXFxcYmFja3NpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmNkXCIsIFwiXFxcXGJhY2tzaW1lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWM1XCIsIFwiXFxcXHN1YnNldGVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQwXCIsIFwiXFxcXFN1YnNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjhmXCIsIFwiXFxcXHNxc3Vic2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyN2NcIiwgXCJcXFxccHJlY2N1cmx5ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkZVwiLCBcIlxcXFxjdXJseWVxcHJlY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjdlXCIsIFwiXFxcXHByZWNzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmFiN1wiLCBcIlxcXFxwcmVjYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYjJcIiwgXCJcXFxcdmFydHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYjRcIiwgXCJcXFxcdHJpYW5nbGVsZWZ0ZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJhOFwiLCBcIlxcXFx2RGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmFhXCIsIFwiXFxcXFZ2ZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMzIzXCIsIFwiXFxcXHNtYWxsc21pbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjMyMlwiLCBcIlxcXFxzbWFsbGZyb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNGZcIiwgXCJcXFxcYnVtcGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNGVcIiwgXCJcXFxcQnVtcGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNjdcIiwgXCJcXFxcZ2VxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYTdlXCIsIFwiXFxcXGdlcXNsYW50XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhOTZcIiwgXCJcXFxcZXFzbGFudGd0clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjczXCIsIFwiXFxcXGd0cnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYTg2XCIsIFwiXFxcXGd0cmFwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQ3XCIsIFwiXFxcXGd0cmRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQ5XCIsIFwiXFxcXGdnZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjc3XCIsIFwiXFxcXGd0cmxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkYlwiLCBcIlxcXFxndHJlcWxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4Y1wiLCBcIlxcXFxndHJlcXFsZXNzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTZcIiwgXCJcXFxcZXFjaXJjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNTdcIiwgXCJcXFxcY2lyY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNWNcIiwgXCJcXFxcdHJpYW5nbGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyM2NcIiwgXCJcXFxcdGhpY2tzaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0OFwiLCBcIlxcXFx0aGlja2FwcHJveFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWM2XCIsIFwiXFxcXHN1cHNldGVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQxXCIsIFwiXFxcXFN1cHNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjkwXCIsIFwiXFxcXHNxc3Vwc2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyN2RcIiwgXCJcXFxcc3VjY2N1cmx5ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkZlwiLCBcIlxcXFxjdXJseWVxc3VjY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjdmXCIsIFwiXFxcXHN1Y2NzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmFiOFwiLCBcIlxcXFxzdWNjYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYjNcIiwgXCJcXFxcdmFydHJpYW5nbGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmI1XCIsIFwiXFxcXHRyaWFuZ2xlcmlnaHRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmE5XCIsIFwiXFxcXFZkYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMjNcIiwgXCJcXFxcc2hvcnRtaWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIyNVwiLCBcIlxcXFxzaG9ydHBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNmNcIiwgXCJcXFxcYmV0d2VlblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQ0XCIsIFwiXFxcXHBpdGNoZm9ya1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjFkXCIsIFwiXFxcXHZhcnByb3B0b1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyNWMwXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVsZWZ0XCIpOyAvLyB1bmljb2RlLW1hdGggc2F5cyB0aGF0IFxcdGhlcmVmb3JlIGlzIGEgbWF0aG9yZCBhdG9tLlxuLy8gV2Uga2VwdCB0aGUgYW1zc3ltYiBhdG9tIHR5cGUsIHdoaWNoIGlzIHJlbC5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMzRcIiwgXCJcXFxcdGhlcmVmb3JlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMGRcIiwgXCJcXFxcYmFja2Vwc2lsb25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjViNlwiLCBcIlxcXFxibGFja3RyaWFuZ2xlcmlnaHRcIik7IC8vIHVuaWNvZGUtbWF0aCBzYXlzIHRoYXQgXFxiZWNhdXNlIGlzIGEgbWF0aG9yZCBhdG9tLlxuLy8gV2Uga2VwdCB0aGUgYW1zc3ltYiBhdG9tIHR5cGUsIHdoaWNoIGlzIHJlbC5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMzVcIiwgXCJcXFxcYmVjYXVzZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQ4XCIsIFwiXFxcXGxsbGVzc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmQ5XCIsIFwiXFxcXGdnZ3RyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYjJcIiwgXCJcXFxcbGhkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYjNcIiwgXCJcXFxccmhkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNDJcIiwgXCJcXFxcZXFzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYzhcIiwgXCJcXFxcSm9pblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjUxXCIsIFwiXFxcXERvdGVxXCIsIHRydWUpOyAvLyBBTVMgQmluYXJ5IE9wZXJhdG9yc1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjIxNFwiLCBcIlxcXFxkb3RwbHVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyMTZcIiwgXCJcXFxcc21hbGxzZXRtaW51c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQyXCIsIFwiXFxcXENhcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQzXCIsIFwiXFxcXEN1cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyYTVlXCIsIFwiXFxcXGRvdWJsZWJhcndlZGdlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyOWZcIiwgXCJcXFxcYm94bWludXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5ZVwiLCBcIlxcXFxib3hwbHVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYzdcIiwgXCJcXFxcZGl2aWRlb250aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmM5XCIsIFwiXFxcXGx0aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmNhXCIsIFwiXFxcXHJ0aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmNiXCIsIFwiXFxcXGxlZnR0aHJlZXRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2NcIiwgXCJcXFxccmlnaHR0aHJlZXRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2ZcIiwgXCJcXFxcY3VybHl3ZWRnZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmNlXCIsIFwiXFxcXGN1cmx5dmVlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyOWRcIiwgXCJcXFxcY2lyY2xlZGRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5YlwiLCBcIlxcXFxjaXJjbGVkYXN0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYzVcIiwgXCJcXFxcY2VudGVyZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYmFcIiwgXCJcXFxcaW50ZXJjYWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJkMlwiLCBcIlxcXFxkb3VibGVjYXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJkM1wiLCBcIlxcXFxkb3VibGVjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJhMFwiLCBcIlxcXFxib3h0aW1lc1wiLCB0cnVlKTsgLy8gQU1TIEFycm93c1xuLy8gTm90ZTogdW5pY29kZS1tYXRoIG1hcHMgXFx1MjFlMiB0byB0aGVpciBvd24gZnVuY3Rpb24gXFxyaWdodGRhc2hhcnJvdy5cbi8vIFdlJ2xsIG1hcCBpdCB0byBBTVMgZnVuY3Rpb24gXFxkYXNocmlnaHRhcnJvdy4gSXQgcHJvZHVjZXMgdGhlIHNhbWUgYXRvbS5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxZTJcIiwgXCJcXFxcZGFzaHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7IC8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIxZTAgdG8gXFxsZWZ0ZGFzaGFycm93LiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFlMFwiLCBcIlxcXFxkYXNobGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzdcIiwgXCJcXFxcbGVmdGxlZnRhcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjNlwiLCBcIlxcXFxsZWZ0cmlnaHRhcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFkYVwiLCBcIlxcXFxMbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxOWVcIiwgXCJcXFxcdHdvaGVhZGxlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWEyXCIsIFwiXFxcXGxlZnRhcnJvd3RhaWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFhYlwiLCBcIlxcXFxsb29wYXJyb3dsZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxY2JcIiwgXCJcXFxcbGVmdHJpZ2h0aGFycG9vbnNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFiNlwiLCBcIlxcXFxjdXJ2ZWFycm93bGVmdFwiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjFiYSB0byBcXGFjd29wZW5jaXJjbGVhcnJvdy4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmFcIiwgXCJcXFxcY2lyY2xlYXJyb3dsZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYjBcIiwgXCJcXFxcTHNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzhcIiwgXCJcXFxcdXB1cGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWJmXCIsIFwiXFxcXHVwaGFycG9vbmxlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjM1wiLCBcIlxcXFxkb3duaGFycG9vbmxlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYjZcIiwgXCJcXFxcb3JpZ29mXCIsIHRydWUpOyAvLyBub3QgaW4gZm9udFxuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYjdcIiwgXCJcXFxcaW1hZ2VvZlwiLCB0cnVlKTsgLy8gbm90IGluIGZvbnRcblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYjhcIiwgXCJcXFxcbXVsdGltYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFhZFwiLCBcIlxcXFxsZWZ0cmlnaHRzcXVpZ2Fycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzlcIiwgXCJcXFxccmlnaHRyaWdodGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWM0XCIsIFwiXFxcXHJpZ2h0bGVmdGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWEwXCIsIFwiXFxcXHR3b2hlYWRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYTNcIiwgXCJcXFxccmlnaHRhcnJvd3RhaWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFhY1wiLCBcIlxcXFxsb29wYXJyb3dyaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWI3XCIsIFwiXFxcXGN1cnZlYXJyb3dyaWdodFwiLCB0cnVlKTsgLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjFiYiB0byBcXGN3b3BlbmNpcmNsZWFycm93LiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFiYlwiLCBcIlxcXFxjaXJjbGVhcnJvd3JpZ2h0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYjFcIiwgXCJcXFxcUnNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxY2FcIiwgXCJcXFxcZG93bmRvd25hcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFiZVwiLCBcIlxcXFx1cGhhcnBvb25yaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWMyXCIsIFwiXFxcXGRvd25oYXJwb29ucmlnaHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFkZFwiLCBcIlxcXFxyaWdodHNxdWlnYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFkZFwiLCBcIlxcXFxsZWFkc3RvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxZGJcIiwgXCJcXFxcUnJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFiZVwiLCBcIlxcXFxyZXN0cmljdGlvblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCJgXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiJFwiLCBcIlxcXFwkXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiJFwiLCBcIlxcXFwkXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiJFwiLCBcIlxcXFx0ZXh0ZG9sbGFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiJVwiLCBcIlxcXFwlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiJVwiLCBcIlxcXFwlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiX1wiLCBcIlxcXFx0ZXh0dW5kZXJzY29yZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjBcIiwgXCJcXFxcYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjFlXCIsIFwiXFxcXGluZnR5XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAzMlwiLCBcIlxcXFxwcmltZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI1YjNcIiwgXCJcXFxcdHJpYW5nbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMzkzXCIsIFwiXFxcXEdhbW1hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDM5NFwiLCBcIlxcXFxEZWx0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzOThcIiwgXCJcXFxcVGhldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMzliXCIsIFwiXFxcXExhbWJkYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzOWVcIiwgXCJcXFxcWGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwM2EwXCIsIFwiXFxcXFBpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDNhM1wiLCBcIlxcXFxTaWdtYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzYTVcIiwgXCJcXFxcVXBzaWxvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzYTZcIiwgXCJcXFxcUGhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDNhOFwiLCBcIlxcXFxQc2lcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwM2E5XCIsIFwiXFxcXE9tZWdhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiQVwiLCBcIlxcdTAzOTFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJCXCIsIFwiXFx1MDM5MlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIkVcIiwgXCJcXHUwMzk1XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiWlwiLCBcIlxcdTAzOTZcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJIXCIsIFwiXFx1MDM5N1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIklcIiwgXCJcXHUwMzk5XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiS1wiLCBcIlxcdTAzOUFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJNXCIsIFwiXFx1MDM5Q1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIk5cIiwgXCJcXHUwMzlEXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiT1wiLCBcIlxcdTAzOUZcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJQXCIsIFwiXFx1MDNBMVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlRcIiwgXCJcXHUwM0E0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiWFwiLCBcIlxcdTAzQTdcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGFjXCIsIFwiXFxcXG5lZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYWNcIiwgXCJcXFxcbG5vdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyYTRcIiwgXCJcXFxcdG9wXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjJhNVwiLCBcIlxcXFxib3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjA1XCIsIFwiXFxcXGVtcHR5c2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjA1XCIsIFwiXFxcXHZhcm5vdGhpbmdcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2IxXCIsIFwiXFxcXGFscGhhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiMlwiLCBcIlxcXFxiZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiM1wiLCBcIlxcXFxnYW1tYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjRcIiwgXCJcXFxcZGVsdGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2Y1XCIsIFwiXFxcXGVwc2lsb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I2XCIsIFwiXFxcXHpldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I3XCIsIFwiXFxcXGV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjhcIiwgXCJcXFxcdGhldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I5XCIsIFwiXFxcXGlvdGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2JhXCIsIFwiXFxcXGthcHBhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiYlwiLCBcIlxcXFxsYW1iZGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2JjXCIsIFwiXFxcXG11XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiZFwiLCBcIlxcXFxudVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYmVcIiwgXCJcXFxceGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2JmXCIsIFwiXFxcXG9taWNyb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2MwXCIsIFwiXFxcXHBpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjMVwiLCBcIlxcXFxyaG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2MzXCIsIFwiXFxcXHNpZ21hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjNFwiLCBcIlxcXFx0YXVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M1XCIsIFwiXFxcXHVwc2lsb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2Q1XCIsIFwiXFxcXHBoaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzdcIiwgXCJcXFxcY2hpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjOFwiLCBcIlxcXFxwc2lcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M5XCIsIFwiXFxcXG9tZWdhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiNVwiLCBcIlxcXFx2YXJlcHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNkMVwiLCBcIlxcXFx2YXJ0aGV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzZDZcIiwgXCJcXFxcdmFycGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2YxXCIsIFwiXFxcXHZhcnJob1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzJcIiwgXCJcXFxcdmFyc2lnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M2XCIsIFwiXFxcXHZhcnBoaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIxN1wiLCBcIipcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIitcIiwgXCIrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjEyXCIsIFwiLVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjJjNVwiLCBcIlxcXFxjZG90XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE4XCIsIFwiXFxcXGNpcmNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTAwZjdcIiwgXCJcXFxcZGl2XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUwMGIxXCIsIFwiXFxcXHBtXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUwMGQ3XCIsIFwiXFxcXHRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjI5XCIsIFwiXFxcXGNhcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyYVwiLCBcIlxcXFxjdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTZcIiwgXCJcXFxcc2V0bWludXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjdcIiwgXCJcXFxcbGFuZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyOFwiLCBcIlxcXFxsb3JcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjdcIiwgXCJcXFxcd2VkZ2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjhcIiwgXCJcXFxcdmVlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIxYVwiLCBcIlxcXFxzdXJkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiXFx1MjdlOFwiLCBcIlxcXFxsYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJcXHUyMjIzXCIsIFwiXFxcXGx2ZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiXFx1MjIyNVwiLCBcIlxcXFxsVmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCI/XCIsIFwiP1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCIhXCIsIFwiIVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJcXHUyN2U5XCIsIFwiXFxcXHJhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJcXHUyMjIzXCIsIFwiXFxcXHJ2ZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIlxcdTIyMjVcIiwgXCJcXFxcclZlcnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIj1cIiwgXCI9XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCI6XCIsIFwiOlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI0OFwiLCBcIlxcXFxhcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNDVcIiwgXCJcXFxcY29uZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2NVwiLCBcIlxcXFxnZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2NVwiLCBcIlxcXFxnZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTBcIiwgXCJcXFxcZ2V0c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiPlwiLCBcIlxcXFxndFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIwOFwiLCBcIlxcXFxpblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1ZTAyMFwiLCBcIlxcXFxAbm90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjgyXCIsIFwiXFxcXHN1YnNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI4M1wiLCBcIlxcXFxzdXBzZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyODZcIiwgXCJcXFxcc3Vic2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyODdcIiwgXCJcXFxcc3Vwc2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI4OFwiLCBcIlxcXFxuc3Vic2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI4OVwiLCBcIlxcXFxuc3Vwc2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYThcIiwgXCJcXFxcbW9kZWxzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTkwXCIsIFwiXFxcXGxlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2NFwiLCBcIlxcXFxsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2NFwiLCBcIlxcXFxsZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIjxcIiwgXCJcXFxcbHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTJcIiwgXCJcXFxccmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MlwiLCBcIlxcXFx0b1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjcxXCIsIFwiXFxcXG5nZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3MFwiLCBcIlxcXFxubGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFwgXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFxzcGFjZVwiKTsgLy8gUmVmOiBMYVRlWCBTb3VyY2UgMmU6IFxcRGVjbGFyZVJvYnVzdENvbW1hbmR7XFxub2JyZWFrc3BhY2V9eyVcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFxub2JyZWFrc3BhY2VcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXCBcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiIFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcc3BhY2VcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXG5vYnJlYWtzcGFjZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBudWxsLCBcIlxcXFxub2JyZWFrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHNwYWNpbmcsIG51bGwsIFwiXFxcXGFsbG93YnJlYWtcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsIFwiLFwiLCBcIixcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsIFwiO1wiLCBcIjtcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJiY1wiLCBcIlxcXFxiYXJ3ZWRnZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmJiXCIsIFwiXFxcXHZlZWJhclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5OVwiLCBcIlxcXFxvZG90XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjk1XCIsIFwiXFxcXG9wbHVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjk3XCIsIFwiXFxcXG90aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMDJcIiwgXCJcXFxccGFydGlhbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5OFwiLCBcIlxcXFxvc2xhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5YVwiLCBcIlxcXFxjaXJjbGVkY2lyY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmExXCIsIFwiXFxcXGJveGRvdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjViM1wiLCBcIlxcXFxiaWd0cmlhbmdsZXVwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyNWJkXCIsIFwiXFxcXGJpZ3RyaWFuZ2xlZG93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjAyMFwiLCBcIlxcXFxkYWdnZXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyYzRcIiwgXCJcXFxcZGlhbW9uZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjJjNlwiLCBcIlxcXFxzdGFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyNWMzXCIsIFwiXFxcXHRyaWFuZ2xlbGVmdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjViOVwiLCBcIlxcXFx0cmlhbmdsZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwie1wiLCBcIlxcXFx7XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwie1wiLCBcIlxcXFx7XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwie1wiLCBcIlxcXFx0ZXh0YnJhY2VsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIn1cIiwgXCJcXFxcfVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIn1cIiwgXCJcXFxcfVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIn1cIiwgXCJcXFxcdGV4dGJyYWNlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJ7XCIsIFwiXFxcXGxicmFjZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJ9XCIsIFwiXFxcXHJicmFjZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIltcIiwgXCJcXFxcbGJyYWNrXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiW1wiLCBcIlxcXFxsYnJhY2tcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiXVwiLCBcIlxcXFxyYnJhY2tcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJdXCIsIFwiXFxcXHJicmFja1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIihcIiwgXCJcXFxcbHBhcmVuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIilcIiwgXCJcXFxccnBhcmVuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiPFwiLCBcIlxcXFx0ZXh0bGVzc1wiLCB0cnVlKTsgLy8gaW4gVDEgZm9udGVuY1xuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCI+XCIsIFwiXFxcXHRleHRncmVhdGVyXCIsIHRydWUpOyAvLyBpbiBUMSBmb250ZW5jXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTIzMGFcIiwgXCJcXFxcbGZsb29yXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIlxcdTIzMGJcIiwgXCJcXFxccmZsb29yXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiXFx1MjMwOFwiLCBcIlxcXFxsY2VpbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJcXHUyMzA5XCIsIFwiXFxcXHJjZWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFxcXFwiLCBcIlxcXFxiYWNrc2xhc2hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjIzXCIsIFwifFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjNcIiwgXCJcXFxcdmVydFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcInxcIiwgXCJcXFxcdGV4dGJhclwiLCB0cnVlKTsgLy8gaW4gVDEgZm9udGVuY1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjI1XCIsIFwiXFxcXHxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjI1XCIsIFwiXFxcXFZlcnRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjI1XCIsIFwiXFxcXHRleHRiYXJkYmxcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJ+XCIsIFwiXFxcXHRleHRhc2NpaXRpbGRlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFxcXFwiLCBcIlxcXFx0ZXh0YmFja3NsYXNoXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXlwiLCBcIlxcXFx0ZXh0YXNjaWljaXJjdW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTFcIiwgXCJcXFxcdXBhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkMVwiLCBcIlxcXFxVcGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTkzXCIsIFwiXFxcXGRvd25hcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkM1wiLCBcIlxcXFxEb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTVcIiwgXCJcXFxcdXBkb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxZDVcIiwgXCJcXFxcVXBkb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIxMFwiLCBcIlxcXFxjb3Byb2RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjJjMVwiLCBcIlxcXFxiaWd2ZWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjJjMFwiLCBcIlxcXFxiaWd3ZWRnZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgXCJcXHUyYTA0XCIsIFwiXFxcXGJpZ3VwbHVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyYzJcIiwgXCJcXFxcYmlnY2FwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyYzNcIiwgXCJcXFxcYmlnY3VwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMmJcIiwgXCJcXFxcaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMmJcIiwgXCJcXFxcaW50b3BcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIyY1wiLCBcIlxcXFxpaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMmRcIiwgXCJcXFxcaWlpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIwZlwiLCBcIlxcXFxwcm9kXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMTFcIiwgXCJcXFxcc3VtXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTJhMDJcIiwgXCJcXFxcYmlnb3RpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTJhMDFcIiwgXCJcXFxcYmlnb3BsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MmEwMFwiLCBcIlxcXFxiaWdvZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMmVcIiwgXCJcXFxcb2ludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgXCJcXHUyMjJmXCIsIFwiXFxcXG9paW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTIyMzBcIiwgXCJcXFxcb2lpaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCBcIlxcdTJhMDZcIiwgXCJcXFxcYmlnc3FjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxzbWFsbGludFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXHRleHRlbGxpcHNpc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXG1hdGhlbGxpcHNpc1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXGxkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGlubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcbGRvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgaW5uZXIsIFwiXFx1MjJlZlwiLCBcIlxcXFxAY2RvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgaW5uZXIsIFwiXFx1MjJmMVwiLCBcIlxcXFxkZG90c1wiLCB0cnVlKTsgLy8gXFx2ZG90cyBpcyBhIG1hY3JvIHRoYXQgdXNlcyBvbmUgb2YgdGhlc2UgdHdvIHN5bWJvbHMgKHdpdGggbWFkZS11cCBuYW1lcyk6XG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyZWVcIiwgXCJcXFxcdmFydmRvdHNcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMmVlXCIsIFwiXFxcXHZhcnZkb3RzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmNhXCIsIFwiXFxcXGFjdXRlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmNiXCIsIFwiXFxcXGdyYXZlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMGE4XCIsIFwiXFxcXGRkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYWNjZW50LCBcIlxcdTAwN2VcIiwgXCJcXFxcdGlsZGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYWNjZW50LCBcIlxcdTAyYzlcIiwgXCJcXFxcYmFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmQ4XCIsIFwiXFxcXGJyZXZlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmM3XCIsIFwiXFxcXGNoZWNrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMDVlXCIsIFwiXFxcXGhhdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MjBkN1wiLCBcIlxcXFx2ZWNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYWNjZW50LCBcIlxcdTAyZDlcIiwgXCJcXFxcZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmRhXCIsIFwiXFxcXG1hdGhyaW5nXCIpOyAvLyBcXGltYXRoIGFuZCBcXGptYXRoIHNob3VsZCBiZSBpbnZhcmlhbnQgdG8gXFxtYXRocm0sIFxcbWF0aGJmLCBldGMuLCBzbyB1c2UgUFVBXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdWUxMzFcIiwgXCJcXFxcQGltYXRoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1ZTIzN1wiLCBcIlxcXFxAam1hdGhcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMTMxXCIsIFwiXFx1MDEzMVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAyMzdcIiwgXCJcXHUwMjM3XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDEzMVwiLCBcIlxcXFxpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDIzN1wiLCBcIlxcXFxqXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBkZlwiLCBcIlxcXFxzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwZTZcIiwgXCJcXFxcYWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMTUzXCIsIFwiXFxcXG9lXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBmOFwiLCBcIlxcXFxvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBjNlwiLCBcIlxcXFxBRVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAxNTJcIiwgXCJcXFxcT0VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGQ4XCIsIFwiXFxcXE9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgYWNjZW50LCBcIlxcdTAyY2FcIiwgXCJcXFxcJ1wiKTsgLy8gYWN1dGVcblxuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIGFjY2VudCwgXCJcXHUwMmNiXCIsIFwiXFxcXGBcIik7IC8vIGdyYXZlXG5cbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJjNlwiLCBcIlxcXFxeXCIpOyAvLyBjaXJjdW1mbGV4XG5cbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJkY1wiLCBcIlxcXFx+XCIpOyAvLyB0aWxkZVxuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgYWNjZW50LCBcIlxcdTAyYzlcIiwgXCJcXFxcPVwiKTsgLy8gbWFjcm9uXG5cbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJkOFwiLCBcIlxcXFx1XCIpOyAvLyBicmV2ZVxuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgYWNjZW50LCBcIlxcdTAyZDlcIiwgXCJcXFxcLlwiKTsgLy8gZG90IGFib3ZlXG5cbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDBiOFwiLCBcIlxcXFxjXCIpOyAvLyBjZWRpbGxhXG5cbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJkYVwiLCBcIlxcXFxyXCIpOyAvLyByaW5nIGFib3ZlXG5cbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBhY2NlbnQsIFwiXFx1MDJjN1wiLCBcIlxcXFx2XCIpOyAvLyBjYXJvblxuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgYWNjZW50LCBcIlxcdTAwYThcIiwgJ1xcXFxcIicpOyAvLyBkaWFlcmVzaXNcblxuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIGFjY2VudCwgXCJcXHUwMmRkXCIsIFwiXFxcXEhcIik7IC8vIGRvdWJsZSBhY3V0ZVxuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgYWNjZW50LCBcIlxcdTI1ZWZcIiwgXCJcXFxcdGV4dGNpcmNsZWRcIik7IC8vIFxcYmlnY2lyYyBnbHlwaFxuLy8gVGhlc2UgbGlnYXR1cmVzIGFyZSBkZXRlY3RlZCBhbmQgY3JlYXRlZCBpbiBQYXJzZXIuanMncyBgZm9ybUxpZ2F0dXJlc2AuXG5cbnZhciBsaWdhdHVyZXMgPSB7XG4gIFwiLS1cIjogdHJ1ZSxcbiAgXCItLS1cIjogdHJ1ZSxcbiAgXCJgYFwiOiB0cnVlLFxuICBcIicnXCI6IHRydWVcbn07XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwiLS1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwiXFxcXHRleHRlbmRhc2hcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE0XCIsIFwiLS0tXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxNFwiLCBcIlxcXFx0ZXh0ZW1kYXNoXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxOFwiLCBcImBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE4XCIsIFwiXFxcXHRleHRxdW90ZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE5XCIsIFwiJ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMTlcIiwgXCJcXFxcdGV4dHF1b3RlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDFjXCIsIFwiYGBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDFjXCIsIFwiXFxcXHRleHRxdW90ZWRibGxlZnRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDFkXCIsIFwiJydcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDFkXCIsIFwiXFxcXHRleHRxdW90ZWRibHJpZ2h0XCIpOyAvLyAgXFxkZWdyZWUgZnJvbSBnZW5zeW1iIHBhY2thZ2VcblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBiMFwiLCBcIlxcXFxkZWdyZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGIwXCIsIFwiXFxcXGRlZ3JlZVwiKTsgLy8gXFx0ZXh0ZGVncmVlIGZyb20gaW5wdXRlbmMgcGFja2FnZVxuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGIwXCIsIFwiXFxcXHRleHRkZWdyZWVcIiwgdHJ1ZSk7IC8vIFRPRE86IEluIExhVGVYLCBcXHBvdW5kcyBjYW4gZ2VuZXJhdGUgYSBkaWZmZXJlbnQgY2hhcmFjdGVyIGluIHRleHQgYW5kIG1hdGhcbi8vIG1vZGUsIGJ1dCBhbW9uZyBvdXIgZm9udHMsIG9ubHkgTWFpbi1SZWd1bGFyIGRlZmluZXMgdGhpcyBjaGFyYWN0ZXIgXCIxNjNcIi5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBhM1wiLCBcIlxcXFxwb3VuZHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGEzXCIsIFwiXFxcXG1hdGhzdGVybGluZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYTNcIiwgXCJcXFxccG91bmRzXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBhM1wiLCBcIlxcXFx0ZXh0c3RlcmxpbmdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI3MjBcIiwgXCJcXFxcbWFsdGVzZVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBhbXMsIHRleHRvcmQsIFwiXFx1MjcyMFwiLCBcIlxcXFxtYWx0ZXNlXCIpOyAvLyBUaGVyZSBhcmUgbG90cyBvZiBzeW1ib2xzIHdoaWNoIGFyZSB0aGUgc2FtZSwgc28gd2UgYWRkIHRoZW0gaW4gYWZ0ZXJ3YXJkcy5cbi8vIEFsbCBvZiB0aGVzZSBhcmUgdGV4dG9yZHMgaW4gbWF0aCBtb2RlXG5cbnZhciBtYXRoVGV4dFN5bWJvbHMgPSBcIjAxMjM0NTY3ODkvQC5cXFwiXCI7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgbWF0aFRleHRTeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBjaCA9IG1hdGhUZXh0U3ltYm9scy5jaGFyQXQoaSk7XG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBjaCwgY2gpO1xufSAvLyBBbGwgb2YgdGhlc2UgYXJlIHRleHRvcmRzIGluIHRleHQgbW9kZVxuXG5cbnZhciB0ZXh0U3ltYm9scyA9IFwiMDEyMzQ1Njc4OSFAKigpLT0rXFxcIjs6Py8uLFwiO1xuXG5mb3IgKHZhciBfaSA9IDA7IF9pIDwgdGV4dFN5bWJvbHMubGVuZ3RoOyBfaSsrKSB7XG4gIHZhciBfY2ggPSB0ZXh0U3ltYm9scy5jaGFyQXQoX2kpO1xuXG4gIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2gsIF9jaCk7XG59IC8vIEFsbCBvZiB0aGVzZSBhcmUgdGV4dG9yZHMgaW4gdGV4dCBtb2RlLCBhbmQgbWF0aG9yZHMgaW4gbWF0aCBtb2RlXG5cblxudmFyIGxldHRlcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcblxuZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbGV0dGVycy5sZW5ndGg7IF9pMisrKSB7XG4gIHZhciBfY2gyID0gbGV0dGVycy5jaGFyQXQoX2kyKTtcblxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMiwgX2NoMik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2gyLCBfY2gyKTtcbn0gLy8gQmxhY2tib2FyZCBib2xkIGFuZCBzY3JpcHQgbGV0dGVycyBpbiBVbmljb2RlIHJhbmdlXG5cblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJDXCIsIFwiXFx1MjEwMlwiKTsgLy8gYmxhY2tib2FyZCBib2xkXG5cbmRlZmluZVN5bWJvbCh0ZXh0LCBhbXMsIHRleHRvcmQsIFwiQ1wiLCBcIlxcdTIxMDJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIkhcIiwgXCJcXHUyMTBEXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIGFtcywgdGV4dG9yZCwgXCJIXCIsIFwiXFx1MjEwRFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiTlwiLCBcIlxcdTIxMTVcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgYW1zLCB0ZXh0b3JkLCBcIk5cIiwgXCJcXHUyMTE1XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJQXCIsIFwiXFx1MjExOVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBhbXMsIHRleHRvcmQsIFwiUFwiLCBcIlxcdTIxMTlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlFcIiwgXCJcXHUyMTFBXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIGFtcywgdGV4dG9yZCwgXCJRXCIsIFwiXFx1MjExQVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiUlwiLCBcIlxcdTIxMURcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgYW1zLCB0ZXh0b3JkLCBcIlJcIiwgXCJcXHUyMTFEXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJaXCIsIFwiXFx1MjEyNFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBhbXMsIHRleHRvcmQsIFwiWlwiLCBcIlxcdTIxMjRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJoXCIsIFwiXFx1MjEwRVwiKTsgLy8gaXRhbGljIGgsIFBsYW5jayBjb25zdGFudFxuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgbWF0aG9yZCwgXCJoXCIsIFwiXFx1MjEwRVwiKTsgLy8gVGhlIG5leHQgbG9vcCBsb2FkcyB3aWRlIChzdXJyb2dhdGUgcGFpcikgY2hhcmFjdGVycy5cbi8vIFdlIHN1cHBvcnQgc29tZSBsZXR0ZXJzIGluIHRoZSBVbmljb2RlIHJhbmdlIFUrMUQ0MDAgdG8gVSsxRDdGRixcbi8vIE1hdGhlbWF0aWNhbCBBbHBoYW51bWVyaWMgU3ltYm9scy5cbi8vIFNvbWUgZWRpdG9ycyBkbyBub3QgZGVhbCB3ZWxsIHdpdGggd2lkZSBjaGFyYWN0ZXJzLiBTbyBkb24ndCB3cml0ZSB0aGVcbi8vIHN0cmluZyBpbnRvIHRoaXMgZmlsZS4gSW5zdGVhZCwgY3JlYXRlIHRoZSBzdHJpbmcgZnJvbSB0aGUgc3Vycm9nYXRlIHBhaXIuXG5cbnZhciB3aWRlQ2hhciA9IFwiXCI7XG5cbmZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGxldHRlcnMubGVuZ3RoOyBfaTMrKykge1xuICB2YXIgX2NoMyA9IGxldHRlcnMuY2hhckF0KF9pMyk7IC8vIFRoZSBoZXggbnVtYmVycyBpbiB0aGUgbmV4dCBsaW5lIGFyZSBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAvLyAweEQ4MzUgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIGZvciBhbGwgbGV0dGVycyBpbiB0aGUgcmFuZ2Ugd2Ugc3VwcG9ydC5cbiAgLy8gMHhEQzAwIGlzIHRoZSBsb3cgc3Vycm9nYXRlIGZvciBib2xkIEEuXG5cblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERDMDAgKyBfaTMpOyAvLyBBLVogYS16IGJvbGRcblxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERDMzQgKyBfaTMpOyAvLyBBLVogYS16IGl0YWxpY1xuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2gzLCB3aWRlQ2hhcik7XG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REM2OCArIF9pMyk7IC8vIEEtWiBhLXogYm9sZCBpdGFsaWNcblxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweEREMDQgKyBfaTMpOyAvLyBBLVogYS16IEZyYWt0dXJcblxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERENkMgKyBfaTMpOyAvLyBBLVogYS16IGJvbGQgRnJha3R1clxuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2gzLCB3aWRlQ2hhcik7XG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4RERBMCArIF9pMyk7IC8vIEEtWiBhLXogc2Fucy1zZXJpZlxuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2gzLCB3aWRlQ2hhcik7XG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4RERENCArIF9pMyk7IC8vIEEtWiBhLXogc2FucyBib2xkXG5cbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIF9jaDMsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIF9jaDMsIHdpZGVDaGFyKTtcbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhERTA4ICsgX2kzKTsgLy8gQS1aIGEteiBzYW5zIGl0YWxpY1xuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2gzLCB3aWRlQ2hhcik7XG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REU3MCArIF9pMyk7IC8vIEEtWiBhLXogbW9ub3NwYWNlXG5cbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIF9jaDMsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIF9jaDMsIHdpZGVDaGFyKTtcblxuICBpZiAoX2kzIDwgMjYpIHtcbiAgICAvLyBLYVRlWCBmb250cyBoYXZlIG9ubHkgY2FwaXRhbCBsZXR0ZXJzIGZvciBibGFja2JvYXJkIGJvbGQgYW5kIHNjcmlwdC5cbiAgICAvLyBTZWUgZXhjZXB0aW9uIGZvciBrIGJlbG93LlxuICAgIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REQzOCArIF9pMyk7IC8vIEEtWiBkb3VibGUgc3RydWNrXG5cbiAgICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICAgIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2gzLCB3aWRlQ2hhcik7XG4gICAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhEQzlDICsgX2kzKTsgLy8gQS1aIHNjcmlwdFxuXG4gICAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIF9jaDMsIHdpZGVDaGFyKTtcbiAgICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoMywgd2lkZUNoYXIpO1xuICB9IC8vIFRPRE86IEFkZCBib2xkIHNjcmlwdCB3aGVuIGl0IGlzIHN1cHBvcnRlZCBieSBhIEthVGVYIGZvbnQuXG5cbn0gLy8gXCJrXCIgaXMgdGhlIG9ubHkgZG91YmxlIHN0cnVjayBsb3dlciBjYXNlIGxldHRlciBpbiB0aGUgS2FUZVggZm9udHMuXG5cblxud2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhERDVDKTsgLy8gayBkb3VibGUgc3RydWNrXG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcImtcIiwgd2lkZUNoYXIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwia1wiLCB3aWRlQ2hhcik7IC8vIE5leHQsIHNvbWUgd2lkZSBjaGFyYWN0ZXIgbnVtZXJhbHNcblxuZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgMTA7IF9pNCsrKSB7XG4gIHZhciBfY2g0ID0gX2k0LnRvU3RyaW5nKCk7XG5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgzNSwgMHhERkNFICsgX2k0KTsgLy8gMC05IGJvbGRcblxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoNCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoNCwgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERGRTIgKyBfaTQpOyAvLyAwLTkgc2FucyBzZXJpZlxuXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBfY2g0LCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2g0LCB3aWRlQ2hhcik7XG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MzUsIDB4REZFQyArIF9pNCk7IC8vIDAtOSBib2xkIHNhbnNcblxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoNCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoNCwgd2lkZUNoYXIpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODM1LCAweERGRjYgKyBfaTQpOyAvLyAwLTkgbW9ub3NwYWNlXG5cbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIF9jaDQsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIF9jaDQsIHdpZGVDaGFyKTtcbn0gLy8gV2UgYWRkIHRoZXNlIExhdGluLTEgbGV0dGVycyBhcyBzeW1ib2xzIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSxcbi8vIGJ1dCB0aGV5IGFyZSBub3QgYWN0dWFsbHkgaW4gdGhlIGZvbnQsIG5vciBhcmUgdGhleSBzdXBwb3J0ZWQgYnkgdGhlXG4vLyBVbmljb2RlIGFjY2VudCBtZWNoYW5pc20sIHNvIHRoZXkgZmFsbCBiYWNrIHRvIFRpbWVzIGZvbnQgYW5kIGxvb2sgdWdseS5cbi8vIFRPRE8oZWRlbWFpbmUpOiBGaXggdGhpcy5cblxuXG52YXIgZXh0cmFMYXRpbiA9IFwiXFx1MDBkMFxcdTAwZGVcXHUwMGZlXCI7XG5cbmZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGV4dHJhTGF0aW4ubGVuZ3RoOyBfaTUrKykge1xuICB2YXIgX2NoNSA9IGV4dHJhTGF0aW4uY2hhckF0KF9pNSk7XG5cbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIF9jaDUsIF9jaDUpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoNSwgX2NoNSk7XG59XG5cbi8qKlxuICogVGhpcyBmaWxlIHByb3ZpZGVzIHN1cHBvcnQgZm9yIFVuaWNvZGUgcmFuZ2UgVSsxRDQwMCB0byBVKzFEN0ZGLFxuICogTWF0aGVtYXRpY2FsIEFscGhhbnVtZXJpYyBTeW1ib2xzLlxuICpcbiAqIEZ1bmN0aW9uIHdpZGVDaGFyYWN0ZXJGb250IHRha2VzIGEgd2lkZSBjaGFyYWN0ZXIgYXMgaW5wdXQgYW5kIHJldHVybnNcbiAqIHRoZSBmb250IGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byByZW5kZXIgaXQgcHJvcGVybHkuXG4gKi9cbi8qKlxuICogRGF0YSBiZWxvdyBpcyBmcm9tIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL2NoYXJ0cy9QREYvVTFENDAwLnBkZlxuICogVGhhdCBkb2N1bWVudCBzb3J0cyBjaGFyYWN0ZXJzIGludG8gZ3JvdXBzIGJ5IGZvbnQgdHlwZSwgc2F5IGJvbGQgb3IgaXRhbGljLlxuICpcbiAqIEluIHRoZSBhcnJheXMgYmVsb3csIGVhY2ggc3ViYXJyYXkgY29uc2lzdHMgdGhyZWUgZWxlbWVudHM6XG4gKiAgICAgICogVGhlIENTUyBjbGFzcyBvZiB0aGF0IGdyb3VwIHdoZW4gaW4gbWF0aCBtb2RlLlxuICogICAgICAqIFRoZSBDU1MgY2xhc3Mgb2YgdGhhdCBncm91cCB3aGVuIGluIHRleHQgbW9kZS5cbiAqICAgICAgKiBUaGUgZm9udCBuYW1lLCBzbyB0aGF0IEthVGVYIGNhbiBnZXQgZm9udCBtZXRyaWNzLlxuICovXG5cbnZhciB3aWRlTGF0aW5MZXR0ZXJEYXRhID0gW1tcIm1hdGhiZlwiLCBcInRleHRiZlwiLCBcIk1haW4tQm9sZFwiXSwgLy8gQS1aIGJvbGQgdXByaWdodFxuW1wibWF0aGJmXCIsIFwidGV4dGJmXCIsIFwiTWFpbi1Cb2xkXCJdLCAvLyBhLXogYm9sZCB1cHJpZ2h0XG5bXCJtYXRobm9ybWFsXCIsIFwidGV4dGl0XCIsIFwiTWF0aC1JdGFsaWNcIl0sIC8vIEEtWiBpdGFsaWNcbltcIm1hdGhub3JtYWxcIiwgXCJ0ZXh0aXRcIiwgXCJNYXRoLUl0YWxpY1wiXSwgLy8gYS16IGl0YWxpY1xuW1wiYm9sZHN5bWJvbFwiLCBcImJvbGRzeW1ib2xcIiwgXCJNYWluLUJvbGRJdGFsaWNcIl0sIC8vIEEtWiBib2xkIGl0YWxpY1xuW1wiYm9sZHN5bWJvbFwiLCBcImJvbGRzeW1ib2xcIiwgXCJNYWluLUJvbGRJdGFsaWNcIl0sIC8vIGEteiBib2xkIGl0YWxpY1xuLy8gTWFwIGZhbmN5IEEtWiBsZXR0ZXJzIHRvIHNjcmlwdCwgbm90IGNhbGxpZ3JhcGhpYy5cbi8vIFRoaXMgYWxpZ25zIHdpdGggdW5pY29kZS1tYXRoIGFuZCBtYXRoIGZvbnRzIChleGNlcHQgQ2FtYnJpYSBNYXRoKS5cbltcIm1hdGhzY3JcIiwgXCJ0ZXh0c2NyXCIsIFwiU2NyaXB0LVJlZ3VsYXJcIl0sIC8vIEEtWiBzY3JpcHRcbltcIlwiLCBcIlwiLCBcIlwiXSwgLy8gYS16IHNjcmlwdC4gIE5vIGZvbnRcbltcIlwiLCBcIlwiLCBcIlwiXSwgLy8gQS1aIGJvbGQgc2NyaXB0LiBObyBmb250XG5bXCJcIiwgXCJcIiwgXCJcIl0sIC8vIGEteiBib2xkIHNjcmlwdC4gTm8gZm9udFxuW1wibWF0aGZyYWtcIiwgXCJ0ZXh0ZnJha1wiLCBcIkZyYWt0dXItUmVndWxhclwiXSwgLy8gQS1aIEZyYWt0dXJcbltcIm1hdGhmcmFrXCIsIFwidGV4dGZyYWtcIiwgXCJGcmFrdHVyLVJlZ3VsYXJcIl0sIC8vIGEteiBGcmFrdHVyXG5bXCJtYXRoYmJcIiwgXCJ0ZXh0YmJcIiwgXCJBTVMtUmVndWxhclwiXSwgLy8gQS1aIGRvdWJsZS1zdHJ1Y2tcbltcIm1hdGhiYlwiLCBcInRleHRiYlwiLCBcIkFNUy1SZWd1bGFyXCJdLCAvLyBrIGRvdWJsZS1zdHJ1Y2tcbi8vIE5vdGUgdGhhdCB3ZSBhcmUgdXNpbmcgYSBib2xkIGZvbnQsIGJ1dCBmb250IG1ldHJpY3MgZm9yIHJlZ3VsYXIgRnJha3R1ci5cbltcIm1hdGhib2xkZnJha1wiLCBcInRleHRib2xkZnJha1wiLCBcIkZyYWt0dXItUmVndWxhclwiXSwgLy8gQS1aIGJvbGQgRnJha3R1clxuW1wibWF0aGJvbGRmcmFrXCIsIFwidGV4dGJvbGRmcmFrXCIsIFwiRnJha3R1ci1SZWd1bGFyXCJdLCAvLyBhLXogYm9sZCBGcmFrdHVyXG5bXCJtYXRoc2ZcIiwgXCJ0ZXh0c2ZcIiwgXCJTYW5zU2VyaWYtUmVndWxhclwiXSwgLy8gQS1aIHNhbnMtc2VyaWZcbltcIm1hdGhzZlwiLCBcInRleHRzZlwiLCBcIlNhbnNTZXJpZi1SZWd1bGFyXCJdLCAvLyBhLXogc2Fucy1zZXJpZlxuW1wibWF0aGJvbGRzZlwiLCBcInRleHRib2xkc2ZcIiwgXCJTYW5zU2VyaWYtQm9sZFwiXSwgLy8gQS1aIGJvbGQgc2Fucy1zZXJpZlxuW1wibWF0aGJvbGRzZlwiLCBcInRleHRib2xkc2ZcIiwgXCJTYW5zU2VyaWYtQm9sZFwiXSwgLy8gYS16IGJvbGQgc2Fucy1zZXJpZlxuW1wibWF0aGl0c2ZcIiwgXCJ0ZXh0aXRzZlwiLCBcIlNhbnNTZXJpZi1JdGFsaWNcIl0sIC8vIEEtWiBpdGFsaWMgc2Fucy1zZXJpZlxuW1wibWF0aGl0c2ZcIiwgXCJ0ZXh0aXRzZlwiLCBcIlNhbnNTZXJpZi1JdGFsaWNcIl0sIC8vIGEteiBpdGFsaWMgc2Fucy1zZXJpZlxuW1wiXCIsIFwiXCIsIFwiXCJdLCAvLyBBLVogYm9sZCBpdGFsaWMgc2Fucy4gTm8gZm9udFxuW1wiXCIsIFwiXCIsIFwiXCJdLCAvLyBhLXogYm9sZCBpdGFsaWMgc2Fucy4gTm8gZm9udFxuW1wibWF0aHR0XCIsIFwidGV4dHR0XCIsIFwiVHlwZXdyaXRlci1SZWd1bGFyXCJdLCAvLyBBLVogbW9ub3NwYWNlXG5bXCJtYXRodHRcIiwgXCJ0ZXh0dHRcIiwgXCJUeXBld3JpdGVyLVJlZ3VsYXJcIl0gLy8gYS16IG1vbm9zcGFjZVxuXTtcbnZhciB3aWRlTnVtZXJhbERhdGEgPSBbW1wibWF0aGJmXCIsIFwidGV4dGJmXCIsIFwiTWFpbi1Cb2xkXCJdLCAvLyAwLTkgYm9sZFxuW1wiXCIsIFwiXCIsIFwiXCJdLCAvLyAwLTkgZG91YmxlLXN0cnVjay4gTm8gS2FUZVggZm9udC5cbltcIm1hdGhzZlwiLCBcInRleHRzZlwiLCBcIlNhbnNTZXJpZi1SZWd1bGFyXCJdLCAvLyAwLTkgc2Fucy1zZXJpZlxuW1wibWF0aGJvbGRzZlwiLCBcInRleHRib2xkc2ZcIiwgXCJTYW5zU2VyaWYtQm9sZFwiXSwgLy8gMC05IGJvbGQgc2Fucy1zZXJpZlxuW1wibWF0aHR0XCIsIFwidGV4dHR0XCIsIFwiVHlwZXdyaXRlci1SZWd1bGFyXCJdIC8vIDAtOSBtb25vc3BhY2Vcbl07XG52YXIgd2lkZUNoYXJhY3RlckZvbnQgPSBmdW5jdGlvbiB3aWRlQ2hhcmFjdGVyRm9udCh3aWRlQ2hhciwgbW9kZSkge1xuICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgY29kZVBvaW50QXQoKS4gU28gd29yayB3aXRoIHRoZSBzdXJyb2dhdGUgcGFpci5cbiAgdmFyIEggPSB3aWRlQ2hhci5jaGFyQ29kZUF0KDApOyAvLyBoaWdoIHN1cnJvZ2F0ZVxuXG4gIHZhciBMID0gd2lkZUNoYXIuY2hhckNvZGVBdCgxKTsgLy8gbG93IHN1cnJvZ2F0ZVxuXG4gIHZhciBjb2RlUG9pbnQgPSAoSCAtIDB4RDgwMCkgKiAweDQwMCArIChMIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gIHZhciBqID0gbW9kZSA9PT0gXCJtYXRoXCIgPyAwIDogMTsgLy8gY29sdW1uIGluZGV4IGZvciBDU1MgY2xhc3MuXG5cbiAgaWYgKDB4MUQ0MDAgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4MUQ2QTQpIHtcbiAgICAvLyB3aWRlTGF0aW5MZXR0ZXJEYXRhIGNvbnRhaW5zIGV4YWN0bHkgMjYgY2hhcnMgb24gZWFjaCByb3cuXG4gICAgLy8gU28gd2UgY2FuIGNhbGN1bGF0ZSB0aGUgcmVsZXZhbnQgcm93LiBObyB0cmF2ZXJzZSBuZWNlc3NhcnkuXG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKChjb2RlUG9pbnQgLSAweDFENDAwKSAvIDI2KTtcbiAgICByZXR1cm4gW3dpZGVMYXRpbkxldHRlckRhdGFbaV1bMl0sIHdpZGVMYXRpbkxldHRlckRhdGFbaV1bal1dO1xuICB9IGVsc2UgaWYgKDB4MUQ3Q0UgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweDFEN0ZGKSB7XG4gICAgLy8gTnVtZXJhbHMsIHRlbiBwZXIgcm93LlxuICAgIHZhciBfaSA9IE1hdGguZmxvb3IoKGNvZGVQb2ludCAtIDB4MUQ3Q0UpIC8gMTApO1xuXG4gICAgcmV0dXJuIFt3aWRlTnVtZXJhbERhdGFbX2ldWzJdLCB3aWRlTnVtZXJhbERhdGFbX2ldW2pdXTtcbiAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPT09IDB4MUQ2QTUgfHwgY29kZVBvaW50ID09PSAweDFENkE2KSB7XG4gICAgLy8gZG90bGVzcyBpIG9yIGpcbiAgICByZXR1cm4gW3dpZGVMYXRpbkxldHRlckRhdGFbMF1bMl0sIHdpZGVMYXRpbkxldHRlckRhdGFbMF1bal1dO1xuICB9IGVsc2UgaWYgKDB4MUQ2QTYgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHgxRDdDRSkge1xuICAgIC8vIEdyZWVrIGxldHRlcnMuIE5vdCBzdXBwb3J0ZWQsIHlldC5cbiAgICByZXR1cm4gW1wiXCIsIFwiXCJdO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgYW55IHdpZGUgY2hhcmFjdGVycyBvdXRzaWRlIDFENDAw4oCTMUQ3RkYuXG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJVbnN1cHBvcnRlZCBjaGFyYWN0ZXI6IFwiICsgd2lkZUNoYXIpO1xuICB9XG59O1xuXG4vKiBlc2xpbnQgbm8tY29uc29sZTowICovXG5cbi8qKlxuICogTG9va3MgdXAgdGhlIGdpdmVuIHN5bWJvbCBpbiBmb250TWV0cmljcywgYWZ0ZXIgYXBwbHlpbmcgYW55IHN5bWJvbFxuICogcmVwbGFjZW1lbnRzIGRlZmluZWQgaW4gc3ltYm9sLmpzXG4gKi9cbnZhciBsb29rdXBTeW1ib2wgPSBmdW5jdGlvbiBsb29rdXBTeW1ib2wodmFsdWUsIC8vIFRPRE8oIzk2Myk6IFVzZSBhIHVuaW9uIHR5cGUgZm9yIHRoaXMuXG5mb250TmFtZSwgbW9kZSkge1xuICAvLyBSZXBsYWNlIHRoZSB2YWx1ZSB3aXRoIGl0cyByZXBsYWNlZCB2YWx1ZSBmcm9tIHN5bWJvbC5qc1xuICBpZiAoc3ltYm9sc1ttb2RlXVt2YWx1ZV0gJiYgc3ltYm9sc1ttb2RlXVt2YWx1ZV0ucmVwbGFjZSkge1xuICAgIHZhbHVlID0gc3ltYm9sc1ttb2RlXVt2YWx1ZV0ucmVwbGFjZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIG1ldHJpY3M6IGdldENoYXJhY3Rlck1ldHJpY3ModmFsdWUsIGZvbnROYW1lLCBtb2RlKVxuICB9O1xufTtcbi8qKlxuICogTWFrZXMgYSBzeW1ib2xOb2RlIGFmdGVyIHRyYW5zbGF0aW9uIHZpYSB0aGUgbGlzdCBvZiBzeW1ib2xzIGluIHN5bWJvbHMuanMuXG4gKiBDb3JyZWN0bHkgcHVsbHMgb3V0IG1ldHJpY3MgZm9yIHRoZSBjaGFyYWN0ZXIsIGFuZCBvcHRpb25hbGx5IHRha2VzIGEgbGlzdCBvZlxuICogY2xhc3NlcyB0byBiZSBhdHRhY2hlZCB0byB0aGUgbm9kZS5cbiAqXG4gKiBUT0RPOiBtYWtlIGFyZ3VtZW50IG9yZGVyIGNsb3NlciB0byBtYWtlU3BhblxuICogVE9ETzogYWRkIGEgc2VwYXJhdGUgYXJndW1lbnQgZm9yIG1hdGggY2xhc3MgKGUuZy4gYG1vcGAsIGBtYmluYCksIHdoaWNoXG4gKiBzaG91bGQgaWYgcHJlc2VudCBjb21lIGZpcnN0IGluIGBjbGFzc2VzYC5cbiAqIFRPRE8oIzk1Myk6IE1ha2UgYG9wdGlvbnNgIG1hbmRhdG9yeSBhbmQgYWx3YXlzIHBhc3MgaXQgaW4uXG4gKi9cblxuXG52YXIgbWFrZVN5bWJvbCA9IGZ1bmN0aW9uIG1ha2VTeW1ib2wodmFsdWUsIGZvbnROYW1lLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzKSB7XG4gIHZhciBsb29rdXAgPSBsb29rdXBTeW1ib2wodmFsdWUsIGZvbnROYW1lLCBtb2RlKTtcbiAgdmFyIG1ldHJpY3MgPSBsb29rdXAubWV0cmljcztcbiAgdmFsdWUgPSBsb29rdXAudmFsdWU7XG4gIHZhciBzeW1ib2xOb2RlO1xuXG4gIGlmIChtZXRyaWNzKSB7XG4gICAgdmFyIGl0YWxpYyA9IG1ldHJpY3MuaXRhbGljO1xuXG4gICAgaWYgKG1vZGUgPT09IFwidGV4dFwiIHx8IG9wdGlvbnMgJiYgb3B0aW9ucy5mb250ID09PSBcIm1hdGhpdFwiKSB7XG4gICAgICBpdGFsaWMgPSAwO1xuICAgIH1cblxuICAgIHN5bWJvbE5vZGUgPSBuZXcgU3ltYm9sTm9kZSh2YWx1ZSwgbWV0cmljcy5oZWlnaHQsIG1ldHJpY3MuZGVwdGgsIGl0YWxpYywgbWV0cmljcy5za2V3LCBtZXRyaWNzLndpZHRoLCBjbGFzc2VzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPKGVtaWx5KTogRmlndXJlIG91dCBhIGdvb2Qgd2F5IHRvIG9ubHkgcHJpbnQgdGhpcyBpbiBkZXZlbG9wbWVudFxuICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2FybihcIk5vIGNoYXJhY3RlciBtZXRyaWNzIFwiICsgKFwiZm9yICdcIiArIHZhbHVlICsgXCInIGluIHN0eWxlICdcIiArIGZvbnROYW1lICsgXCInIGFuZCBtb2RlICdcIiArIG1vZGUgKyBcIidcIikpO1xuICAgIHN5bWJvbE5vZGUgPSBuZXcgU3ltYm9sTm9kZSh2YWx1ZSwgMCwgMCwgMCwgMCwgMCwgY2xhc3Nlcyk7XG4gIH1cblxuICBpZiAob3B0aW9ucykge1xuICAgIHN5bWJvbE5vZGUubWF4Rm9udFNpemUgPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgaWYgKG9wdGlvbnMuc3R5bGUuaXNUaWdodCgpKSB7XG4gICAgICBzeW1ib2xOb2RlLmNsYXNzZXMucHVzaChcIm10aWdodFwiKTtcbiAgICB9XG5cbiAgICB2YXIgY29sb3IgPSBvcHRpb25zLmdldENvbG9yKCk7XG5cbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIHN5bWJvbE5vZGUuc3R5bGUuY29sb3IgPSBjb2xvcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ltYm9sTm9kZTtcbn07XG4vKipcbiAqIE1ha2VzIGEgc3ltYm9sIGluIE1haW4tUmVndWxhciBvciBBTVMtUmVndWxhci5cbiAqIFVzZWQgZm9yIHJlbCwgYmluLCBvcGVuLCBjbG9zZSwgaW5uZXIsIGFuZCBwdW5jdC5cbiAqL1xuXG5cbnZhciBtYXRoc3ltID0gZnVuY3Rpb24gbWF0aHN5bSh2YWx1ZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICBpZiAoY2xhc3NlcyA9PT0gdm9pZCAwKSB7XG4gICAgY2xhc3NlcyA9IFtdO1xuICB9XG5cbiAgLy8gRGVjaWRlIHdoYXQgZm9udCB0byByZW5kZXIgdGhlIHN5bWJvbCBpbiBieSBpdHMgZW50cnkgaW4gdGhlIHN5bWJvbHNcbiAgLy8gdGFibGUuXG4gIC8vIEhhdmUgYSBzcGVjaWFsIGNhc2UgZm9yIHdoZW4gdGhlIHZhbHVlID0gXFwgYmVjYXVzZSB0aGUgXFwgaXMgdXNlZCBhcyBhXG4gIC8vIHRleHRvcmQgaW4gdW5zdXBwb3J0ZWQgY29tbWFuZCBlcnJvcnMgYnV0IGNhbm5vdCBiZSBwYXJzZWQgYXMgYSByZWd1bGFyXG4gIC8vIHRleHQgb3JkaW5hbCBhbmQgaXMgdGhlcmVmb3JlIG5vdCBwcmVzZW50IGFzIGEgc3ltYm9sIGluIHRoZSBzeW1ib2xzXG4gIC8vIHRhYmxlIGZvciB0ZXh0LCBhcyB3ZWxsIGFzIGEgc3BlY2lhbCBjYXNlIGZvciBib2xkc3ltYm9sIGJlY2F1c2UgaXRcbiAgLy8gY2FuIGJlIHVzZWQgZm9yIGJvbGQgKyBhbmQgLVxuICBpZiAob3B0aW9ucy5mb250ID09PSBcImJvbGRzeW1ib2xcIiAmJiBsb29rdXBTeW1ib2wodmFsdWUsIFwiTWFpbi1Cb2xkXCIsIG1vZGUpLm1ldHJpY3MpIHtcbiAgICByZXR1cm4gbWFrZVN5bWJvbCh2YWx1ZSwgXCJNYWluLUJvbGRcIiwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoW1wibWF0aGJmXCJdKSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IFwiXFxcXFwiIHx8IHN5bWJvbHNbbW9kZV1bdmFsdWVdLmZvbnQgPT09IFwibWFpblwiKSB7XG4gICAgcmV0dXJuIG1ha2VTeW1ib2wodmFsdWUsIFwiTWFpbi1SZWd1bGFyXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYWtlU3ltYm9sKHZhbHVlLCBcIkFNUy1SZWd1bGFyXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KFtcImFtc3JtXCJdKSk7XG4gIH1cbn07XG4vKipcbiAqIERldGVybWluZXMgd2hpY2ggb2YgdGhlIHR3byBmb250IG5hbWVzIChNYWluLUJvbGQgYW5kIE1hdGgtQm9sZEl0YWxpYykgYW5kXG4gKiBjb3JyZXNwb25kaW5nIHN0eWxlIHRhZ3MgKG1hdGhiZiBvciBib2xkc3ltYm9sKSB0byB1c2UgZm9yIGZvbnQgXCJib2xkc3ltYm9sXCIsXG4gKiBkZXBlbmRpbmcgb24gdGhlIHN5bWJvbC4gIFVzZSB0aGlzIGZ1bmN0aW9uIGluc3RlYWQgb2YgZm9udE1hcCBmb3IgZm9udFxuICogXCJib2xkc3ltYm9sXCIuXG4gKi9cblxuXG52YXIgYm9sZHN5bWJvbCA9IGZ1bmN0aW9uIGJvbGRzeW1ib2wodmFsdWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMsIHR5cGUpIHtcbiAgaWYgKHR5cGUgIT09IFwidGV4dG9yZFwiICYmIGxvb2t1cFN5bWJvbCh2YWx1ZSwgXCJNYXRoLUJvbGRJdGFsaWNcIiwgbW9kZSkubWV0cmljcykge1xuICAgIHJldHVybiB7XG4gICAgICBmb250TmFtZTogXCJNYXRoLUJvbGRJdGFsaWNcIixcbiAgICAgIGZvbnRDbGFzczogXCJib2xkc3ltYm9sXCJcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFNvbWUgZ2x5cGhzIGRvIG5vdCBleGlzdCBpbiBNYXRoLUJvbGRJdGFsaWMgc28gd2UgbmVlZCB0byB1c2VcbiAgICAvLyBNYWluLUJvbGQgaW5zdGVhZC5cbiAgICByZXR1cm4ge1xuICAgICAgZm9udE5hbWU6IFwiTWFpbi1Cb2xkXCIsXG4gICAgICBmb250Q2xhc3M6IFwibWF0aGJmXCJcbiAgICB9O1xuICB9XG59O1xuLyoqXG4gKiBNYWtlcyBlaXRoZXIgYSBtYXRob3JkIG9yIHRleHRvcmQgaW4gdGhlIGNvcnJlY3QgZm9udCBhbmQgY29sb3IuXG4gKi9cblxuXG52YXIgbWFrZU9yZCA9IGZ1bmN0aW9uIG1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIHR5cGUpIHtcbiAgdmFyIG1vZGUgPSBncm91cC5tb2RlO1xuICB2YXIgdGV4dCA9IGdyb3VwLnRleHQ7XG4gIHZhciBjbGFzc2VzID0gW1wibW9yZFwiXTsgLy8gTWF0aCBtb2RlIG9yIE9sZCBmb250IChpLmUuIFxccm0pXG5cbiAgdmFyIGlzRm9udCA9IG1vZGUgPT09IFwibWF0aFwiIHx8IG1vZGUgPT09IFwidGV4dFwiICYmIG9wdGlvbnMuZm9udDtcbiAgdmFyIGZvbnRPckZhbWlseSA9IGlzRm9udCA/IG9wdGlvbnMuZm9udCA6IG9wdGlvbnMuZm9udEZhbWlseTtcbiAgdmFyIHdpZGVGb250TmFtZSA9IFwiXCI7XG4gIHZhciB3aWRlRm9udENsYXNzID0gXCJcIjtcblxuICBpZiAodGV4dC5jaGFyQ29kZUF0KDApID09PSAweEQ4MzUpIHtcbiAgICBbd2lkZUZvbnROYW1lLCB3aWRlRm9udENsYXNzXSA9IHdpZGVDaGFyYWN0ZXJGb250KHRleHQsIG1vZGUpO1xuICB9XG5cbiAgaWYgKHdpZGVGb250TmFtZS5sZW5ndGggPiAwKSB7XG4gICAgLy8gc3Vycm9nYXRlIHBhaXJzIGdldCBzcGVjaWFsIHRyZWF0bWVudFxuICAgIHJldHVybiBtYWtlU3ltYm9sKHRleHQsIHdpZGVGb250TmFtZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQod2lkZUZvbnRDbGFzcykpO1xuICB9IGVsc2UgaWYgKGZvbnRPckZhbWlseSkge1xuICAgIHZhciBmb250TmFtZTtcbiAgICB2YXIgZm9udENsYXNzZXM7XG5cbiAgICBpZiAoZm9udE9yRmFtaWx5ID09PSBcImJvbGRzeW1ib2xcIikge1xuICAgICAgdmFyIGZvbnREYXRhID0gYm9sZHN5bWJvbCh0ZXh0LCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLCB0eXBlKTtcbiAgICAgIGZvbnROYW1lID0gZm9udERhdGEuZm9udE5hbWU7XG4gICAgICBmb250Q2xhc3NlcyA9IFtmb250RGF0YS5mb250Q2xhc3NdO1xuICAgIH0gZWxzZSBpZiAoaXNGb250KSB7XG4gICAgICBmb250TmFtZSA9IGZvbnRNYXBbZm9udE9yRmFtaWx5XS5mb250TmFtZTtcbiAgICAgIGZvbnRDbGFzc2VzID0gW2ZvbnRPckZhbWlseV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvbnROYW1lID0gcmV0cmlldmVUZXh0Rm9udE5hbWUoZm9udE9yRmFtaWx5LCBvcHRpb25zLmZvbnRXZWlnaHQsIG9wdGlvbnMuZm9udFNoYXBlKTtcbiAgICAgIGZvbnRDbGFzc2VzID0gW2ZvbnRPckZhbWlseSwgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZV07XG4gICAgfVxuXG4gICAgaWYgKGxvb2t1cFN5bWJvbCh0ZXh0LCBmb250TmFtZSwgbW9kZSkubWV0cmljcykge1xuICAgICAgcmV0dXJuIG1ha2VTeW1ib2wodGV4dCwgZm9udE5hbWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KGZvbnRDbGFzc2VzKSk7XG4gICAgfSBlbHNlIGlmIChsaWdhdHVyZXMuaGFzT3duUHJvcGVydHkodGV4dCkgJiYgZm9udE5hbWUuc2xpY2UoMCwgMTApID09PSBcIlR5cGV3cml0ZXJcIikge1xuICAgICAgLy8gRGVjb25zdHJ1Y3QgbGlnYXR1cmVzIGluIG1vbm9zcGFjZSBmb250cyAoXFx0ZXh0dHQsIFxcdHQpLlxuICAgICAgdmFyIHBhcnRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJ0cy5wdXNoKG1ha2VTeW1ib2wodGV4dFtpXSwgZm9udE5hbWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KGZvbnRDbGFzc2VzKSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFrZUZyYWdtZW50KHBhcnRzKTtcbiAgICB9XG4gIH0gLy8gTWFrZXMgYSBzeW1ib2wgaW4gdGhlIGRlZmF1bHQgZm9udCBmb3IgbWF0aG9yZHMgYW5kIHRleHRvcmRzLlxuXG5cbiAgaWYgKHR5cGUgPT09IFwibWF0aG9yZFwiKSB7XG4gICAgcmV0dXJuIG1ha2VTeW1ib2wodGV4dCwgXCJNYXRoLUl0YWxpY1wiLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbXCJtYXRobm9ybWFsXCJdKSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ0ZXh0b3JkXCIpIHtcbiAgICB2YXIgZm9udCA9IHN5bWJvbHNbbW9kZV1bdGV4dF0gJiYgc3ltYm9sc1ttb2RlXVt0ZXh0XS5mb250O1xuXG4gICAgaWYgKGZvbnQgPT09IFwiYW1zXCIpIHtcbiAgICAgIHZhciBfZm9udE5hbWUgPSByZXRyaWV2ZVRleHRGb250TmFtZShcImFtc3JtXCIsIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGUpO1xuXG4gICAgICByZXR1cm4gbWFrZVN5bWJvbCh0ZXh0LCBfZm9udE5hbWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KFwiYW1zcm1cIiwgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSkpO1xuICAgIH0gZWxzZSBpZiAoZm9udCA9PT0gXCJtYWluXCIgfHwgIWZvbnQpIHtcbiAgICAgIHZhciBfZm9udE5hbWUyID0gcmV0cmlldmVUZXh0Rm9udE5hbWUoXCJ0ZXh0cm1cIiwgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSk7XG5cbiAgICAgIHJldHVybiBtYWtlU3ltYm9sKHRleHQsIF9mb250TmFtZTIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9udHMgYWRkZWQgYnkgcGx1Z2luc1xuICAgICAgdmFyIF9mb250TmFtZTMgPSByZXRyaWV2ZVRleHRGb250TmFtZShmb250LCBvcHRpb25zLmZvbnRXZWlnaHQsIG9wdGlvbnMuZm9udFNoYXBlKTsgLy8gV2UgYWRkIGZvbnQgbmFtZSBhcyBhIGNzcyBjbGFzc1xuXG5cbiAgICAgIHJldHVybiBtYWtlU3ltYm9sKHRleHQsIF9mb250TmFtZTMsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KF9mb250TmFtZTMsIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGUpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCB0eXBlOiBcIiArIHR5cGUgKyBcIiBpbiBtYWtlT3JkXCIpO1xuICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgc3Vic2VxdWVudCBzeW1ib2xOb2RlcyBoYXZlIHRoZSBzYW1lIGNsYXNzZXMsIHNrZXcsIG1heEZvbnQsXG4gKiBhbmQgc3R5bGVzLlxuICovXG5cblxudmFyIGNhbkNvbWJpbmUgPSAocHJldiwgbmV4dCkgPT4ge1xuICBpZiAoY3JlYXRlQ2xhc3MocHJldi5jbGFzc2VzKSAhPT0gY3JlYXRlQ2xhc3MobmV4dC5jbGFzc2VzKSB8fCBwcmV2LnNrZXcgIT09IG5leHQuc2tldyB8fCBwcmV2Lm1heEZvbnRTaXplICE9PSBuZXh0Lm1heEZvbnRTaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElmIHByZXYgYW5kIG5leHQgYm90aCBhcmUganVzdCBcIm1iaW5cInMgb3IgXCJtb3JkXCJzIHdlIGRvbid0IGNvbWJpbmUgdGhlbVxuICAvLyBzbyB0aGF0IHRoZSBwcm9wZXIgc3BhY2luZyBjYW4gYmUgcHJlc2VydmVkLlxuXG5cbiAgaWYgKHByZXYuY2xhc3Nlcy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgY2xzID0gcHJldi5jbGFzc2VzWzBdO1xuXG4gICAgaWYgKGNscyA9PT0gXCJtYmluXCIgfHwgY2xzID09PSBcIm1vcmRcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIHN0eWxlIGluIHByZXYuc3R5bGUpIHtcbiAgICBpZiAocHJldi5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkgJiYgcHJldi5zdHlsZVtzdHlsZV0gIT09IG5leHQuc3R5bGVbc3R5bGVdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX3N0eWxlIGluIG5leHQuc3R5bGUpIHtcbiAgICBpZiAobmV4dC5zdHlsZS5oYXNPd25Qcm9wZXJ0eShfc3R5bGUpICYmIHByZXYuc3R5bGVbX3N0eWxlXSAhPT0gbmV4dC5zdHlsZVtfc3R5bGVdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBDb21iaW5lIGNvbnNlY3V0aXZlIGRvbVRyZWUuc3ltYm9sTm9kZXMgaW50byBhIHNpbmdsZSBzeW1ib2xOb2RlLlxuICogTm90ZTogdGhpcyBmdW5jdGlvbiBtdXRhdGVzIHRoZSBhcmd1bWVudC5cbiAqL1xuXG5cbnZhciB0cnlDb21iaW5lQ2hhcnMgPSBjaGFycyA9PiB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdmFyIHByZXYgPSBjaGFyc1tpXTtcbiAgICB2YXIgbmV4dCA9IGNoYXJzW2kgKyAxXTtcblxuICAgIGlmIChwcmV2IGluc3RhbmNlb2YgU3ltYm9sTm9kZSAmJiBuZXh0IGluc3RhbmNlb2YgU3ltYm9sTm9kZSAmJiBjYW5Db21iaW5lKHByZXYsIG5leHQpKSB7XG4gICAgICBwcmV2LnRleHQgKz0gbmV4dC50ZXh0O1xuICAgICAgcHJldi5oZWlnaHQgPSBNYXRoLm1heChwcmV2LmhlaWdodCwgbmV4dC5oZWlnaHQpO1xuICAgICAgcHJldi5kZXB0aCA9IE1hdGgubWF4KHByZXYuZGVwdGgsIG5leHQuZGVwdGgpOyAvLyBVc2UgdGhlIGxhc3QgY2hhcmFjdGVyJ3MgaXRhbGljIGNvcnJlY3Rpb24gc2luY2Ugd2UgdXNlXG4gICAgICAvLyBpdCB0byBhZGQgcGFkZGluZyB0byB0aGUgcmlnaHQgb2YgdGhlIHNwYW4gY3JlYXRlZCBmcm9tXG4gICAgICAvLyB0aGUgY29tYmluZWQgY2hhcmFjdGVycy5cblxuICAgICAgcHJldi5pdGFsaWMgPSBuZXh0Lml0YWxpYztcbiAgICAgIGNoYXJzLnNwbGljZShpICsgMSwgMSk7XG4gICAgICBpLS07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoYXJzO1xufTtcbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBoZWlnaHQsIGRlcHRoLCBhbmQgbWF4Rm9udFNpemUgb2YgYW4gZWxlbWVudCBiYXNlZCBvbiBpdHNcbiAqIGNoaWxkcmVuLlxuICovXG5cblxudmFyIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuID0gZnVuY3Rpb24gc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4oZWxlbSkge1xuICB2YXIgaGVpZ2h0ID0gMDtcbiAgdmFyIGRlcHRoID0gMDtcbiAgdmFyIG1heEZvbnRTaXplID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW0uY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBlbGVtLmNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKGNoaWxkLmhlaWdodCA+IGhlaWdodCkge1xuICAgICAgaGVpZ2h0ID0gY2hpbGQuaGVpZ2h0O1xuICAgIH1cblxuICAgIGlmIChjaGlsZC5kZXB0aCA+IGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IGNoaWxkLmRlcHRoO1xuICAgIH1cblxuICAgIGlmIChjaGlsZC5tYXhGb250U2l6ZSA+IG1heEZvbnRTaXplKSB7XG4gICAgICBtYXhGb250U2l6ZSA9IGNoaWxkLm1heEZvbnRTaXplO1xuICAgIH1cbiAgfVxuXG4gIGVsZW0uaGVpZ2h0ID0gaGVpZ2h0O1xuICBlbGVtLmRlcHRoID0gZGVwdGg7XG4gIGVsZW0ubWF4Rm9udFNpemUgPSBtYXhGb250U2l6ZTtcbn07XG4vKipcbiAqIE1ha2VzIGEgc3BhbiB3aXRoIHRoZSBnaXZlbiBsaXN0IG9mIGNsYXNzZXMsIGxpc3Qgb2YgY2hpbGRyZW4sIGFuZCBvcHRpb25zLlxuICpcbiAqIFRPRE8oIzk1Myk6IEVuc3VyZSB0aGF0IGBvcHRpb25zYCBpcyBhbHdheXMgcHJvdmlkZWQgKGN1cnJlbnRseSBzb21lIGNhbGxcbiAqIHNpdGVzIGRvbid0IHBhc3MgaXQpIGFuZCBtYWtlIHRoZSB0eXBlIGJlbG93IG1hbmRhdG9yeS5cbiAqIFRPRE86IGFkZCBhIHNlcGFyYXRlIGFyZ3VtZW50IGZvciBtYXRoIGNsYXNzIChlLmcuIGBtb3BgLCBgbWJpbmApLCB3aGljaFxuICogc2hvdWxkIGlmIHByZXNlbnQgY29tZSBmaXJzdCBpbiBgY2xhc3Nlc2AuXG4gKi9cblxuXG52YXIgbWFrZVNwYW4kMiA9IGZ1bmN0aW9uIG1ha2VTcGFuKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zLCBzdHlsZSkge1xuICB2YXIgc3BhbiA9IG5ldyBTcGFuKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zLCBzdHlsZSk7XG4gIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKHNwYW4pO1xuICByZXR1cm4gc3Bhbjtcbn07IC8vIFNWRyBvbmUgaXMgc2ltcGxlciAtLSBkb2Vzbid0IHJlcXVpcmUgaGVpZ2h0LCBkZXB0aCwgbWF4LWZvbnQgc2V0dGluZy5cbi8vIFRoaXMgaXMgYWxzbyBhIHNlcGFyYXRlIG1ldGhvZCBmb3IgdHlwZXNhZmV0eS5cblxuXG52YXIgbWFrZVN2Z1NwYW4gPSAoY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMsIHN0eWxlKSA9PiBuZXcgU3BhbihjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucywgc3R5bGUpO1xuXG52YXIgbWFrZUxpbmVTcGFuID0gZnVuY3Rpb24gbWFrZUxpbmVTcGFuKGNsYXNzTmFtZSwgb3B0aW9ucywgdGhpY2tuZXNzKSB7XG4gIHZhciBsaW5lID0gbWFrZVNwYW4kMihbY2xhc3NOYW1lXSwgW10sIG9wdGlvbnMpO1xuICBsaW5lLmhlaWdodCA9IE1hdGgubWF4KHRoaWNrbmVzcyB8fCBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVmYXVsdFJ1bGVUaGlja25lc3MsIG9wdGlvbnMubWluUnVsZVRoaWNrbmVzcyk7XG4gIGxpbmUuc3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSBtYWtlRW0obGluZS5oZWlnaHQpO1xuICBsaW5lLm1heEZvbnRTaXplID0gMS4wO1xuICByZXR1cm4gbGluZTtcbn07XG4vKipcbiAqIE1ha2VzIGFuIGFuY2hvciB3aXRoIHRoZSBnaXZlbiBocmVmLCBsaXN0IG9mIGNsYXNzZXMsIGxpc3Qgb2YgY2hpbGRyZW4sXG4gKiBhbmQgb3B0aW9ucy5cbiAqL1xuXG5cbnZhciBtYWtlQW5jaG9yID0gZnVuY3Rpb24gbWFrZUFuY2hvcihocmVmLCBjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucykge1xuICB2YXIgYW5jaG9yID0gbmV3IEFuY2hvcihocmVmLCBjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucyk7XG4gIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKGFuY2hvcik7XG4gIHJldHVybiBhbmNob3I7XG59O1xuLyoqXG4gKiBNYWtlcyBhIGRvY3VtZW50IGZyYWdtZW50IHdpdGggdGhlIGdpdmVuIGxpc3Qgb2YgY2hpbGRyZW4uXG4gKi9cblxuXG52YXIgbWFrZUZyYWdtZW50ID0gZnVuY3Rpb24gbWFrZUZyYWdtZW50KGNoaWxkcmVuKSB7XG4gIHZhciBmcmFnbWVudCA9IG5ldyBEb2N1bWVudEZyYWdtZW50KGNoaWxkcmVuKTtcbiAgc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4oZnJhZ21lbnQpO1xuICByZXR1cm4gZnJhZ21lbnQ7XG59O1xuLyoqXG4gKiBXcmFwcyBncm91cCBpbiBhIHNwYW4gaWYgaXQncyBhIGRvY3VtZW50IGZyYWdtZW50LCBhbGxvd2luZyB0byBhcHBseSBjbGFzc2VzXG4gKiBhbmQgc3R5bGVzXG4gKi9cblxuXG52YXIgd3JhcEZyYWdtZW50ID0gZnVuY3Rpb24gd3JhcEZyYWdtZW50KGdyb3VwLCBvcHRpb25zKSB7XG4gIGlmIChncm91cCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICByZXR1cm4gbWFrZVNwYW4kMihbXSwgW2dyb3VwXSwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gZ3JvdXA7XG59OyAvLyBUaGVzZSBhcmUgZXhhY3Qgb2JqZWN0IHR5cGVzIHRvIGNhdGNoIHR5cG9zIGluIHRoZSBuYW1lcyBvZiB0aGUgb3B0aW9uYWwgZmllbGRzLlxuXG5cbi8vIENvbXB1dGVzIHRoZSB1cGRhdGVkIGBjaGlsZHJlbmAgbGlzdCBhbmQgdGhlIG92ZXJhbGwgZGVwdGguXG4vL1xuLy8gVGhpcyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1ha2VWTGlzdCBtYWtlcyBpdCBlYXNpZXIgdG8gZW5mb3JjZSB0eXBlIHNhZmV0eSBieVxuLy8gYWxsb3dpbmcgZWFybHkgZXhpdHMgKHJldHVybnMpIGluIHRoZSBsb2dpYy5cbnZhciBnZXRWTGlzdENoaWxkcmVuQW5kRGVwdGggPSBmdW5jdGlvbiBnZXRWTGlzdENoaWxkcmVuQW5kRGVwdGgocGFyYW1zKSB7XG4gIGlmIChwYXJhbXMucG9zaXRpb25UeXBlID09PSBcImluZGl2aWR1YWxTaGlmdFwiKSB7XG4gICAgdmFyIG9sZENoaWxkcmVuID0gcGFyYW1zLmNoaWxkcmVuO1xuICAgIHZhciBjaGlsZHJlbiA9IFtvbGRDaGlsZHJlblswXV07IC8vIEFkZCBpbiBrZXJucyB0byB0aGUgbGlzdCBvZiBwYXJhbXMuY2hpbGRyZW4gdG8gZ2V0IGVhY2ggZWxlbWVudCB0byBiZVxuICAgIC8vIHNoaWZ0ZWQgdG8gdGhlIGNvcnJlY3Qgc3BlY2lmaWVkIHNoaWZ0XG5cbiAgICB2YXIgX2RlcHRoID0gLW9sZENoaWxkcmVuWzBdLnNoaWZ0IC0gb2xkQ2hpbGRyZW5bMF0uZWxlbS5kZXB0aDtcblxuICAgIHZhciBjdXJyUG9zID0gX2RlcHRoO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBvbGRDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRpZmYgPSAtb2xkQ2hpbGRyZW5baV0uc2hpZnQgLSBjdXJyUG9zIC0gb2xkQ2hpbGRyZW5baV0uZWxlbS5kZXB0aDtcbiAgICAgIHZhciBzaXplID0gZGlmZiAtIChvbGRDaGlsZHJlbltpIC0gMV0uZWxlbS5oZWlnaHQgKyBvbGRDaGlsZHJlbltpIC0gMV0uZWxlbS5kZXB0aCk7XG4gICAgICBjdXJyUG9zID0gY3VyclBvcyArIGRpZmY7XG4gICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemVcbiAgICAgIH0pO1xuICAgICAgY2hpbGRyZW4ucHVzaChvbGRDaGlsZHJlbltpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZGVwdGg6IF9kZXB0aFxuICAgIH07XG4gIH1cblxuICB2YXIgZGVwdGg7XG5cbiAgaWYgKHBhcmFtcy5wb3NpdGlvblR5cGUgPT09IFwidG9wXCIpIHtcbiAgICAvLyBXZSBhbHdheXMgc3RhcnQgYXQgdGhlIGJvdHRvbSwgc28gY2FsY3VsYXRlIHRoZSBib3R0b20gYnkgYWRkaW5nIHVwXG4gICAgLy8gYWxsIHRoZSBzaXplc1xuICAgIHZhciBib3R0b20gPSBwYXJhbXMucG9zaXRpb25EYXRhO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHBhcmFtcy5jaGlsZHJlbi5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmFtcy5jaGlsZHJlbltfaV07XG4gICAgICBib3R0b20gLT0gY2hpbGQudHlwZSA9PT0gXCJrZXJuXCIgPyBjaGlsZC5zaXplIDogY2hpbGQuZWxlbS5oZWlnaHQgKyBjaGlsZC5lbGVtLmRlcHRoO1xuICAgIH1cblxuICAgIGRlcHRoID0gYm90dG9tO1xuICB9IGVsc2UgaWYgKHBhcmFtcy5wb3NpdGlvblR5cGUgPT09IFwiYm90dG9tXCIpIHtcbiAgICBkZXB0aCA9IC1wYXJhbXMucG9zaXRpb25EYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBmaXJzdENoaWxkID0gcGFyYW1zLmNoaWxkcmVuWzBdO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQudHlwZSAhPT0gXCJlbGVtXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgY2hpbGQgbXVzdCBoYXZlIHR5cGUgXCJlbGVtXCIuJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5wb3NpdGlvblR5cGUgPT09IFwic2hpZnRcIikge1xuICAgICAgZGVwdGggPSAtZmlyc3RDaGlsZC5lbGVtLmRlcHRoIC0gcGFyYW1zLnBvc2l0aW9uRGF0YTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5wb3NpdGlvblR5cGUgPT09IFwiZmlyc3RCYXNlbGluZVwiKSB7XG4gICAgICBkZXB0aCA9IC1maXJzdENoaWxkLmVsZW0uZGVwdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcG9zaXRpb25UeXBlIFwiICsgcGFyYW1zLnBvc2l0aW9uVHlwZSArIFwiLlwiKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNoaWxkcmVuOiBwYXJhbXMuY2hpbGRyZW4sXG4gICAgZGVwdGhcbiAgfTtcbn07XG4vKipcbiAqIE1ha2VzIGEgdmVydGljYWwgbGlzdCBieSBzdGFja2luZyBlbGVtZW50cyBhbmQga2VybnMgb24gdG9wIG9mIGVhY2ggb3RoZXIuXG4gKiBBbGxvd3MgZm9yIG1hbnkgZGlmZmVyZW50IHdheXMgb2Ygc3BlY2lmeWluZyB0aGUgcG9zaXRpb25pbmcgbWV0aG9kLlxuICpcbiAqIFNlZSBWTGlzdFBhcmFtIGRvY3VtZW50YXRpb24gYWJvdmUuXG4gKi9cblxuXG52YXIgbWFrZVZMaXN0ID0gZnVuY3Rpb24gbWFrZVZMaXN0KHBhcmFtcywgb3B0aW9ucykge1xuICB2YXIge1xuICAgIGNoaWxkcmVuLFxuICAgIGRlcHRoXG4gIH0gPSBnZXRWTGlzdENoaWxkcmVuQW5kRGVwdGgocGFyYW1zKTsgLy8gQ3JlYXRlIGEgc3RydXQgdGhhdCBpcyB0YWxsZXIgdGhhbiBhbnkgbGlzdCBpdGVtLiBUaGUgc3RydXQgaXMgYWRkZWQgdG9cbiAgLy8gZWFjaCBpdGVtLCB3aGVyZSBpdCB3aWxsIGRldGVybWluZSB0aGUgaXRlbSdzIGJhc2VsaW5lLiBTaW5jZSBpdCBoYXNcbiAgLy8gYG92ZXJmbG93OmhpZGRlbmAsIHRoZSBzdHJ1dCdzIHRvcCBlZGdlIHdpbGwgc2l0IG9uIHRoZSBpdGVtJ3MgbGluZSBib3gnc1xuICAvLyB0b3AgZWRnZSBhbmQgdGhlIHN0cnV0J3MgYm90dG9tIGVkZ2Ugd2lsbCBzaXQgb24gdGhlIGl0ZW0ncyBiYXNlbGluZSxcbiAgLy8gd2l0aCBubyBhZGRpdGlvbmFsIGxpbmUtaGVpZ2h0IHNwYWNpbmcuIFRoaXMgYWxsb3dzIHRoZSBpdGVtIGJhc2VsaW5lIHRvXG4gIC8vIGJlIHBvc2l0aW9uZWQgcHJlY2lzZWx5IHdpdGhvdXQgd29ycnlpbmcgYWJvdXQgZm9udCBhc2NlbnQgYW5kXG4gIC8vIGxpbmUtaGVpZ2h0LlxuXG4gIHZhciBwc3RydXRTaXplID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJlbGVtXCIpIHtcbiAgICAgIHZhciBlbGVtID0gY2hpbGQuZWxlbTtcbiAgICAgIHBzdHJ1dFNpemUgPSBNYXRoLm1heChwc3RydXRTaXplLCBlbGVtLm1heEZvbnRTaXplLCBlbGVtLmhlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgcHN0cnV0U2l6ZSArPSAyO1xuICB2YXIgcHN0cnV0ID0gbWFrZVNwYW4kMihbXCJwc3RydXRcIl0sIFtdKTtcbiAgcHN0cnV0LnN0eWxlLmhlaWdodCA9IG1ha2VFbShwc3RydXRTaXplKTsgLy8gQ3JlYXRlIGEgbmV3IGxpc3Qgb2YgYWN0dWFsIGNoaWxkcmVuIGF0IHRoZSBjb3JyZWN0IG9mZnNldHNcblxuICB2YXIgcmVhbENoaWxkcmVuID0gW107XG4gIHZhciBtaW5Qb3MgPSBkZXB0aDtcbiAgdmFyIG1heFBvcyA9IGRlcHRoO1xuICB2YXIgY3VyclBvcyA9IGRlcHRoO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGNoaWxkcmVuLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX2NoaWxkID0gY2hpbGRyZW5bX2kyXTtcblxuICAgIGlmIChfY2hpbGQudHlwZSA9PT0gXCJrZXJuXCIpIHtcbiAgICAgIGN1cnJQb3MgKz0gX2NoaWxkLnNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfZWxlbSA9IF9jaGlsZC5lbGVtO1xuICAgICAgdmFyIGNsYXNzZXMgPSBfY2hpbGQud3JhcHBlckNsYXNzZXMgfHwgW107XG4gICAgICB2YXIgc3R5bGUgPSBfY2hpbGQud3JhcHBlclN0eWxlIHx8IHt9O1xuICAgICAgdmFyIGNoaWxkV3JhcCA9IG1ha2VTcGFuJDIoY2xhc3NlcywgW3BzdHJ1dCwgX2VsZW1dLCB1bmRlZmluZWQsIHN0eWxlKTtcbiAgICAgIGNoaWxkV3JhcC5zdHlsZS50b3AgPSBtYWtlRW0oLXBzdHJ1dFNpemUgLSBjdXJyUG9zIC0gX2VsZW0uZGVwdGgpO1xuXG4gICAgICBpZiAoX2NoaWxkLm1hcmdpbkxlZnQpIHtcbiAgICAgICAgY2hpbGRXcmFwLnN0eWxlLm1hcmdpbkxlZnQgPSBfY2hpbGQubWFyZ2luTGVmdDtcbiAgICAgIH1cblxuICAgICAgaWYgKF9jaGlsZC5tYXJnaW5SaWdodCkge1xuICAgICAgICBjaGlsZFdyYXAuc3R5bGUubWFyZ2luUmlnaHQgPSBfY2hpbGQubWFyZ2luUmlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHJlYWxDaGlsZHJlbi5wdXNoKGNoaWxkV3JhcCk7XG4gICAgICBjdXJyUG9zICs9IF9lbGVtLmhlaWdodCArIF9lbGVtLmRlcHRoO1xuICAgIH1cblxuICAgIG1pblBvcyA9IE1hdGgubWluKG1pblBvcywgY3VyclBvcyk7XG4gICAgbWF4UG9zID0gTWF0aC5tYXgobWF4UG9zLCBjdXJyUG9zKTtcbiAgfSAvLyBUaGUgdmxpc3QgY29udGVudHMgZ28gaW4gYSB0YWJsZS1jZWxsIHdpdGggYHZlcnRpY2FsLWFsaWduOmJvdHRvbWAuXG4gIC8vIFRoaXMgY2VsbCdzIGJvdHRvbSBlZGdlIHdpbGwgZGV0ZXJtaW5lIHRoZSBjb250YWluaW5nIHRhYmxlJ3MgYmFzZWxpbmVcbiAgLy8gd2l0aG91dCBvdmVybHkgZXhwYW5kaW5nIHRoZSBjb250YWluaW5nIGxpbmUtYm94LlxuXG5cbiAgdmFyIHZsaXN0ID0gbWFrZVNwYW4kMihbXCJ2bGlzdFwiXSwgcmVhbENoaWxkcmVuKTtcbiAgdmxpc3Quc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKG1heFBvcyk7IC8vIEEgc2Vjb25kIHJvdyBpcyB1c2VkIGlmIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIHZsaXN0J3MgZGVwdGguXG5cbiAgdmFyIHJvd3M7XG5cbiAgaWYgKG1pblBvcyA8IDApIHtcbiAgICAvLyBXZSB3aWxsIGRlZmluZSBkZXB0aCBpbiBhbiBlbXB0eSBzcGFuIHdpdGggZGlzcGxheTogdGFibGUtY2VsbC5cbiAgICAvLyBJdCBzaG91bGQgcmVuZGVyIHdpdGggdGhlIGhlaWdodCB0aGF0IHdlIGRlZmluZS4gQnV0IENocm9tZSwgaW5cbiAgICAvLyBjb250ZW50ZWRpdGFibGUgbW9kZSBvbmx5LCB0cmVhdHMgdGhhdCBzcGFuIGFzIGlmIGl0IGNvbnRhaW5zIHNvbWVcbiAgICAvLyB0ZXh0IGNvbnRlbnQuIEFuZCB0aGF0IG1pbi1oZWlnaHQgb3Zlci1yaWRlcyBvdXIgZGVzaXJlZCBoZWlnaHQuXG4gICAgLy8gU28gd2UgcHV0IGFub3RoZXIgZW1wdHkgc3BhbiBpbnNpZGUgdGhlIGRlcHRoIHN0cnV0IHNwYW4uXG4gICAgdmFyIGVtcHR5U3BhbiA9IG1ha2VTcGFuJDIoW10sIFtdKTtcbiAgICB2YXIgZGVwdGhTdHJ1dCA9IG1ha2VTcGFuJDIoW1widmxpc3RcIl0sIFtlbXB0eVNwYW5dKTtcbiAgICBkZXB0aFN0cnV0LnN0eWxlLmhlaWdodCA9IG1ha2VFbSgtbWluUG9zKTsgLy8gU2FmYXJpIHdhbnRzIHRoZSBmaXJzdCByb3cgdG8gaGF2ZSBpbmxpbmUgY29udGVudDsgb3RoZXJ3aXNlIGl0XG4gICAgLy8gcHV0cyB0aGUgYm90dG9tIG9mIHRoZSAqc2Vjb25kKiByb3cgb24gdGhlIGJhc2VsaW5lLlxuXG4gICAgdmFyIHRvcFN0cnV0ID0gbWFrZVNwYW4kMihbXCJ2bGlzdC1zXCJdLCBbbmV3IFN5bWJvbE5vZGUoXCJcXHUyMDBiXCIpXSk7XG4gICAgcm93cyA9IFttYWtlU3BhbiQyKFtcInZsaXN0LXJcIl0sIFt2bGlzdCwgdG9wU3RydXRdKSwgbWFrZVNwYW4kMihbXCJ2bGlzdC1yXCJdLCBbZGVwdGhTdHJ1dF0pXTtcbiAgfSBlbHNlIHtcbiAgICByb3dzID0gW21ha2VTcGFuJDIoW1widmxpc3QtclwiXSwgW3ZsaXN0XSldO1xuICB9XG5cbiAgdmFyIHZ0YWJsZSA9IG1ha2VTcGFuJDIoW1widmxpc3QtdFwiXSwgcm93cyk7XG5cbiAgaWYgKHJvd3MubGVuZ3RoID09PSAyKSB7XG4gICAgdnRhYmxlLmNsYXNzZXMucHVzaChcInZsaXN0LXQyXCIpO1xuICB9XG5cbiAgdnRhYmxlLmhlaWdodCA9IG1heFBvcztcbiAgdnRhYmxlLmRlcHRoID0gLW1pblBvcztcbiAgcmV0dXJuIHZ0YWJsZTtcbn07IC8vIEdsdWUgaXMgYSBjb25jZXB0IGZyb20gVGVYIHdoaWNoIGlzIGEgZmxleGlibGUgc3BhY2UgYmV0d2VlbiBlbGVtZW50cyBpblxuLy8gZWl0aGVyIGEgdmVydGljYWwgb3IgaG9yaXpvbnRhbCBsaXN0LiBJbiBLYVRlWCwgYXQgbGVhc3QgZm9yIG5vdywgaXQnc1xuLy8gc3RhdGljIHNwYWNlIGJldHdlZW4gZWxlbWVudHMgaW4gYSBob3Jpem9udGFsIGxheW91dC5cblxuXG52YXIgbWFrZUdsdWUgPSAobWVhc3VyZW1lbnQsIG9wdGlvbnMpID0+IHtcbiAgLy8gTWFrZSBhbiBlbXB0eSBzcGFuIGZvciB0aGUgc3BhY2VcbiAgdmFyIHJ1bGUgPSBtYWtlU3BhbiQyKFtcIm1zcGFjZVwiXSwgW10sIG9wdGlvbnMpO1xuICB2YXIgc2l6ZSA9IGNhbGN1bGF0ZVNpemUobWVhc3VyZW1lbnQsIG9wdGlvbnMpO1xuICBydWxlLnN0eWxlLm1hcmdpblJpZ2h0ID0gbWFrZUVtKHNpemUpO1xuICByZXR1cm4gcnVsZTtcbn07IC8vIFRha2VzIGZvbnQgb3B0aW9ucywgYW5kIHJldHVybnMgdGhlIGFwcHJvcHJpYXRlIGZvbnRMb29rdXAgbmFtZVxuXG5cbnZhciByZXRyaWV2ZVRleHRGb250TmFtZSA9IGZ1bmN0aW9uIHJldHJpZXZlVGV4dEZvbnROYW1lKGZvbnRGYW1pbHksIGZvbnRXZWlnaHQsIGZvbnRTaGFwZSkge1xuICB2YXIgYmFzZUZvbnROYW1lID0gXCJcIjtcblxuICBzd2l0Y2ggKGZvbnRGYW1pbHkpIHtcbiAgICBjYXNlIFwiYW1zcm1cIjpcbiAgICAgIGJhc2VGb250TmFtZSA9IFwiQU1TXCI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0ZXh0cm1cIjpcbiAgICAgIGJhc2VGb250TmFtZSA9IFwiTWFpblwiO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dHNmXCI6XG4gICAgICBiYXNlRm9udE5hbWUgPSBcIlNhbnNTZXJpZlwiO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidGV4dHR0XCI6XG4gICAgICBiYXNlRm9udE5hbWUgPSBcIlR5cGV3cml0ZXJcIjtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGJhc2VGb250TmFtZSA9IGZvbnRGYW1pbHk7XG4gICAgLy8gdXNlIGZvbnRzIGFkZGVkIGJ5IGEgcGx1Z2luXG4gIH1cblxuICB2YXIgZm9udFN0eWxlc05hbWU7XG5cbiAgaWYgKGZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIgJiYgZm9udFNoYXBlID09PSBcInRleHRpdFwiKSB7XG4gICAgZm9udFN0eWxlc05hbWUgPSBcIkJvbGRJdGFsaWNcIjtcbiAgfSBlbHNlIGlmIChmb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgZm9udFN0eWxlc05hbWUgPSBcIkJvbGRcIjtcbiAgfSBlbHNlIGlmIChmb250V2VpZ2h0ID09PSBcInRleHRpdFwiKSB7XG4gICAgZm9udFN0eWxlc05hbWUgPSBcIkl0YWxpY1wiO1xuICB9IGVsc2Uge1xuICAgIGZvbnRTdHlsZXNOYW1lID0gXCJSZWd1bGFyXCI7XG4gIH1cblxuICByZXR1cm4gYmFzZUZvbnROYW1lICsgXCItXCIgKyBmb250U3R5bGVzTmFtZTtcbn07XG4vKipcbiAqIE1hcHMgVGVYIGZvbnQgY29tbWFuZHMgdG8gb2JqZWN0cyBjb250YWluaW5nOlxuICogLSB2YXJpYW50OiBzdHJpbmcgdXNlZCBmb3IgXCJtYXRodmFyaWFudFwiIGF0dHJpYnV0ZSBpbiBidWlsZE1hdGhNTC5qc1xuICogLSBmb250TmFtZTogdGhlIFwic3R5bGVcIiBwYXJhbWV0ZXIgdG8gZm9udE1ldHJpY3MuZ2V0Q2hhcmFjdGVyTWV0cmljc1xuICovXG4vLyBBIG1hcCBiZXR3ZWVuIHRleCBmb250IGNvbW1hbmRzIGFuIE1hdGhNTCBtYXRodmFyaWFudCBhdHRyaWJ1dGUgdmFsdWVzXG5cblxudmFyIGZvbnRNYXAgPSB7XG4gIC8vIHN0eWxlc1xuICBcIm1hdGhiZlwiOiB7XG4gICAgdmFyaWFudDogXCJib2xkXCIsXG4gICAgZm9udE5hbWU6IFwiTWFpbi1Cb2xkXCJcbiAgfSxcbiAgXCJtYXRocm1cIjoge1xuICAgIHZhcmlhbnQ6IFwibm9ybWFsXCIsXG4gICAgZm9udE5hbWU6IFwiTWFpbi1SZWd1bGFyXCJcbiAgfSxcbiAgXCJ0ZXh0aXRcIjoge1xuICAgIHZhcmlhbnQ6IFwiaXRhbGljXCIsXG4gICAgZm9udE5hbWU6IFwiTWFpbi1JdGFsaWNcIlxuICB9LFxuICBcIm1hdGhpdFwiOiB7XG4gICAgdmFyaWFudDogXCJpdGFsaWNcIixcbiAgICBmb250TmFtZTogXCJNYWluLUl0YWxpY1wiXG4gIH0sXG4gIFwibWF0aG5vcm1hbFwiOiB7XG4gICAgdmFyaWFudDogXCJpdGFsaWNcIixcbiAgICBmb250TmFtZTogXCJNYXRoLUl0YWxpY1wiXG4gIH0sXG4gIFwibWF0aHNmaXRcIjoge1xuICAgIHZhcmlhbnQ6IFwic2Fucy1zZXJpZi1pdGFsaWNcIixcbiAgICBmb250TmFtZTogXCJTYW5zU2VyaWYtSXRhbGljXCJcbiAgfSxcbiAgLy8gXCJib2xkc3ltYm9sXCIgaXMgbWlzc2luZyBiZWNhdXNlIHRoZXkgcmVxdWlyZSB0aGUgdXNlIG9mIG11bHRpcGxlIGZvbnRzOlxuICAvLyBNYXRoLUJvbGRJdGFsaWMgYW5kIE1haW4tQm9sZC4gIFRoaXMgaXMgaGFuZGxlZCBieSBhIHNwZWNpYWwgY2FzZSBpblxuICAvLyBtYWtlT3JkIHdoaWNoIGVuZHMgdXAgY2FsbGluZyBib2xkc3ltYm9sLlxuICAvLyBmYW1pbGllc1xuICBcIm1hdGhiYlwiOiB7XG4gICAgdmFyaWFudDogXCJkb3VibGUtc3RydWNrXCIsXG4gICAgZm9udE5hbWU6IFwiQU1TLVJlZ3VsYXJcIlxuICB9LFxuICBcIm1hdGhjYWxcIjoge1xuICAgIHZhcmlhbnQ6IFwic2NyaXB0XCIsXG4gICAgZm9udE5hbWU6IFwiQ2FsaWdyYXBoaWMtUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aGZyYWtcIjoge1xuICAgIHZhcmlhbnQ6IFwiZnJha3R1clwiLFxuICAgIGZvbnROYW1lOiBcIkZyYWt0dXItUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aHNjclwiOiB7XG4gICAgdmFyaWFudDogXCJzY3JpcHRcIixcbiAgICBmb250TmFtZTogXCJTY3JpcHQtUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aHNmXCI6IHtcbiAgICB2YXJpYW50OiBcInNhbnMtc2VyaWZcIixcbiAgICBmb250TmFtZTogXCJTYW5zU2VyaWYtUmVndWxhclwiXG4gIH0sXG4gIFwibWF0aHR0XCI6IHtcbiAgICB2YXJpYW50OiBcIm1vbm9zcGFjZVwiLFxuICAgIGZvbnROYW1lOiBcIlR5cGV3cml0ZXItUmVndWxhclwiXG4gIH1cbn07XG52YXIgc3ZnRGF0YSA9IHtcbiAgLy8gICBwYXRoLCB3aWR0aCwgaGVpZ2h0XG4gIHZlYzogW1widmVjXCIsIDAuNDcxLCAwLjcxNF0sXG4gIC8vIHZhbHVlcyBmcm9tIHRoZSBmb250IGdseXBoXG4gIG9paW50U2l6ZTE6IFtcIm9paW50U2l6ZTFcIiwgMC45NTcsIDAuNDk5XSxcbiAgLy8gb3ZhbCB0byBvdmVybGF5IHRoZSBpbnRlZ3JhbmRcbiAgb2lpbnRTaXplMjogW1wib2lpbnRTaXplMlwiLCAxLjQ3MiwgMC42NTldLFxuICBvaWlpbnRTaXplMTogW1wib2lpaW50U2l6ZTFcIiwgMS4zMDQsIDAuNDk5XSxcbiAgb2lpaW50U2l6ZTI6IFtcIm9paWludFNpemUyXCIsIDEuOTgsIDAuNjU5XVxufTtcblxudmFyIHN0YXRpY1N2ZyA9IGZ1bmN0aW9uIHN0YXRpY1N2Zyh2YWx1ZSwgb3B0aW9ucykge1xuICAvLyBDcmVhdGUgYSBzcGFuIHdpdGggaW5saW5lIFNWRyBmb3IgdGhlIGVsZW1lbnQuXG4gIHZhciBbcGF0aE5hbWUsIHdpZHRoLCBoZWlnaHRdID0gc3ZnRGF0YVt2YWx1ZV07XG4gIHZhciBwYXRoID0gbmV3IFBhdGhOb2RlKHBhdGhOYW1lKTtcbiAgdmFyIHN2Z05vZGUgPSBuZXcgU3ZnTm9kZShbcGF0aF0sIHtcbiAgICBcIndpZHRoXCI6IG1ha2VFbSh3aWR0aCksXG4gICAgXCJoZWlnaHRcIjogbWFrZUVtKGhlaWdodCksXG4gICAgLy8gT3ZlcnJpZGUgQ1NTIHJ1bGUgYC5rYXRleCBzdmcgeyB3aWR0aDogMTAwJSB9YFxuICAgIFwic3R5bGVcIjogXCJ3aWR0aDpcIiArIG1ha2VFbSh3aWR0aCksXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIFwiICsgMTAwMCAqIHdpZHRoICsgXCIgXCIgKyAxMDAwICogaGVpZ2h0LFxuICAgIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiOiBcInhNaW5ZTWluXCJcbiAgfSk7XG4gIHZhciBzcGFuID0gbWFrZVN2Z1NwYW4oW1wib3ZlcmxheVwiXSwgW3N2Z05vZGVdLCBvcHRpb25zKTtcbiAgc3Bhbi5oZWlnaHQgPSBoZWlnaHQ7XG4gIHNwYW4uc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKGhlaWdodCk7XG4gIHNwYW4uc3R5bGUud2lkdGggPSBtYWtlRW0od2lkdGgpO1xuICByZXR1cm4gc3Bhbjtcbn07XG5cbnZhciBidWlsZENvbW1vbiA9IHtcbiAgZm9udE1hcCxcbiAgbWFrZVN5bWJvbCxcbiAgbWF0aHN5bSxcbiAgbWFrZVNwYW46IG1ha2VTcGFuJDIsXG4gIG1ha2VTdmdTcGFuLFxuICBtYWtlTGluZVNwYW4sXG4gIG1ha2VBbmNob3IsXG4gIG1ha2VGcmFnbWVudCxcbiAgd3JhcEZyYWdtZW50LFxuICBtYWtlVkxpc3QsXG4gIG1ha2VPcmQsXG4gIG1ha2VHbHVlLFxuICBzdGF0aWNTdmcsXG4gIHN2Z0RhdGEsXG4gIHRyeUNvbWJpbmVDaGFyc1xufTtcblxuLyoqXG4gKiBEZXNjcmliZXMgc3BhY2VzIGJldHdlZW4gZGlmZmVyZW50IGNsYXNzZXMgb2YgYXRvbXMuXG4gKi9cbnZhciB0aGluc3BhY2UgPSB7XG4gIG51bWJlcjogMyxcbiAgdW5pdDogXCJtdVwiXG59O1xudmFyIG1lZGl1bXNwYWNlID0ge1xuICBudW1iZXI6IDQsXG4gIHVuaXQ6IFwibXVcIlxufTtcbnZhciB0aGlja3NwYWNlID0ge1xuICBudW1iZXI6IDUsXG4gIHVuaXQ6IFwibXVcIlxufTsgLy8gTWFraW5nIHRoZSB0eXBlIGJlbG93IGV4YWN0IHdpdGggYWxsIG9wdGlvbmFsIGZpZWxkcyBkb2Vzbid0IHdvcmsgZHVlIHRvXG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy80NTgyXG4vLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy81Njg4XG4vLyBIb3dldmVyLCBzaW5jZSAqYWxsKiBmaWVsZHMgYXJlIG9wdGlvbmFsLCAkU2hhcGU8PiB3b3JrcyBhcyBzdWdnZXN0ZWQgaW4gNTY4OFxuLy8gYWJvdmUuXG5cbi8vIFNwYWNpbmcgcmVsYXRpb25zaGlwcyBmb3IgZGlzcGxheSBhbmQgdGV4dCBzdHlsZXNcbnZhciBzcGFjaW5ncyA9IHtcbiAgbW9yZDoge1xuICAgIG1vcDogdGhpbnNwYWNlLFxuICAgIG1iaW46IG1lZGl1bXNwYWNlLFxuICAgIG1yZWw6IHRoaWNrc3BhY2UsXG4gICAgbWlubmVyOiB0aGluc3BhY2VcbiAgfSxcbiAgbW9wOiB7XG4gICAgbW9yZDogdGhpbnNwYWNlLFxuICAgIG1vcDogdGhpbnNwYWNlLFxuICAgIG1yZWw6IHRoaWNrc3BhY2UsXG4gICAgbWlubmVyOiB0aGluc3BhY2VcbiAgfSxcbiAgbWJpbjoge1xuICAgIG1vcmQ6IG1lZGl1bXNwYWNlLFxuICAgIG1vcDogbWVkaXVtc3BhY2UsXG4gICAgbW9wZW46IG1lZGl1bXNwYWNlLFxuICAgIG1pbm5lcjogbWVkaXVtc3BhY2VcbiAgfSxcbiAgbXJlbDoge1xuICAgIG1vcmQ6IHRoaWNrc3BhY2UsXG4gICAgbW9wOiB0aGlja3NwYWNlLFxuICAgIG1vcGVuOiB0aGlja3NwYWNlLFxuICAgIG1pbm5lcjogdGhpY2tzcGFjZVxuICB9LFxuICBtb3Blbjoge30sXG4gIG1jbG9zZToge1xuICAgIG1vcDogdGhpbnNwYWNlLFxuICAgIG1iaW46IG1lZGl1bXNwYWNlLFxuICAgIG1yZWw6IHRoaWNrc3BhY2UsXG4gICAgbWlubmVyOiB0aGluc3BhY2VcbiAgfSxcbiAgbXB1bmN0OiB7XG4gICAgbW9yZDogdGhpbnNwYWNlLFxuICAgIG1vcDogdGhpbnNwYWNlLFxuICAgIG1yZWw6IHRoaWNrc3BhY2UsXG4gICAgbW9wZW46IHRoaW5zcGFjZSxcbiAgICBtY2xvc2U6IHRoaW5zcGFjZSxcbiAgICBtcHVuY3Q6IHRoaW5zcGFjZSxcbiAgICBtaW5uZXI6IHRoaW5zcGFjZVxuICB9LFxuICBtaW5uZXI6IHtcbiAgICBtb3JkOiB0aGluc3BhY2UsXG4gICAgbW9wOiB0aGluc3BhY2UsXG4gICAgbWJpbjogbWVkaXVtc3BhY2UsXG4gICAgbXJlbDogdGhpY2tzcGFjZSxcbiAgICBtb3BlbjogdGhpbnNwYWNlLFxuICAgIG1wdW5jdDogdGhpbnNwYWNlLFxuICAgIG1pbm5lcjogdGhpbnNwYWNlXG4gIH1cbn07IC8vIFNwYWNpbmcgcmVsYXRpb25zaGlwcyBmb3Igc2NyaXB0IGFuZCBzY3JpcHRzY3JpcHQgc3R5bGVzXG5cbnZhciB0aWdodFNwYWNpbmdzID0ge1xuICBtb3JkOiB7XG4gICAgbW9wOiB0aGluc3BhY2VcbiAgfSxcbiAgbW9wOiB7XG4gICAgbW9yZDogdGhpbnNwYWNlLFxuICAgIG1vcDogdGhpbnNwYWNlXG4gIH0sXG4gIG1iaW46IHt9LFxuICBtcmVsOiB7fSxcbiAgbW9wZW46IHt9LFxuICBtY2xvc2U6IHtcbiAgICBtb3A6IHRoaW5zcGFjZVxuICB9LFxuICBtcHVuY3Q6IHt9LFxuICBtaW5uZXI6IHtcbiAgICBtb3A6IHRoaW5zcGFjZVxuICB9XG59O1xuXG4vKiogQ29udGV4dCBwcm92aWRlZCB0byBmdW5jdGlvbiBoYW5kbGVycyBmb3IgZXJyb3IgbWVzc2FnZXMuICovXG4vLyBOb3RlOiByZXZlcnNlIHRoZSBvcmRlciBvZiB0aGUgcmV0dXJuIHR5cGUgdW5pb24gd2lsbCBjYXVzZSBhIGZsb3cgZXJyb3IuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzM2NjMuXG4vLyBNb3JlIGdlbmVyYWwgdmVyc2lvbiBvZiBgSHRtbEJ1aWxkZXJgIGZvciBub2RlcyAoZS5nLiBcXHN1bSwgYWNjZW50IHR5cGVzKVxuLy8gd2hvc2UgcHJlc2VuY2UgaW1wYWN0cyBzdXBlci9zdWJzY3JpcHRpbmcuIEluIHRoaXMgY2FzZSwgUGFyc2VOb2RlPFwic3Vwc3ViXCI+XG4vLyBkZWxlZ2F0ZXMgaXRzIEhUTUwgYnVpbGRpbmcgdG8gdGhlIEh0bWxCdWlsZGVyIGNvcnJlc3BvbmRpbmcgdG8gdGhlc2Ugbm9kZXMuXG5cbi8qKlxuICogRmluYWwgZnVuY3Rpb24gc3BlYyBmb3IgdXNlIGF0IHBhcnNlIHRpbWUuXG4gKiBUaGlzIGlzIGFsbW9zdCBpZGVudGljYWwgdG8gYEZ1bmN0aW9uUHJvcFNwZWNgLCBleGNlcHQgaXRcbiAqIDEuIGluY2x1ZGVzIHRoZSBmdW5jdGlvbiBoYW5kbGVyLCBhbmRcbiAqIDIuIHJlcXVpcmVzIGFsbCBhcmd1bWVudHMgZXhjZXB0IGFyZ1R5cGVzLlxuICogSXQgaXMgZ2VuZXJhdGVkIGJ5IGBkZWZpbmVGdW5jdGlvbigpYCBiZWxvdy5cbiAqL1xuXG4vKipcbiAqIEFsbCByZWdpc3RlcmVkIGZ1bmN0aW9ucy5cbiAqIGBmdW5jdGlvbnMuanNgIGp1c3QgZXhwb3J0cyB0aGlzIHNhbWUgZGljdGlvbmFyeSBhZ2FpbiBhbmQgbWFrZXMgaXQgcHVibGljLlxuICogYFBhcnNlci5qc2AgcmVxdWlyZXMgdGhpcyBkaWN0aW9uYXJ5LlxuICovXG52YXIgX2Z1bmN0aW9ucyA9IHt9O1xuLyoqXG4gKiBBbGwgSFRNTCBidWlsZGVycy4gU2hvdWxkIGJlIG9ubHkgdXNlZCBpbiB0aGUgYGRlZmluZSpgIGFuZCB0aGUgYGJ1aWxkKk1MYFxuICogZnVuY3Rpb25zLlxuICovXG5cbnZhciBfaHRtbEdyb3VwQnVpbGRlcnMgPSB7fTtcbi8qKlxuICogQWxsIE1hdGhNTCBidWlsZGVycy4gU2hvdWxkIGJlIG9ubHkgdXNlZCBpbiB0aGUgYGRlZmluZSpgIGFuZCB0aGUgYGJ1aWxkKk1MYFxuICogZnVuY3Rpb25zLlxuICovXG5cbnZhciBfbWF0aG1sR3JvdXBCdWlsZGVycyA9IHt9O1xuZnVuY3Rpb24gZGVmaW5lRnVuY3Rpb24oX3JlZikge1xuICB2YXIge1xuICAgIHR5cGUsXG4gICAgbmFtZXMsXG4gICAgcHJvcHMsXG4gICAgaGFuZGxlcixcbiAgICBodG1sQnVpbGRlcixcbiAgICBtYXRobWxCdWlsZGVyXG4gIH0gPSBfcmVmO1xuICAvLyBTZXQgZGVmYXVsdCB2YWx1ZXMgb2YgZnVuY3Rpb25zXG4gIHZhciBkYXRhID0ge1xuICAgIHR5cGUsXG4gICAgbnVtQXJnczogcHJvcHMubnVtQXJncyxcbiAgICBhcmdUeXBlczogcHJvcHMuYXJnVHlwZXMsXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6ICEhcHJvcHMuYWxsb3dlZEluQXJndW1lbnQsXG4gICAgYWxsb3dlZEluVGV4dDogISFwcm9wcy5hbGxvd2VkSW5UZXh0LFxuICAgIGFsbG93ZWRJbk1hdGg6IHByb3BzLmFsbG93ZWRJbk1hdGggPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwcm9wcy5hbGxvd2VkSW5NYXRoLFxuICAgIG51bU9wdGlvbmFsQXJnczogcHJvcHMubnVtT3B0aW9uYWxBcmdzIHx8IDAsXG4gICAgaW5maXg6ICEhcHJvcHMuaW5maXgsXG4gICAgcHJpbWl0aXZlOiAhIXByb3BzLnByaW1pdGl2ZSxcbiAgICBoYW5kbGVyOiBoYW5kbGVyXG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgIF9mdW5jdGlvbnNbbmFtZXNbaV1dID0gZGF0YTtcbiAgfVxuXG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKGh0bWxCdWlsZGVyKSB7XG4gICAgICBfaHRtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBodG1sQnVpbGRlcjtcbiAgICB9XG5cbiAgICBpZiAobWF0aG1sQnVpbGRlcikge1xuICAgICAgX21hdGhtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBtYXRobWxCdWlsZGVyO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBVc2UgdGhpcyB0byByZWdpc3RlciBvbmx5IHRoZSBIVE1MIGFuZCBNYXRoTUwgYnVpbGRlcnMgZm9yIGEgZnVuY3Rpb24gKGUuZy5cbiAqIGlmIHRoZSBmdW5jdGlvbidzIFBhcnNlTm9kZSBpcyBnZW5lcmF0ZWQgaW4gUGFyc2VyLmpzIHJhdGhlciB0aGFuIHZpYSBhXG4gKiBzdGFuZC1hbG9uZSBoYW5kbGVyIHByb3ZpZGVkIHRvIGBkZWZpbmVGdW5jdGlvbmApLlxuICovXG5cbmZ1bmN0aW9uIGRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoX3JlZjIpIHtcbiAgdmFyIHtcbiAgICB0eXBlLFxuICAgIGh0bWxCdWlsZGVyLFxuICAgIG1hdGhtbEJ1aWxkZXJcbiAgfSA9IF9yZWYyO1xuICBkZWZpbmVGdW5jdGlvbih7XG4gICAgdHlwZSxcbiAgICBuYW1lczogW10sXG4gICAgcHJvcHM6IHtcbiAgICAgIG51bUFyZ3M6IDBcbiAgICB9LFxuXG4gICAgaGFuZGxlcigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5ldmVyIGJlIGNhbGxlZC4nKTtcbiAgICB9LFxuXG4gICAgaHRtbEJ1aWxkZXIsXG4gICAgbWF0aG1sQnVpbGRlclxuICB9KTtcbn1cbnZhciBub3JtYWxpemVBcmd1bWVudCA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUFyZ3VtZW50KGFyZykge1xuICByZXR1cm4gYXJnLnR5cGUgPT09IFwib3JkZ3JvdXBcIiAmJiBhcmcuYm9keS5sZW5ndGggPT09IDEgPyBhcmcuYm9keVswXSA6IGFyZztcbn07IC8vIFNpbmNlIHRoZSBjb3JyZXNwb25kaW5nIGJ1aWxkSFRNTC9idWlsZE1hdGhNTCBmdW5jdGlvbiBleHBlY3RzIGFcbi8vIGxpc3Qgb2YgZWxlbWVudHMsIHdlIG5vcm1hbGl6ZSBmb3IgZGlmZmVyZW50IGtpbmRzIG9mIGFyZ3VtZW50c1xuXG52YXIgb3JkYXJndW1lbnQgPSBmdW5jdGlvbiBvcmRhcmd1bWVudChhcmcpIHtcbiAgcmV0dXJuIGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIgPyBhcmcuYm9keSA6IFthcmddO1xufTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgZG9lcyB0aGUgbWFpbiB3b3JrIG9mIGJ1aWxkaW5nIGEgZG9tVHJlZSBzdHJ1Y3R1cmUgZnJvbSBhIHBhcnNlXG4gKiB0cmVlLiBUaGUgZW50cnkgcG9pbnQgaXMgdGhlIGBidWlsZEhUTUxgIGZ1bmN0aW9uLCB3aGljaCB0YWtlcyBhIHBhcnNlIHRyZWUuXG4gKiBUaGVuLCB0aGUgYnVpbGRFeHByZXNzaW9uLCBidWlsZEdyb3VwLCBhbmQgdmFyaW91cyBncm91cEJ1aWxkZXJzIGZ1bmN0aW9uc1xuICogYXJlIGNhbGxlZCwgdG8gcHJvZHVjZSBhIGZpbmFsIEhUTUwgdHJlZS5cbiAqL1xudmFyIG1ha2VTcGFuJDEgPSBidWlsZENvbW1vbi5tYWtlU3BhbjsgLy8gQmluYXJ5IGF0b21zIChmaXJzdCBjbGFzcyBgbWJpbmApIGNoYW5nZSBpbnRvIG9yZGluYXJ5IGF0b21zIChgbW9yZGApXG4vLyBkZXBlbmRpbmcgb24gdGhlaXIgc3Vycm91bmRpbmdzLiBTZWUgVGVYYm9vayBwZy4gNDQyLTQ0NiwgUnVsZXMgNSBhbmQgNixcbi8vIGFuZCB0aGUgdGV4dCBiZWZvcmUgUnVsZSAxOS5cblxudmFyIGJpbkxlZnRDYW5jZWxsZXIgPSBbXCJsZWZ0bW9zdFwiLCBcIm1iaW5cIiwgXCJtb3BlblwiLCBcIm1yZWxcIiwgXCJtb3BcIiwgXCJtcHVuY3RcIl07XG52YXIgYmluUmlnaHRDYW5jZWxsZXIgPSBbXCJyaWdodG1vc3RcIiwgXCJtcmVsXCIsIFwibWNsb3NlXCIsIFwibXB1bmN0XCJdO1xudmFyIHN0eWxlTWFwJDEgPSB7XG4gIFwiZGlzcGxheVwiOiBTdHlsZSQxLkRJU1BMQVksXG4gIFwidGV4dFwiOiBTdHlsZSQxLlRFWFQsXG4gIFwic2NyaXB0XCI6IFN0eWxlJDEuU0NSSVBULFxuICBcInNjcmlwdHNjcmlwdFwiOiBTdHlsZSQxLlNDUklQVFNDUklQVFxufTtcbnZhciBEb21FbnVtID0ge1xuICBtb3JkOiBcIm1vcmRcIixcbiAgbW9wOiBcIm1vcFwiLFxuICBtYmluOiBcIm1iaW5cIixcbiAgbXJlbDogXCJtcmVsXCIsXG4gIG1vcGVuOiBcIm1vcGVuXCIsXG4gIG1jbG9zZTogXCJtY2xvc2VcIixcbiAgbXB1bmN0OiBcIm1wdW5jdFwiLFxuICBtaW5uZXI6IFwibWlubmVyXCJcbn07XG5cbi8qKlxuICogVGFrZSBhIGxpc3Qgb2Ygbm9kZXMsIGJ1aWxkIHRoZW0gaW4gb3JkZXIsIGFuZCByZXR1cm4gYSBsaXN0IG9mIHRoZSBidWlsdFxuICogbm9kZXMuIGRvY3VtZW50RnJhZ21lbnRzIGFyZSBmbGF0dGVuZWQgaW50byB0aGVpciBjb250ZW50cywgc28gdGhlXG4gKiByZXR1cm5lZCBsaXN0IGNvbnRhaW5zIG5vIGZyYWdtZW50cy4gYGlzUmVhbEdyb3VwYCBpcyB0cnVlIGlmIGBleHByZXNzaW9uYFxuICogaXMgYSByZWFsIGdyb3VwIChubyBhdG9tcyB3aWxsIGJlIGFkZGVkIG9uIGVpdGhlciBzaWRlKSwgYXMgb3Bwb3NlZCB0b1xuICogYSBwYXJ0aWFsIGdyb3VwIChlLmcuIG9uZSBjcmVhdGVkIGJ5IFxcY29sb3IpLiBgc3Vycm91bmRpbmdgIGlzIGFuIGFycmF5XG4gKiBjb25zaXN0aW5nIHR5cGUgb2Ygbm9kZXMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBsZWZ0IGFuZCByaWdodC5cbiAqL1xudmFyIGJ1aWxkRXhwcmVzc2lvbiQxID0gZnVuY3Rpb24gYnVpbGRFeHByZXNzaW9uKGV4cHJlc3Npb24sIG9wdGlvbnMsIGlzUmVhbEdyb3VwLCBzdXJyb3VuZGluZykge1xuICBpZiAoc3Vycm91bmRpbmcgPT09IHZvaWQgMCkge1xuICAgIHN1cnJvdW5kaW5nID0gW251bGwsIG51bGxdO1xuICB9XG5cbiAgLy8gUGFyc2UgZXhwcmVzc2lvbnMgaW50byBgZ3JvdXBzYC5cbiAgdmFyIGdyb3VwcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBvdXRwdXQgPSBidWlsZEdyb3VwJDEoZXhwcmVzc2lvbltpXSwgb3B0aW9ucyk7XG5cbiAgICBpZiAob3V0cHV0IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gb3V0cHV0LmNoaWxkcmVuO1xuICAgICAgZ3JvdXBzLnB1c2goLi4uY2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cHMucHVzaChvdXRwdXQpO1xuICAgIH1cbiAgfSAvLyBDb21iaW5lIGNvbnNlY3V0aXZlIGRvbVRyZWUuc3ltYm9sTm9kZXMgaW50byBhIHNpbmdsZSBzeW1ib2xOb2RlLlxuXG5cbiAgYnVpbGRDb21tb24udHJ5Q29tYmluZUNoYXJzKGdyb3Vwcyk7IC8vIElmIGBleHByZXNzaW9uYCBpcyBhIHBhcnRpYWwgZ3JvdXAsIGxldCB0aGUgcGFyZW50IGhhbmRsZSBzcGFjaW5nc1xuICAvLyB0byBhdm9pZCBwcm9jZXNzaW5nIGdyb3VwcyBtdWx0aXBsZSB0aW1lcy5cblxuICBpZiAoIWlzUmVhbEdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuXG4gIHZhciBnbHVlT3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgaWYgKGV4cHJlc3Npb24ubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG5vZGUgPSBleHByZXNzaW9uWzBdO1xuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJzaXppbmdcIikge1xuICAgICAgZ2x1ZU9wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1NpemUobm9kZS5zaXplKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJzdHlsaW5nXCIpIHtcbiAgICAgIGdsdWVPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShzdHlsZU1hcCQxW25vZGUuc3R5bGVdKTtcbiAgICB9XG4gIH0gLy8gRHVtbXkgc3BhbnMgZm9yIGRldGVybWluaW5nIHNwYWNpbmdzIGJldHdlZW4gc3Vycm91bmRpbmcgYXRvbXMuXG4gIC8vIElmIGBleHByZXNzaW9uYCBoYXMgbm8gYXRvbXMgb24gdGhlIGxlZnQgb3IgcmlnaHQsIGNsYXNzIFwibGVmdG1vc3RcIlxuICAvLyBvciBcInJpZ2h0bW9zdFwiLCByZXNwZWN0aXZlbHksIGlzIHVzZWQgdG8gaW5kaWNhdGUgaXQuXG5cblxuICB2YXIgZHVtbXlQcmV2ID0gbWFrZVNwYW4kMShbc3Vycm91bmRpbmdbMF0gfHwgXCJsZWZ0bW9zdFwiXSwgW10sIG9wdGlvbnMpO1xuICB2YXIgZHVtbXlOZXh0ID0gbWFrZVNwYW4kMShbc3Vycm91bmRpbmdbMV0gfHwgXCJyaWdodG1vc3RcIl0sIFtdLCBvcHRpb25zKTsgLy8gVE9ETzogVGhlc2UgY29kZSBhc3N1bWVzIHRoYXQgYSBub2RlJ3MgbWF0aCBjbGFzcyBpcyB0aGUgZmlyc3QgZWxlbWVudFxuICAvLyBvZiBpdHMgYGNsYXNzZXNgIGFycmF5LiBBIGxhdGVyIGNsZWFudXAgc2hvdWxkIGVuc3VyZSB0aGlzLCBmb3JcbiAgLy8gaW5zdGFuY2UgYnkgY2hhbmdpbmcgdGhlIHNpZ25hdHVyZSBvZiBgbWFrZVNwYW5gLlxuICAvLyBCZWZvcmUgZGV0ZXJtaW5pbmcgd2hhdCBzcGFjZXMgdG8gaW5zZXJ0LCBwZXJmb3JtIGJpbiBjYW5jZWxsYXRpb24uXG4gIC8vIEJpbmFyeSBvcGVyYXRvcnMgY2hhbmdlIHRvIG9yZGluYXJ5IHN5bWJvbHMgaW4gc29tZSBjb250ZXh0cy5cblxuICB2YXIgaXNSb290ID0gaXNSZWFsR3JvdXAgPT09IFwicm9vdFwiO1xuICB0cmF2ZXJzZU5vblNwYWNlTm9kZXMoZ3JvdXBzLCAobm9kZSwgcHJldikgPT4ge1xuICAgIHZhciBwcmV2VHlwZSA9IHByZXYuY2xhc3Nlc1swXTtcbiAgICB2YXIgdHlwZSA9IG5vZGUuY2xhc3Nlc1swXTtcblxuICAgIGlmIChwcmV2VHlwZSA9PT0gXCJtYmluXCIgJiYgYmluUmlnaHRDYW5jZWxsZXIuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgIHByZXYuY2xhc3Nlc1swXSA9IFwibW9yZFwiO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJtYmluXCIgJiYgYmluTGVmdENhbmNlbGxlci5pbmNsdWRlcyhwcmV2VHlwZSkpIHtcbiAgICAgIG5vZGUuY2xhc3Nlc1swXSA9IFwibW9yZFwiO1xuICAgIH1cbiAgfSwge1xuICAgIG5vZGU6IGR1bW15UHJldlxuICB9LCBkdW1teU5leHQsIGlzUm9vdCk7XG4gIHRyYXZlcnNlTm9uU3BhY2VOb2Rlcyhncm91cHMsIChub2RlLCBwcmV2KSA9PiB7XG4gICAgdmFyIHByZXZUeXBlID0gZ2V0VHlwZU9mRG9tVHJlZShwcmV2KTtcbiAgICB2YXIgdHlwZSA9IGdldFR5cGVPZkRvbVRyZWUobm9kZSk7IC8vICdtdGlnaHQnIGluZGljYXRlcyB0aGF0IHRoZSBub2RlIGlzIHNjcmlwdCBvciBzY3JpcHRzY3JpcHQgc3R5bGUuXG5cbiAgICB2YXIgc3BhY2UgPSBwcmV2VHlwZSAmJiB0eXBlID8gbm9kZS5oYXNDbGFzcyhcIm10aWdodFwiKSA/IHRpZ2h0U3BhY2luZ3NbcHJldlR5cGVdW3R5cGVdIDogc3BhY2luZ3NbcHJldlR5cGVdW3R5cGVdIDogbnVsbDtcblxuICAgIGlmIChzcGFjZSkge1xuICAgICAgLy8gSW5zZXJ0IGdsdWUgKHNwYWNpbmcpIGFmdGVyIHRoZSBgcHJldmAuXG4gICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUdsdWUoc3BhY2UsIGdsdWVPcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBub2RlOiBkdW1teVByZXZcbiAgfSwgZHVtbXlOZXh0LCBpc1Jvb3QpO1xuICByZXR1cm4gZ3JvdXBzO1xufTsgLy8gRGVwdGgtZmlyc3QgdHJhdmVyc2Ugbm9uLXNwYWNlIGBub2Rlc2AsIGNhbGxpbmcgYGNhbGxiYWNrYCB3aXRoIHRoZSBjdXJyZW50IGFuZFxuLy8gcHJldmlvdXMgbm9kZSBhcyBhcmd1bWVudHMsIG9wdGlvbmFsbHkgcmV0dXJuaW5nIGEgbm9kZSB0byBpbnNlcnQgYWZ0ZXIgdGhlXG4vLyBwcmV2aW91cyBub2RlLiBgcHJldmAgaXMgYW4gb2JqZWN0IHdpdGggdGhlIHByZXZpb3VzIG5vZGUgYW5kIGBpbnNlcnRBZnRlcmBcbi8vIGZ1bmN0aW9uIHRvIGluc2VydCBhZnRlciBpdC4gYG5leHRgIGlzIGEgbm9kZSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHJpZ2h0LlxuLy8gVXNlZCBmb3IgYmluIGNhbmNlbGxhdGlvbiBhbmQgaW5zZXJ0aW5nIHNwYWNpbmdzLlxuXG52YXIgdHJhdmVyc2VOb25TcGFjZU5vZGVzID0gZnVuY3Rpb24gdHJhdmVyc2VOb25TcGFjZU5vZGVzKG5vZGVzLCBjYWxsYmFjaywgcHJldiwgbmV4dCwgaXNSb290KSB7XG4gIGlmIChuZXh0KSB7XG4gICAgLy8gdGVtcG9yYXJpbHkgYXBwZW5kIHRoZSByaWdodCBub2RlLCBpZiBleGlzdHNcbiAgICBub2Rlcy5wdXNoKG5leHQpO1xuICB9XG5cbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIHZhciBwYXJ0aWFsR3JvdXAgPSBjaGVja1BhcnRpYWxHcm91cChub2RlKTtcblxuICAgIGlmIChwYXJ0aWFsR3JvdXApIHtcbiAgICAgIC8vIFJlY3Vyc2l2ZSBERlNcbiAgICAgIC8vICRGbG93Rml4TWU6IG1ha2Ugbm9kZXMgYSAkUmVhZE9ubHlBcnJheSBieSByZXR1cm5pbmcgYSBuZXcgYXJyYXlcbiAgICAgIHRyYXZlcnNlTm9uU3BhY2VOb2RlcyhwYXJ0aWFsR3JvdXAuY2hpbGRyZW4sIGNhbGxiYWNrLCBwcmV2LCBudWxsLCBpc1Jvb3QpO1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBJZ25vcmUgZXhwbGljaXQgc3BhY2VzIChlLmcuLCBcXDssIFxcLCkgd2hlbiBkZXRlcm1pbmluZyB3aGF0IGltcGxpY2l0XG4gICAgLy8gc3BhY2luZyBzaG91bGQgZ28gYmV0d2VlbiBhdG9tcyBvZiBkaWZmZXJlbnQgY2xhc3Nlc1xuXG5cbiAgICB2YXIgbm9uc3BhY2UgPSAhbm9kZS5oYXNDbGFzcyhcIm1zcGFjZVwiKTtcblxuICAgIGlmIChub25zcGFjZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrKG5vZGUsIHByZXYubm9kZSk7XG5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHByZXYuaW5zZXJ0QWZ0ZXIpIHtcbiAgICAgICAgICBwcmV2Lmluc2VydEFmdGVyKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaW5zZXJ0IGF0IGZyb250XG4gICAgICAgICAgbm9kZXMudW5zaGlmdChyZXN1bHQpO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub25zcGFjZSkge1xuICAgICAgcHJldi5ub2RlID0gbm9kZTtcbiAgICB9IGVsc2UgaWYgKGlzUm9vdCAmJiBub2RlLmhhc0NsYXNzKFwibmV3bGluZVwiKSkge1xuICAgICAgcHJldi5ub2RlID0gbWFrZVNwYW4kMShbXCJsZWZ0bW9zdFwiXSk7IC8vIHRyZWF0IGxpa2UgYmVnaW5uaW5nIG9mIGxpbmVcbiAgICB9XG5cbiAgICBwcmV2Lmluc2VydEFmdGVyID0gKGluZGV4ID0+IG4gPT4ge1xuICAgICAgbm9kZXMuc3BsaWNlKGluZGV4ICsgMSwgMCwgbik7XG4gICAgICBpKys7XG4gICAgfSkoaSk7XG4gIH1cblxuICBpZiAobmV4dCkge1xuICAgIG5vZGVzLnBvcCgpO1xuICB9XG59OyAvLyBDaGVjayBpZiBnaXZlbiBub2RlIGlzIGEgcGFydGlhbCBncm91cCwgaS5lLiwgZG9lcyBub3QgYWZmZWN0IHNwYWNpbmcgYXJvdW5kLlxuXG5cbnZhciBjaGVja1BhcnRpYWxHcm91cCA9IGZ1bmN0aW9uIGNoZWNrUGFydGlhbEdyb3VwKG5vZGUpIHtcbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBBbmNob3IgfHwgbm9kZSBpbnN0YW5jZW9mIFNwYW4gJiYgbm9kZS5oYXNDbGFzcyhcImVuY2xvc2luZ1wiKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59OyAvLyBSZXR1cm4gdGhlIG91dGVybW9zdCBub2RlIG9mIGEgZG9tVHJlZS5cblxuXG52YXIgZ2V0T3V0ZXJtb3N0Tm9kZSA9IGZ1bmN0aW9uIGdldE91dGVybW9zdE5vZGUobm9kZSwgc2lkZSkge1xuICB2YXIgcGFydGlhbEdyb3VwID0gY2hlY2tQYXJ0aWFsR3JvdXAobm9kZSk7XG5cbiAgaWYgKHBhcnRpYWxHcm91cCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHBhcnRpYWxHcm91cC5jaGlsZHJlbjtcblxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGlmIChzaWRlID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgcmV0dXJuIGdldE91dGVybW9zdE5vZGUoY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0sIFwicmlnaHRcIik7XG4gICAgICB9IGVsc2UgaWYgKHNpZGUgPT09IFwibGVmdFwiKSB7XG4gICAgICAgIHJldHVybiBnZXRPdXRlcm1vc3ROb2RlKGNoaWxkcmVuWzBdLCBcImxlZnRcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59OyAvLyBSZXR1cm4gbWF0aCBhdG9tIGNsYXNzIChtY2xhc3MpIG9mIGEgZG9tVHJlZS5cbi8vIElmIGBzaWRlYCBpcyBnaXZlbiwgaXQgd2lsbCBnZXQgdGhlIHR5cGUgb2YgdGhlIG91dGVybW9zdCBub2RlIGF0IGdpdmVuIHNpZGUuXG5cblxudmFyIGdldFR5cGVPZkRvbVRyZWUgPSBmdW5jdGlvbiBnZXRUeXBlT2ZEb21UcmVlKG5vZGUsIHNpZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoc2lkZSkge1xuICAgIG5vZGUgPSBnZXRPdXRlcm1vc3ROb2RlKG5vZGUsIHNpZGUpO1xuICB9IC8vIFRoaXMgbWFrZXMgYSBsb3Qgb2YgYXNzdW1wdGlvbnMgYXMgdG8gd2hlcmUgdGhlIHR5cGUgb2YgYXRvbVxuICAvLyBhcHBlYXJzLiAgV2Ugc2hvdWxkIGRvIGEgYmV0dGVyIGpvYiBvZiBlbmZvcmNpbmcgdGhpcy5cblxuXG4gIHJldHVybiBEb21FbnVtW25vZGUuY2xhc3Nlc1swXV0gfHwgbnVsbDtcbn07XG52YXIgbWFrZU51bGxEZWxpbWl0ZXIgPSBmdW5jdGlvbiBtYWtlTnVsbERlbGltaXRlcihvcHRpb25zLCBjbGFzc2VzKSB7XG4gIHZhciBtb3JlQ2xhc3NlcyA9IFtcIm51bGxkZWxpbWl0ZXJcIl0uY29uY2F0KG9wdGlvbnMuYmFzZVNpemluZ0NsYXNzZXMoKSk7XG4gIHJldHVybiBtYWtlU3BhbiQxKGNsYXNzZXMuY29uY2F0KG1vcmVDbGFzc2VzKSk7XG59O1xuLyoqXG4gKiBidWlsZEdyb3VwIGlzIHRoZSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgZ3JvdXAgYW5kIGNhbGxzIHRoZSBjb3JyZWN0IGdyb3VwVHlwZVxuICogZnVuY3Rpb24gZm9yIGl0LiBJdCBhbHNvIGhhbmRsZXMgdGhlIGludGVyYWN0aW9uIG9mIHNpemUgYW5kIHN0eWxlIGNoYW5nZXNcbiAqIGJldHdlZW4gcGFyZW50cyBhbmQgY2hpbGRyZW4uXG4gKi9cblxudmFyIGJ1aWxkR3JvdXAkMSA9IGZ1bmN0aW9uIGJ1aWxkR3JvdXAoZ3JvdXAsIG9wdGlvbnMsIGJhc2VPcHRpb25zKSB7XG4gIGlmICghZ3JvdXApIHtcbiAgICByZXR1cm4gbWFrZVNwYW4kMSgpO1xuICB9XG5cbiAgaWYgKF9odG1sR3JvdXBCdWlsZGVyc1tncm91cC50eXBlXSkge1xuICAgIC8vIENhbGwgdGhlIGdyb3VwQnVpbGRlcnMgZnVuY3Rpb25cbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgdmFyIGdyb3VwTm9kZSA9IF9odG1sR3JvdXBCdWlsZGVyc1tncm91cC50eXBlXShncm91cCwgb3B0aW9ucyk7IC8vIElmIHRoZSBzaXplIGNoYW5nZWQgYmV0d2VlbiB0aGUgcGFyZW50IGFuZCB0aGUgY3VycmVudCBncm91cCwgYWNjb3VudFxuICAgIC8vIGZvciB0aGF0IHNpemUgZGlmZmVyZW5jZS5cblxuICAgIGlmIChiYXNlT3B0aW9ucyAmJiBvcHRpb25zLnNpemUgIT09IGJhc2VPcHRpb25zLnNpemUpIHtcbiAgICAgIGdyb3VwTm9kZSA9IG1ha2VTcGFuJDEob3B0aW9ucy5zaXppbmdDbGFzc2VzKGJhc2VPcHRpb25zKSwgW2dyb3VwTm9kZV0sIG9wdGlvbnMpO1xuICAgICAgdmFyIG11bHRpcGxpZXIgPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gYmFzZU9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgICBncm91cE5vZGUuaGVpZ2h0ICo9IG11bHRpcGxpZXI7XG4gICAgICBncm91cE5vZGUuZGVwdGggKj0gbXVsdGlwbGllcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JvdXBOb2RlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiR290IGdyb3VwIG9mIHVua25vd24gdHlwZTogJ1wiICsgZ3JvdXAudHlwZSArIFwiJ1wiKTtcbiAgfVxufTtcbi8qKlxuICogQ29tYmluZSBhbiBhcnJheSBvZiBIVE1MIERPTSBub2RlcyAoZS5nLiwgdGhlIG91dHB1dCBvZiBgYnVpbGRFeHByZXNzaW9uYClcbiAqIGludG8gYW4gdW5icmVha2FibGUgSFRNTCBub2RlIG9mIGNsYXNzIC5iYXNlLCB3aXRoIHByb3BlciBzdHJ1dHMgdG9cbiAqIGd1YXJhbnRlZSBjb3JyZWN0IHZlcnRpY2FsIGV4dGVudC4gIGBidWlsZEhUTUxgIGNhbGxzIHRoaXMgcmVwZWF0ZWRseSB0b1xuICogbWFrZSB1cCB0aGUgZW50aXJlIGV4cHJlc3Npb24gYXMgYSBzZXF1ZW5jZSBvZiB1bmJyZWFrYWJsZSB1bml0cy5cbiAqL1xuXG5mdW5jdGlvbiBidWlsZEhUTUxVbmJyZWFrYWJsZShjaGlsZHJlbiwgb3B0aW9ucykge1xuICAvLyBDb21wdXRlIGhlaWdodCBhbmQgZGVwdGggb2YgdGhpcyBjaHVuay5cbiAgdmFyIGJvZHkgPSBtYWtlU3BhbiQxKFtcImJhc2VcIl0sIGNoaWxkcmVuLCBvcHRpb25zKTsgLy8gQWRkIHN0cnV0LCB3aGljaCBlbnN1cmVzIHRoYXQgdGhlIHRvcCBvZiB0aGUgSFRNTCBlbGVtZW50IGZhbGxzIGF0XG4gIC8vIHRoZSBoZWlnaHQgb2YgdGhlIGV4cHJlc3Npb24sIGFuZCB0aGUgYm90dG9tIG9mIHRoZSBIVE1MIGVsZW1lbnRcbiAgLy8gZmFsbHMgYXQgdGhlIGRlcHRoIG9mIHRoZSBleHByZXNzaW9uLlxuXG4gIHZhciBzdHJ1dCA9IG1ha2VTcGFuJDEoW1wic3RydXRcIl0pO1xuICBzdHJ1dC5zdHlsZS5oZWlnaHQgPSBtYWtlRW0oYm9keS5oZWlnaHQgKyBib2R5LmRlcHRoKTtcblxuICBpZiAoYm9keS5kZXB0aCkge1xuICAgIHN0cnV0LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBtYWtlRW0oLWJvZHkuZGVwdGgpO1xuICB9XG5cbiAgYm9keS5jaGlsZHJlbi51bnNoaWZ0KHN0cnV0KTtcbiAgcmV0dXJuIGJvZHk7XG59XG4vKipcbiAqIFRha2UgYW4gZW50aXJlIHBhcnNlIHRyZWUsIGFuZCBidWlsZCBpdCBpbnRvIGFuIGFwcHJvcHJpYXRlIHNldCBvZiBIVE1MXG4gKiBub2Rlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJ1aWxkSFRNTCh0cmVlLCBvcHRpb25zKSB7XG4gIC8vIFN0cmlwIG9mZiBvdXRlciB0YWcgd3JhcHBlciBmb3IgcHJvY2Vzc2luZyBiZWxvdy5cbiAgdmFyIHRhZyA9IG51bGw7XG5cbiAgaWYgKHRyZWUubGVuZ3RoID09PSAxICYmIHRyZWVbMF0udHlwZSA9PT0gXCJ0YWdcIikge1xuICAgIHRhZyA9IHRyZWVbMF0udGFnO1xuICAgIHRyZWUgPSB0cmVlWzBdLmJvZHk7XG4gIH0gLy8gQnVpbGQgdGhlIGV4cHJlc3Npb24gY29udGFpbmVkIGluIHRoZSB0cmVlXG5cblxuICB2YXIgZXhwcmVzc2lvbiA9IGJ1aWxkRXhwcmVzc2lvbiQxKHRyZWUsIG9wdGlvbnMsIFwicm9vdFwiKTtcbiAgdmFyIGVxbk51bTtcblxuICBpZiAoZXhwcmVzc2lvbi5sZW5ndGggPT09IDIgJiYgZXhwcmVzc2lvblsxXS5oYXNDbGFzcyhcInRhZ1wiKSkge1xuICAgIC8vIEFuIGVudmlyb25tZW50IHdpdGggYXV0b21hdGljIGVxdWF0aW9uIG51bWJlcnMsIGUuZy4ge2dhdGhlcn0uXG4gICAgZXFuTnVtID0gZXhwcmVzc2lvbi5wb3AoKTtcbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IFtdOyAvLyBDcmVhdGUgb25lIGJhc2Ugbm9kZSBmb3IgZWFjaCBjaHVuayBiZXR3ZWVuIHBvdGVudGlhbCBsaW5lIGJyZWFrcy5cbiAgLy8gVGhlIFRlWEJvb2sgW3AuMTczXSBzYXlzIFwiQSBmb3JtdWxhIHdpbGwgYmUgYnJva2VuIG9ubHkgYWZ0ZXIgYVxuICAvLyByZWxhdGlvbiBzeW1ib2wgbGlrZSAkPSQgb3IgJDwkIG9yICRcXHJpZ2h0YXJyb3ckLCBvciBhZnRlciBhIGJpbmFyeVxuICAvLyBvcGVyYXRpb24gc3ltYm9sIGxpa2UgJCskIG9yICQtJCBvciAkXFx0aW1lcyQsIHdoZXJlIHRoZSByZWxhdGlvbiBvclxuICAvLyBiaW5hcnkgb3BlcmF0aW9uIGlzIG9uIHRoZSBgYG91dGVyIGxldmVsJycgb2YgdGhlIGZvcm11bGEgKGkuZS4sIG5vdFxuICAvLyBlbmNsb3NlZCBpbiB7Li4ufSBhbmQgbm90IHBhcnQgb2YgYW4gXFxvdmVyIGNvbnN0cnVjdGlvbikuXCJcblxuICB2YXIgcGFydHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKGV4cHJlc3Npb25baV0pO1xuXG4gICAgaWYgKGV4cHJlc3Npb25baV0uaGFzQ2xhc3MoXCJtYmluXCIpIHx8IGV4cHJlc3Npb25baV0uaGFzQ2xhc3MoXCJtcmVsXCIpIHx8IGV4cHJlc3Npb25baV0uaGFzQ2xhc3MoXCJhbGxvd2JyZWFrXCIpKSB7XG4gICAgICAvLyBQdXQgYW55IHBvc3Qtb3BlcmF0b3IgZ2x1ZSBvbiBzYW1lIGxpbmUgYXMgb3BlcmF0b3IuXG4gICAgICAvLyBXYXRjaCBmb3IgXFxub2JyZWFrIGFsb25nIHRoZSB3YXksIGFuZCBzdG9wIGF0IFxcbmV3bGluZS5cbiAgICAgIHZhciBub2JyZWFrID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChpIDwgZXhwcmVzc2lvbi5sZW5ndGggLSAxICYmIGV4cHJlc3Npb25baSArIDFdLmhhc0NsYXNzKFwibXNwYWNlXCIpICYmICFleHByZXNzaW9uW2kgKyAxXS5oYXNDbGFzcyhcIm5ld2xpbmVcIikpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBwYXJ0cy5wdXNoKGV4cHJlc3Npb25baV0pO1xuXG4gICAgICAgIGlmIChleHByZXNzaW9uW2ldLmhhc0NsYXNzKFwibm9icmVha1wiKSkge1xuICAgICAgICAgIG5vYnJlYWsgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIERvbid0IGFsbG93IGJyZWFrIGlmIFxcbm9icmVhayBhbW9uZyB0aGUgcG9zdC1vcGVyYXRvciBnbHVlLlxuXG5cbiAgICAgIGlmICghbm9icmVhaykge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGJ1aWxkSFRNTFVuYnJlYWthYmxlKHBhcnRzLCBvcHRpb25zKSk7XG4gICAgICAgIHBhcnRzID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChleHByZXNzaW9uW2ldLmhhc0NsYXNzKFwibmV3bGluZVwiKSkge1xuICAgICAgLy8gV3JpdGUgdGhlIGxpbmUgZXhjZXB0IHRoZSBuZXdsaW5lXG4gICAgICBwYXJ0cy5wb3AoKTtcblxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChidWlsZEhUTUxVbmJyZWFrYWJsZShwYXJ0cywgb3B0aW9ucykpO1xuICAgICAgICBwYXJ0cyA9IFtdO1xuICAgICAgfSAvLyBQdXQgdGhlIG5ld2xpbmUgYXQgdGhlIHRvcCBsZXZlbFxuXG5cbiAgICAgIGNoaWxkcmVuLnB1c2goZXhwcmVzc2lvbltpXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICBjaGlsZHJlbi5wdXNoKGJ1aWxkSFRNTFVuYnJlYWthYmxlKHBhcnRzLCBvcHRpb25zKSk7XG4gIH0gLy8gTm93LCBpZiB0aGVyZSB3YXMgYSB0YWcsIGJ1aWxkIGl0IHRvbyBhbmQgYXBwZW5kIGl0IGFzIGEgZmluYWwgY2hpbGQuXG5cblxuICB2YXIgdGFnQ2hpbGQ7XG5cbiAgaWYgKHRhZykge1xuICAgIHRhZ0NoaWxkID0gYnVpbGRIVE1MVW5icmVha2FibGUoYnVpbGRFeHByZXNzaW9uJDEodGFnLCBvcHRpb25zLCB0cnVlKSk7XG4gICAgdGFnQ2hpbGQuY2xhc3NlcyA9IFtcInRhZ1wiXTtcbiAgICBjaGlsZHJlbi5wdXNoKHRhZ0NoaWxkKTtcbiAgfSBlbHNlIGlmIChlcW5OdW0pIHtcbiAgICBjaGlsZHJlbi5wdXNoKGVxbk51bSk7XG4gIH1cblxuICB2YXIgaHRtbE5vZGUgPSBtYWtlU3BhbiQxKFtcImthdGV4LWh0bWxcIl0sIGNoaWxkcmVuKTtcbiAgaHRtbE5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpOyAvLyBBZGp1c3QgdGhlIHN0cnV0IG9mIHRoZSB0YWcgdG8gYmUgdGhlIG1heGltdW0gaGVpZ2h0IG9mIGFsbCBjaGlsZHJlblxuICAvLyAodGhlIGhlaWdodCBvZiB0aGUgZW5jbG9zaW5nIGh0bWxOb2RlKSBmb3IgcHJvcGVyIHZlcnRpY2FsIGFsaWdubWVudC5cblxuICBpZiAodGFnQ2hpbGQpIHtcbiAgICB2YXIgc3RydXQgPSB0YWdDaGlsZC5jaGlsZHJlblswXTtcbiAgICBzdHJ1dC5zdHlsZS5oZWlnaHQgPSBtYWtlRW0oaHRtbE5vZGUuaGVpZ2h0ICsgaHRtbE5vZGUuZGVwdGgpO1xuXG4gICAgaWYgKGh0bWxOb2RlLmRlcHRoKSB7XG4gICAgICBzdHJ1dC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gbWFrZUVtKC1odG1sTm9kZS5kZXB0aCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGh0bWxOb2RlO1xufVxuXG4vKipcbiAqIFRoZXNlIG9iamVjdHMgc3RvcmUgZGF0YSBhYm91dCBNYXRoTUwgbm9kZXMuIFRoaXMgaXMgdGhlIE1hdGhNTCBlcXVpdmFsZW50XG4gKiBvZiB0aGUgdHlwZXMgaW4gZG9tVHJlZS5qcy4gU2luY2UgTWF0aE1MIGhhbmRsZXMgaXRzIG93biByZW5kZXJpbmcsIGFuZFxuICogc2luY2Ugd2UncmUgbWFpbmx5IHVzaW5nIE1hdGhNTCB0byBpbXByb3ZlIGFjY2Vzc2liaWxpdHksIHdlIGRvbid0IG1hbmFnZVxuICogYW55IG9mIHRoZSBzdHlsaW5nIHN0YXRlIHRoYXQgdGhlIHBsYWluIERPTSBub2RlcyBkby5cbiAqXG4gKiBUaGUgYHRvTm9kZWAgYW5kIGB0b01hcmt1cGAgZnVuY3Rpb25zIHdvcmsgc2ltaWxhcmx5IHRvIGhvdyB0aGV5IGRvIGluXG4gKiBkb21UcmVlLmpzLCBjcmVhdGluZyBuYW1lc3BhY2VkIERPTSBub2RlcyBhbmQgSFRNTCB0ZXh0IG1hcmt1cCByZXNwZWN0aXZlbHkuXG4gKi9cbmZ1bmN0aW9uIG5ld0RvY3VtZW50RnJhZ21lbnQoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIG5ldyBEb2N1bWVudEZyYWdtZW50KGNoaWxkcmVuKTtcbn1cbi8qKlxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYSBnZW5lcmFsIHB1cnBvc2UgTWF0aE1MIG5vZGUgb2YgYW55IHR5cGUuIFRoZVxuICogY29uc3RydWN0b3IgcmVxdWlyZXMgdGhlIHR5cGUgb2Ygbm9kZSB0byBjcmVhdGUgKGZvciBleGFtcGxlLCBgXCJtb1wiYCBvclxuICogYFwibXNwYWNlXCJgLCBjb3JyZXNwb25kaW5nIHRvIGA8bW8+YCBhbmQgYDxtc3BhY2U+YCB0YWdzKS5cbiAqL1xuXG5jbGFzcyBNYXRoTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGNoaWxkcmVuLCBjbGFzc2VzKSB7XG4gICAgdGhpcy50eXBlID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmNoaWxkcmVuID0gdm9pZCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzIHx8IFtdO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSBvbiBhIE1hdGhNTCBub2RlLiBNYXRoTUwgZGVwZW5kcyBvbiBhdHRyaWJ1dGVzIHRvIGNvbnZleSBhXG4gICAqIHNlbWFudGljIGNvbnRlbnQsIHNvIHRoaXMgaXMgdXNlZCBoZWF2aWx5LlxuICAgKi9cblxuXG4gIHNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGFuIGF0dHJpYnV0ZSBvbiBhIE1hdGhNTCBub2RlLlxuICAgKi9cblxuXG4gIGdldEF0dHJpYnV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGEgTWF0aE1MLW5hbWVzcGFjZWQgRE9NIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgdG9Ob2RlKCkge1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLCB0aGlzLnR5cGUpO1xuXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgbm9kZS5jbGFzc05hbWUgPSBjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gQ29tYmluZSBtdWx0aXBsZSBUZXh0Tm9kZXMgaW50byBvbmUgVGV4dE5vZGUsIHRvIHByZXZlbnRcbiAgICAgIC8vIHNjcmVlbiByZWFkZXJzIGZyb20gcmVhZGluZyBlYWNoIGFzIGEgc2VwYXJhdGUgd29yZCBbIzM5OTVdXG4gICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSBpbnN0YW5jZW9mIFRleHROb2RlICYmIHRoaXMuY2hpbGRyZW5baSArIDFdIGluc3RhbmNlb2YgVGV4dE5vZGUpIHtcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmNoaWxkcmVuW2ldLnRvVGV4dCgpICsgdGhpcy5jaGlsZHJlblsrK2ldLnRvVGV4dCgpO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLmNoaWxkcmVuW2kgKyAxXSBpbnN0YW5jZW9mIFRleHROb2RlKSB7XG4gICAgICAgICAgdGV4dCArPSB0aGlzLmNoaWxkcmVuWysraV0udG9UZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLmFwcGVuZENoaWxkKG5ldyBUZXh0Tm9kZSh0ZXh0KS50b05vZGUoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYW4gSFRNTCBtYXJrdXAgc3RyaW5nLlxuICAgKi9cblxuXG4gIHRvTWFya3VwKCkge1xuICAgIHZhciBtYXJrdXAgPSBcIjxcIiArIHRoaXMudHlwZTsgLy8gQWRkIHRoZSBhdHRyaWJ1dGVzXG5cbiAgICBmb3IgKHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG1hcmt1cCArPSBcIiBcIiArIGF0dHIgKyBcIj1cXFwiXCI7XG4gICAgICAgIG1hcmt1cCArPSB1dGlscy5lc2NhcGUodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgICAgbWFya3VwICs9IFwiXFxcIlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgbWFya3VwICs9IFwiIGNsYXNzID1cXFwiXCIgKyB1dGlscy5lc2NhcGUoY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSkgKyBcIlxcXCJcIjtcbiAgICB9XG5cbiAgICBtYXJrdXAgKz0gXCI+XCI7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hcmt1cCArPSB0aGlzLmNoaWxkcmVuW2ldLnRvTWFya3VwKCk7XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiPC9cIiArIHRoaXMudHlwZSArIFwiPlwiO1xuICAgIHJldHVybiBtYXJrdXA7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIHN0cmluZywgc2ltaWxhciB0byBpbm5lclRleHQsIGJ1dCBlc2NhcGVkLlxuICAgKi9cblxuXG4gIHRvVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQudG9UZXh0KCkpLmpvaW4oXCJcIik7XG4gIH1cblxufVxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIHBpZWNlIG9mIHRleHQuXG4gKi9cblxuY2xhc3MgVGV4dE5vZGUge1xuICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgdGhpcy50ZXh0ID0gdm9pZCAwO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSB0ZXh0IG5vZGUgaW50byBhIERPTSB0ZXh0IG5vZGUuXG4gICAqL1xuXG5cbiAgdG9Ob2RlKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgdGV4dCBub2RlIGludG8gZXNjYXBlZCBIVE1MIG1hcmt1cFxuICAgKiAocmVwcmVzZW50aW5nIHRoZSB0ZXh0IGl0c2VsZikuXG4gICAqL1xuXG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVzY2FwZSh0aGlzLnRvVGV4dCgpKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHRleHQgbm9kZSBpbnRvIGEgc3RyaW5nXG4gICAqIChyZXByZXNlbnRpbmcgdGhlIHRleHQgaXRzZWxmKS5cbiAgICovXG5cblxuICB0b1RleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgfVxuXG59XG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgc3BhY2UsIGJ1dCBtYXkgcmVuZGVyIGFzIDxtc3BhY2UuLi4vPiBvciBhcyB0ZXh0LFxuICogZGVwZW5kaW5nIG9uIHRoZSB3aWR0aC5cbiAqL1xuXG5jbGFzcyBTcGFjZU5vZGUge1xuICAvKipcbiAgICogQ3JlYXRlIGEgU3BhY2Ugbm9kZSB3aXRoIHdpZHRoIGdpdmVuIGluIENTUyBlbXMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3aWR0aCkge1xuICAgIHRoaXMud2lkdGggPSB2b2lkIDA7XG4gICAgdGhpcy5jaGFyYWN0ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoOyAvLyBTZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDAvV0QtTWF0aE1MMi0yMDAwMDMyOC9jaGFwdGVyNi5odG1sXG4gICAgLy8gZm9yIGEgdGFibGUgb2Ygc3BhY2UtbGlrZSBjaGFyYWN0ZXJzLiAgV2UgdXNlIFVuaWNvZGVcbiAgICAvLyByZXByZXNlbnRhdGlvbnMgaW5zdGVhZCBvZiAmTG9uZ05hbWVzOyBhcyBpdCdzIG5vdCBjbGVhciBob3cgdG9cbiAgICAvLyBtYWtlIHRoZSBsYXR0ZXIgdmlhIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlLlxuXG4gICAgaWYgKHdpZHRoID49IDAuMDU1NTUgJiYgd2lkdGggPD0gMC4wNTU1Nikge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBcIlxcdTIwMGFcIjsgLy8gJlZlcnlUaGluU3BhY2U7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+PSAwLjE2NjYgJiYgd2lkdGggPD0gMC4xNjY3KSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IFwiXFx1MjAwOVwiOyAvLyAmVGhpblNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gMC4yMjIyICYmIHdpZHRoIDw9IDAuMjIyMykge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBcIlxcdTIwMDVcIjsgLy8gJk1lZGl1bVNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gMC4yNzc3ICYmIHdpZHRoIDw9IDAuMjc3OCkge1xuICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBcIlxcdTIwMDVcXHUyMDBhXCI7IC8vICZUaGlja1NwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gLTAuMDU1NTYgJiYgd2lkdGggPD0gLTAuMDU1NTUpIHtcbiAgICAgIHRoaXMuY2hhcmFjdGVyID0gXCJcXHUyMDBhXFx1MjA2M1wiOyAvLyAmTmVnYXRpdmVWZXJ5VGhpblNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gLTAuMTY2NyAmJiB3aWR0aCA8PSAtMC4xNjY2KSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IFwiXFx1MjAwOVxcdTIwNjNcIjsgLy8gJk5lZ2F0aXZlVGhpblNwYWNlO1xuICAgIH0gZWxzZSBpZiAod2lkdGggPj0gLTAuMjIyMyAmJiB3aWR0aCA8PSAtMC4yMjIyKSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IFwiXFx1MjA1ZlxcdTIwNjNcIjsgLy8gJk5lZ2F0aXZlTWVkaXVtU3BhY2U7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+PSAtMC4yNzc4ICYmIHdpZHRoIDw9IC0wLjI3NzcpIHtcbiAgICAgIHRoaXMuY2hhcmFjdGVyID0gXCJcXHUyMDA1XFx1MjA2M1wiOyAvLyAmTmVnYXRpdmVUaGlja1NwYWNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoYXJhY3RlciA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBNYXRoTUwtbmFtZXNwYWNlZCBET00gZWxlbWVudC5cbiAgICovXG5cblxuICB0b05vZGUoKSB7XG4gICAgaWYgKHRoaXMuY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5jaGFyYWN0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIiwgXCJtc3BhY2VcIik7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIG1ha2VFbSh0aGlzLndpZHRoKSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmcuXG4gICAqL1xuXG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgaWYgKHRoaXMuY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gXCI8bXRleHQ+XCIgKyB0aGlzLmNoYXJhY3RlciArIFwiPC9tdGV4dD5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiPG1zcGFjZSB3aWR0aD1cXFwiXCIgKyBtYWtlRW0odGhpcy53aWR0aCkgKyBcIlxcXCIvPlwiO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGEgc3RyaW5nLCBzaW1pbGFyIHRvIGlubmVyVGV4dC5cbiAgICovXG5cblxuICB0b1RleHQoKSB7XG4gICAgaWYgKHRoaXMuY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFyYWN0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIiBcIjtcbiAgICB9XG4gIH1cblxufVxuXG52YXIgbWF0aE1MVHJlZSA9IHtcbiAgTWF0aE5vZGUsXG4gIFRleHROb2RlLFxuICBTcGFjZU5vZGUsXG4gIG5ld0RvY3VtZW50RnJhZ21lbnRcbn07XG5cbi8qKlxuICogVGhpcyBmaWxlIGNvbnZlcnRzIGEgcGFyc2UgdHJlZSBpbnRvIGEgY29ycmVzcG9uZGluZyBNYXRoTUwgdHJlZS4gVGhlIG1haW5cbiAqIGVudHJ5IHBvaW50IGlzIHRoZSBgYnVpbGRNYXRoTUxgIGZ1bmN0aW9uLCB3aGljaCB0YWtlcyBhIHBhcnNlIHRyZWUgZnJvbSB0aGVcbiAqIHBhcnNlci5cbiAqL1xuXG4vKipcbiAqIFRha2VzIGEgc3ltYm9sIGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgTWF0aE1MIHRleHQgbm9kZSBhZnRlciBwZXJmb3JtaW5nXG4gKiBvcHRpb25hbCByZXBsYWNlbWVudCBmcm9tIHN5bWJvbHMuanMuXG4gKi9cbnZhciBtYWtlVGV4dCA9IGZ1bmN0aW9uIG1ha2VUZXh0KHRleHQsIG1vZGUsIG9wdGlvbnMpIHtcbiAgaWYgKHN5bWJvbHNbbW9kZV1bdGV4dF0gJiYgc3ltYm9sc1ttb2RlXVt0ZXh0XS5yZXBsYWNlICYmIHRleHQuY2hhckNvZGVBdCgwKSAhPT0gMHhEODM1ICYmICEobGlnYXR1cmVzLmhhc093blByb3BlcnR5KHRleHQpICYmIG9wdGlvbnMgJiYgKG9wdGlvbnMuZm9udEZhbWlseSAmJiBvcHRpb25zLmZvbnRGYW1pbHkuc2xpY2UoNCwgNikgPT09IFwidHRcIiB8fCBvcHRpb25zLmZvbnQgJiYgb3B0aW9ucy5mb250LnNsaWNlKDQsIDYpID09PSBcInR0XCIpKSkge1xuICAgIHRleHQgPSBzeW1ib2xzW21vZGVdW3RleHRdLnJlcGxhY2U7XG4gIH1cblxuICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUodGV4dCk7XG59O1xuLyoqXG4gKiBXcmFwIHRoZSBnaXZlbiBhcnJheSBvZiBub2RlcyBpbiBhbiA8bXJvdz4gbm9kZSBpZiBuZWVkZWQsIGkuZS4sXG4gKiB1bmxlc3MgdGhlIGFycmF5IGhhcyBsZW5ndGggMS4gIEFsd2F5cyByZXR1cm5zIGEgc2luZ2xlIG5vZGUuXG4gKi9cblxudmFyIG1ha2VSb3cgPSBmdW5jdGlvbiBtYWtlUm93KGJvZHkpIHtcbiAgaWYgKGJvZHkubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGJvZHlbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBib2R5KTtcbiAgfVxufTtcbi8qKlxuICogUmV0dXJucyB0aGUgbWF0aCB2YXJpYW50IGFzIGEgc3RyaW5nIG9yIG51bGwgaWYgbm9uZSBpcyByZXF1aXJlZC5cbiAqL1xuXG52YXIgZ2V0VmFyaWFudCA9IGZ1bmN0aW9uIGdldFZhcmlhbnQoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgLy8gSGFuZGxlIFxcdGV4dC4uLiBmb250IHNwZWNpZmllcnMgYXMgYmVzdCB3ZSBjYW4uXG4gIC8vIE1hdGhNTCBoYXMgYSBsaW1pdGVkIGxpc3Qgb2YgYWxsb3dhYmxlIG1hdGh2YXJpYW50IHNwZWNpZmllcnM7IHNlZVxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvTWF0aE1MMy9jaGFwdGVyMy5odG1sI3ByZXNtLmNvbW1hdHRcbiAgaWYgKG9wdGlvbnMuZm9udEZhbWlseSA9PT0gXCJ0ZXh0dHRcIikge1xuICAgIHJldHVybiBcIm1vbm9zcGFjZVwiO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udEZhbWlseSA9PT0gXCJ0ZXh0c2ZcIikge1xuICAgIGlmIChvcHRpb25zLmZvbnRTaGFwZSA9PT0gXCJ0ZXh0aXRcIiAmJiBvcHRpb25zLmZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIpIHtcbiAgICAgIHJldHVybiBcInNhbnMtc2VyaWYtYm9sZC1pdGFsaWNcIjtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udFNoYXBlID09PSBcInRleHRpdFwiKSB7XG4gICAgICByZXR1cm4gXCJzYW5zLXNlcmlmLWl0YWxpY1wiO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5mb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgICByZXR1cm4gXCJib2xkLXNhbnMtc2VyaWZcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwic2Fucy1zZXJpZlwiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcHRpb25zLmZvbnRTaGFwZSA9PT0gXCJ0ZXh0aXRcIiAmJiBvcHRpb25zLmZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIpIHtcbiAgICByZXR1cm4gXCJib2xkLWl0YWxpY1wiO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udFNoYXBlID09PSBcInRleHRpdFwiKSB7XG4gICAgcmV0dXJuIFwiaXRhbGljXCI7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5mb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgcmV0dXJuIFwiYm9sZFwiO1xuICB9XG5cbiAgdmFyIGZvbnQgPSBvcHRpb25zLmZvbnQ7XG5cbiAgaWYgKCFmb250IHx8IGZvbnQgPT09IFwibWF0aG5vcm1hbFwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbW9kZSA9IGdyb3VwLm1vZGU7XG5cbiAgaWYgKGZvbnQgPT09IFwibWF0aGl0XCIpIHtcbiAgICByZXR1cm4gXCJpdGFsaWNcIjtcbiAgfSBlbHNlIGlmIChmb250ID09PSBcImJvbGRzeW1ib2xcIikge1xuICAgIHJldHVybiBncm91cC50eXBlID09PSBcInRleHRvcmRcIiA/IFwiYm9sZFwiIDogXCJib2xkLWl0YWxpY1wiO1xuICB9IGVsc2UgaWYgKGZvbnQgPT09IFwibWF0aGJmXCIpIHtcbiAgICByZXR1cm4gXCJib2xkXCI7XG4gIH0gZWxzZSBpZiAoZm9udCA9PT0gXCJtYXRoYmJcIikge1xuICAgIHJldHVybiBcImRvdWJsZS1zdHJ1Y2tcIjtcbiAgfSBlbHNlIGlmIChmb250ID09PSBcIm1hdGhzZml0XCIpIHtcbiAgICByZXR1cm4gXCJzYW5zLXNlcmlmLWl0YWxpY1wiO1xuICB9IGVsc2UgaWYgKGZvbnQgPT09IFwibWF0aGZyYWtcIikge1xuICAgIHJldHVybiBcImZyYWt0dXJcIjtcbiAgfSBlbHNlIGlmIChmb250ID09PSBcIm1hdGhzY3JcIiB8fCBmb250ID09PSBcIm1hdGhjYWxcIikge1xuICAgIC8vIE1hdGhNTCBtYWtlcyBubyBkaXN0aW5jdGlvbiBiZXR3ZWVuIHNjcmlwdCBhbmQgY2FsbGlncmFwaGljXG4gICAgcmV0dXJuIFwic2NyaXB0XCI7XG4gIH0gZWxzZSBpZiAoZm9udCA9PT0gXCJtYXRoc2ZcIikge1xuICAgIHJldHVybiBcInNhbnMtc2VyaWZcIjtcbiAgfSBlbHNlIGlmIChmb250ID09PSBcIm1hdGh0dFwiKSB7XG4gICAgcmV0dXJuIFwibW9ub3NwYWNlXCI7XG4gIH1cblxuICB2YXIgdGV4dCA9IGdyb3VwLnRleHQ7XG5cbiAgaWYgKFtcIlxcXFxpbWF0aFwiLCBcIlxcXFxqbWF0aFwiXS5pbmNsdWRlcyh0ZXh0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHN5bWJvbHNbbW9kZV1bdGV4dF0gJiYgc3ltYm9sc1ttb2RlXVt0ZXh0XS5yZXBsYWNlKSB7XG4gICAgdGV4dCA9IHN5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZTtcbiAgfVxuXG4gIHZhciBmb250TmFtZSA9IGJ1aWxkQ29tbW9uLmZvbnRNYXBbZm9udF0uZm9udE5hbWU7XG5cbiAgaWYgKGdldENoYXJhY3Rlck1ldHJpY3ModGV4dCwgZm9udE5hbWUsIG1vZGUpKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLmZvbnRNYXBbZm9udF0udmFyaWFudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcbi8qKlxuICogQ2hlY2sgZm9yIDxtaT4uPC9taT4gd2hpY2ggaXMgaG93IGEgZG90IHJlbmRlcnMgaW4gTWF0aE1MLFxuICogb3IgPG1vIHNlcGFyYXRvcj1cInRydWVcIiBsc3BhY2U9XCIwZW1cIiByc3BhY2U9XCIwZW1cIj4sPC9tbz5cbiAqIHdoaWNoIGlzIGhvdyBhIGJyYWNlZCBjb21tYSB7LH0gcmVuZGVycyBpbiBNYXRoTUxcbiAqL1xuXG5mdW5jdGlvbiBpc051bWJlclB1bmN0dWF0aW9uKGdyb3VwKSB7XG4gIGlmICghZ3JvdXApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZ3JvdXAudHlwZSA9PT0gJ21pJyAmJiBncm91cC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgY2hpbGQgPSBncm91cC5jaGlsZHJlblswXTtcbiAgICByZXR1cm4gY2hpbGQgaW5zdGFuY2VvZiBUZXh0Tm9kZSAmJiBjaGlsZC50ZXh0ID09PSAnLic7XG4gIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gJ21vJyAmJiBncm91cC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgZ3JvdXAuZ2V0QXR0cmlidXRlKCdzZXBhcmF0b3InKSA9PT0gJ3RydWUnICYmIGdyb3VwLmdldEF0dHJpYnV0ZSgnbHNwYWNlJykgPT09ICcwZW0nICYmIGdyb3VwLmdldEF0dHJpYnV0ZSgncnNwYWNlJykgPT09ICcwZW0nKSB7XG4gICAgdmFyIF9jaGlsZCA9IGdyb3VwLmNoaWxkcmVuWzBdO1xuICAgIHJldHVybiBfY2hpbGQgaW5zdGFuY2VvZiBUZXh0Tm9kZSAmJiBfY2hpbGQudGV4dCA9PT0gJywnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuLyoqXG4gKiBUYWtlcyBhIGxpc3Qgb2Ygbm9kZXMsIGJ1aWxkcyB0aGVtLCBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgdGhlIGdlbmVyYXRlZFxuICogTWF0aE1MIG5vZGVzLiAgQWxzbyBjb21iaW5lIGNvbnNlY3V0aXZlIDxtdGV4dD4gb3V0cHV0cyBpbnRvIGEgc2luZ2xlXG4gKiA8bXRleHQ+IHRhZy5cbiAqL1xuXG5cbnZhciBidWlsZEV4cHJlc3Npb24gPSBmdW5jdGlvbiBidWlsZEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgb3B0aW9ucywgaXNPcmRncm91cCkge1xuICBpZiAoZXhwcmVzc2lvbi5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ3JvdXAgPSBidWlsZEdyb3VwKGV4cHJlc3Npb25bMF0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKGlzT3JkZ3JvdXAgJiYgZ3JvdXAgaW5zdGFuY2VvZiBNYXRoTm9kZSAmJiBncm91cC50eXBlID09PSBcIm1vXCIpIHtcbiAgICAgIC8vIFdoZW4gVGVYIHdyaXRlcnMgd2FudCB0byBzdXBwcmVzcyBzcGFjaW5nIG9uIGFuIG9wZXJhdG9yLFxuICAgICAgLy8gdGhleSBvZnRlbiBwdXQgdGhlIG9wZXJhdG9yIGJ5IGl0c2VsZiBpbnNpZGUgYnJhY2VzLlxuICAgICAgZ3JvdXAuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIFwiMGVtXCIpO1xuICAgICAgZ3JvdXAuc2V0QXR0cmlidXRlKFwicnNwYWNlXCIsIFwiMGVtXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBbZ3JvdXBdO1xuICB9XG5cbiAgdmFyIGdyb3VwcyA9IFtdO1xuICB2YXIgbGFzdEdyb3VwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfZ3JvdXAgPSBidWlsZEdyb3VwKGV4cHJlc3Npb25baV0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKF9ncm91cCBpbnN0YW5jZW9mIE1hdGhOb2RlICYmIGxhc3RHcm91cCBpbnN0YW5jZW9mIE1hdGhOb2RlKSB7XG4gICAgICAvLyBDb25jYXRlbmF0ZSBhZGphY2VudCA8bXRleHQ+c1xuICAgICAgaWYgKF9ncm91cC50eXBlID09PSAnbXRleHQnICYmIGxhc3RHcm91cC50eXBlID09PSAnbXRleHQnICYmIF9ncm91cC5nZXRBdHRyaWJ1dGUoJ21hdGh2YXJpYW50JykgPT09IGxhc3RHcm91cC5nZXRBdHRyaWJ1dGUoJ21hdGh2YXJpYW50JykpIHtcbiAgICAgICAgbGFzdEdyb3VwLmNoaWxkcmVuLnB1c2goLi4uX2dyb3VwLmNoaWxkcmVuKTtcbiAgICAgICAgY29udGludWU7IC8vIENvbmNhdGVuYXRlIGFkamFjZW50IDxtbj5zXG4gICAgICB9IGVsc2UgaWYgKF9ncm91cC50eXBlID09PSAnbW4nICYmIGxhc3RHcm91cC50eXBlID09PSAnbW4nKSB7XG4gICAgICAgIGxhc3RHcm91cC5jaGlsZHJlbi5wdXNoKC4uLl9ncm91cC5jaGlsZHJlbik7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBDb25jYXRlbmF0ZSA8bW4+Li4uPC9tbj4gZm9sbG93ZWQgYnkgPG1pPi48L21pPlxuICAgICAgfSBlbHNlIGlmIChpc051bWJlclB1bmN0dWF0aW9uKF9ncm91cCkgJiYgbGFzdEdyb3VwLnR5cGUgPT09ICdtbicpIHtcbiAgICAgICAgbGFzdEdyb3VwLmNoaWxkcmVuLnB1c2goLi4uX2dyb3VwLmNoaWxkcmVuKTtcbiAgICAgICAgY29udGludWU7IC8vIENvbmNhdGVuYXRlIDxtaT4uPC9taT4gZm9sbG93ZWQgYnkgPG1uPi4uLjwvbW4+XG4gICAgICB9IGVsc2UgaWYgKF9ncm91cC50eXBlID09PSAnbW4nICYmIGlzTnVtYmVyUHVuY3R1YXRpb24obGFzdEdyb3VwKSkge1xuICAgICAgICBfZ3JvdXAuY2hpbGRyZW4gPSBbLi4ubGFzdEdyb3VwLmNoaWxkcmVuLCAuLi5fZ3JvdXAuY2hpbGRyZW5dO1xuICAgICAgICBncm91cHMucG9wKCk7IC8vIFB1dCBwcmVjZWRpbmcgPG1uPi4uLjwvbW4+IG9yIDxtaT4uPC9taT4gaW5zaWRlIGJhc2Ugb2ZcbiAgICAgICAgLy8gPG1zdXA+PG1uPi4uLmJhc2UuLi48L21uPi4uLmV4cG9uZW50Li4uPC9tc3VwPiAob3IgPG1zdWI+KVxuICAgICAgfSBlbHNlIGlmICgoX2dyb3VwLnR5cGUgPT09ICdtc3VwJyB8fCBfZ3JvdXAudHlwZSA9PT0gJ21zdWInKSAmJiBfZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoID49IDEgJiYgKGxhc3RHcm91cC50eXBlID09PSAnbW4nIHx8IGlzTnVtYmVyUHVuY3R1YXRpb24obGFzdEdyb3VwKSkpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBfZ3JvdXAuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgaWYgKGJhc2UgaW5zdGFuY2VvZiBNYXRoTm9kZSAmJiBiYXNlLnR5cGUgPT09ICdtbicpIHtcbiAgICAgICAgICBiYXNlLmNoaWxkcmVuID0gWy4uLmxhc3RHcm91cC5jaGlsZHJlbiwgLi4uYmFzZS5jaGlsZHJlbl07XG4gICAgICAgICAgZ3JvdXBzLnBvcCgpO1xuICAgICAgICB9IC8vIFxcbm90XG5cbiAgICAgIH0gZWxzZSBpZiAobGFzdEdyb3VwLnR5cGUgPT09ICdtaScgJiYgbGFzdEdyb3VwLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgbGFzdENoaWxkID0gbGFzdEdyb3VwLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgIGlmIChsYXN0Q2hpbGQgaW5zdGFuY2VvZiBUZXh0Tm9kZSAmJiBsYXN0Q2hpbGQudGV4dCA9PT0gJ1xcdTAzMzgnICYmIChfZ3JvdXAudHlwZSA9PT0gJ21vJyB8fCBfZ3JvdXAudHlwZSA9PT0gJ21pJyB8fCBfZ3JvdXAudHlwZSA9PT0gJ21uJykpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBfZ3JvdXAuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUZXh0Tm9kZSAmJiBjaGlsZC50ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIE92ZXJsYXkgd2l0aCBjb21iaW5pbmcgY2hhcmFjdGVyIGxvbmcgc29saWR1c1xuICAgICAgICAgICAgY2hpbGQudGV4dCA9IGNoaWxkLnRleHQuc2xpY2UoMCwgMSkgKyBcIlxcdTAzMzhcIiArIGNoaWxkLnRleHQuc2xpY2UoMSk7XG4gICAgICAgICAgICBncm91cHMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ3JvdXBzLnB1c2goX2dyb3VwKTtcbiAgICBsYXN0R3JvdXAgPSBfZ3JvdXA7XG4gIH1cblxuICByZXR1cm4gZ3JvdXBzO1xufTtcbi8qKlxuICogRXF1aXZhbGVudCB0byBidWlsZEV4cHJlc3Npb24sIGJ1dCB3cmFwcyB0aGUgZWxlbWVudHMgaW4gYW4gPG1yb3c+XG4gKiBpZiB0aGVyZSdzIG1vcmUgdGhhbiBvbmUuICBSZXR1cm5zIGEgc2luZ2xlIG5vZGUgaW5zdGVhZCBvZiBhbiBhcnJheS5cbiAqL1xuXG52YXIgYnVpbGRFeHByZXNzaW9uUm93ID0gZnVuY3Rpb24gYnVpbGRFeHByZXNzaW9uUm93KGV4cHJlc3Npb24sIG9wdGlvbnMsIGlzT3JkZ3JvdXApIHtcbiAgcmV0dXJuIG1ha2VSb3coYnVpbGRFeHByZXNzaW9uKGV4cHJlc3Npb24sIG9wdGlvbnMsIGlzT3JkZ3JvdXApKTtcbn07XG4vKipcbiAqIFRha2VzIGEgZ3JvdXAgZnJvbSB0aGUgcGFyc2VyIGFuZCBjYWxscyB0aGUgYXBwcm9wcmlhdGUgZ3JvdXBCdWlsZGVycyBmdW5jdGlvblxuICogb24gaXQgdG8gcHJvZHVjZSBhIE1hdGhNTCBub2RlLlxuICovXG5cbnZhciBidWlsZEdyb3VwID0gZnVuY3Rpb24gYnVpbGRHcm91cChncm91cCwgb3B0aW9ucykge1xuICBpZiAoIWdyb3VwKSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcbiAgfVxuXG4gIGlmIChfbWF0aG1sR3JvdXBCdWlsZGVyc1tncm91cC50eXBlXSkge1xuICAgIC8vIENhbGwgdGhlIGdyb3VwQnVpbGRlcnMgZnVuY3Rpb25cbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgdmFyIHJlc3VsdCA9IF9tYXRobWxHcm91cEJ1aWxkZXJzW2dyb3VwLnR5cGVdKGdyb3VwLCBvcHRpb25zKTsgLy8gJEZsb3dGaXhNZVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkdvdCBncm91cCBvZiB1bmtub3duIHR5cGU6ICdcIiArIGdyb3VwLnR5cGUgKyBcIidcIik7XG4gIH1cbn07XG4vKipcbiAqIFRha2VzIGEgZnVsbCBwYXJzZSB0cmVlIGFuZCBzZXR0aW5ncyBhbmQgYnVpbGRzIGEgTWF0aE1MIHJlcHJlc2VudGF0aW9uIG9mXG4gKiBpdC4gSW4gcGFydGljdWxhciwgd2UgcHV0IHRoZSBlbGVtZW50cyBmcm9tIGJ1aWxkaW5nIHRoZSBwYXJzZSB0cmVlIGludG8gYVxuICogPHNlbWFudGljcz4gdGFnIHNvIHdlIGNhbiBhbHNvIGluY2x1ZGUgdGhhdCBUZVggc291cmNlIGFzIGFuIGFubm90YXRpb24uXG4gKlxuICogTm90ZSB0aGF0IHdlIGFjdHVhbGx5IHJldHVybiBhIGRvbVRyZWUgZWxlbWVudCB3aXRoIGEgYDxtYXRoPmAgaW5zaWRlIGl0IHNvXG4gKiB3ZSBjYW4gZG8gYXBwcm9wcmlhdGUgc3R5bGluZy5cbiAqL1xuXG5mdW5jdGlvbiBidWlsZE1hdGhNTCh0cmVlLCB0ZXhFeHByZXNzaW9uLCBvcHRpb25zLCBpc0Rpc3BsYXlNb2RlLCBmb3JNYXRobWxPbmx5KSB7XG4gIHZhciBleHByZXNzaW9uID0gYnVpbGRFeHByZXNzaW9uKHRyZWUsIG9wdGlvbnMpOyAvLyBUT0RPOiBNYWtlIGEgcGFzcyB0aHJ1IHRoZSBNYXRoTUwgc2ltaWxhciB0byBidWlsZEhUTUwudHJhdmVyc2VOb25TcGFjZU5vZGVzXG4gIC8vIGFuZCBhZGQgc3BhY2luZyBub2Rlcy4gVGhpcyBpcyBuZWNlc3Nhcnkgb25seSBhZGphY2VudCB0byBtYXRoIG9wZXJhdG9yc1xuICAvLyBsaWtlIFxcc2luIG9yIFxcbGltIG9yIHRvIHN1YnN1cCBlbGVtZW50cyB0aGF0IGNvbnRhaW4gbWF0aCBvcGVyYXRvcnMuXG4gIC8vIE1hdGhNTCB0YWtlcyBjYXJlIG9mIHRoZSBvdGhlciBzcGFjaW5nIGlzc3Vlcy5cbiAgLy8gV3JhcCB1cCB0aGUgZXhwcmVzc2lvbiBpbiBhbiBtcm93IHNvIGl0IGlzIHByZXNlbnRlZCBpbiB0aGUgc2VtYW50aWNzXG4gIC8vIHRhZyBjb3JyZWN0bHksIHVubGVzcyBpdCdzIGEgc2luZ2xlIDxtcm93PiBvciA8bXRhYmxlPi5cblxuICB2YXIgd3JhcHBlcjtcblxuICBpZiAoZXhwcmVzc2lvbi5sZW5ndGggPT09IDEgJiYgZXhwcmVzc2lvblswXSBpbnN0YW5jZW9mIE1hdGhOb2RlICYmIFtcIm1yb3dcIiwgXCJtdGFibGVcIl0uaW5jbHVkZXMoZXhwcmVzc2lvblswXS50eXBlKSkge1xuICAgIHdyYXBwZXIgPSBleHByZXNzaW9uWzBdO1xuICB9IGVsc2Uge1xuICAgIHdyYXBwZXIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgZXhwcmVzc2lvbik7XG4gIH0gLy8gQnVpbGQgYSBUZVggYW5ub3RhdGlvbiBvZiB0aGUgc291cmNlXG5cblxuICB2YXIgYW5ub3RhdGlvbiA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwiYW5ub3RhdGlvblwiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUodGV4RXhwcmVzc2lvbildKTtcbiAgYW5ub3RhdGlvbi5zZXRBdHRyaWJ1dGUoXCJlbmNvZGluZ1wiLCBcImFwcGxpY2F0aW9uL3gtdGV4XCIpO1xuICB2YXIgc2VtYW50aWNzID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJzZW1hbnRpY3NcIiwgW3dyYXBwZXIsIGFubm90YXRpb25dKTtcbiAgdmFyIG1hdGggPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1hdGhcIiwgW3NlbWFudGljc10pO1xuICBtYXRoLnNldEF0dHJpYnV0ZShcInhtbG5zXCIsIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiKTtcblxuICBpZiAoaXNEaXNwbGF5TW9kZSkge1xuICAgIG1hdGguc2V0QXR0cmlidXRlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICB9IC8vIFlvdSBjYW4ndCBzdHlsZSA8bWF0aD4gbm9kZXMsIHNvIHdlIHdyYXAgdGhlIG5vZGUgaW4gYSBzcGFuLlxuICAvLyBOT1RFOiBUaGUgc3BhbiBjbGFzcyBpcyBub3QgdHlwZWQgdG8gaGF2ZSA8bWF0aD4gbm9kZXMgYXMgY2hpbGRyZW4sIGFuZFxuICAvLyB3ZSBkb24ndCB3YW50IHRvIG1ha2UgdGhlIGNoaWxkcmVuIHR5cGUgbW9yZSBnZW5lcmljIHNpbmNlIHRoZSBjaGlsZHJlblxuICAvLyBvZiBzcGFuIGFyZSBleHBlY3RlZCB0byBoYXZlIG1vcmUgZmllbGRzIGluIGBidWlsZEh0bWxgIGNvbnRleHRzLlxuXG5cbiAgdmFyIHdyYXBwZXJDbGFzcyA9IGZvck1hdGhtbE9ubHkgPyBcImthdGV4XCIgOiBcImthdGV4LW1hdGhtbFwiOyAvLyAkRmxvd0ZpeE1lXG5cbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFt3cmFwcGVyQ2xhc3NdLCBbbWF0aF0pO1xufVxuXG52YXIgb3B0aW9uc0Zyb21TZXR0aW5ncyA9IGZ1bmN0aW9uIG9wdGlvbnNGcm9tU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgcmV0dXJuIG5ldyBPcHRpb25zKHtcbiAgICBzdHlsZTogc2V0dGluZ3MuZGlzcGxheU1vZGUgPyBTdHlsZSQxLkRJU1BMQVkgOiBTdHlsZSQxLlRFWFQsXG4gICAgbWF4U2l6ZTogc2V0dGluZ3MubWF4U2l6ZSxcbiAgICBtaW5SdWxlVGhpY2tuZXNzOiBzZXR0aW5ncy5taW5SdWxlVGhpY2tuZXNzXG4gIH0pO1xufTtcblxudmFyIGRpc3BsYXlXcmFwID0gZnVuY3Rpb24gZGlzcGxheVdyYXAobm9kZSwgc2V0dGluZ3MpIHtcbiAgaWYgKHNldHRpbmdzLmRpc3BsYXlNb2RlKSB7XG4gICAgdmFyIGNsYXNzZXMgPSBbXCJrYXRleC1kaXNwbGF5XCJdO1xuXG4gICAgaWYgKHNldHRpbmdzLmxlcW5vKSB7XG4gICAgICBjbGFzc2VzLnB1c2goXCJsZXFub1wiKTtcbiAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3MuZmxlcW4pIHtcbiAgICAgIGNsYXNzZXMucHVzaChcImZsZXFuXCIpO1xuICAgIH1cblxuICAgIG5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihjbGFzc2VzLCBbbm9kZV0pO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG52YXIgYnVpbGRUcmVlID0gZnVuY3Rpb24gYnVpbGRUcmVlKHRyZWUsIGV4cHJlc3Npb24sIHNldHRpbmdzKSB7XG4gIHZhciBvcHRpb25zID0gb3B0aW9uc0Zyb21TZXR0aW5ncyhzZXR0aW5ncyk7XG4gIHZhciBrYXRleE5vZGU7XG5cbiAgaWYgKHNldHRpbmdzLm91dHB1dCA9PT0gXCJtYXRobWxcIikge1xuICAgIHJldHVybiBidWlsZE1hdGhNTCh0cmVlLCBleHByZXNzaW9uLCBvcHRpb25zLCBzZXR0aW5ncy5kaXNwbGF5TW9kZSwgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAoc2V0dGluZ3Mub3V0cHV0ID09PSBcImh0bWxcIikge1xuICAgIHZhciBodG1sTm9kZSA9IGJ1aWxkSFRNTCh0cmVlLCBvcHRpb25zKTtcbiAgICBrYXRleE5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJrYXRleFwiXSwgW2h0bWxOb2RlXSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1hdGhNTE5vZGUgPSBidWlsZE1hdGhNTCh0cmVlLCBleHByZXNzaW9uLCBvcHRpb25zLCBzZXR0aW5ncy5kaXNwbGF5TW9kZSwgZmFsc2UpO1xuXG4gICAgdmFyIF9odG1sTm9kZSA9IGJ1aWxkSFRNTCh0cmVlLCBvcHRpb25zKTtcblxuICAgIGthdGV4Tm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImthdGV4XCJdLCBbbWF0aE1MTm9kZSwgX2h0bWxOb2RlXSk7XG4gIH1cblxuICByZXR1cm4gZGlzcGxheVdyYXAoa2F0ZXhOb2RlLCBzZXR0aW5ncyk7XG59O1xudmFyIGJ1aWxkSFRNTFRyZWUgPSBmdW5jdGlvbiBidWlsZEhUTUxUcmVlKHRyZWUsIGV4cHJlc3Npb24sIHNldHRpbmdzKSB7XG4gIHZhciBvcHRpb25zID0gb3B0aW9uc0Zyb21TZXR0aW5ncyhzZXR0aW5ncyk7XG4gIHZhciBodG1sTm9kZSA9IGJ1aWxkSFRNTCh0cmVlLCBvcHRpb25zKTtcbiAgdmFyIGthdGV4Tm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImthdGV4XCJdLCBbaHRtbE5vZGVdKTtcbiAgcmV0dXJuIGRpc3BsYXlXcmFwKGthdGV4Tm9kZSwgc2V0dGluZ3MpO1xufTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgcHJvdmlkZXMgc3VwcG9ydCB0byBidWlsZE1hdGhNTC5qcyBhbmQgYnVpbGRIVE1MLmpzXG4gKiBmb3Igc3RyZXRjaHkgd2lkZSBlbGVtZW50cyByZW5kZXJlZCBmcm9tIFNWRyBmaWxlc1xuICogYW5kIG90aGVyIENTUyB0cmlja2VyeS5cbiAqL1xudmFyIHN0cmV0Y2h5Q29kZVBvaW50ID0ge1xuICB3aWRlaGF0OiBcIl5cIixcbiAgd2lkZWNoZWNrOiBcIsuHXCIsXG4gIHdpZGV0aWxkZTogXCJ+XCIsXG4gIHV0aWxkZTogXCJ+XCIsXG4gIG92ZXJsZWZ0YXJyb3c6IFwiXFx1MjE5MFwiLFxuICB1bmRlcmxlZnRhcnJvdzogXCJcXHUyMTkwXCIsXG4gIHhsZWZ0YXJyb3c6IFwiXFx1MjE5MFwiLFxuICBvdmVycmlnaHRhcnJvdzogXCJcXHUyMTkyXCIsXG4gIHVuZGVycmlnaHRhcnJvdzogXCJcXHUyMTkyXCIsXG4gIHhyaWdodGFycm93OiBcIlxcdTIxOTJcIixcbiAgdW5kZXJicmFjZTogXCJcXHUyM2RmXCIsXG4gIG92ZXJicmFjZTogXCJcXHUyM2RlXCIsXG4gIG92ZXJncm91cDogXCJcXHUyM2UwXCIsXG4gIHVuZGVyZ3JvdXA6IFwiXFx1MjNlMVwiLFxuICBvdmVybGVmdHJpZ2h0YXJyb3c6IFwiXFx1MjE5NFwiLFxuICB1bmRlcmxlZnRyaWdodGFycm93OiBcIlxcdTIxOTRcIixcbiAgeGxlZnRyaWdodGFycm93OiBcIlxcdTIxOTRcIixcbiAgT3ZlcnJpZ2h0YXJyb3c6IFwiXFx1MjFkMlwiLFxuICB4UmlnaHRhcnJvdzogXCJcXHUyMWQyXCIsXG4gIG92ZXJsZWZ0aGFycG9vbjogXCJcXHUyMWJjXCIsXG4gIHhsZWZ0aGFycG9vbnVwOiBcIlxcdTIxYmNcIixcbiAgb3ZlcnJpZ2h0aGFycG9vbjogXCJcXHUyMWMwXCIsXG4gIHhyaWdodGhhcnBvb251cDogXCJcXHUyMWMwXCIsXG4gIHhMZWZ0YXJyb3c6IFwiXFx1MjFkMFwiLFxuICB4TGVmdHJpZ2h0YXJyb3c6IFwiXFx1MjFkNFwiLFxuICB4aG9va2xlZnRhcnJvdzogXCJcXHUyMWE5XCIsXG4gIHhob29rcmlnaHRhcnJvdzogXCJcXHUyMWFhXCIsXG4gIHhtYXBzdG86IFwiXFx1MjFhNlwiLFxuICB4cmlnaHRoYXJwb29uZG93bjogXCJcXHUyMWMxXCIsXG4gIHhsZWZ0aGFycG9vbmRvd246IFwiXFx1MjFiZFwiLFxuICB4cmlnaHRsZWZ0aGFycG9vbnM6IFwiXFx1MjFjY1wiLFxuICB4bGVmdHJpZ2h0aGFycG9vbnM6IFwiXFx1MjFjYlwiLFxuICB4dHdvaGVhZGxlZnRhcnJvdzogXCJcXHUyMTllXCIsXG4gIHh0d29oZWFkcmlnaHRhcnJvdzogXCJcXHUyMWEwXCIsXG4gIHhsb25nZXF1YWw6IFwiPVwiLFxuICB4dG9mcm9tOiBcIlxcdTIxYzRcIixcbiAgeHJpZ2h0bGVmdGFycm93czogXCJcXHUyMWM0XCIsXG4gIHhyaWdodGVxdWlsaWJyaXVtOiBcIlxcdTIxY2NcIixcbiAgLy8gTm90IGEgcGVyZmVjdCBtYXRjaC5cbiAgeGxlZnRlcXVpbGlicml1bTogXCJcXHUyMWNiXCIsXG4gIC8vIE5vbmUgYmV0dGVyIGF2YWlsYWJsZS5cbiAgXCJcXFxcY2RyaWdodGFycm93XCI6IFwiXFx1MjE5MlwiLFxuICBcIlxcXFxjZGxlZnRhcnJvd1wiOiBcIlxcdTIxOTBcIixcbiAgXCJcXFxcY2Rsb25nZXF1YWxcIjogXCI9XCJcbn07XG5cbnZhciBtYXRoTUxub2RlID0gZnVuY3Rpb24gbWF0aE1Mbm9kZShsYWJlbCkge1xuICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKHN0cmV0Y2h5Q29kZVBvaW50W2xhYmVsLnJlcGxhY2UoL15cXFxcLywgJycpXSldKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcInRydWVcIik7XG4gIHJldHVybiBub2RlO1xufTsgLy8gTWFueSBvZiB0aGUgS2FUZVggU1ZHIGltYWdlcyBoYXZlIGJlZW4gYWRhcHRlZCBmcm9tIGdseXBocyBpbiBLYVRlWCBmb250cy5cbi8vIENvcHlyaWdodCAoYykgMjAwOS0yMDEwLCBEZXNpZ24gU2NpZW5jZSwgSW5jLiAoPHd3dy5tYXRoamF4Lm9yZz4pXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNyBLaGFuIEFjYWRlbXkgKDx3d3cua2hhbmFjYWRlbXkub3JnPilcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBTSUwgT3BlbiBGb250IExpY2Vuc2UsIFZlcnNpb24gMS4xLlxuLy8gU2VlIFxcbmh0dHA6Ly9zY3JpcHRzLnNpbC5vcmcvT0ZMXG4vLyBWZXJ5IExvbmcgU1ZHc1xuLy8gICAgTWFueSBvZiB0aGUgS2FUZVggc3RyZXRjaHkgd2lkZSBlbGVtZW50cyB1c2UgYSBsb25nIFNWRyBpbWFnZSBhbmQgYW5cbi8vICAgIG92ZXJmbG93OiBoaWRkZW4gdGFjdGljIHRvIGFjaGlldmUgYSBzdHJldGNoeSBpbWFnZSB3aGlsZSBhdm9pZGluZ1xuLy8gICAgZGlzdG9ydGlvbiBvZiBhcnJvd2hlYWRzIG9yIGJyYWNlIGNvcm5lcnMuXG4vLyAgICBUaGUgU1ZHIHR5cGljYWxseSBjb250YWlucyBhIHZlcnkgbG9uZyAoNDAwIGVtKSBhcnJvdy5cbi8vICAgIFRoZSBTVkcgaXMgaW4gYSBjb250YWluZXIgc3BhbiB0aGF0IGhhcyBvdmVyZmxvdzogaGlkZGVuLCBzbyB0aGUgc3BhblxuLy8gICAgYWN0cyBsaWtlIGEgd2luZG93IHRoYXQgZXhwb3NlcyBvbmx5IHBhcnQgb2YgdGhlICBTVkcuXG4vLyAgICBUaGUgU1ZHIGFsd2F5cyBoYXMgYSBsb25nZXIsIHRoaW5uZXIgYXNwZWN0IHJhdGlvIHRoYW4gdGhlIGNvbnRhaW5lciBzcGFuLlxuLy8gICAgQWZ0ZXIgdGhlIFNWRyBmaWxscyAxMDAlIG9mIHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRhaW5lciBzcGFuLFxuLy8gICAgdGhlcmUgaXMgYSBsb25nIGFycm93IHNoYWZ0IGxlZnQgb3Zlci4gVGhhdCBsZWZ0LW92ZXIgc2hhZnQgaXMgbm90IHNob3duLlxuLy8gICAgSW5zdGVhZCwgaXQgaXMgc2xpY2VkIG9mZiBiZWNhdXNlIHRoZSBzcGFuJ3MgQ1NTIGhhcyBvdmVyZmxvdzogaGlkZGVuLlxuLy8gICAgVGh1cywgdGhlIHJlYWRlciBzZWVzIGFuIGFycm93IHRoYXQgbWF0Y2hlcyB0aGUgc3ViamVjdCBtYXR0ZXIgd2lkdGhcbi8vICAgIHdpdGhvdXQgZGlzdG9ydGlvbi5cbi8vICAgIFNvbWUgZnVuY3Rpb25zLCBzdWNoIGFzIFxcY2FuY2VsLCBuZWVkIHRvIHZhcnkgdGhlaXIgYXNwZWN0IHJhdGlvLiBUaGVzZVxuLy8gICAgZnVuY3Rpb25zIGRvIG5vdCBnZXQgdGhlIG92ZXJmbG93IFNWRyB0cmVhdG1lbnQuXG4vLyBTZWNvbmQgQnJ1c2ggU3Ryb2tlXG4vLyAgICBMb3cgcmVzb2x1dGlvbiBtb25pdG9ycyBzdHJ1Z2dsZSB0byBkaXNwbGF5IGltYWdlcyBpbiBmaW5lIGRldGFpbC5cbi8vICAgIFNvIGJyb3dzZXJzIGFwcGx5IGFudGktYWxpYXNpbmcuIEEgbG9uZyBzdHJhaWdodCBhcnJvdyBzaGFmdCB0aGVyZWZvcmVcbi8vICAgIHdpbGwgc29tZXRpbWVzIGFwcGVhciBhcyBpZiBpdCBoYXMgYSBibHVycmVkIGVkZ2UuXG4vLyAgICBUbyBtaXRpZ2F0ZSB0aGlzLCB0aGVzZSBTVkcgZmlsZXMgY29udGFpbiBhIHNlY29uZCBcImJydXNoLXN0cm9rZVwiIG9uIHRoZVxuLy8gICAgYXJyb3cgc2hhZnRzLiBUaGF0IGlzLCBhIHNlY29uZCBsb25nIHRoaW4gcmVjdGFuZ3VsYXIgU1ZHIHBhdGggaGFzIGJlZW5cbi8vICAgIHdyaXR0ZW4gZGlyZWN0bHkgb24gdG9wIG9mIGVhY2ggYXJyb3cgc2hhZnQuIFRoaXMgcmVpbmZvcmNlbWVudCBjYXVzZXNcbi8vICAgIHNvbWUgb2YgdGhlIHNjcmVlbiBwaXhlbHMgdG8gZGlzcGxheSBhcyBibGFjayBpbnN0ZWFkIG9mIHRoZSBhbnRpLWFsaWFzZWRcbi8vICAgIGdyYXkgcGl4ZWwgdGhhdCBhICBzaW5nbGUgcGF0aCB3b3VsZCBnZW5lcmF0ZS4gU28gd2UgZ2V0IGFycm93IHNoYWZ0c1xuLy8gICAgd2hvc2UgZWRnZXMgYXBwZWFyIHRvIGJlIHNoYXJwZXIuXG4vLyBJbiB0aGUga2F0ZXhJbWFnZXNEYXRhIG9iamVjdCBqdXN0IGJlbG93LCB0aGUgZGltZW5zaW9ucyBhbGxcbi8vIGNvcnJlc3BvbmQgdG8gcGF0aCBnZW9tZXRyeSBpbnNpZGUgdGhlIHJlbGV2YW50IFNWRy5cbi8vIEZvciBleGFtcGxlLCBcXG92ZXJyaWdodGFycm93IHVzZXMgdGhlIHNhbWUgYXJyb3doZWFkIGFzIGdseXBoIFUrMjE5MlxuLy8gZnJvbSB0aGUgS2FUZVggTWFpbiBmb250LiBUaGUgc2NhbGluZyBmYWN0b3IgaXMgMTAwMC5cbi8vIFRoYXQgaXMsIGluc2lkZSB0aGUgZm9udCwgdGhhdCBhcnJvd2hlYWQgaXMgNTIyIHVuaXRzIHRhbGwsIHdoaWNoXG4vLyBjb3JyZXNwb25kcyB0byAwLjUyMiBlbSBpbnNpZGUgdGhlIGRvY3VtZW50LlxuXG5cbnZhciBrYXRleEltYWdlc0RhdGEgPSB7XG4gIC8vICAgcGF0aChzKSwgbWluV2lkdGgsIGhlaWdodCwgYWxpZ25cbiAgb3ZlcnJpZ2h0YXJyb3c6IFtbXCJyaWdodGFycm93XCJdLCAwLjg4OCwgNTIyLCBcInhNYXhZTWluXCJdLFxuICBvdmVybGVmdGFycm93OiBbW1wibGVmdGFycm93XCJdLCAwLjg4OCwgNTIyLCBcInhNaW5ZTWluXCJdLFxuICB1bmRlcnJpZ2h0YXJyb3c6IFtbXCJyaWdodGFycm93XCJdLCAwLjg4OCwgNTIyLCBcInhNYXhZTWluXCJdLFxuICB1bmRlcmxlZnRhcnJvdzogW1tcImxlZnRhcnJvd1wiXSwgMC44ODgsIDUyMiwgXCJ4TWluWU1pblwiXSxcbiAgeHJpZ2h0YXJyb3c6IFtbXCJyaWdodGFycm93XCJdLCAxLjQ2OSwgNTIyLCBcInhNYXhZTWluXCJdLFxuICBcIlxcXFxjZHJpZ2h0YXJyb3dcIjogW1tcInJpZ2h0YXJyb3dcIl0sIDMuMCwgNTIyLCBcInhNYXhZTWluXCJdLFxuICAvLyBDRCBtaW53d2lkdGgyLjVwY1xuICB4bGVmdGFycm93OiBbW1wibGVmdGFycm93XCJdLCAxLjQ2OSwgNTIyLCBcInhNaW5ZTWluXCJdLFxuICBcIlxcXFxjZGxlZnRhcnJvd1wiOiBbW1wibGVmdGFycm93XCJdLCAzLjAsIDUyMiwgXCJ4TWluWU1pblwiXSxcbiAgT3ZlcnJpZ2h0YXJyb3c6IFtbXCJkb3VibGVyaWdodGFycm93XCJdLCAwLjg4OCwgNTYwLCBcInhNYXhZTWluXCJdLFxuICB4UmlnaHRhcnJvdzogW1tcImRvdWJsZXJpZ2h0YXJyb3dcIl0sIDEuNTI2LCA1NjAsIFwieE1heFlNaW5cIl0sXG4gIHhMZWZ0YXJyb3c6IFtbXCJkb3VibGVsZWZ0YXJyb3dcIl0sIDEuNTI2LCA1NjAsIFwieE1pbllNaW5cIl0sXG4gIG92ZXJsZWZ0aGFycG9vbjogW1tcImxlZnRoYXJwb29uXCJdLCAwLjg4OCwgNTIyLCBcInhNaW5ZTWluXCJdLFxuICB4bGVmdGhhcnBvb251cDogW1tcImxlZnRoYXJwb29uXCJdLCAwLjg4OCwgNTIyLCBcInhNaW5ZTWluXCJdLFxuICB4bGVmdGhhcnBvb25kb3duOiBbW1wibGVmdGhhcnBvb25kb3duXCJdLCAwLjg4OCwgNTIyLCBcInhNaW5ZTWluXCJdLFxuICBvdmVycmlnaHRoYXJwb29uOiBbW1wicmlnaHRoYXJwb29uXCJdLCAwLjg4OCwgNTIyLCBcInhNYXhZTWluXCJdLFxuICB4cmlnaHRoYXJwb29udXA6IFtbXCJyaWdodGhhcnBvb25cIl0sIDAuODg4LCA1MjIsIFwieE1heFlNaW5cIl0sXG4gIHhyaWdodGhhcnBvb25kb3duOiBbW1wicmlnaHRoYXJwb29uZG93blwiXSwgMC44ODgsIDUyMiwgXCJ4TWF4WU1pblwiXSxcbiAgeGxvbmdlcXVhbDogW1tcImxvbmdlcXVhbFwiXSwgMC44ODgsIDMzNCwgXCJ4TWluWU1pblwiXSxcbiAgXCJcXFxcY2Rsb25nZXF1YWxcIjogW1tcImxvbmdlcXVhbFwiXSwgMy4wLCAzMzQsIFwieE1pbllNaW5cIl0sXG4gIHh0d29oZWFkbGVmdGFycm93OiBbW1widHdvaGVhZGxlZnRhcnJvd1wiXSwgMC44ODgsIDMzNCwgXCJ4TWluWU1pblwiXSxcbiAgeHR3b2hlYWRyaWdodGFycm93OiBbW1widHdvaGVhZHJpZ2h0YXJyb3dcIl0sIDAuODg4LCAzMzQsIFwieE1heFlNaW5cIl0sXG4gIG92ZXJsZWZ0cmlnaHRhcnJvdzogW1tcImxlZnRhcnJvd1wiLCBcInJpZ2h0YXJyb3dcIl0sIDAuODg4LCA1MjJdLFxuICBvdmVyYnJhY2U6IFtbXCJsZWZ0YnJhY2VcIiwgXCJtaWRicmFjZVwiLCBcInJpZ2h0YnJhY2VcIl0sIDEuNiwgNTQ4XSxcbiAgdW5kZXJicmFjZTogW1tcImxlZnRicmFjZXVuZGVyXCIsIFwibWlkYnJhY2V1bmRlclwiLCBcInJpZ2h0YnJhY2V1bmRlclwiXSwgMS42LCA1NDhdLFxuICB1bmRlcmxlZnRyaWdodGFycm93OiBbW1wibGVmdGFycm93XCIsIFwicmlnaHRhcnJvd1wiXSwgMC44ODgsIDUyMl0sXG4gIHhsZWZ0cmlnaHRhcnJvdzogW1tcImxlZnRhcnJvd1wiLCBcInJpZ2h0YXJyb3dcIl0sIDEuNzUsIDUyMl0sXG4gIHhMZWZ0cmlnaHRhcnJvdzogW1tcImRvdWJsZWxlZnRhcnJvd1wiLCBcImRvdWJsZXJpZ2h0YXJyb3dcIl0sIDEuNzUsIDU2MF0sXG4gIHhyaWdodGxlZnRoYXJwb29uczogW1tcImxlZnRoYXJwb29uZG93bnBsdXNcIiwgXCJyaWdodGhhcnBvb25wbHVzXCJdLCAxLjc1LCA3MTZdLFxuICB4bGVmdHJpZ2h0aGFycG9vbnM6IFtbXCJsZWZ0aGFycG9vbnBsdXNcIiwgXCJyaWdodGhhcnBvb25kb3ducGx1c1wiXSwgMS43NSwgNzE2XSxcbiAgeGhvb2tsZWZ0YXJyb3c6IFtbXCJsZWZ0YXJyb3dcIiwgXCJyaWdodGhvb2tcIl0sIDEuMDgsIDUyMl0sXG4gIHhob29rcmlnaHRhcnJvdzogW1tcImxlZnRob29rXCIsIFwicmlnaHRhcnJvd1wiXSwgMS4wOCwgNTIyXSxcbiAgb3ZlcmxpbmVzZWdtZW50OiBbW1wibGVmdGxpbmVzZWdtZW50XCIsIFwicmlnaHRsaW5lc2VnbWVudFwiXSwgMC44ODgsIDUyMl0sXG4gIHVuZGVybGluZXNlZ21lbnQ6IFtbXCJsZWZ0bGluZXNlZ21lbnRcIiwgXCJyaWdodGxpbmVzZWdtZW50XCJdLCAwLjg4OCwgNTIyXSxcbiAgb3Zlcmdyb3VwOiBbW1wibGVmdGdyb3VwXCIsIFwicmlnaHRncm91cFwiXSwgMC44ODgsIDM0Ml0sXG4gIHVuZGVyZ3JvdXA6IFtbXCJsZWZ0Z3JvdXB1bmRlclwiLCBcInJpZ2h0Z3JvdXB1bmRlclwiXSwgMC44ODgsIDM0Ml0sXG4gIHhtYXBzdG86IFtbXCJsZWZ0bWFwc3RvXCIsIFwicmlnaHRhcnJvd1wiXSwgMS41LCA1MjJdLFxuICB4dG9mcm9tOiBbW1wibGVmdFRvRnJvbVwiLCBcInJpZ2h0VG9Gcm9tXCJdLCAxLjc1LCA1MjhdLFxuICAvLyBUaGUgbmV4dCB0aHJlZSBhcnJvd3MgYXJlIGZyb20gdGhlIG1oY2hlbSBwYWNrYWdlLlxuICAvLyBJbiBtaGNoZW0uc3R5LCBtaW4tbGVuZ3RoIGlzIDIuMGVtLiBCdXQgdGhlc2UgYXJyb3dzIG1pZ2h0IGFwcGVhciBpbiB0aGVcbiAgLy8gZG9jdW1lbnQgYXMgXFx4cmlnaHRhcnJvdyBvciBcXHhyaWdodGxlZnRoYXJwb29ucy4gVGhvc2UgaGF2ZVxuICAvLyBtaW4tbGVuZ3RoID0gMS43NWVtLCBzbyB3ZSBzZXQgbWluLWxlbmd0aCBvbiB0aGVzZSBuZXh0IHRocmVlIHRvIG1hdGNoLlxuICB4cmlnaHRsZWZ0YXJyb3dzOiBbW1wiYmFyYWJvdmVsZWZ0YXJyb3dcIiwgXCJyaWdodGFycm93YWJvdmViYXJcIl0sIDEuNzUsIDkwMV0sXG4gIHhyaWdodGVxdWlsaWJyaXVtOiBbW1wiYmFyYWJvdmVzaG9ydGxlZnRoYXJwb29uXCIsIFwicmlnaHRoYXJwb29uYWJvdmVzaG9ydGJhclwiXSwgMS43NSwgNzE2XSxcbiAgeGxlZnRlcXVpbGlicml1bTogW1tcInNob3J0YmFyYWJvdmVsZWZ0aGFycG9vblwiLCBcInNob3J0cmlnaHRoYXJwb29uYWJvdmViYXJcIl0sIDEuNzUsIDcxNl1cbn07XG5cbnZhciBncm91cExlbmd0aCA9IGZ1bmN0aW9uIGdyb3VwTGVuZ3RoKGFyZykge1xuICBpZiAoYXJnLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgIHJldHVybiBhcmcuYm9keS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn07XG5cbnZhciBzdmdTcGFuID0gZnVuY3Rpb24gc3ZnU3Bhbihncm91cCwgb3B0aW9ucykge1xuICAvLyBDcmVhdGUgYSBzcGFuIHdpdGggaW5saW5lIFNWRyBmb3IgdGhlIGVsZW1lbnQuXG4gIGZ1bmN0aW9uIGJ1aWxkU3ZnU3Bhbl8oKSB7XG4gICAgdmFyIHZpZXdCb3hXaWR0aCA9IDQwMDAwMDsgLy8gZGVmYXVsdFxuXG4gICAgdmFyIGxhYmVsID0gZ3JvdXAubGFiZWwuc2xpY2UoMSk7XG5cbiAgICBpZiAoW1wid2lkZWhhdFwiLCBcIndpZGVjaGVja1wiLCBcIndpZGV0aWxkZVwiLCBcInV0aWxkZVwiXS5pbmNsdWRlcyhsYWJlbCkpIHtcbiAgICAgIC8vIEVhY2ggdHlwZSBpbiB0aGUgYGlmYCBzdGF0ZW1lbnQgY29ycmVzcG9uZHMgdG8gb25lIG9mIHRoZSBQYXJzZU5vZGVcbiAgICAgIC8vIHR5cGVzIGJlbG93LiBUaGlzIG5hcnJvd2luZyBpcyByZXF1aXJlZCB0byBhY2Nlc3MgYGdycC5iYXNlYC5cbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIHZhciBncnAgPSBncm91cDsgLy8gVGhlcmUgYXJlIGZvdXIgU1ZHIGltYWdlcyBhdmFpbGFibGUgZm9yIGVhY2ggZnVuY3Rpb24uXG4gICAgICAvLyBDaG9vc2UgYSB0YWxsZXIgaW1hZ2Ugd2hlbiB0aGVyZSBhcmUgbW9yZSBjaGFyYWN0ZXJzLlxuXG4gICAgICB2YXIgbnVtQ2hhcnMgPSBncm91cExlbmd0aChncnAuYmFzZSk7XG4gICAgICB2YXIgdmlld0JveEhlaWdodDtcbiAgICAgIHZhciBwYXRoTmFtZTtcblxuICAgICAgdmFyIF9oZWlnaHQ7XG5cbiAgICAgIGlmIChudW1DaGFycyA+IDUpIHtcbiAgICAgICAgaWYgKGxhYmVsID09PSBcIndpZGVoYXRcIiB8fCBsYWJlbCA9PT0gXCJ3aWRlY2hlY2tcIikge1xuICAgICAgICAgIHZpZXdCb3hIZWlnaHQgPSA0MjA7XG4gICAgICAgICAgdmlld0JveFdpZHRoID0gMjM2NDtcbiAgICAgICAgICBfaGVpZ2h0ID0gMC40MjtcbiAgICAgICAgICBwYXRoTmFtZSA9IGxhYmVsICsgXCI0XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmlld0JveEhlaWdodCA9IDMxMjtcbiAgICAgICAgICB2aWV3Qm94V2lkdGggPSAyMzQwO1xuICAgICAgICAgIF9oZWlnaHQgPSAwLjM0O1xuICAgICAgICAgIHBhdGhOYW1lID0gXCJ0aWxkZTRcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGltZ0luZGV4ID0gWzEsIDEsIDIsIDIsIDMsIDNdW251bUNoYXJzXTtcblxuICAgICAgICBpZiAobGFiZWwgPT09IFwid2lkZWhhdFwiIHx8IGxhYmVsID09PSBcIndpZGVjaGVja1wiKSB7XG4gICAgICAgICAgdmlld0JveFdpZHRoID0gWzAsIDEwNjIsIDIzNjQsIDIzNjQsIDIzNjRdW2ltZ0luZGV4XTtcbiAgICAgICAgICB2aWV3Qm94SGVpZ2h0ID0gWzAsIDIzOSwgMzAwLCAzNjAsIDQyMF1baW1nSW5kZXhdO1xuICAgICAgICAgIF9oZWlnaHQgPSBbMCwgMC4yNCwgMC4zLCAwLjMsIDAuMzYsIDAuNDJdW2ltZ0luZGV4XTtcbiAgICAgICAgICBwYXRoTmFtZSA9IGxhYmVsICsgaW1nSW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmlld0JveFdpZHRoID0gWzAsIDYwMCwgMTAzMywgMjMzOSwgMjM0MF1baW1nSW5kZXhdO1xuICAgICAgICAgIHZpZXdCb3hIZWlnaHQgPSBbMCwgMjYwLCAyODYsIDMwNiwgMzEyXVtpbWdJbmRleF07XG4gICAgICAgICAgX2hlaWdodCA9IFswLCAwLjI2LCAwLjI4NiwgMC4zLCAwLjMwNiwgMC4zNF1baW1nSW5kZXhdO1xuICAgICAgICAgIHBhdGhOYW1lID0gXCJ0aWxkZVwiICsgaW1nSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGggPSBuZXcgUGF0aE5vZGUocGF0aE5hbWUpO1xuICAgICAgdmFyIHN2Z05vZGUgPSBuZXcgU3ZnTm9kZShbcGF0aF0sIHtcbiAgICAgICAgXCJ3aWR0aFwiOiBcIjEwMCVcIixcbiAgICAgICAgXCJoZWlnaHRcIjogbWFrZUVtKF9oZWlnaHQpLFxuICAgICAgICBcInZpZXdCb3hcIjogXCIwIDAgXCIgKyB2aWV3Qm94V2lkdGggKyBcIiBcIiArIHZpZXdCb3hIZWlnaHQsXG4gICAgICAgIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiOiBcIm5vbmVcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzcGFuOiBidWlsZENvbW1vbi5tYWtlU3ZnU3BhbihbXSwgW3N2Z05vZGVdLCBvcHRpb25zKSxcbiAgICAgICAgbWluV2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogX2hlaWdodFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNwYW5zID0gW107XG4gICAgICB2YXIgZGF0YSA9IGthdGV4SW1hZ2VzRGF0YVtsYWJlbF07XG4gICAgICB2YXIgW3BhdGhzLCBfbWluV2lkdGgsIF92aWV3Qm94SGVpZ2h0XSA9IGRhdGE7XG5cbiAgICAgIHZhciBfaGVpZ2h0MiA9IF92aWV3Qm94SGVpZ2h0IC8gMTAwMDtcblxuICAgICAgdmFyIG51bVN2Z0NoaWxkcmVuID0gcGF0aHMubGVuZ3RoO1xuICAgICAgdmFyIHdpZHRoQ2xhc3NlcztcbiAgICAgIHZhciBhbGlnbnM7XG5cbiAgICAgIGlmIChudW1TdmdDaGlsZHJlbiA9PT0gMSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lOiBBbGwgdGhlc2UgY2FzZXMgbXVzdCBiZSBvZiB0aGUgNC10dXBsZSB0eXBlLlxuICAgICAgICB2YXIgYWxpZ24xID0gZGF0YVszXTtcbiAgICAgICAgd2lkdGhDbGFzc2VzID0gW1wiaGlkZS10YWlsXCJdO1xuICAgICAgICBhbGlnbnMgPSBbYWxpZ24xXTtcbiAgICAgIH0gZWxzZSBpZiAobnVtU3ZnQ2hpbGRyZW4gPT09IDIpIHtcbiAgICAgICAgd2lkdGhDbGFzc2VzID0gW1wiaGFsZmFycm93LWxlZnRcIiwgXCJoYWxmYXJyb3ctcmlnaHRcIl07XG4gICAgICAgIGFsaWducyA9IFtcInhNaW5ZTWluXCIsIFwieE1heFlNaW5cIl07XG4gICAgICB9IGVsc2UgaWYgKG51bVN2Z0NoaWxkcmVuID09PSAzKSB7XG4gICAgICAgIHdpZHRoQ2xhc3NlcyA9IFtcImJyYWNlLWxlZnRcIiwgXCJicmFjZS1jZW50ZXJcIiwgXCJicmFjZS1yaWdodFwiXTtcbiAgICAgICAgYWxpZ25zID0gW1wieE1pbllNaW5cIiwgXCJ4TWlkWU1pblwiLCBcInhNYXhZTWluXCJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycmVjdCBrYXRleEltYWdlc0RhdGEgb3IgdXBkYXRlIGNvZGUgaGVyZSB0byBzdXBwb3J0XFxuICAgICAgICAgICAgICAgICAgICBcIiArIG51bVN2Z0NoaWxkcmVuICsgXCIgY2hpbGRyZW4uXCIpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVN2Z0NoaWxkcmVuOyBpKyspIHtcbiAgICAgICAgdmFyIF9wYXRoID0gbmV3IFBhdGhOb2RlKHBhdGhzW2ldKTtcblxuICAgICAgICB2YXIgX3N2Z05vZGUgPSBuZXcgU3ZnTm9kZShbX3BhdGhdLCB7XG4gICAgICAgICAgXCJ3aWR0aFwiOiBcIjQwMGVtXCIsXG4gICAgICAgICAgXCJoZWlnaHRcIjogbWFrZUVtKF9oZWlnaHQyKSxcbiAgICAgICAgICBcInZpZXdCb3hcIjogXCIwIDAgXCIgKyB2aWV3Qm94V2lkdGggKyBcIiBcIiArIF92aWV3Qm94SGVpZ2h0LFxuICAgICAgICAgIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiOiBhbGlnbnNbaV0gKyBcIiBzbGljZVwiXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBfc3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFt3aWR0aENsYXNzZXNbaV1dLCBbX3N2Z05vZGVdLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAobnVtU3ZnQ2hpbGRyZW4gPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BhbjogX3NwYW4sXG4gICAgICAgICAgICBtaW5XaWR0aDogX21pbldpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBfaGVpZ2h0MlxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3NwYW4uc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKF9oZWlnaHQyKTtcbiAgICAgICAgICBzcGFucy5wdXNoKF9zcGFuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzcGFuOiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJzdHJldGNoeVwiXSwgc3BhbnMsIG9wdGlvbnMpLFxuICAgICAgICBtaW5XaWR0aDogX21pbldpZHRoLFxuICAgICAgICBoZWlnaHQ6IF9oZWlnaHQyXG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBidWlsZFN2Z1NwYW5fKClcblxuXG4gIHZhciB7XG4gICAgc3BhbixcbiAgICBtaW5XaWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGJ1aWxkU3ZnU3Bhbl8oKTsgLy8gTm90ZSB0aGF0IHdlIGFyZSByZXR1cm5pbmcgc3Bhbi5kZXB0aCA9IDAuXG4gIC8vIEFueSBhZGp1c3RtZW50cyByZWxhdGl2ZSB0byB0aGUgYmFzZWxpbmUgbXVzdCBiZSBkb25lIGluIGJ1aWxkSFRNTC5cblxuICBzcGFuLmhlaWdodCA9IGhlaWdodDtcbiAgc3Bhbi5zdHlsZS5oZWlnaHQgPSBtYWtlRW0oaGVpZ2h0KTtcblxuICBpZiAobWluV2lkdGggPiAwKSB7XG4gICAgc3Bhbi5zdHlsZS5taW5XaWR0aCA9IG1ha2VFbShtaW5XaWR0aCk7XG4gIH1cblxuICByZXR1cm4gc3Bhbjtcbn07XG5cbnZhciBlbmNsb3NlU3BhbiA9IGZ1bmN0aW9uIGVuY2xvc2VTcGFuKGlubmVyLCBsYWJlbCwgdG9wUGFkLCBib3R0b21QYWQsIG9wdGlvbnMpIHtcbiAgLy8gUmV0dXJuIGFuIGltYWdlIHNwYW4gZm9yIFxcY2FuY2VsLCBcXGJjYW5jZWwsIFxceGNhbmNlbCwgXFxmYm94LCBvciBcXGFuZ2xcbiAgdmFyIGltZztcbiAgdmFyIHRvdGFsSGVpZ2h0ID0gaW5uZXIuaGVpZ2h0ICsgaW5uZXIuZGVwdGggKyB0b3BQYWQgKyBib3R0b21QYWQ7XG5cbiAgaWYgKC9mYm94fGNvbG9yfGFuZ2wvLnRlc3QobGFiZWwpKSB7XG4gICAgaW1nID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wic3RyZXRjaHlcIiwgbGFiZWxdLCBbXSwgb3B0aW9ucyk7XG5cbiAgICBpZiAobGFiZWwgPT09IFwiZmJveFwiKSB7XG4gICAgICB2YXIgY29sb3IgPSBvcHRpb25zLmNvbG9yICYmIG9wdGlvbnMuZ2V0Q29sb3IoKTtcblxuICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIGltZy5zdHlsZS5ib3JkZXJDb2xvciA9IGNvbG9yO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBcXGNhbmNlbCwgXFxiY2FuY2VsLCBvciBcXHhjYW5jZWxcbiAgICAvLyBTaW5jZSBcXGNhbmNlbCdzIFNWRyBpcyBpbmxpbmUgYW5kIGl0IG9taXRzIHRoZSB2aWV3Qm94IGF0dHJpYnV0ZSxcbiAgICAvLyBpdHMgc3Ryb2tlLXdpZHRoIHdpbGwgbm90IHZhcnkgd2l0aCBzcGFuIGFyZWEuXG4gICAgdmFyIGxpbmVzID0gW107XG5cbiAgICBpZiAoL15bYnhdY2FuY2VsJC8udGVzdChsYWJlbCkpIHtcbiAgICAgIGxpbmVzLnB1c2gobmV3IExpbmVOb2RlKHtcbiAgICAgICAgXCJ4MVwiOiBcIjBcIixcbiAgICAgICAgXCJ5MVwiOiBcIjBcIixcbiAgICAgICAgXCJ4MlwiOiBcIjEwMCVcIixcbiAgICAgICAgXCJ5MlwiOiBcIjEwMCVcIixcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogXCIwLjA0NmVtXCJcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBpZiAoL154P2NhbmNlbCQvLnRlc3QobGFiZWwpKSB7XG4gICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lTm9kZSh7XG4gICAgICAgIFwieDFcIjogXCIwXCIsXG4gICAgICAgIFwieTFcIjogXCIxMDAlXCIsXG4gICAgICAgIFwieDJcIjogXCIxMDAlXCIsXG4gICAgICAgIFwieTJcIjogXCIwXCIsXG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IFwiMC4wNDZlbVwiXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgdmFyIHN2Z05vZGUgPSBuZXcgU3ZnTm9kZShsaW5lcywge1xuICAgICAgXCJ3aWR0aFwiOiBcIjEwMCVcIixcbiAgICAgIFwiaGVpZ2h0XCI6IG1ha2VFbSh0b3RhbEhlaWdodClcbiAgICB9KTtcbiAgICBpbWcgPSBidWlsZENvbW1vbi5tYWtlU3ZnU3BhbihbXSwgW3N2Z05vZGVdLCBvcHRpb25zKTtcbiAgfVxuXG4gIGltZy5oZWlnaHQgPSB0b3RhbEhlaWdodDtcbiAgaW1nLnN0eWxlLmhlaWdodCA9IG1ha2VFbSh0b3RhbEhlaWdodCk7XG4gIHJldHVybiBpbWc7XG59O1xuXG52YXIgc3RyZXRjaHkgPSB7XG4gIGVuY2xvc2VTcGFuLFxuICBtYXRoTUxub2RlLFxuICBzdmdTcGFuXG59O1xuXG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgbm9kZSBpcyBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgcmV0dXJucyBpdCB3aXRoIHN0cmljdGVyXG4gKiB0eXBpbmcuIFRocm93cyBpZiB0aGUgbm9kZSdzIHR5cGUgZG9lcyBub3QgbWF0Y2guXG4gKi9cbmZ1bmN0aW9uIGFzc2VydE5vZGVUeXBlKG5vZGUsIHR5cGUpIHtcbiAgaWYgKCFub2RlIHx8IG5vZGUudHlwZSAhPT0gdHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG5vZGUgb2YgdHlwZSBcIiArIHR5cGUgKyBcIiwgYnV0IGdvdCBcIiArIChub2RlID8gXCJub2RlIG9mIHR5cGUgXCIgKyBub2RlLnR5cGUgOiBTdHJpbmcobm9kZSkpKTtcbiAgfSAvLyAkRmxvd0ZpeE1lLCA+PTAuMTI1XG5cblxuICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbm9kZSBtb3JlIHN0cmljdGx5IHR5cGVkIGlmZiBpdCBpcyBvZiB0aGUgZ2l2ZW4gdHlwZS4gT3RoZXJ3aXNlLFxuICogcmV0dXJucyBudWxsLlxuICovXG5cbmZ1bmN0aW9uIGFzc2VydFN5bWJvbE5vZGVUeXBlKG5vZGUpIHtcbiAgdmFyIHR5cGVkTm9kZSA9IGNoZWNrU3ltYm9sTm9kZVR5cGUobm9kZSk7XG5cbiAgaWYgKCF0eXBlZE5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBub2RlIG9mIHN5bWJvbCBncm91cCB0eXBlLCBidXQgZ290IFwiICsgKG5vZGUgPyBcIm5vZGUgb2YgdHlwZSBcIiArIG5vZGUudHlwZSA6IFN0cmluZyhub2RlKSkpO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVkTm9kZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbm9kZSBtb3JlIHN0cmljdGx5IHR5cGVkIGlmZiBpdCBpcyBvZiB0aGUgZ2l2ZW4gdHlwZS4gT3RoZXJ3aXNlLFxuICogcmV0dXJucyBudWxsLlxuICovXG5cbmZ1bmN0aW9uIGNoZWNrU3ltYm9sTm9kZVR5cGUobm9kZSkge1xuICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSBcImF0b21cIiB8fCBOT05fQVRPTVMuaGFzT3duUHJvcGVydHkobm9kZS50eXBlKSkpIHtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gTk9URTogVW5saWtlIG1vc3QgYGh0bWxCdWlsZGVyYHMsIHRoaXMgb25lIGhhbmRsZXMgbm90IG9ubHkgXCJhY2NlbnRcIiwgYnV0XG4vLyBhbHNvIFwic3Vwc3ViXCIgc2luY2UgYW4gYWNjZW50IGNhbiBhZmZlY3Qgc3VwZXIvc3Vic2NyaXB0aW5nLlxudmFyIGh0bWxCdWlsZGVyJGEgPSAoZ3JwLCBvcHRpb25zKSA9PiB7XG4gIC8vIEFjY2VudHMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgcGcuIDQ0MywgcnVsZSAxMi5cbiAgdmFyIGJhc2U7XG4gIHZhciBncm91cDtcbiAgdmFyIHN1cFN1Ykdyb3VwO1xuXG4gIGlmIChncnAgJiYgZ3JwLnR5cGUgPT09IFwic3Vwc3ViXCIpIHtcbiAgICAvLyBJZiBvdXIgYmFzZSBpcyBhIGNoYXJhY3RlciBib3gsIGFuZCB3ZSBoYXZlIHN1cGVyc2NyaXB0cyBhbmRcbiAgICAvLyBzdWJzY3JpcHRzLCB0aGUgc3Vwc3ViIHdpbGwgZGVmZXIgdG8gdXMuIEluIHBhcnRpY3VsYXIsIHdlIHdhbnRcbiAgICAvLyB0byBhdHRhY2ggdGhlIHN1cGVyc2NyaXB0cyBhbmQgc3Vic2NyaXB0cyB0byB0aGUgaW5uZXIgYm9keSAoc29cbiAgICAvLyB0aGF0IHRoZSBwb3NpdGlvbiBvZiB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIHdvbid0IGJlXG4gICAgLy8gYWZmZWN0ZWQgYnkgdGhlIGhlaWdodCBvZiB0aGUgYWNjZW50KS4gV2UgYWNjb21wbGlzaCB0aGlzIGJ5XG4gICAgLy8gc3RpY2tpbmcgdGhlIGJhc2Ugb2YgdGhlIGFjY2VudCBpbnRvIHRoZSBiYXNlIG9mIHRoZSBzdXBzdWIsIGFuZFxuICAgIC8vIHJlbmRlcmluZyB0aGF0LCB3aGlsZSBrZWVwaW5nIHRyYWNrIG9mIHdoZXJlIHRoZSBhY2NlbnQgaXMuXG4gICAgLy8gVGhlIHJlYWwgYWNjZW50IGdyb3VwIGlzIHRoZSBiYXNlIG9mIHRoZSBzdXBzdWIgZ3JvdXBcbiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKGdycC5iYXNlLCBcImFjY2VudFwiKTsgLy8gVGhlIGNoYXJhY3RlciBib3ggaXMgdGhlIGJhc2Ugb2YgdGhlIGFjY2VudCBncm91cFxuXG4gICAgYmFzZSA9IGdyb3VwLmJhc2U7IC8vIFN0aWNrIHRoZSBjaGFyYWN0ZXIgYm94IGludG8gdGhlIGJhc2Ugb2YgdGhlIHN1cHN1YiBncm91cFxuXG4gICAgZ3JwLmJhc2UgPSBiYXNlOyAvLyBSZXJlbmRlciB0aGUgc3Vwc3ViIGdyb3VwIHdpdGggaXRzIG5ldyBiYXNlLCBhbmQgc3RvcmUgdGhhdFxuICAgIC8vIHJlc3VsdC5cblxuICAgIHN1cFN1Ykdyb3VwID0gYXNzZXJ0U3BhbihidWlsZEdyb3VwJDEoZ3JwLCBvcHRpb25zKSk7IC8vIHJlc2V0IG9yaWdpbmFsIGJhc2VcblxuICAgIGdycC5iYXNlID0gZ3JvdXA7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShncnAsIFwiYWNjZW50XCIpO1xuICAgIGJhc2UgPSBncm91cC5iYXNlO1xuICB9IC8vIEJ1aWxkIHRoZSBiYXNlIGdyb3VwXG5cblxuICB2YXIgYm9keSA9IGJ1aWxkR3JvdXAkMShiYXNlLCBvcHRpb25zLmhhdmluZ0NyYW1wZWRTdHlsZSgpKTsgLy8gRG9lcyB0aGUgYWNjZW50IG5lZWQgdG8gc2hpZnQgZm9yIHRoZSBza2V3IG9mIGEgY2hhcmFjdGVyP1xuXG4gIHZhciBtdXN0U2hpZnQgPSBncm91cC5pc1NoaWZ0eSAmJiB1dGlscy5pc0NoYXJhY3RlckJveChiYXNlKTsgLy8gQ2FsY3VsYXRlIHRoZSBza2V3IG9mIHRoZSBhY2NlbnQuIFRoaXMgaXMgYmFzZWQgb24gdGhlIGxpbmUgXCJJZiB0aGVcbiAgLy8gbnVjbGV1cyBpcyBub3QgYSBzaW5nbGUgY2hhcmFjdGVyLCBsZXQgcyA9IDA7IG90aGVyd2lzZSBzZXQgcyB0byB0aGVcbiAgLy8ga2VybiBhbW91bnQgZm9yIHRoZSBudWNsZXVzIGZvbGxvd2VkIGJ5IHRoZSBcXHNrZXdjaGFyIG9mIGl0cyBmb250LlwiXG4gIC8vIE5vdGUgdGhhdCBvdXIgc2tldyBtZXRyaWNzIGFyZSBqdXN0IHRoZSBrZXJuIGJldHdlZW4gZWFjaCBjaGFyYWN0ZXJcbiAgLy8gYW5kIHRoZSBza2V3Y2hhci5cblxuICB2YXIgc2tldyA9IDA7XG5cbiAgaWYgKG11c3RTaGlmdCkge1xuICAgIC8vIElmIHRoZSBiYXNlIGlzIGEgY2hhcmFjdGVyIGJveCwgdGhlbiB3ZSB3YW50IHRoZSBza2V3IG9mIHRoZVxuICAgIC8vIGlubmVybW9zdCBjaGFyYWN0ZXIuIFRvIGRvIHRoYXQsIHdlIGZpbmQgdGhlIGlubmVybW9zdCBjaGFyYWN0ZXI6XG4gICAgdmFyIGJhc2VDaGFyID0gdXRpbHMuZ2V0QmFzZUVsZW0oYmFzZSk7IC8vIFRoZW4sIHdlIHJlbmRlciBpdHMgZ3JvdXAgdG8gZ2V0IHRoZSBzeW1ib2wgaW5zaWRlIGl0XG5cbiAgICB2YXIgYmFzZUdyb3VwID0gYnVpbGRHcm91cCQxKGJhc2VDaGFyLCBvcHRpb25zLmhhdmluZ0NyYW1wZWRTdHlsZSgpKTsgLy8gRmluYWxseSwgd2UgcHVsbCB0aGUgc2tldyBvZmYgb2YgdGhlIHN5bWJvbC5cblxuICAgIHNrZXcgPSBhc3NlcnRTeW1ib2xEb21Ob2RlKGJhc2VHcm91cCkuc2tldzsgLy8gTm90ZSB0aGF0IHdlIG5vdyB0aHJvdyBhd2F5IGJhc2VHcm91cCwgYmVjYXVzZSB0aGUgbGF5ZXJzIHdlXG4gICAgLy8gcmVtb3ZlZCB3aXRoIGdldEJhc2VFbGVtIG1pZ2h0IGNvbnRhaW4gdGhpbmdzIGxpa2UgXFxjb2xvciB3aGljaFxuICAgIC8vIHdlIGNhbid0IGdldCByaWQgb2YuXG4gICAgLy8gVE9ETyhlbWlseSk6IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGdldCB0aGUgc2tld1xuICB9XG5cbiAgdmFyIGFjY2VudEJlbG93ID0gZ3JvdXAubGFiZWwgPT09IFwiXFxcXGNcIjsgLy8gY2FsY3VsYXRlIHRoZSBhbW91bnQgb2Ygc3BhY2UgYmV0d2VlbiB0aGUgYm9keSBhbmQgdGhlIGFjY2VudFxuXG4gIHZhciBjbGVhcmFuY2UgPSBhY2NlbnRCZWxvdyA/IGJvZHkuaGVpZ2h0ICsgYm9keS5kZXB0aCA6IE1hdGgubWluKGJvZHkuaGVpZ2h0LCBvcHRpb25zLmZvbnRNZXRyaWNzKCkueEhlaWdodCk7IC8vIEJ1aWxkIHRoZSBhY2NlbnRcblxuICB2YXIgYWNjZW50Qm9keTtcblxuICBpZiAoIWdyb3VwLmlzU3RyZXRjaHkpIHtcbiAgICB2YXIgYWNjZW50O1xuICAgIHZhciB3aWR0aDtcblxuICAgIGlmIChncm91cC5sYWJlbCA9PT0gXCJcXFxcdmVjXCIpIHtcbiAgICAgIC8vIEJlZm9yZSB2ZXJzaW9uIDAuOSwgXFx2ZWMgdXNlZCB0aGUgY29tYmluaW5nIGZvbnQgZ2x5cGggVSsyMEQ3LlxuICAgICAgLy8gQnV0IGJyb3dzZXJzLCBlc3BlY2lhbGx5IFNhZmFyaSwgYXJlIG5vdCBjb25zaXN0ZW50IGluIGhvdyB0aGV5XG4gICAgICAvLyByZW5kZXIgY29tYmluaW5nIGNoYXJhY3RlcnMgd2hlbiBub3QgcHJlY2VkZWQgYnkgYSBjaGFyYWN0ZXIuXG4gICAgICAvLyBTbyBub3cgd2UgdXNlIGFuIFNWRy5cbiAgICAgIC8vIElmIFNhZmFyaSByZWZvcm1zLCB3ZSBzaG91bGQgY29uc2lkZXIgcmV2ZXJ0aW5nIHRvIHRoZSBnbHlwaC5cbiAgICAgIGFjY2VudCA9IGJ1aWxkQ29tbW9uLnN0YXRpY1N2ZyhcInZlY1wiLCBvcHRpb25zKTtcbiAgICAgIHdpZHRoID0gYnVpbGRDb21tb24uc3ZnRGF0YS52ZWNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY2VudCA9IGJ1aWxkQ29tbW9uLm1ha2VPcmQoe1xuICAgICAgICBtb2RlOiBncm91cC5tb2RlLFxuICAgICAgICB0ZXh0OiBncm91cC5sYWJlbFxuICAgICAgfSwgb3B0aW9ucywgXCJ0ZXh0b3JkXCIpO1xuICAgICAgYWNjZW50ID0gYXNzZXJ0U3ltYm9sRG9tTm9kZShhY2NlbnQpOyAvLyBSZW1vdmUgdGhlIGl0YWxpYyBjb3JyZWN0aW9uIG9mIHRoZSBhY2NlbnQsIGJlY2F1c2UgaXQgb25seSBzZXJ2ZXMgdG9cbiAgICAgIC8vIHNoaWZ0IHRoZSBhY2NlbnQgb3ZlciB0byBhIHBsYWNlIHdlIGRvbid0IHdhbnQuXG5cbiAgICAgIGFjY2VudC5pdGFsaWMgPSAwO1xuICAgICAgd2lkdGggPSBhY2NlbnQud2lkdGg7XG5cbiAgICAgIGlmIChhY2NlbnRCZWxvdykge1xuICAgICAgICBjbGVhcmFuY2UgKz0gYWNjZW50LmRlcHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFjY2VudEJvZHkgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJhY2NlbnQtYm9keVwiXSwgW2FjY2VudF0pOyAvLyBcIkZ1bGxcIiBhY2NlbnRzIGV4cGFuZCB0aGUgd2lkdGggb2YgdGhlIHJlc3VsdGluZyBzeW1ib2wgdG8gYmVcbiAgICAvLyBhdCBsZWFzdCB0aGUgd2lkdGggb2YgdGhlIGFjY2VudCwgYW5kIG92ZXJsYXAgZGlyZWN0bHkgb250byB0aGVcbiAgICAvLyBjaGFyYWN0ZXIgd2l0aG91dCBhbnkgdmVydGljYWwgb2Zmc2V0LlxuXG4gICAgdmFyIGFjY2VudEZ1bGwgPSBncm91cC5sYWJlbCA9PT0gXCJcXFxcdGV4dGNpcmNsZWRcIjtcblxuICAgIGlmIChhY2NlbnRGdWxsKSB7XG4gICAgICBhY2NlbnRCb2R5LmNsYXNzZXMucHVzaCgnYWNjZW50LWZ1bGwnKTtcbiAgICAgIGNsZWFyYW5jZSA9IGJvZHkuaGVpZ2h0O1xuICAgIH0gLy8gU2hpZnQgdGhlIGFjY2VudCBvdmVyIGJ5IHRoZSBza2V3LlxuXG5cbiAgICB2YXIgbGVmdCA9IHNrZXc7IC8vIENTUyBkZWZpbmVzIGAua2F0ZXggLmFjY2VudCAuYWNjZW50LWJvZHk6bm90KC5hY2NlbnQtZnVsbCkgeyB3aWR0aDogMCB9YFxuICAgIC8vIHNvIHRoYXQgdGhlIGFjY2VudCBkb2Vzbid0IGNvbnRyaWJ1dGUgdG8gdGhlIGJvdW5kaW5nIGJveC5cbiAgICAvLyBXZSBuZWVkIHRvIHNoaWZ0IHRoZSBjaGFyYWN0ZXIgYnkgaXRzIHdpZHRoIChlZmZlY3RpdmVseSBoYWxmXG4gICAgLy8gaXRzIHdpZHRoKSB0byBjb21wZW5zYXRlLlxuXG4gICAgaWYgKCFhY2NlbnRGdWxsKSB7XG4gICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICB9XG5cbiAgICBhY2NlbnRCb2R5LnN0eWxlLmxlZnQgPSBtYWtlRW0obGVmdCk7IC8vIFxcdGV4dGNpcmNsZWQgdXNlcyB0aGUgXFxiaWdjaXJjIGdseXBoLCBzbyBpdCBuZWVkcyBzb21lXG4gICAgLy8gdmVydGljYWwgYWRqdXN0bWVudCB0byBtYXRjaCBMYVRlWC5cblxuICAgIGlmIChncm91cC5sYWJlbCA9PT0gXCJcXFxcdGV4dGNpcmNsZWRcIikge1xuICAgICAgYWNjZW50Qm9keS5zdHlsZS50b3AgPSBcIi4yZW1cIjtcbiAgICB9XG5cbiAgICBhY2NlbnRCb2R5ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJmaXJzdEJhc2VsaW5lXCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJvZHlcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IC1jbGVhcmFuY2VcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGFjY2VudEJvZHlcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgYWNjZW50Qm9keSA9IHN0cmV0Y2h5LnN2Z1NwYW4oZ3JvdXAsIG9wdGlvbnMpO1xuICAgIGFjY2VudEJvZHkgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYm9keVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYWNjZW50Qm9keSxcbiAgICAgICAgd3JhcHBlckNsYXNzZXM6IFtcInN2Zy1hbGlnblwiXSxcbiAgICAgICAgd3JhcHBlclN0eWxlOiBza2V3ID4gMCA/IHtcbiAgICAgICAgICB3aWR0aDogXCJjYWxjKDEwMCUgLSBcIiArIG1ha2VFbSgyICogc2tldykgKyBcIilcIixcbiAgICAgICAgICBtYXJnaW5MZWZ0OiBtYWtlRW0oMiAqIHNrZXcpXG4gICAgICAgIH0gOiB1bmRlZmluZWRcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgYWNjZW50V3JhcCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJhY2NlbnRcIl0sIFthY2NlbnRCb2R5XSwgb3B0aW9ucyk7XG5cbiAgaWYgKHN1cFN1Ykdyb3VwKSB7XG4gICAgLy8gSGVyZSwgd2UgcmVwbGFjZSB0aGUgXCJiYXNlXCIgY2hpbGQgb2YgdGhlIHN1cHN1YiB3aXRoIG91ciBuZXdseVxuICAgIC8vIGdlbmVyYXRlZCBhY2NlbnQuXG4gICAgc3VwU3ViR3JvdXAuY2hpbGRyZW5bMF0gPSBhY2NlbnRXcmFwOyAvLyBTaW5jZSB3ZSBkb24ndCByZXJ1biB0aGUgaGVpZ2h0IGNhbGN1bGF0aW9uIGFmdGVyIHJlcGxhY2luZyB0aGVcbiAgICAvLyBhY2NlbnQsIHdlIG1hbnVhbGx5IHJlY2FsY3VsYXRlIGhlaWdodC5cblxuICAgIHN1cFN1Ykdyb3VwLmhlaWdodCA9IE1hdGgubWF4KGFjY2VudFdyYXAuaGVpZ2h0LCBzdXBTdWJHcm91cC5oZWlnaHQpOyAvLyBBY2NlbnRzIHNob3VsZCBhbHdheXMgYmUgb3JkcywgZXZlbiB3aGVuIHRoZWlyIGlubmFyZHMgYXJlIG5vdC5cblxuICAgIHN1cFN1Ykdyb3VwLmNsYXNzZXNbMF0gPSBcIm1vcmRcIjtcbiAgICByZXR1cm4gc3VwU3ViR3JvdXA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFjY2VudFdyYXA7XG4gIH1cbn07XG5cbnZhciBtYXRobWxCdWlsZGVyJDkgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgdmFyIGFjY2VudE5vZGUgPSBncm91cC5pc1N0cmV0Y2h5ID8gc3RyZXRjaHkubWF0aE1Mbm9kZShncm91cC5sYWJlbCkgOiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChncm91cC5sYWJlbCwgZ3JvdXAubW9kZSldKTtcbiAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vdmVyXCIsIFtidWlsZEdyb3VwKGdyb3VwLmJhc2UsIG9wdGlvbnMpLCBhY2NlbnROb2RlXSk7XG4gIG5vZGUuc2V0QXR0cmlidXRlKFwiYWNjZW50XCIsIFwidHJ1ZVwiKTtcbiAgcmV0dXJuIG5vZGU7XG59O1xuXG52YXIgTk9OX1NUUkVUQ0hZX0FDQ0VOVF9SRUdFWCA9IG5ldyBSZWdFeHAoW1wiXFxcXGFjdXRlXCIsIFwiXFxcXGdyYXZlXCIsIFwiXFxcXGRkb3RcIiwgXCJcXFxcdGlsZGVcIiwgXCJcXFxcYmFyXCIsIFwiXFxcXGJyZXZlXCIsIFwiXFxcXGNoZWNrXCIsIFwiXFxcXGhhdFwiLCBcIlxcXFx2ZWNcIiwgXCJcXFxcZG90XCIsIFwiXFxcXG1hdGhyaW5nXCJdLm1hcChhY2NlbnQgPT4gXCJcXFxcXCIgKyBhY2NlbnQpLmpvaW4oXCJ8XCIpKTsgLy8gQWNjZW50c1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiYWNjZW50XCIsXG4gIG5hbWVzOiBbXCJcXFxcYWN1dGVcIiwgXCJcXFxcZ3JhdmVcIiwgXCJcXFxcZGRvdFwiLCBcIlxcXFx0aWxkZVwiLCBcIlxcXFxiYXJcIiwgXCJcXFxcYnJldmVcIiwgXCJcXFxcY2hlY2tcIiwgXCJcXFxcaGF0XCIsIFwiXFxcXHZlY1wiLCBcIlxcXFxkb3RcIiwgXCJcXFxcbWF0aHJpbmdcIiwgXCJcXFxcd2lkZWNoZWNrXCIsIFwiXFxcXHdpZGVoYXRcIiwgXCJcXFxcd2lkZXRpbGRlXCIsIFwiXFxcXG92ZXJyaWdodGFycm93XCIsIFwiXFxcXG92ZXJsZWZ0YXJyb3dcIiwgXCJcXFxcT3ZlcnJpZ2h0YXJyb3dcIiwgXCJcXFxcb3ZlcmxlZnRyaWdodGFycm93XCIsIFwiXFxcXG92ZXJncm91cFwiLCBcIlxcXFxvdmVybGluZXNlZ21lbnRcIiwgXCJcXFxcb3ZlcmxlZnRoYXJwb29uXCIsIFwiXFxcXG92ZXJyaWdodGhhcnBvb25cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIHZhciBiYXNlID0gbm9ybWFsaXplQXJndW1lbnQoYXJnc1swXSk7XG4gICAgdmFyIGlzU3RyZXRjaHkgPSAhTk9OX1NUUkVUQ0hZX0FDQ0VOVF9SRUdFWC50ZXN0KGNvbnRleHQuZnVuY05hbWUpO1xuICAgIHZhciBpc1NoaWZ0eSA9ICFpc1N0cmV0Y2h5IHx8IGNvbnRleHQuZnVuY05hbWUgPT09IFwiXFxcXHdpZGVoYXRcIiB8fCBjb250ZXh0LmZ1bmNOYW1lID09PSBcIlxcXFx3aWRldGlsZGVcIiB8fCBjb250ZXh0LmZ1bmNOYW1lID09PSBcIlxcXFx3aWRlY2hlY2tcIjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhY2NlbnRcIixcbiAgICAgIG1vZGU6IGNvbnRleHQucGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogY29udGV4dC5mdW5jTmFtZSxcbiAgICAgIGlzU3RyZXRjaHk6IGlzU3RyZXRjaHksXG4gICAgICBpc1NoaWZ0eTogaXNTaGlmdHksXG4gICAgICBiYXNlOiBiYXNlXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJGEsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7IC8vIFRleHQtbW9kZSBhY2NlbnRzXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJhY2NlbnRcIixcbiAgbmFtZXM6IFtcIlxcXFwnXCIsIFwiXFxcXGBcIiwgXCJcXFxcXlwiLCBcIlxcXFx+XCIsIFwiXFxcXD1cIiwgXCJcXFxcdVwiLCBcIlxcXFwuXCIsICdcXFxcXCInLCBcIlxcXFxjXCIsIFwiXFxcXHJcIiwgXCJcXFxcSFwiLCBcIlxcXFx2XCIsIFwiXFxcXHRleHRjaXJjbGVkXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5NYXRoOiB0cnVlLFxuICAgIC8vIHVubGVzcyBpbiBzdHJpY3QgbW9kZVxuICAgIGFyZ1R5cGVzOiBbXCJwcmltaXRpdmVcIl1cbiAgfSxcbiAgaGFuZGxlcjogKGNvbnRleHQsIGFyZ3MpID0+IHtcbiAgICB2YXIgYmFzZSA9IGFyZ3NbMF07XG4gICAgdmFyIG1vZGUgPSBjb250ZXh0LnBhcnNlci5tb2RlO1xuXG4gICAgaWYgKG1vZGUgPT09IFwibWF0aFwiKSB7XG4gICAgICBjb250ZXh0LnBhcnNlci5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoXCJtYXRoVnNUZXh0QWNjZW50c1wiLCBcIkxhVGVYJ3MgYWNjZW50IFwiICsgY29udGV4dC5mdW5jTmFtZSArIFwiIHdvcmtzIG9ubHkgaW4gdGV4dCBtb2RlXCIpO1xuICAgICAgbW9kZSA9IFwidGV4dFwiO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFjY2VudFwiLFxuICAgICAgbW9kZTogbW9kZSxcbiAgICAgIGxhYmVsOiBjb250ZXh0LmZ1bmNOYW1lLFxuICAgICAgaXNTdHJldGNoeTogZmFsc2UsXG4gICAgICBpc1NoaWZ0eTogdHJ1ZSxcbiAgICAgIGJhc2U6IGJhc2VcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkYSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ5XG59KTtcblxuLy8gSG9yaXpvbnRhbCBvdmVybGFwIGZ1bmN0aW9uc1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImFjY2VudFVuZGVyXCIsXG4gIG5hbWVzOiBbXCJcXFxcdW5kZXJsZWZ0YXJyb3dcIiwgXCJcXFxcdW5kZXJyaWdodGFycm93XCIsIFwiXFxcXHVuZGVybGVmdHJpZ2h0YXJyb3dcIiwgXCJcXFxcdW5kZXJncm91cFwiLCBcIlxcXFx1bmRlcmxpbmVzZWdtZW50XCIsIFwiXFxcXHV0aWxkZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIGJhc2UgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFjY2VudFVuZGVyXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJhc2U6IGJhc2VcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgLy8gVHJlYXQgdW5kZXIgYWNjZW50cyBtdWNoIGxpa2UgdW5kZXJsaW5lcy5cbiAgICB2YXIgaW5uZXJHcm91cCA9IGJ1aWxkR3JvdXAkMShncm91cC5iYXNlLCBvcHRpb25zKTtcbiAgICB2YXIgYWNjZW50Qm9keSA9IHN0cmV0Y2h5LnN2Z1NwYW4oZ3JvdXAsIG9wdGlvbnMpO1xuICAgIHZhciBrZXJuID0gZ3JvdXAubGFiZWwgPT09IFwiXFxcXHV0aWxkZVwiID8gMC4xMiA6IDA7IC8vIEdlbmVyYXRlIHRoZSB2bGlzdCwgd2l0aCB0aGUgYXBwcm9wcmlhdGUga2VybnNcblxuICAgIHZhciB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwidG9wXCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IGlubmVyR3JvdXAuaGVpZ2h0LFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBhY2NlbnRCb2R5LFxuICAgICAgICB3cmFwcGVyQ2xhc3NlczogW1wic3ZnLWFsaWduXCJdXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBrZXJuXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbm5lckdyb3VwXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwiYWNjZW50dW5kZXJcIl0sIFt2bGlzdF0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgYWNjZW50Tm9kZSA9IHN0cmV0Y2h5Lm1hdGhNTG5vZGUoZ3JvdXAubGFiZWwpO1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdW5kZXJcIiwgW2J1aWxkR3JvdXAoZ3JvdXAuYmFzZSwgb3B0aW9ucyksIGFjY2VudE5vZGVdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudHVuZGVyXCIsIFwidHJ1ZVwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbi8vIEhlbHBlciBmdW5jdGlvblxudmFyIHBhZGRlZE5vZGUgPSBncm91cCA9PiB7XG4gIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIGdyb3VwID8gW2dyb3VwXSA6IFtdKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIiswLjZlbVwiKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwLjNlbVwiKTtcbiAgcmV0dXJuIG5vZGU7XG59OyAvLyBTdHJldGNoeSBhcnJvd3Mgd2l0aCBhbiBvcHRpb25hbCBhcmd1bWVudFxuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ4QXJyb3dcIixcbiAgbmFtZXM6IFtcIlxcXFx4bGVmdGFycm93XCIsIFwiXFxcXHhyaWdodGFycm93XCIsIFwiXFxcXHhMZWZ0YXJyb3dcIiwgXCJcXFxceFJpZ2h0YXJyb3dcIiwgXCJcXFxceGxlZnRyaWdodGFycm93XCIsIFwiXFxcXHhMZWZ0cmlnaHRhcnJvd1wiLCBcIlxcXFx4aG9va2xlZnRhcnJvd1wiLCBcIlxcXFx4aG9va3JpZ2h0YXJyb3dcIiwgXCJcXFxceG1hcHN0b1wiLCBcIlxcXFx4cmlnaHRoYXJwb29uZG93blwiLCBcIlxcXFx4cmlnaHRoYXJwb29udXBcIiwgXCJcXFxceGxlZnRoYXJwb29uZG93blwiLCBcIlxcXFx4bGVmdGhhcnBvb251cFwiLCBcIlxcXFx4cmlnaHRsZWZ0aGFycG9vbnNcIiwgXCJcXFxceGxlZnRyaWdodGhhcnBvb25zXCIsIFwiXFxcXHhsb25nZXF1YWxcIiwgXCJcXFxceHR3b2hlYWRyaWdodGFycm93XCIsIFwiXFxcXHh0d29oZWFkbGVmdGFycm93XCIsIFwiXFxcXHh0b2Zyb21cIiwgLy8gVGhlIG5leHQgMyBmdW5jdGlvbnMgYXJlIGhlcmUgdG8gc3VwcG9ydCB0aGUgbWhjaGVtIGV4dGVuc2lvbi5cbiAgLy8gRGlyZWN0IHVzZSBvZiB0aGVzZSBmdW5jdGlvbnMgaXMgZGlzY291cmFnZWQgYW5kIG1heSBicmVhayBzb21lZGF5LlxuICBcIlxcXFx4cmlnaHRsZWZ0YXJyb3dzXCIsIFwiXFxcXHhyaWdodGVxdWlsaWJyaXVtXCIsIFwiXFxcXHhsZWZ0ZXF1aWxpYnJpdW1cIiwgLy8gVGhlIG5leHQgMyBmdW5jdGlvbnMgYXJlIGhlcmUgb25seSB0byBzdXBwb3J0IHRoZSB7Q0R9IGVudmlyb25tZW50LlxuICBcIlxcXFxcXFxcY2RyaWdodGFycm93XCIsIFwiXFxcXFxcXFxjZGxlZnRhcnJvd1wiLCBcIlxcXFxcXFxcY2Rsb25nZXF1YWxcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDFcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ4QXJyb3dcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYm9keTogYXJnc1swXSxcbiAgICAgIGJlbG93OiBvcHRBcmdzWzBdXG4gICAgfTtcbiAgfSxcblxuICAvLyBGbG93IGlzIHVuYWJsZSB0byBjb3JyZWN0bHkgaW5mZXIgdGhlIHR5cGUgb2YgYGdyb3VwYCwgZXZlbiB0aG91Z2ggaXQnc1xuICAvLyB1bmFtYmlndW91c2x5IGRldGVybWluZWQgZnJvbSB0aGUgcGFzc2VkLWluIGB0eXBlYCBhYm92ZS5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlOyAvLyBCdWlsZCB0aGUgYXJndW1lbnQgZ3JvdXBzIGluIHRoZSBhcHByb3ByaWF0ZSBzdHlsZS5cbiAgICAvLyBSZWY6IGFtc21hdGguZHR4OiAgIFxcaGJveHskXFxzY3JpcHRzdHlsZVxcbWtlcm4jM211eyM2fVxcbWtlcm4jNG11JH0lXG4gICAgLy8gU29tZSBncm91cHMgY2FuIHJldHVybiBkb2N1bWVudCBmcmFnbWVudHMuICBIYW5kbGUgdGhvc2UgYnkgd3JhcHBpbmdcbiAgICAvLyB0aGVtIGluIGEgc3Bhbi5cblxuICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShzdHlsZS5zdXAoKSk7XG4gICAgdmFyIHVwcGVyR3JvdXAgPSBidWlsZENvbW1vbi53cmFwRnJhZ21lbnQoYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG5ld09wdGlvbnMsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB2YXIgYXJyb3dQcmVmaXggPSBncm91cC5sYWJlbC5zbGljZSgwLCAyKSA9PT0gXCJcXFxceFwiID8gXCJ4XCIgOiBcImNkXCI7XG4gICAgdXBwZXJHcm91cC5jbGFzc2VzLnB1c2goYXJyb3dQcmVmaXggKyBcIi1hcnJvdy1wYWRcIik7XG4gICAgdmFyIGxvd2VyR3JvdXA7XG5cbiAgICBpZiAoZ3JvdXAuYmVsb3cpIHtcbiAgICAgIC8vIEJ1aWxkIHRoZSBsb3dlciBncm91cFxuICAgICAgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUuc3ViKCkpO1xuICAgICAgbG93ZXJHcm91cCA9IGJ1aWxkQ29tbW9uLndyYXBGcmFnbWVudChidWlsZEdyb3VwJDEoZ3JvdXAuYmVsb3csIG5ld09wdGlvbnMsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgIGxvd2VyR3JvdXAuY2xhc3Nlcy5wdXNoKGFycm93UHJlZml4ICsgXCItYXJyb3ctcGFkXCIpO1xuICAgIH1cblxuICAgIHZhciBhcnJvd0JvZHkgPSBzdHJldGNoeS5zdmdTcGFuKGdyb3VwLCBvcHRpb25zKTsgLy8gUmUgc2hpZnQ6IE5vdGUgdGhhdCBzdHJldGNoeS5zdmdTcGFuIHJldHVybmVkIGFycm93Qm9keS5kZXB0aCA9IDAuXG4gICAgLy8gVGhlIHBvaW50IHdlIHdhbnQgb24gdGhlIG1hdGggYXhpcyBpcyBhdCAwLjUgKiBhcnJvd0JvZHkuaGVpZ2h0LlxuXG4gICAgdmFyIGFycm93U2hpZnQgPSAtb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQgKyAwLjUgKiBhcnJvd0JvZHkuaGVpZ2h0OyAvLyAyIG11IGtlcm4uIFJlZjogYW1zbWF0aC5kdHg6ICM3XFxpZjAjMlxcZWxzZVxcbWtlcm4jMm11XFxmaVxuXG4gICAgdmFyIHVwcGVyU2hpZnQgPSAtb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQgLSAwLjUgKiBhcnJvd0JvZHkuaGVpZ2h0IC0gMC4xMTE7IC8vIDAuMTExIGVtID0gMiBtdVxuXG4gICAgaWYgKHVwcGVyR3JvdXAuZGVwdGggPiAwLjI1IHx8IGdyb3VwLmxhYmVsID09PSBcIlxcXFx4bGVmdGVxdWlsaWJyaXVtXCIpIHtcbiAgICAgIHVwcGVyU2hpZnQgLT0gdXBwZXJHcm91cC5kZXB0aDsgLy8gc2hpZnQgdXAgaWYgZGVwdGggZW5jcm9hY2hlc1xuICAgIH0gLy8gR2VuZXJhdGUgdGhlIHZsaXN0XG5cblxuICAgIHZhciB2bGlzdDtcblxuICAgIGlmIChsb3dlckdyb3VwKSB7XG4gICAgICB2YXIgbG93ZXJTaGlmdCA9IC1vcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodCArIGxvd2VyR3JvdXAuaGVpZ2h0ICsgMC41ICogYXJyb3dCb2R5LmhlaWdodCArIDAuMTExO1xuICAgICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHVwcGVyR3JvdXAsXG4gICAgICAgICAgc2hpZnQ6IHVwcGVyU2hpZnRcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IGFycm93Qm9keSxcbiAgICAgICAgICBzaGlmdDogYXJyb3dTaGlmdFxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogbG93ZXJHcm91cCxcbiAgICAgICAgICBzaGlmdDogbG93ZXJTaGlmdFxuICAgICAgICB9XVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiB1cHBlckdyb3VwLFxuICAgICAgICAgIHNoaWZ0OiB1cHBlclNoaWZ0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBhcnJvd0JvZHksXG4gICAgICAgICAgc2hpZnQ6IGFycm93U2hpZnRcbiAgICAgICAgfV1cbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH0gLy8gJEZsb3dGaXhNZTogUmVwbGFjZSB0aGlzIHdpdGggcGFzc2luZyBcInN2Zy1hbGlnblwiIGludG8gbWFrZVZMaXN0LlxuXG5cbiAgICB2bGlzdC5jaGlsZHJlblswXS5jaGlsZHJlblswXS5jaGlsZHJlblsxXS5jbGFzc2VzLnB1c2goXCJzdmctYWxpZ25cIik7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1yZWxcIiwgXCJ4LWFycm93XCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGFycm93Tm9kZSA9IHN0cmV0Y2h5Lm1hdGhNTG5vZGUoZ3JvdXAubGFiZWwpO1xuICAgIGFycm93Tm9kZS5zZXRBdHRyaWJ1dGUoXCJtaW5zaXplXCIsIGdyb3VwLmxhYmVsLmNoYXJBdCgwKSA9PT0gXCJ4XCIgPyBcIjEuNzVlbVwiIDogXCIzLjBlbVwiKTtcbiAgICB2YXIgbm9kZTtcblxuICAgIGlmIChncm91cC5ib2R5KSB7XG4gICAgICB2YXIgdXBwZXJOb2RlID0gcGFkZGVkTm9kZShidWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpKTtcblxuICAgICAgaWYgKGdyb3VwLmJlbG93KSB7XG4gICAgICAgIHZhciBsb3dlck5vZGUgPSBwYWRkZWROb2RlKGJ1aWxkR3JvdXAoZ3JvdXAuYmVsb3csIG9wdGlvbnMpKTtcbiAgICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXVuZGVyb3ZlclwiLCBbYXJyb3dOb2RlLCBsb3dlck5vZGUsIHVwcGVyTm9kZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW92ZXJcIiwgW2Fycm93Tm9kZSwgdXBwZXJOb2RlXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChncm91cC5iZWxvdykge1xuICAgICAgdmFyIF9sb3dlck5vZGUgPSBwYWRkZWROb2RlKGJ1aWxkR3JvdXAoZ3JvdXAuYmVsb3csIG9wdGlvbnMpKTtcblxuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXVuZGVyXCIsIFthcnJvd05vZGUsIF9sb3dlck5vZGVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLlxuICAgICAgLy8gUGFyc2VyLmpzIHRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBpcyBubyBhcmd1bWVudC5cbiAgICAgIG5vZGUgPSBwYWRkZWROb2RlKCk7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb3ZlclwiLCBbYXJyb3dOb2RlLCBub2RlXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG5cbnZhciBtYWtlU3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuO1xuXG5mdW5jdGlvbiBodG1sQnVpbGRlciQ5KGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciBlbGVtZW50cyA9IGJ1aWxkRXhwcmVzc2lvbiQxKGdyb3VwLmJvZHksIG9wdGlvbnMsIHRydWUpO1xuICByZXR1cm4gbWFrZVNwYW4oW2dyb3VwLm1jbGFzc10sIGVsZW1lbnRzLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gbWF0aG1sQnVpbGRlciQ4KGdyb3VwLCBvcHRpb25zKSB7XG4gIHZhciBub2RlO1xuICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucyk7XG5cbiAgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtaW5uZXJcIikge1xuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgaW5uZXIpO1xuICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtb3JkXCIpIHtcbiAgICBpZiAoZ3JvdXAuaXNDaGFyYWN0ZXJCb3gpIHtcbiAgICAgIG5vZGUgPSBpbm5lclswXTtcbiAgICAgIG5vZGUudHlwZSA9IFwibWlcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgaW5uZXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZ3JvdXAuaXNDaGFyYWN0ZXJCb3gpIHtcbiAgICAgIG5vZGUgPSBpbm5lclswXTtcbiAgICAgIG5vZGUudHlwZSA9IFwibW9cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgaW5uZXIpO1xuICAgIH0gLy8gU2V0IHNwYWNpbmcgYmFzZWQgb24gd2hhdCBpcyB0aGUgbW9zdCBsaWtlbHkgYWRqYWNlbnQgYXRvbSB0eXBlLlxuICAgIC8vIFNlZSBUZVhib29rIHAxNzAuXG5cblxuICAgIGlmIChncm91cC5tY2xhc3MgPT09IFwibWJpblwiKSB7XG4gICAgICBub2RlLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwLjIyZW1cIjsgLy8gbWVkaXVtIHNwYWNlXG5cbiAgICAgIG5vZGUuYXR0cmlidXRlcy5yc3BhY2UgPSBcIjAuMjJlbVwiO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1wdW5jdFwiKSB7XG4gICAgICBub2RlLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwZW1cIjtcbiAgICAgIG5vZGUuYXR0cmlidXRlcy5yc3BhY2UgPSBcIjAuMTdlbVwiOyAvLyB0aGluc3BhY2VcbiAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtb3BlblwiIHx8IGdyb3VwLm1jbGFzcyA9PT0gXCJtY2xvc2VcIikge1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMGVtXCI7XG4gICAgICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gXCIwZW1cIjtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtaW5uZXJcIikge1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMC4wNTU2ZW1cIjsgLy8gMSBtdSBpcyB0aGUgbW9zdCBsaWtlbHkgb3B0aW9uXG5cbiAgICAgIG5vZGUuYXR0cmlidXRlcy53aWR0aCA9IFwiKzAuMTExMWVtXCI7XG4gICAgfSAvLyBNYXRoTUwgPG1vPiBkZWZhdWx0IHNwYWNlIGlzIDUvMTggZW0sIHNvIDxtcmVsPiBuZWVkcyBubyBhY3Rpb24uXG4gICAgLy8gUmVmOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9NYXRoTUwvRWxlbWVudC9tb1xuXG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0gLy8gTWF0aCBjbGFzcyBjb21tYW5kcyBleGNlcHQgXFxtYXRob3BcblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWNsYXNzXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWF0aG9yZFwiLCBcIlxcXFxtYXRoYmluXCIsIFwiXFxcXG1hdGhyZWxcIiwgXCJcXFxcbWF0aG9wZW5cIiwgXCJcXFxcbWF0aGNsb3NlXCIsIFwiXFxcXG1hdGhwdW5jdFwiLCBcIlxcXFxtYXRoaW5uZXJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG1jbGFzczogXCJtXCIgKyBmdW5jTmFtZS5zbGljZSg1KSxcbiAgICAgIC8vIFRPRE8oa2V2aW5iKTogZG9uJ3QgcHJlZml4IHdpdGggJ20nXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KSxcbiAgICAgIGlzQ2hhcmFjdGVyQm94OiB1dGlscy5pc0NoYXJhY3RlckJveChib2R5KVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDksXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOFxufSk7XG52YXIgYmlucmVsQ2xhc3MgPSBhcmcgPT4ge1xuICAvLyBcXGJpbnJlbEAgc3BhY2luZyB2YXJpZXMgd2l0aCAoYmlufHJlbHxvcmQpIG9mIHRoZSBhdG9tIGluIHRoZSBhcmd1bWVudC5cbiAgLy8gKGJ5IHJlbmRlcmluZyBzZXBhcmF0ZWx5IGFuZCB3aXRoIHt9cyBiZWZvcmUgYW5kIGFmdGVyLCBhbmQgbWVhc3VyaW5nXG4gIC8vIHRoZSBjaGFuZ2UgaW4gc3BhY2luZykuICBXZSdsbCBkbyByb3VnaGx5IHRoZSBzYW1lIGJ5IGRldGVjdGluZyB0aGVcbiAgLy8gYXRvbSB0eXBlIGRpcmVjdGx5LlxuICB2YXIgYXRvbSA9IGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIgJiYgYXJnLmJvZHkubGVuZ3RoID8gYXJnLmJvZHlbMF0gOiBhcmc7XG5cbiAgaWYgKGF0b20udHlwZSA9PT0gXCJhdG9tXCIgJiYgKGF0b20uZmFtaWx5ID09PSBcImJpblwiIHx8IGF0b20uZmFtaWx5ID09PSBcInJlbFwiKSkge1xuICAgIHJldHVybiBcIm1cIiArIGF0b20uZmFtaWx5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm1vcmRcIjtcbiAgfVxufTsgLy8gXFxAYmlucmVse3h9e3l9IHJlbmRlcnMgbGlrZSB5IGJ1dCBhcyBtYmluL21yZWwvbW9yZCBpZiB4IGlzIG1iaW4vbXJlbC9tb3JkLlxuLy8gVGhpcyBpcyBlcXVpdmFsZW50IHRvIFxcYmlucmVsQHt4fVxcYmlucmVsQEB7eX0gaW4gQU1TVGVYLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWNsYXNzXCIsXG4gIG5hbWVzOiBbXCJcXFxcQGJpbnJlbFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmMiwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG1jbGFzczogYmlucmVsQ2xhc3MoYXJnc1swXSksXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChhcmdzWzFdKSxcbiAgICAgIGlzQ2hhcmFjdGVyQm94OiB1dGlscy5pc0NoYXJhY3RlckJveChhcmdzWzFdKVxuICAgIH07XG4gIH1cblxufSk7IC8vIEJ1aWxkIGEgcmVsYXRpb24gb3Igc3RhY2tlZCBvcCBieSBwbGFjaW5nIG9uZSBzeW1ib2wgb24gdG9wIG9mIGFub3RoZXJcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1jbGFzc1wiLFxuICBuYW1lczogW1wiXFxcXHN0YWNrcmVsXCIsIFwiXFxcXG92ZXJzZXRcIiwgXCJcXFxcdW5kZXJzZXRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMlxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjMsIGFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjM7XG4gICAgdmFyIGJhc2VBcmcgPSBhcmdzWzFdO1xuICAgIHZhciBzaGlmdGVkQXJnID0gYXJnc1swXTtcbiAgICB2YXIgbWNsYXNzO1xuXG4gICAgaWYgKGZ1bmNOYW1lICE9PSBcIlxcXFxzdGFja3JlbFwiKSB7XG4gICAgICAvLyBMYVRlWCBhcHBsaWVzIFxcYmlucmVsIHNwYWNpbmcgdG8gXFxvdmVyc2V0IGFuZCBcXHVuZGVyc2V0LlxuICAgICAgbWNsYXNzID0gYmlucmVsQ2xhc3MoYmFzZUFyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1jbGFzcyA9IFwibXJlbFwiOyAvLyBmb3IgXFxzdGFja3JlbFxuICAgIH1cblxuICAgIHZhciBiYXNlT3AgPSB7XG4gICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICBtb2RlOiBiYXNlQXJnLm1vZGUsXG4gICAgICBsaW1pdHM6IHRydWUsXG4gICAgICBhbHdheXNIYW5kbGVTdXBTdWI6IHRydWUsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IGZhbHNlLFxuICAgICAgc3VwcHJlc3NCYXNlU2hpZnQ6IGZ1bmNOYW1lICE9PSBcIlxcXFxzdGFja3JlbFwiLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYmFzZUFyZylcbiAgICB9O1xuICAgIHZhciBzdXBzdWIgPSB7XG4gICAgICB0eXBlOiBcInN1cHN1YlwiLFxuICAgICAgbW9kZTogc2hpZnRlZEFyZy5tb2RlLFxuICAgICAgYmFzZTogYmFzZU9wLFxuICAgICAgc3VwOiBmdW5jTmFtZSA9PT0gXCJcXFxcdW5kZXJzZXRcIiA/IG51bGwgOiBzaGlmdGVkQXJnLFxuICAgICAgc3ViOiBmdW5jTmFtZSA9PT0gXCJcXFxcdW5kZXJzZXRcIiA/IHNoaWZ0ZWRBcmcgOiBudWxsXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtY2xhc3NcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbWNsYXNzLFxuICAgICAgYm9keTogW3N1cHN1Yl0sXG4gICAgICBpc0NoYXJhY3RlckJveDogdXRpbHMuaXNDaGFyYWN0ZXJCb3goc3Vwc3ViKVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDksXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOFxufSk7XG5cbi8vIFxccG1iIGlzIGEgc2ltdWxhdGlvbiBvZiBib2xkIGZvbnQuXG4vLyBUaGUgdmVyc2lvbiBvZiBcXHBtYiBpbiBhbWJzeS5zdHkgd29ya3MgYnkgdHlwZXNldHRpbmcgdGhyZWUgY29waWVzXG4vLyB3aXRoIHNtYWxsIG9mZnNldHMuIFdlIHVzZSBDU1MgdGV4dC1zaGFkb3cuXG4vLyBJdCdzIGEgaGFjay4gTm90IGFzIGdvb2QgYXMgYSByZWFsIGJvbGQgZm9udC4gQmV0dGVyIHRoYW4gbm90aGluZy5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJwbWJcIixcbiAgbmFtZXM6IFtcIlxcXFxwbWJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInBtYlwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBtY2xhc3M6IGJpbnJlbENsYXNzKGFyZ3NbMF0pLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYXJnc1swXSlcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uJDEoZ3JvdXAuYm9keSwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgdmFyIG5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbZ3JvdXAubWNsYXNzXSwgZWxlbWVudHMsIG9wdGlvbnMpO1xuICAgIG5vZGUuc3R5bGUudGV4dFNoYWRvdyA9IFwiMC4wMmVtIDAuMDFlbSAwLjA0cHhcIjtcbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBzdHlsZSk7IC8vIFdyYXAgd2l0aCBhbiA8bXN0eWxlPiBlbGVtZW50LlxuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcInRleHQtc2hhZG93OiAwLjAyZW0gMC4wMWVtIDAuMDRweFwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG59KTtcblxudmFyIGNkQXJyb3dGdW5jdGlvbk5hbWUgPSB7XG4gIFwiPlwiOiBcIlxcXFxcXFxcY2RyaWdodGFycm93XCIsXG4gIFwiPFwiOiBcIlxcXFxcXFxcY2RsZWZ0YXJyb3dcIixcbiAgXCI9XCI6IFwiXFxcXFxcXFxjZGxvbmdlcXVhbFwiLFxuICBcIkFcIjogXCJcXFxcdXBhcnJvd1wiLFxuICBcIlZcIjogXCJcXFxcZG93bmFycm93XCIsXG4gIFwifFwiOiBcIlxcXFxWZXJ0XCIsXG4gIFwiLlwiOiBcIm5vIGFycm93XCJcbn07XG5cbnZhciBuZXdDZWxsID0gKCkgPT4ge1xuICAvLyBDcmVhdGUgYW4gZW1wdHkgY2VsbCwgdG8gYmUgZmlsbGVkIGJlbG93IHdpdGggcGFyc2Ugbm9kZXMuXG4gIC8vIFRoZSBwYXJzZVRyZWUgZnJvbSB0aGlzIG1vZHVsZSBtdXN0IGJlIGNvbnN0cnVjdGVkIGxpa2UgdGhlXG4gIC8vIG9uZSBjcmVhdGVkIGJ5IHBhcnNlQXJyYXkoKSwgc28gYW4gZW1wdHkgQ0QgY2VsbCBtdXN0XG4gIC8vIGJlIGEgUGFyc2VOb2RlPFwic3R5bGluZ1wiPi4gQW5kIENEIGlzIGFsd2F5cyBkaXNwbGF5c3R5bGUuXG4gIC8vIFNvIHRoZXNlIHZhbHVlcyBhcmUgZml4ZWQgYW5kIGZsb3cgY2FuIGRvIGltcGxpY2l0IHR5cGluZy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICBib2R5OiBbXSxcbiAgICBtb2RlOiBcIm1hdGhcIixcbiAgICBzdHlsZTogXCJkaXNwbGF5XCJcbiAgfTtcbn07XG5cbnZhciBpc1N0YXJ0T2ZBcnJvdyA9IG5vZGUgPT4ge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBcInRleHRvcmRcIiAmJiBub2RlLnRleHQgPT09IFwiQFwiO1xufTtcblxudmFyIGlzTGFiZWxFbmQgPSAobm9kZSwgZW5kQ2hhcikgPT4ge1xuICByZXR1cm4gKG5vZGUudHlwZSA9PT0gXCJtYXRob3JkXCIgfHwgbm9kZS50eXBlID09PSBcImF0b21cIikgJiYgbm9kZS50ZXh0ID09PSBlbmRDaGFyO1xufTtcblxuZnVuY3Rpb24gY2RBcnJvdyhhcnJvd0NoYXIsIGxhYmVscywgcGFyc2VyKSB7XG4gIC8vIFJldHVybiBhIHBhcnNlIHRyZWUgb2YgYW4gYXJyb3cgYW5kIGl0cyBsYWJlbHMuXG4gIC8vIFRoaXMgYWN0cyBpbiBhIHdheSBzaW1pbGFyIHRvIGEgbWFjcm8gZXhwYW5zaW9uLlxuICB2YXIgZnVuY05hbWUgPSBjZEFycm93RnVuY3Rpb25OYW1lW2Fycm93Q2hhcl07XG5cbiAgc3dpdGNoIChmdW5jTmFtZSkge1xuICAgIGNhc2UgXCJcXFxcXFxcXGNkcmlnaHRhcnJvd1wiOlxuICAgIGNhc2UgXCJcXFxcXFxcXGNkbGVmdGFycm93XCI6XG4gICAgICByZXR1cm4gcGFyc2VyLmNhbGxGdW5jdGlvbihmdW5jTmFtZSwgW2xhYmVsc1swXV0sIFtsYWJlbHNbMV1dKTtcblxuICAgIGNhc2UgXCJcXFxcdXBhcnJvd1wiOlxuICAgIGNhc2UgXCJcXFxcZG93bmFycm93XCI6XG4gICAgICB7XG4gICAgICAgIHZhciBsZWZ0TGFiZWwgPSBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXFxcXFxjZGxlZnRcIiwgW2xhYmVsc1swXV0sIFtdKTtcbiAgICAgICAgdmFyIGJhcmVBcnJvdyA9IHtcbiAgICAgICAgICB0eXBlOiBcImF0b21cIixcbiAgICAgICAgICB0ZXh0OiBmdW5jTmFtZSxcbiAgICAgICAgICBtb2RlOiBcIm1hdGhcIixcbiAgICAgICAgICBmYW1pbHk6IFwicmVsXCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNpemVkQXJyb3cgPSBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXEJpZ1wiLCBbYmFyZUFycm93XSwgW10pO1xuICAgICAgICB2YXIgcmlnaHRMYWJlbCA9IHBhcnNlci5jYWxsRnVuY3Rpb24oXCJcXFxcXFxcXGNkcmlnaHRcIiwgW2xhYmVsc1sxXV0sIFtdKTtcbiAgICAgICAgdmFyIGFycm93R3JvdXAgPSB7XG4gICAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICAgIG1vZGU6IFwibWF0aFwiLFxuICAgICAgICAgIGJvZHk6IFtsZWZ0TGFiZWwsIHNpemVkQXJyb3csIHJpZ2h0TGFiZWxdXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXFxcXFxjZHBhcmVudFwiLCBbYXJyb3dHcm91cF0sIFtdKTtcbiAgICAgIH1cblxuICAgIGNhc2UgXCJcXFxcXFxcXGNkbG9uZ2VxdWFsXCI6XG4gICAgICByZXR1cm4gcGFyc2VyLmNhbGxGdW5jdGlvbihcIlxcXFxcXFxcY2Rsb25nZXF1YWxcIiwgW10sIFtdKTtcblxuICAgIGNhc2UgXCJcXFxcVmVydFwiOlxuICAgICAge1xuICAgICAgICB2YXIgYXJyb3cgPSB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgdGV4dDogXCJcXFxcVmVydFwiLFxuICAgICAgICAgIG1vZGU6IFwibWF0aFwiXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXEJpZ1wiLCBbYXJyb3ddLCBbXSk7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgIHRleHQ6IFwiIFwiLFxuICAgICAgICBtb2RlOiBcIm1hdGhcIlxuICAgICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUNEKHBhcnNlcikge1xuICAvLyBHZXQgdGhlIGFycmF5J3MgcGFyc2Ugbm9kZXMgd2l0aCBcXFxcIHRlbXBvcmFyaWx5IG1hcHBlZCB0byBcXGNyLlxuICB2YXIgcGFyc2VkUm93cyA9IFtdO1xuICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXGNyXCIsIFwiXFxcXFxcXFxcXFxccmVsYXhcIik7XG4gIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAvLyBHZXQgdGhlIHBhcnNlIG5vZGVzIGZvciB0aGUgbmV4dCByb3cuXG4gICAgcGFyc2VkUm93cy5wdXNoKHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIFwiXFxcXFxcXFxcIikpO1xuICAgIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgICB2YXIgbmV4dCA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG5cbiAgICBpZiAobmV4dCA9PT0gXCImXCIgfHwgbmV4dCA9PT0gXCJcXFxcXFxcXFwiKSB7XG4gICAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gXCJcXFxcZW5kXCIpIHtcbiAgICAgIGlmIChwYXJzZWRSb3dzW3BhcnNlZFJvd3MubGVuZ3RoIC0gMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHBhcnNlZFJvd3MucG9wKCk7IC8vIGZpbmFsIHJvdyBlbmRlZCBpbiBcXFxcXG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkV4cGVjdGVkIFxcXFxcXFxcIG9yIFxcXFxjciBvciBcXFxcZW5kXCIsIHBhcnNlci5uZXh0VG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIHZhciByb3cgPSBbXTtcbiAgdmFyIGJvZHkgPSBbcm93XTsgLy8gTG9vcCB0aHJ1IHRoZSBwYXJzZSBub2Rlcy4gQ29sbGVjdCB0aGVtIGludG8gY2VsbHMgYW5kIGFycm93cy5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnNlZFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBTdGFydCBhIG5ldyByb3cuXG4gICAgdmFyIHJvd05vZGVzID0gcGFyc2VkUm93c1tpXTsgLy8gQ3JlYXRlIHRoZSBmaXJzdCBjZWxsLlxuXG4gICAgdmFyIGNlbGwgPSBuZXdDZWxsKCk7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvd05vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAoIWlzU3RhcnRPZkFycm93KHJvd05vZGVzW2pdKSkge1xuICAgICAgICAvLyBJZiBhIHBhcnNlTm9kZSBpcyBub3QgYW4gYXJyb3csIGl0IGdvZXMgaW50byBhIGNlbGwuXG4gICAgICAgIGNlbGwuYm9keS5wdXNoKHJvd05vZGVzW2pdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBhcnNlIG5vZGUgaiBpcyBhbiBcIkBcIiwgdGhlIHN0YXJ0IG9mIGFuIGFycm93LlxuICAgICAgICAvLyBCZWZvcmUgc3RhcnRpbmcgb24gdGhlIGFycm93LCBwdXNoIHRoZSBjZWxsIGludG8gYHJvd2AuXG4gICAgICAgIHJvdy5wdXNoKGNlbGwpOyAvLyBOb3cgY29sbGVjdCBwYXJzZU5vZGVzIGludG8gYW4gYXJyb3cuXG4gICAgICAgIC8vIFRoZSBjaGFyYWN0ZXIgYWZ0ZXIgXCJAXCIgZGVmaW5lcyB0aGUgYXJyb3cgdHlwZS5cblxuICAgICAgICBqICs9IDE7XG4gICAgICAgIHZhciBhcnJvd0NoYXIgPSBhc3NlcnRTeW1ib2xOb2RlVHlwZShyb3dOb2Rlc1tqXSkudGV4dDsgLy8gQ3JlYXRlIHR3byBlbXB0eSBsYWJlbCBub2Rlcy4gV2UgbWF5IG9yIG1heSBub3QgdXNlIHRoZW0uXG5cbiAgICAgICAgdmFyIGxhYmVscyA9IG5ldyBBcnJheSgyKTtcbiAgICAgICAgbGFiZWxzWzBdID0ge1xuICAgICAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgICAgICBtb2RlOiBcIm1hdGhcIixcbiAgICAgICAgICBib2R5OiBbXVxuICAgICAgICB9O1xuICAgICAgICBsYWJlbHNbMV0gPSB7XG4gICAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICAgIG1vZGU6IFwibWF0aFwiLFxuICAgICAgICAgIGJvZHk6IFtdXG4gICAgICAgIH07IC8vIFByb2Nlc3MgdGhlIGFycm93LlxuXG4gICAgICAgIGlmIChcIj18LlwiLmluZGV4T2YoYXJyb3dDaGFyKSA+IC0xKSA7IGVsc2UgaWYgKFwiPD5BVlwiLmluZGV4T2YoYXJyb3dDaGFyKSA+IC0xKSB7XG4gICAgICAgICAgLy8gRm91ciBhcnJvd3MsIGBAPj4+YCwgYEA8PDxgLCBgQEFBQWAsIGFuZCBgQFZWVmAsIGVhY2ggdGFrZVxuICAgICAgICAgIC8vIHR3byBvcHRpb25hbCBsYWJlbHMuIEUuZy4gdGhlIHJpZ2h0LXBvaW50IGFycm93IHN5bnRheCBpc1xuICAgICAgICAgIC8vIHJlYWxseTogIEA+e29wdGlvbmFsIGxhYmVsfT57b3B0aW9uYWwgbGFiZWx9PlxuICAgICAgICAgIC8vIENvbGxlY3QgcGFyc2VOb2RlcyBpbnRvIGxhYmVscy5cbiAgICAgICAgICBmb3IgKHZhciBsYWJlbE51bSA9IDA7IGxhYmVsTnVtIDwgMjsgbGFiZWxOdW0rKykge1xuICAgICAgICAgICAgdmFyIGluTGFiZWwgPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gaiArIDE7IGsgPCByb3dOb2Rlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICBpZiAoaXNMYWJlbEVuZChyb3dOb2Rlc1trXSwgYXJyb3dDaGFyKSkge1xuICAgICAgICAgICAgICAgIGluTGFiZWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBqID0gaztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChpc1N0YXJ0T2ZBcnJvdyhyb3dOb2Rlc1trXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIk1pc3NpbmcgYSBcIiArIGFycm93Q2hhciArIFwiIGNoYXJhY3RlciB0byBjb21wbGV0ZSBhIENEIGFycm93LlwiLCByb3dOb2Rlc1trXSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsYWJlbHNbbGFiZWxOdW1dLmJvZHkucHVzaChyb3dOb2Rlc1trXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbkxhYmVsKSB7XG4gICAgICAgICAgICAgIC8vIGlzTGFiZWxFbmQgbmV2ZXIgcmV0dXJuZWQgYSB0cnVlLlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIk1pc3NpbmcgYSBcIiArIGFycm93Q2hhciArIFwiIGNoYXJhY3RlciB0byBjb21wbGV0ZSBhIENEIGFycm93LlwiLCByb3dOb2Rlc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgb25lIG9mIFxcXCI8PkFWPXwuXFxcIiBhZnRlciBAXCIsIHJvd05vZGVzW2pdKTtcbiAgICAgICAgfSAvLyBOb3cgam9pbiB0aGUgYXJyb3cgdG8gaXRzIGxhYmVscy5cblxuXG4gICAgICAgIHZhciBhcnJvdyA9IGNkQXJyb3coYXJyb3dDaGFyLCBsYWJlbHMsIHBhcnNlcik7IC8vIFdyYXAgdGhlIGFycm93IGluICBQYXJzZU5vZGU8XCJzdHlsaW5nXCI+LlxuICAgICAgICAvLyBUaGlzIGlzIGRvbmUgdG8gbWF0Y2ggcGFyc2VBcnJheSgpIGJlaGF2aW9yLlxuXG4gICAgICAgIHZhciB3cmFwcGVkQXJyb3cgPSB7XG4gICAgICAgICAgdHlwZTogXCJzdHlsaW5nXCIsXG4gICAgICAgICAgYm9keTogW2Fycm93XSxcbiAgICAgICAgICBtb2RlOiBcIm1hdGhcIixcbiAgICAgICAgICBzdHlsZTogXCJkaXNwbGF5XCIgLy8gQ0QgaXMgYWx3YXlzIGRpc3BsYXlzdHlsZS5cblxuICAgICAgICB9O1xuICAgICAgICByb3cucHVzaCh3cmFwcGVkQXJyb3cpOyAvLyBJbiBDRCdzIHN5bnRheCwgY2VsbHMgYXJlIGltcGxpY2l0LiBUaGF0IGlzLCBldmVyeXRoaW5nIHRoYXRcbiAgICAgICAgLy8gaXMgbm90IGFuIGFycm93IGdldHMgY29sbGVjdGVkIGludG8gYSBjZWxsLiBTbyBjcmVhdGUgYW4gZW1wdHlcbiAgICAgICAgLy8gY2VsbCBub3cuIEl0IHdpbGwgY29sbGVjdCB1cGNvbWluZyBwYXJzZU5vZGVzLlxuXG4gICAgICAgIGNlbGwgPSBuZXdDZWxsKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAvLyBFdmVuLW51bWJlcmVkIHJvd3MgY29uc2lzdCBvZjogY2VsbCwgYXJyb3csIGNlbGwsIGFycm93LCAuLi4gY2VsbFxuICAgICAgLy8gVGhlIGxhc3QgY2VsbCBpcyBub3QgeWV0IHB1c2hlZCBpbnRvIGByb3dgLCBzbzpcbiAgICAgIHJvdy5wdXNoKGNlbGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPZGQtbnVtYmVyZWQgcm93cyBjb25zaXN0IG9mOiB2ZXJ0IGFycm93LCBlbXB0eSBjZWxsLCAuLi4gdmVydCBhcnJvd1xuICAgICAgLy8gUmVtb3ZlIHRoZSBlbXB0eSBjZWxsIHRoYXQgd2FzIHBsYWNlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGByb3dgLlxuICAgICAgcm93LnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgcm93ID0gW107XG4gICAgYm9keS5wdXNoKHJvdyk7XG4gIH0gLy8gRW5kIHJvdyBncm91cFxuXG5cbiAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpOyAvLyBFbmQgYXJyYXkgZ3JvdXAgZGVmaW5pbmcgXFxcXFxuXG4gIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTsgLy8gZGVmaW5lIGNvbHVtbiBzZXBhcmF0aW9uLlxuXG4gIHZhciBjb2xzID0gbmV3IEFycmF5KGJvZHlbMF0ubGVuZ3RoKS5maWxsKHtcbiAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgYWxpZ246IFwiY1wiLFxuICAgIHByZWdhcDogMC4yNSxcbiAgICAvLyBDRCBwYWNrYWdlIHNldHMgXFxlbnNraXAgYmV0d2VlbiBjb2x1bW5zLlxuICAgIHBvc3RnYXA6IDAuMjUgLy8gU28gcHJlIGFuZCBwb3N0IGVhY2ggZ2V0IGhhbGYgYW4gXFxlbnNraXAsIGkuZS4gMC4yNWVtLlxuXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBtb2RlOiBcIm1hdGhcIixcbiAgICBib2R5LFxuICAgIGFycmF5c3RyZXRjaDogMSxcbiAgICBhZGRKb3Q6IHRydWUsXG4gICAgcm93R2FwczogW251bGxdLFxuICAgIGNvbHMsXG4gICAgY29sU2VwYXJhdGlvblR5cGU6IFwiQ0RcIixcbiAgICBoTGluZXNCZWZvcmVSb3c6IG5ldyBBcnJheShib2R5Lmxlbmd0aCArIDEpLmZpbGwoW10pXG4gIH07XG59IC8vIFRoZSBmdW5jdGlvbnMgYmVsb3cgYXJlIG5vdCBhdmFpbGFibGUgZm9yIGdlbmVyYWwgdXNlLlxuLy8gVGhleSBhcmUgaGVyZSBvbmx5IGZvciBpbnRlcm5hbCB1c2UgYnkgdGhlIHtDRH0gZW52aXJvbm1lbnQgaW4gcGxhY2luZyBsYWJlbHNcbi8vIG5leHQgdG8gdmVydGljYWwgYXJyb3dzLlxuLy8gV2UgZG9uJ3QgbmVlZCBhbnkgc3VjaCBmdW5jdGlvbnMgZm9yIGhvcml6b250YWwgYXJyb3dzIGJlY2F1c2Ugd2UgY2FuIHJldXNlXG4vLyB0aGUgZnVuY3Rpb25hbGl0eSB0aGF0IGFscmVhZHkgZXhpc3RzIGZvciBleHRlbnNpYmxlIGFycm93cy5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImNkbGFiZWxcIixcbiAgbmFtZXM6IFtcIlxcXFxcXFxcY2RsZWZ0XCIsIFwiXFxcXFxcXFxjZHJpZ2h0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjZGxhYmVsXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHNpZGU6IGZ1bmNOYW1lLnNsaWNlKDQpLFxuICAgICAgbGFiZWw6IGFyZ3NbMF1cbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKG9wdGlvbnMuc3R5bGUuc3VwKCkpO1xuICAgIHZhciBsYWJlbCA9IGJ1aWxkQ29tbW9uLndyYXBGcmFnbWVudChidWlsZEdyb3VwJDEoZ3JvdXAubGFiZWwsIG5ld09wdGlvbnMsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICBsYWJlbC5jbGFzc2VzLnB1c2goXCJjZC1sYWJlbC1cIiArIGdyb3VwLnNpZGUpO1xuICAgIGxhYmVsLnN0eWxlLmJvdHRvbSA9IG1ha2VFbSgwLjggLSBsYWJlbC5kZXB0aCk7IC8vIFplcm8gb3V0IGxhYmVsIGhlaWdodCAmIGRlcHRoLCBzbyB2ZXJ0aWNhbCBhbGlnbiBvZiBhcnJvdyBpcyBzZXRcbiAgICAvLyBieSB0aGUgYXJyb3cgaGVpZ2h0LCBub3QgYnkgdGhlIGxhYmVsLlxuXG4gICAgbGFiZWwuaGVpZ2h0ID0gMDtcbiAgICBsYWJlbC5kZXB0aCA9IDA7XG4gICAgcmV0dXJuIGxhYmVsO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbGFiZWwgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW2J1aWxkR3JvdXAoZ3JvdXAubGFiZWwsIG9wdGlvbnMpXSk7XG4gICAgbGFiZWwgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW2xhYmVsXSk7XG4gICAgbGFiZWwuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwXCIpO1xuXG4gICAgaWYgKGdyb3VwLnNpZGUgPT09IFwibGVmdFwiKSB7XG4gICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCItMXdpZHRoXCIpO1xuICAgIH0gLy8gV2UgaGF2ZSB0byBndWVzcyBhdCB2ZXJ0aWNhbCBhbGlnbm1lbnQuIFdlIGtub3cgdGhlIGFycm93IGlzIDEuOGVtIHRhbGwsXG4gICAgLy8gQnV0IHdlIGRvbid0IGtub3cgdGhlIGhlaWdodCBvciBkZXB0aCBvZiB0aGUgbGFiZWwuXG5cblxuICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcInZvZmZzZXRcIiwgXCIwLjdlbVwiKTtcbiAgICBsYWJlbCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXN0eWxlXCIsIFtsYWJlbF0pO1xuICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcImRpc3BsYXlzdHlsZVwiLCBcImZhbHNlXCIpO1xuICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcInNjcmlwdGxldmVsXCIsIFwiMVwiKTtcbiAgICByZXR1cm4gbGFiZWw7XG4gIH1cblxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY2RsYWJlbHBhcmVudFwiLFxuICBuYW1lczogW1wiXFxcXFxcXFxjZHBhcmVudFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmMiwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY2RsYWJlbHBhcmVudFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBmcmFnbWVudDogYXJnc1swXVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBXcmFwIHRoZSB2ZXJ0aWNhbCBhcnJvdyBhbmQgaXRzIGxhYmVscy5cbiAgICAvLyBUaGUgcGFyZW50IGdldHMgcG9zaXRpb246IHJlbGF0aXZlLiBUaGUgY2hpbGQgZ2V0cyBwb3NpdGlvbjogYWJzb2x1dGUuXG4gICAgLy8gU28gQ1NTIGNhbiBsb2NhdGUgdGhlIGxhYmVsIGNvcnJlY3RseS5cbiAgICB2YXIgcGFyZW50ID0gYnVpbGRDb21tb24ud3JhcEZyYWdtZW50KGJ1aWxkR3JvdXAkMShncm91cC5mcmFnbWVudCwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIHBhcmVudC5jbGFzc2VzLnB1c2goXCJjZC12ZXJ0LWFycm93XCIpO1xuICAgIHJldHVybiBwYXJlbnQ7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW2J1aWxkR3JvdXAoZ3JvdXAuZnJhZ21lbnQsIG9wdGlvbnMpXSk7XG4gIH1cblxufSk7XG5cbi8vIHsxMjN9IGFuZCBjb252ZXJ0cyBpbnRvIHN5bWJvbCB3aXRoIGNvZGUgMTIzLiAgSXQgaXMgdXNlZCBieSB0aGUgKm1hY3JvKlxuLy8gXFxjaGFyIGRlZmluZWQgaW4gbWFjcm9zLmpzLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidGV4dG9yZFwiLFxuICBuYW1lczogW1wiXFxcXEBjaGFyXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgYXJnID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJvcmRncm91cFwiKTtcbiAgICB2YXIgZ3JvdXAgPSBhcmcuYm9keTtcbiAgICB2YXIgbnVtYmVyID0gXCJcIjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gYXNzZXJ0Tm9kZVR5cGUoZ3JvdXBbaV0sIFwidGV4dG9yZFwiKTtcbiAgICAgIG51bWJlciArPSBub2RlLnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNvZGUgPSBwYXJzZUludChudW1iZXIpO1xuICAgIHZhciB0ZXh0O1xuXG4gICAgaWYgKGlzTmFOKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFxAY2hhciBoYXMgbm9uLW51bWVyaWMgYXJndW1lbnQgXCIgKyBudW1iZXIpOyAvLyBJZiB3ZSBkcm9wIElFIHN1cHBvcnQsIHRoZSBmb2xsb3dpbmcgY29kZSBjb3VsZCBiZSByZXBsYWNlZCB3aXRoXG4gICAgICAvLyB0ZXh0ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZSlcbiAgICB9IGVsc2UgaWYgKGNvZGUgPCAwIHx8IGNvZGUgPj0gMHgxMGZmZmYpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiXFxcXEBjaGFyIHdpdGggaW52YWxpZCBjb2RlIHBvaW50IFwiICsgbnVtYmVyKTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPD0gMHhmZmZmKSB7XG4gICAgICB0ZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXN0cmFsIGNvZGUgcG9pbnQ7IHNwbGl0IGludG8gc3Vycm9nYXRlIGhhbHZlc1xuICAgICAgY29kZSAtPSAweDEwMDAwO1xuICAgICAgdGV4dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGUgPj4gMTApICsgMHhkODAwLCAoY29kZSAmIDB4M2ZmKSArIDB4ZGMwMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICB0ZXh0OiB0ZXh0XG4gICAgfTtcbiAgfVxuXG59KTtcblxudmFyIGh0bWxCdWlsZGVyJDggPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uJDEoZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoQ29sb3IoZ3JvdXAuY29sb3IpLCBmYWxzZSk7IC8vIFxcY29sb3IgaXNuJ3Qgc3VwcG9zZWQgdG8gYWZmZWN0IHRoZSB0eXBlIG9mIHRoZSBlbGVtZW50cyBpdCBjb250YWlucy5cbiAgLy8gVG8gYWNjb21wbGlzaCB0aGlzLCB3ZSB3cmFwIHRoZSByZXN1bHRzIGluIGEgZnJhZ21lbnQsIHNvIHRoZSBpbm5lclxuICAvLyBlbGVtZW50cyB3aWxsIGJlIGFibGUgdG8gZGlyZWN0bHkgaW50ZXJhY3Qgd2l0aCB0aGVpciBuZWlnaGJvcnMuIEZvclxuICAvLyBleGFtcGxlLCBgXFxjb2xvcntyZWR9ezIgK30gM2AgaGFzIHRoZSBzYW1lIHNwYWNpbmcgYXMgYDIgKyAzYFxuXG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoZWxlbWVudHMpO1xufTtcblxudmFyIG1hdGhtbEJ1aWxkZXIkNyA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoQ29sb3IoZ3JvdXAuY29sb3IpKTtcbiAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG4gIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aGNvbG9yXCIsIGdyb3VwLmNvbG9yKTtcbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY29sb3JcIixcbiAgbmFtZXM6IFtcIlxcXFx0ZXh0Y29sb3JcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFyZ1R5cGVzOiBbXCJjb2xvclwiLCBcIm9yaWdpbmFsXCJdXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIHZhciBjb2xvciA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwiY29sb3ItdG9rZW5cIikuY29sb3I7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzFdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGNvbG9yLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ4LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDdcbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImNvbG9yXCIsXG4gIG5hbWVzOiBbXCJcXFxcY29sb3JcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFyZ1R5cGVzOiBbXCJjb2xvclwiXVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjIsIGFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgYnJlYWtPblRva2VuVGV4dFxuICAgIH0gPSBfcmVmMjtcbiAgICB2YXIgY29sb3IgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcImNvbG9yLXRva2VuXCIpLmNvbG9yOyAvLyBTZXQgbWFjcm8gXFxjdXJyZW50QGNvbG9yIGluIGN1cnJlbnQgbmFtZXNwYWNlIHRvIHN0b3JlIHRoZSBjdXJyZW50XG4gICAgLy8gY29sb3IsIG1pbWlja2luZyB0aGUgYmVoYXZpb3Igb2YgY29sb3Iuc3R5LlxuICAgIC8vIFRoaXMgaXMgY3VycmVudGx5IHVzZWQganVzdCB0byBjb3JyZWN0bHkgY29sb3IgYSBcXHJpZ2h0XG4gICAgLy8gdGhhdCBmb2xsb3dzIGEgXFxjb2xvciBjb21tYW5kLlxuXG4gICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXGN1cnJlbnRAY29sb3JcIiwgY29sb3IpOyAvLyBQYXJzZSBvdXQgdGhlIGltcGxpY2l0IGJvZHkgdGhhdCBzaG91bGQgYmUgY29sb3JlZC5cblxuICAgIHZhciBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbih0cnVlLCBicmVha09uVG9rZW5UZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBjb2xvcixcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ4LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDdcbn0pO1xuXG4vLyBSb3cgYnJlYWtzIHdpdGhpbiB0YWJ1bGFyIGVudmlyb25tZW50cywgYW5kIGxpbmUgYnJlYWtzIGF0IHRvcCBsZXZlbFxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY3JcIixcbiAgbmFtZXM6IFtcIlxcXFxcXFxcXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIHNpemUgPSBwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpLnRleHQgPT09IFwiW1wiID8gcGFyc2VyLnBhcnNlU2l6ZUdyb3VwKHRydWUpIDogbnVsbDtcbiAgICB2YXIgbmV3TGluZSA9ICFwYXJzZXIuc2V0dGluZ3MuZGlzcGxheU1vZGUgfHwgIXBhcnNlci5zZXR0aW5ncy51c2VTdHJpY3RCZWhhdmlvcihcIm5ld0xpbmVJbkRpc3BsYXlNb2RlXCIsIFwiSW4gTGFUZVgsIFxcXFxcXFxcIG9yIFxcXFxuZXdsaW5lIFwiICsgXCJkb2VzIG5vdGhpbmcgaW4gZGlzcGxheSBtb2RlXCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNyXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG5ld0xpbmUsXG4gICAgICBzaXplOiBzaXplICYmIGFzc2VydE5vZGVUeXBlKHNpemUsIFwic2l6ZVwiKS52YWx1ZVxuICAgIH07XG4gIH0sXG5cbiAgLy8gVGhlIGZvbGxvd2luZyBidWlsZGVycyBhcmUgY2FsbGVkIG9ubHkgYXQgdGhlIHRvcCBsZXZlbCxcbiAgLy8gbm90IHdpdGhpbiB0YWJ1bGFyL2FycmF5IGVudmlyb25tZW50cy5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgc3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1zcGFjZVwiXSwgW10sIG9wdGlvbnMpO1xuXG4gICAgaWYgKGdyb3VwLm5ld0xpbmUpIHtcbiAgICAgIHNwYW4uY2xhc3Nlcy5wdXNoKFwibmV3bGluZVwiKTtcblxuICAgICAgaWYgKGdyb3VwLnNpemUpIHtcbiAgICAgICAgc3Bhbi5zdHlsZS5tYXJnaW5Ub3AgPSBtYWtlRW0oY2FsY3VsYXRlU2l6ZShncm91cC5zaXplLCBvcHRpb25zKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwYW47XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG5cbiAgICBpZiAoZ3JvdXAubmV3TGluZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5lYnJlYWtcIiwgXCJuZXdsaW5lXCIpO1xuXG4gICAgICBpZiAoZ3JvdXAuc2l6ZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBtYWtlRW0oY2FsY3VsYXRlU2l6ZShncm91cC5zaXplLCBvcHRpb25zKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuXG52YXIgZ2xvYmFsTWFwID0ge1xuICBcIlxcXFxnbG9iYWxcIjogXCJcXFxcZ2xvYmFsXCIsXG4gIFwiXFxcXGxvbmdcIjogXCJcXFxcXFxcXGdsb2JhbGxvbmdcIixcbiAgXCJcXFxcXFxcXGdsb2JhbGxvbmdcIjogXCJcXFxcXFxcXGdsb2JhbGxvbmdcIixcbiAgXCJcXFxcZGVmXCI6IFwiXFxcXGdkZWZcIixcbiAgXCJcXFxcZ2RlZlwiOiBcIlxcXFxnZGVmXCIsXG4gIFwiXFxcXGVkZWZcIjogXCJcXFxceGRlZlwiLFxuICBcIlxcXFx4ZGVmXCI6IFwiXFxcXHhkZWZcIixcbiAgXCJcXFxcbGV0XCI6IFwiXFxcXFxcXFxnbG9iYWxsZXRcIixcbiAgXCJcXFxcZnV0dXJlbGV0XCI6IFwiXFxcXFxcXFxnbG9iYWxmdXR1cmVcIlxufTtcblxudmFyIGNoZWNrQ29udHJvbFNlcXVlbmNlID0gdG9rID0+IHtcbiAgdmFyIG5hbWUgPSB0b2sudGV4dDtcblxuICBpZiAoL14oPzpbXFxcXHt9JCYjXl9dfEVPRikkLy50ZXN0KG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCBhIGNvbnRyb2wgc2VxdWVuY2VcIiwgdG9rKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lO1xufTtcblxudmFyIGdldFJIUyA9IHBhcnNlciA9PiB7XG4gIHZhciB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG5cbiAgaWYgKHRvay50ZXh0ID09PSBcIj1cIikge1xuICAgIC8vIGNvbnN1bWUgb3B0aW9uYWwgZXF1YWxzXG4gICAgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuXG4gICAgaWYgKHRvay50ZXh0ID09PSBcIiBcIikge1xuICAgICAgLy8gY29uc3VtZSBvbmUgb3B0aW9uYWwgc3BhY2VcbiAgICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9rO1xufTtcblxudmFyIGxldENvbW1hbmQgPSAocGFyc2VyLCBuYW1lLCB0b2ssIGdsb2JhbCkgPT4ge1xuICB2YXIgbWFjcm8gPSBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5nZXQodG9rLnRleHQpO1xuXG4gIGlmIChtYWNybyA9PSBudWxsKSB7XG4gICAgLy8gZG9uJ3QgZXhwYW5kIGl0IGxhdGVyIGV2ZW4gaWYgYSBtYWNybyB3aXRoIHRoZSBzYW1lIG5hbWUgaXMgZGVmaW5lZFxuICAgIC8vIGUuZy4sIFxcbGV0XFxmb289XFxmcmFjIFxcZGVmXFxmcmFje1xccmVsYXh9IFxcZnJhYzEyXG4gICAgdG9rLm5vZXhwYW5kID0gdHJ1ZTtcbiAgICBtYWNybyA9IHtcbiAgICAgIHRva2VuczogW3Rva10sXG4gICAgICBudW1BcmdzOiAwLFxuICAgICAgLy8gcmVwcm9kdWNlIHRoZSBzYW1lIGJlaGF2aW9yIGluIGV4cGFuc2lvblxuICAgICAgdW5leHBhbmRhYmxlOiAhcGFyc2VyLmd1bGxldC5pc0V4cGFuZGFibGUodG9rLnRleHQpXG4gICAgfTtcbiAgfVxuXG4gIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChuYW1lLCBtYWNybywgZ2xvYmFsKTtcbn07IC8vIDxhc3NpZ25tZW50PiAtPiA8bm9uLW1hY3JvIGFzc2lnbm1lbnQ+fDxtYWNybyBhc3NpZ25tZW50PlxuLy8gPG5vbi1tYWNybyBhc3NpZ25tZW50PiAtPiA8c2ltcGxlIGFzc2lnbm1lbnQ+fFxcZ2xvYmFsPG5vbi1tYWNybyBhc3NpZ25tZW50PlxuLy8gPG1hY3JvIGFzc2lnbm1lbnQ+IC0+IDxkZWZpbml0aW9uPnw8cHJlZml4PjxtYWNybyBhc3NpZ25tZW50PlxuLy8gPHByZWZpeD4gLT4gXFxnbG9iYWx8XFxsb25nfFxcb3V0ZXJcblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcIlxcXFxnbG9iYWxcIiwgXCJcXFxcbG9uZ1wiLCBcIlxcXFxcXFxcZ2xvYmFsbG9uZ1wiIC8vIGNhbuKAmXQgYmUgZW50ZXJlZCBkaXJlY3RseVxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZikge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gICAgdmFyIHRva2VuID0gcGFyc2VyLmZldGNoKCk7XG5cbiAgICBpZiAoZ2xvYmFsTWFwW3Rva2VuLnRleHRdKSB7XG4gICAgICAvLyBLYVRlWCBkb2Vzbid0IGhhdmUgXFxwYXIsIHNvIGlnbm9yZSBcXGxvbmdcbiAgICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcZ2xvYmFsXCIgfHwgZnVuY05hbWUgPT09IFwiXFxcXFxcXFxnbG9iYWxsb25nXCIpIHtcbiAgICAgICAgdG9rZW4udGV4dCA9IGdsb2JhbE1hcFt0b2tlbi50ZXh0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFzc2VydE5vZGVUeXBlKHBhcnNlci5wYXJzZUZ1bmN0aW9uKCksIFwiaW50ZXJuYWxcIik7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIHRva2VuIGFmdGVyIG1hY3JvIHByZWZpeFwiLCB0b2tlbik7XG4gIH1cblxufSk7IC8vIEJhc2ljIHN1cHBvcnQgZm9yIG1hY3JvIGRlZmluaXRpb25zOiBcXGRlZiwgXFxnZGVmLCBcXGVkZWYsIFxceGRlZlxuLy8gPGRlZmluaXRpb24+IC0+IDxkZWY+PGNvbnRyb2wgc2VxdWVuY2U+PGRlZmluaXRpb24gdGV4dD5cbi8vIDxkZWY+IC0+IFxcZGVmfFxcZ2RlZnxcXGVkZWZ8XFx4ZGVmXG4vLyA8ZGVmaW5pdGlvbiB0ZXh0PiAtPiA8cGFyYW1ldGVyIHRleHQ+PGxlZnQgYnJhY2U+PGJhbGFuY2VkIHRleHQ+PHJpZ2h0IGJyYWNlPlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcIlxcXFxkZWZcIiwgXCJcXFxcZ2RlZlwiLCBcIlxcXFxlZGVmXCIsIFwiXFxcXHhkZWZcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjIpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjI7XG4gICAgdmFyIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICB2YXIgbmFtZSA9IHRvay50ZXh0O1xuXG4gICAgaWYgKC9eKD86W1xcXFx7fSQmI15fXXxFT0YpJC8udGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCBhIGNvbnRyb2wgc2VxdWVuY2VcIiwgdG9rKTtcbiAgICB9XG5cbiAgICB2YXIgbnVtQXJncyA9IDA7XG4gICAgdmFyIGluc2VydDtcbiAgICB2YXIgZGVsaW1pdGVycyA9IFtbXV07IC8vIDxwYXJhbWV0ZXIgdGV4dD4gY29udGFpbnMgbm8gYnJhY2VzXG5cbiAgICB3aGlsZSAocGFyc2VyLmd1bGxldC5mdXR1cmUoKS50ZXh0ICE9PSBcIntcIikge1xuICAgICAgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuXG4gICAgICBpZiAodG9rLnRleHQgPT09IFwiI1wiKSB7XG4gICAgICAgIC8vIElmIHRoZSB2ZXJ5IGxhc3QgY2hhcmFjdGVyIG9mIHRoZSA8cGFyYW1ldGVyIHRleHQ+IGlzICMsIHNvIHRoYXRcbiAgICAgICAgLy8gdGhpcyAjIGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHssIFRlWCB3aWxsIGJlaGF2ZSBhcyBpZiB0aGUge1xuICAgICAgICAvLyBoYWQgYmVlbiBpbnNlcnRlZCBhdCB0aGUgcmlnaHQgZW5kIG9mIGJvdGggdGhlIHBhcmFtZXRlciB0ZXh0XG4gICAgICAgIC8vIGFuZCB0aGUgcmVwbGFjZW1lbnQgdGV4dC5cbiAgICAgICAgaWYgKHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dCA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICBpbnNlcnQgPSBwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpO1xuICAgICAgICAgIGRlbGltaXRlcnNbbnVtQXJnc10ucHVzaChcIntcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gQSBwYXJhbWV0ZXIsIHRoZSBmaXJzdCBhcHBlYXJhbmNlIG9mICMgbXVzdCBiZSBmb2xsb3dlZCBieSAxLFxuICAgICAgICAvLyB0aGUgbmV4dCBieSAyLCBhbmQgc28gb247IHVwIHRvIG5pbmUgI+KAmXMgYXJlIGFsbG93ZWRcblxuXG4gICAgICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcblxuICAgICAgICBpZiAoIS9eWzEtOV0kLy50ZXN0KHRvay50ZXh0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudCBudW1iZXIgXFxcIlwiICsgdG9rLnRleHQgKyBcIlxcXCJcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VJbnQodG9rLnRleHQpICE9PSBudW1BcmdzICsgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiQXJndW1lbnQgbnVtYmVyIFxcXCJcIiArIHRvay50ZXh0ICsgXCJcXFwiIG91dCBvZiBvcmRlclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG51bUFyZ3MrKztcbiAgICAgICAgZGVsaW1pdGVycy5wdXNoKFtdKTtcbiAgICAgIH0gZWxzZSBpZiAodG9rLnRleHQgPT09IFwiRU9GXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCBhIG1hY3JvIGRlZmluaXRpb25cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxpbWl0ZXJzW251bUFyZ3NdLnB1c2godG9rLnRleHQpO1xuICAgICAgfVxuICAgIH0gLy8gcmVwbGFjZW1lbnQgdGV4dCwgZW5jbG9zZWQgaW4gJ3snIGFuZCAnfScgYW5kIHByb3Blcmx5IG5lc3RlZFxuXG5cbiAgICB2YXIge1xuICAgICAgdG9rZW5zXG4gICAgfSA9IHBhcnNlci5ndWxsZXQuY29uc3VtZUFyZygpO1xuXG4gICAgaWYgKGluc2VydCkge1xuICAgICAgdG9rZW5zLnVuc2hpZnQoaW5zZXJ0KTtcbiAgICB9XG5cbiAgICBpZiAoZnVuY05hbWUgPT09IFwiXFxcXGVkZWZcIiB8fCBmdW5jTmFtZSA9PT0gXCJcXFxceGRlZlwiKSB7XG4gICAgICB0b2tlbnMgPSBwYXJzZXIuZ3VsbGV0LmV4cGFuZFRva2Vucyh0b2tlbnMpO1xuICAgICAgdG9rZW5zLnJldmVyc2UoKTsgLy8gdG8gZml0IGluIHdpdGggc3RhY2sgb3JkZXJcbiAgICB9IC8vIEZpbmFsIGFyZyBpcyB0aGUgZXhwYW5zaW9uIG9mIHRoZSBtYWNyb1xuXG5cbiAgICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQobmFtZSwge1xuICAgICAgdG9rZW5zLFxuICAgICAgbnVtQXJncyxcbiAgICAgIGRlbGltaXRlcnNcbiAgICB9LCBmdW5jTmFtZSA9PT0gZ2xvYmFsTWFwW2Z1bmNOYW1lXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlXG4gICAgfTtcbiAgfVxuXG59KTsgLy8gPHNpbXBsZSBhc3NpZ25tZW50PiAtPiA8bGV0IGFzc2lnbm1lbnQ+XG4vLyA8bGV0IGFzc2lnbm1lbnQ+IC0+IFxcZnV0dXJlbGV0PGNvbnRyb2wgc2VxdWVuY2U+PHRva2VuPjx0b2tlbj5cbi8vICAgICB8IFxcbGV0PGNvbnRyb2wgc2VxdWVuY2U+PGVxdWFscz48b25lIG9wdGlvbmFsIHNwYWNlPjx0b2tlbj5cbi8vIDxlcXVhbHM+IC0+IDxvcHRpb25hbCBzcGFjZXM+fDxvcHRpb25hbCBzcGFjZXM+PVxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcIlxcXFxsZXRcIiwgXCJcXFxcXFxcXGdsb2JhbGxldFwiIC8vIGNhbuKAmXQgYmUgZW50ZXJlZCBkaXJlY3RseVxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWYzO1xuICAgIHZhciBuYW1lID0gY2hlY2tDb250cm9sU2VxdWVuY2UocGFyc2VyLmd1bGxldC5wb3BUb2tlbigpKTtcbiAgICBwYXJzZXIuZ3VsbGV0LmNvbnN1bWVTcGFjZXMoKTtcbiAgICB2YXIgdG9rID0gZ2V0UkhTKHBhcnNlcik7XG4gICAgbGV0Q29tbWFuZChwYXJzZXIsIG5hbWUsIHRvaywgZnVuY05hbWUgPT09IFwiXFxcXFxcXFxnbG9iYWxsZXRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlXG4gICAgfTtcbiAgfVxuXG59KTsgLy8gcmVmOiBodHRwczovL3d3dy50dWcub3JnL1RVR2JvYXQvdGIwOS0zL3RiMjJiZWNodG9sc2hlaW0ucGRmXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbnRlcm5hbFwiLFxuICBuYW1lczogW1wiXFxcXGZ1dHVyZWxldFwiLCBcIlxcXFxcXFxcZ2xvYmFsZnV0dXJlXCIgLy8gY2Fu4oCZdCBiZSBlbnRlcmVkIGRpcmVjdGx5XG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjQpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjQ7XG4gICAgdmFyIG5hbWUgPSBjaGVja0NvbnRyb2xTZXF1ZW5jZShwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCkpO1xuICAgIHZhciBtaWRkbGUgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgdmFyIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICBsZXRDb21tYW5kKHBhcnNlciwgbmFtZSwgdG9rLCBmdW5jTmFtZSA9PT0gXCJcXFxcXFxcXGdsb2JhbGZ1dHVyZVwiKTtcbiAgICBwYXJzZXIuZ3VsbGV0LnB1c2hUb2tlbih0b2spO1xuICAgIHBhcnNlci5ndWxsZXQucHVzaFRva2VuKG1pZGRsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlXG4gICAgfTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgZGVhbHMgd2l0aCBjcmVhdGluZyBkZWxpbWl0ZXJzIG9mIHZhcmlvdXMgc2l6ZXMuIFRoZSBUZVhib29rXG4gKiBkaXNjdXNzZXMgdGhlc2Ugcm91dGluZXMgb24gcGFnZSA0NDEtNDQyLCBpbiB0aGUgXCJBbm90aGVyIHN1YnJvdXRpbmUgc2V0cyBib3hcbiAqIHggdG8gYSBzcGVjaWZpZWQgdmFyaWFibGUgZGVsaW1pdGVyXCIgcGFyYWdyYXBoLlxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSBtYWluIHJvdXRpbmVzIGhlcmUuIGBtYWtlU21hbGxEZWxpbWAgbWFrZXMgYSBkZWxpbWl0ZXIgaW4gdGhlXG4gKiBub3JtYWwgZm9udCwgYnV0IGluIGVpdGhlciB0ZXh0LCBzY3JpcHQsIG9yIHNjcmlwdHNjcmlwdCBzdHlsZS5cbiAqIGBtYWtlTGFyZ2VEZWxpbWAgbWFrZXMgYSBkZWxpbWl0ZXIgaW4gdGV4dHN0eWxlLCBidXQgaW4gb25lIG9mIHRoZSBTaXplMSxcbiAqIFNpemUyLCBTaXplMywgb3IgU2l6ZTQgZm9udHMuIGBtYWtlU3RhY2tlZERlbGltYCBtYWtlcyBhIGRlbGltaXRlciBvdXQgb2ZcbiAqIHNtYWxsZXIgcGllY2VzIHRoYXQgYXJlIHN0YWNrZWQgb24gdG9wIG9mIG9uZSBhbm90aGVyLlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgdGFrZSBhIHBhcmFtZXRlciBgY2VudGVyYCwgd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgZGVsaW1pdGVyXG4gKiBzaG91bGQgYmUgY2VudGVyZWQgYXJvdW5kIHRoZSBheGlzLlxuICpcbiAqIFRoZW4sIHRoZXJlIGFyZSB0aHJlZSBleHBvc2VkIGZ1bmN0aW9ucy4gYHNpemVkRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIGluXG4gKiBvbmUgb2YgdGhlIGdpdmVuIHNpemVzLiBUaGlzIGlzIHVzZWQgZm9yIHRoaW5ncyBsaWtlIGBcXGJpZ2xgLlxuICogYGN1c3RvbVNpemVkRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIHdpdGggYSBnaXZlbiB0b3RhbCBoZWlnaHQrZGVwdGguIEl0IGlzXG4gKiBjYWxsZWQgaW4gcGxhY2VzIGxpa2UgYFxcc3FydGAuIGBsZWZ0UmlnaHREZWxpbWAgbWFrZXMgYW4gYXBwcm9wcmlhdGVcbiAqIGRlbGltaXRlciB3aGljaCBzdXJyb3VuZHMgYW4gZXhwcmVzc2lvbiBvZiBhIGdpdmVuIGhlaWdodCBhbiBkZXB0aC4gSXQgaXNcbiAqIHVzZWQgaW4gYFxcbGVmdGAgYW5kIGBcXHJpZ2h0YC5cbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgbWV0cmljcyBmb3IgYSBnaXZlbiBzeW1ib2wgYW5kIGZvbnQsIGFmdGVyIHRyYW5zZm9ybWF0aW9uIChpLmUuXG4gKiBhZnRlciBmb2xsb3dpbmcgcmVwbGFjZW1lbnQgZnJvbSBzeW1ib2xzLmpzKVxuICovXG52YXIgZ2V0TWV0cmljcyA9IGZ1bmN0aW9uIGdldE1ldHJpY3Moc3ltYm9sLCBmb250LCBtb2RlKSB7XG4gIHZhciByZXBsYWNlID0gc3ltYm9scy5tYXRoW3N5bWJvbF0gJiYgc3ltYm9scy5tYXRoW3N5bWJvbF0ucmVwbGFjZTtcbiAgdmFyIG1ldHJpY3MgPSBnZXRDaGFyYWN0ZXJNZXRyaWNzKHJlcGxhY2UgfHwgc3ltYm9sLCBmb250LCBtb2RlKTtcblxuICBpZiAoIW1ldHJpY3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBzeW1ib2wgXCIgKyBzeW1ib2wgKyBcIiBhbmQgZm9udCBzaXplIFwiICsgZm9udCArIFwiLlwiKTtcbiAgfVxuXG4gIHJldHVybiBtZXRyaWNzO1xufTtcbi8qKlxuICogUHV0cyBhIGRlbGltaXRlciBzcGFuIGluIGEgZ2l2ZW4gc3R5bGUsIGFuZCBhZGRzIGFwcHJvcHJpYXRlIGhlaWdodCwgZGVwdGgsXG4gKiBhbmQgbWF4Rm9udFNpemVzLlxuICovXG5cblxudmFyIHN0eWxlV3JhcCA9IGZ1bmN0aW9uIHN0eWxlV3JhcChkZWxpbSwgdG9TdHlsZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nQmFzZVN0eWxlKHRvU3R5bGUpO1xuICB2YXIgc3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKGNsYXNzZXMuY29uY2F0KG5ld09wdGlvbnMuc2l6aW5nQ2xhc3NlcyhvcHRpb25zKSksIFtkZWxpbV0sIG9wdGlvbnMpO1xuICB2YXIgZGVsaW1TaXplTXVsdGlwbGllciA9IG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXIgLyBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICBzcGFuLmhlaWdodCAqPSBkZWxpbVNpemVNdWx0aXBsaWVyO1xuICBzcGFuLmRlcHRoICo9IGRlbGltU2l6ZU11bHRpcGxpZXI7XG4gIHNwYW4ubWF4Rm9udFNpemUgPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICByZXR1cm4gc3Bhbjtcbn07XG5cbnZhciBjZW50ZXJTcGFuID0gZnVuY3Rpb24gY2VudGVyU3BhbihzcGFuLCBvcHRpb25zLCBzdHlsZSkge1xuICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nQmFzZVN0eWxlKHN0eWxlKTtcbiAgdmFyIHNoaWZ0ID0gKDEgLSBvcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllcikgKiBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDtcbiAgc3Bhbi5jbGFzc2VzLnB1c2goXCJkZWxpbWNlbnRlclwiKTtcbiAgc3Bhbi5zdHlsZS50b3AgPSBtYWtlRW0oc2hpZnQpO1xuICBzcGFuLmhlaWdodCAtPSBzaGlmdDtcbiAgc3Bhbi5kZXB0aCArPSBzaGlmdDtcbn07XG4vKipcbiAqIE1ha2VzIGEgc21hbGwgZGVsaW1pdGVyLiBUaGlzIGlzIGEgZGVsaW1pdGVyIHRoYXQgY29tZXMgaW4gdGhlIE1haW4tUmVndWxhclxuICogZm9udCwgYnV0IGlzIHJlc3R5bGVkIHRvIGVpdGhlciBiZSBpbiB0ZXh0c3R5bGUsIHNjcmlwdHN0eWxlLCBvclxuICogc2NyaXB0c2NyaXB0c3R5bGUuXG4gKi9cblxuXG52YXIgbWFrZVNtYWxsRGVsaW0gPSBmdW5jdGlvbiBtYWtlU21hbGxEZWxpbShkZWxpbSwgc3R5bGUsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICB2YXIgdGV4dCA9IGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2woZGVsaW0sIFwiTWFpbi1SZWd1bGFyXCIsIG1vZGUsIG9wdGlvbnMpO1xuICB2YXIgc3BhbiA9IHN0eWxlV3JhcCh0ZXh0LCBzdHlsZSwgb3B0aW9ucywgY2xhc3Nlcyk7XG5cbiAgaWYgKGNlbnRlcikge1xuICAgIGNlbnRlclNwYW4oc3Bhbiwgb3B0aW9ucywgc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHNwYW47XG59O1xuLyoqXG4gKiBCdWlsZHMgYSBzeW1ib2wgaW4gdGhlIGdpdmVuIGZvbnQgc2l6ZSAobm90ZSBzaXplIGlzIGFuIGludGVnZXIpXG4gKi9cblxuXG52YXIgbWF0aHJtU2l6ZSA9IGZ1bmN0aW9uIG1hdGhybVNpemUodmFsdWUsIHNpemUsIG1vZGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2wodmFsdWUsIFwiU2l6ZVwiICsgc2l6ZSArIFwiLVJlZ3VsYXJcIiwgbW9kZSwgb3B0aW9ucyk7XG59O1xuLyoqXG4gKiBNYWtlcyBhIGxhcmdlIGRlbGltaXRlci4gVGhpcyBpcyBhIGRlbGltaXRlciB0aGF0IGNvbWVzIGluIHRoZSBTaXplMSwgU2l6ZTIsXG4gKiBTaXplMywgb3IgU2l6ZTQgZm9udHMuIEl0IGlzIGFsd2F5cyByZW5kZXJlZCBpbiB0ZXh0c3R5bGUuXG4gKi9cblxuXG52YXIgbWFrZUxhcmdlRGVsaW0gPSBmdW5jdGlvbiBtYWtlTGFyZ2VEZWxpbShkZWxpbSwgc2l6ZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7XG4gIHZhciBpbm5lciA9IG1hdGhybVNpemUoZGVsaW0sIHNpemUsIG1vZGUsIG9wdGlvbnMpO1xuICB2YXIgc3BhbiA9IHN0eWxlV3JhcChidWlsZENvbW1vbi5tYWtlU3BhbihbXCJkZWxpbXNpemluZ1wiLCBcInNpemVcIiArIHNpemVdLCBbaW5uZXJdLCBvcHRpb25zKSwgU3R5bGUkMS5URVhULCBvcHRpb25zLCBjbGFzc2VzKTtcblxuICBpZiAoY2VudGVyKSB7XG4gICAgY2VudGVyU3BhbihzcGFuLCBvcHRpb25zLCBTdHlsZSQxLlRFWFQpO1xuICB9XG5cbiAgcmV0dXJuIHNwYW47XG59O1xuLyoqXG4gKiBNYWtlIGEgc3BhbiBmcm9tIGEgZm9udCBnbHlwaCB3aXRoIHRoZSBnaXZlbiBvZmZzZXQgYW5kIGluIHRoZSBnaXZlbiBmb250LlxuICogVGhpcyBpcyB1c2VkIGluIG1ha2VTdGFja2VkRGVsaW0gdG8gbWFrZSB0aGUgc3RhY2tpbmcgcGllY2VzIGZvciB0aGUgZGVsaW1pdGVyLlxuICovXG5cblxudmFyIG1ha2VHbHlwaFNwYW4gPSBmdW5jdGlvbiBtYWtlR2x5cGhTcGFuKHN5bWJvbCwgZm9udCwgbW9kZSkge1xuICB2YXIgc2l6ZUNsYXNzOyAvLyBBcHBseSB0aGUgY29ycmVjdCBDU1MgY2xhc3MgdG8gY2hvb3NlIHRoZSByaWdodCBmb250LlxuXG4gIGlmIChmb250ID09PSBcIlNpemUxLVJlZ3VsYXJcIikge1xuICAgIHNpemVDbGFzcyA9IFwiZGVsaW0tc2l6ZTFcIjtcbiAgfSBlbHNlXG4gICAgLyogaWYgKGZvbnQgPT09IFwiU2l6ZTQtUmVndWxhclwiKSAqL1xuICAgIHtcbiAgICAgIHNpemVDbGFzcyA9IFwiZGVsaW0tc2l6ZTRcIjtcbiAgICB9XG5cbiAgdmFyIGNvcm5lciA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImRlbGltc2l6aW5naW5uZXJcIiwgc2l6ZUNsYXNzXSwgW2J1aWxkQ29tbW9uLm1ha2VTcGFuKFtdLCBbYnVpbGRDb21tb24ubWFrZVN5bWJvbChzeW1ib2wsIGZvbnQsIG1vZGUpXSldKTsgLy8gU2luY2UgdGhpcyB3aWxsIGJlIHBhc3NlZCBpbnRvIGBtYWtlVkxpc3RgIGluIHRoZSBlbmQsIHdyYXAgdGhlIGVsZW1lbnRcbiAgLy8gaW4gdGhlIGFwcHJvcHJpYXRlIHRhZyB0aGF0IFZMaXN0IHVzZXMuXG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVsZW1cIixcbiAgICBlbGVtOiBjb3JuZXJcbiAgfTtcbn07XG5cbnZhciBtYWtlSW5uZXIgPSBmdW5jdGlvbiBtYWtlSW5uZXIoY2gsIGhlaWdodCwgb3B0aW9ucykge1xuICAvLyBDcmVhdGUgYSBzcGFuIHdpdGggaW5saW5lIFNWRyBmb3IgdGhlIGlubmVyIHBhcnQgb2YgYSB0YWxsIHN0YWNrZWQgZGVsaW1pdGVyLlxuICB2YXIgd2lkdGggPSBmb250TWV0cmljc0RhdGFbJ1NpemU0LVJlZ3VsYXInXVtjaC5jaGFyQ29kZUF0KDApXSA/IGZvbnRNZXRyaWNzRGF0YVsnU2l6ZTQtUmVndWxhciddW2NoLmNoYXJDb2RlQXQoMCldWzRdIDogZm9udE1ldHJpY3NEYXRhWydTaXplMS1SZWd1bGFyJ11bY2guY2hhckNvZGVBdCgwKV1bNF07XG4gIHZhciBwYXRoID0gbmV3IFBhdGhOb2RlKFwiaW5uZXJcIiwgaW5uZXJQYXRoKGNoLCBNYXRoLnJvdW5kKDEwMDAgKiBoZWlnaHQpKSk7XG4gIHZhciBzdmdOb2RlID0gbmV3IFN2Z05vZGUoW3BhdGhdLCB7XG4gICAgXCJ3aWR0aFwiOiBtYWtlRW0od2lkdGgpLFxuICAgIFwiaGVpZ2h0XCI6IG1ha2VFbShoZWlnaHQpLFxuICAgIC8vIE92ZXJyaWRlIENTUyBydWxlIGAua2F0ZXggc3ZnIHsgd2lkdGg6IDEwMCUgfWBcbiAgICBcInN0eWxlXCI6IFwid2lkdGg6XCIgKyBtYWtlRW0od2lkdGgpLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCBcIiArIDEwMDAgKiB3aWR0aCArIFwiIFwiICsgTWF0aC5yb3VuZCgxMDAwICogaGVpZ2h0KSxcbiAgICBcInByZXNlcnZlQXNwZWN0UmF0aW9cIjogXCJ4TWluWU1pblwiXG4gIH0pO1xuICB2YXIgc3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFtdLCBbc3ZnTm9kZV0sIG9wdGlvbnMpO1xuICBzcGFuLmhlaWdodCA9IGhlaWdodDtcbiAgc3Bhbi5zdHlsZS5oZWlnaHQgPSBtYWtlRW0oaGVpZ2h0KTtcbiAgc3Bhbi5zdHlsZS53aWR0aCA9IG1ha2VFbSh3aWR0aCk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJlbGVtXCIsXG4gICAgZWxlbTogc3BhblxuICB9O1xufTsgLy8gSGVscGVycyBmb3IgbWFrZVN0YWNrZWREZWxpbVxuXG5cbnZhciBsYXBJbkVtcyA9IDAuMDA4O1xudmFyIGxhcCA9IHtcbiAgdHlwZTogXCJrZXJuXCIsXG4gIHNpemU6IC0xICogbGFwSW5FbXNcbn07XG52YXIgdmVydHMgPSBbXCJ8XCIsIFwiXFxcXGx2ZXJ0XCIsIFwiXFxcXHJ2ZXJ0XCIsIFwiXFxcXHZlcnRcIl07XG52YXIgZG91YmxlVmVydHMgPSBbXCJcXFxcfFwiLCBcIlxcXFxsVmVydFwiLCBcIlxcXFxyVmVydFwiLCBcIlxcXFxWZXJ0XCJdO1xuLyoqXG4gKiBNYWtlIGEgc3RhY2tlZCBkZWxpbWl0ZXIgb3V0IG9mIGEgZ2l2ZW4gZGVsaW1pdGVyLCB3aXRoIHRoZSB0b3RhbCBoZWlnaHQgYXRcbiAqIGxlYXN0IGBoZWlnaHRUb3RhbGAuIFRoaXMgcm91dGluZSBpcyBtZW50aW9uZWQgb24gcGFnZSA0NDIgb2YgdGhlIFRlWGJvb2suXG4gKi9cblxudmFyIG1ha2VTdGFja2VkRGVsaW0gPSBmdW5jdGlvbiBtYWtlU3RhY2tlZERlbGltKGRlbGltLCBoZWlnaHRUb3RhbCwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7XG4gIC8vIFRoZXJlIGFyZSBmb3VyIHBhcnRzLCB0aGUgdG9wLCBhbiBvcHRpb25hbCBtaWRkbGUsIGEgcmVwZWF0ZWQgcGFydCwgYW5kIGFcbiAgLy8gYm90dG9tLlxuICB2YXIgdG9wO1xuICB2YXIgbWlkZGxlO1xuICB2YXIgcmVwZWF0O1xuICB2YXIgYm90dG9tO1xuICB2YXIgc3ZnTGFiZWwgPSBcIlwiO1xuICB2YXIgdmlld0JveFdpZHRoID0gMDtcbiAgdG9wID0gcmVwZWF0ID0gYm90dG9tID0gZGVsaW07XG4gIG1pZGRsZSA9IG51bGw7IC8vIEFsc28ga2VlcCB0cmFjayBvZiB3aGF0IGZvbnQgdGhlIGRlbGltaXRlcnMgYXJlIGluXG5cbiAgdmFyIGZvbnQgPSBcIlNpemUxLVJlZ3VsYXJcIjsgLy8gV2Ugc2V0IHRoZSBwYXJ0cyBhbmQgZm9udCBiYXNlZCBvbiB0aGUgc3ltYm9sLiBOb3RlIHRoYXQgd2UgdXNlXG4gIC8vICdcXHUyM2QwJyBpbnN0ZWFkIG9mICd8JyBhbmQgJ1xcdTIwMTYnIGluc3RlYWQgb2YgJ1xcXFx8JyBmb3IgdGhlXG4gIC8vIHJlcGVhdHMgb2YgdGhlIGFycm93c1xuXG4gIGlmIChkZWxpbSA9PT0gXCJcXFxcdXBhcnJvd1wiKSB7XG4gICAgcmVwZWF0ID0gYm90dG9tID0gXCJcXHUyM2QwXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXFVwYXJyb3dcIikge1xuICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjAxNlwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxkb3duYXJyb3dcIikge1xuICAgIHRvcCA9IHJlcGVhdCA9IFwiXFx1MjNkMFwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxEb3duYXJyb3dcIikge1xuICAgIHRvcCA9IHJlcGVhdCA9IFwiXFx1MjAxNlwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFx1cGRvd25hcnJvd1wiKSB7XG4gICAgdG9wID0gXCJcXFxcdXBhcnJvd1wiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjNkMFwiO1xuICAgIGJvdHRvbSA9IFwiXFxcXGRvd25hcnJvd1wiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxVcGRvd25hcnJvd1wiKSB7XG4gICAgdG9wID0gXCJcXFxcVXBhcnJvd1wiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjAxNlwiO1xuICAgIGJvdHRvbSA9IFwiXFxcXERvd25hcnJvd1wiO1xuICB9IGVsc2UgaWYgKHZlcnRzLmluY2x1ZGVzKGRlbGltKSkge1xuICAgIHJlcGVhdCA9IFwiXFx1MjIyM1wiO1xuICAgIHN2Z0xhYmVsID0gXCJ2ZXJ0XCI7XG4gICAgdmlld0JveFdpZHRoID0gMzMzO1xuICB9IGVsc2UgaWYgKGRvdWJsZVZlcnRzLmluY2x1ZGVzKGRlbGltKSkge1xuICAgIHJlcGVhdCA9IFwiXFx1MjIyNVwiO1xuICAgIHN2Z0xhYmVsID0gXCJkb3VibGV2ZXJ0XCI7XG4gICAgdmlld0JveFdpZHRoID0gNTU2O1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIltcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbGJyYWNrXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzYTFcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzYTJcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYTNcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgc3ZnTGFiZWwgPSBcImxicmFja1wiO1xuICAgIHZpZXdCb3hXaWR0aCA9IDY2NztcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJdXCIgfHwgZGVsaW0gPT09IFwiXFxcXHJicmFja1wiKSB7XG4gICAgdG9wID0gXCJcXHUyM2E0XCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyM2E1XCI7XG4gICAgYm90dG9tID0gXCJcXHUyM2E2XCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIHN2Z0xhYmVsID0gXCJyYnJhY2tcIjtcbiAgICB2aWV3Qm94V2lkdGggPSA2Njc7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGxmbG9vclwiIHx8IGRlbGltID09PSBcIlxcdTIzMGFcIikge1xuICAgIHJlcGVhdCA9IHRvcCA9IFwiXFx1MjNhMlwiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNhM1wiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICBzdmdMYWJlbCA9IFwibGZsb29yXCI7XG4gICAgdmlld0JveFdpZHRoID0gNjY3O1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxsY2VpbFwiIHx8IGRlbGltID09PSBcIlxcdTIzMDhcIikge1xuICAgIHRvcCA9IFwiXFx1MjNhMVwiO1xuICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjNhMlwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICBzdmdMYWJlbCA9IFwibGNlaWxcIjtcbiAgICB2aWV3Qm94V2lkdGggPSA2Njc7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHJmbG9vclwiIHx8IGRlbGltID09PSBcIlxcdTIzMGJcIikge1xuICAgIHJlcGVhdCA9IHRvcCA9IFwiXFx1MjNhNVwiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNhNlwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICBzdmdMYWJlbCA9IFwicmZsb29yXCI7XG4gICAgdmlld0JveFdpZHRoID0gNjY3O1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxyY2VpbFwiIHx8IGRlbGltID09PSBcIlxcdTIzMDlcIikge1xuICAgIHRvcCA9IFwiXFx1MjNhNFwiO1xuICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjNhNVwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICBzdmdMYWJlbCA9IFwicmNlaWxcIjtcbiAgICB2aWV3Qm94V2lkdGggPSA2Njc7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiKFwiIHx8IGRlbGltID09PSBcIlxcXFxscGFyZW5cIikge1xuICAgIHRvcCA9IFwiXFx1MjM5YlwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjM5Y1wiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjM5ZFwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICBzdmdMYWJlbCA9IFwibHBhcmVuXCI7XG4gICAgdmlld0JveFdpZHRoID0gODc1O1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIilcIiB8fCBkZWxpbSA9PT0gXCJcXFxccnBhcmVuXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzOWVcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzOWZcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYTBcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgc3ZnTGFiZWwgPSBcInJwYXJlblwiO1xuICAgIHZpZXdCb3hXaWR0aCA9IDg3NTtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxce1wiIHx8IGRlbGltID09PSBcIlxcXFxsYnJhY2VcIikge1xuICAgIHRvcCA9IFwiXFx1MjNhN1wiO1xuICAgIG1pZGRsZSA9IFwiXFx1MjNhOFwiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNhOVwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjNhYVwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcfVwiIHx8IGRlbGltID09PSBcIlxcXFxyYnJhY2VcIikge1xuICAgIHRvcCA9IFwiXFx1MjNhYlwiO1xuICAgIG1pZGRsZSA9IFwiXFx1MjNhY1wiO1xuICAgIGJvdHRvbSA9IFwiXFx1MjNhZFwiO1xuICAgIHJlcGVhdCA9IFwiXFx1MjNhYVwiO1xuICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcbGdyb3VwXCIgfHwgZGVsaW0gPT09IFwiXFx1MjdlZVwiKSB7XG4gICAgdG9wID0gXCJcXHUyM2E3XCI7XG4gICAgYm90dG9tID0gXCJcXHUyM2E5XCI7XG4gICAgcmVwZWF0ID0gXCJcXHUyM2FhXCI7XG4gICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxyZ3JvdXBcIiB8fCBkZWxpbSA9PT0gXCJcXHUyN2VmXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzYWJcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYWRcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGxtb3VzdGFjaGVcIiB8fCBkZWxpbSA9PT0gXCJcXHUyM2IwXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzYTdcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYWRcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHJtb3VzdGFjaGVcIiB8fCBkZWxpbSA9PT0gXCJcXHUyM2IxXCIpIHtcbiAgICB0b3AgPSBcIlxcdTIzYWJcIjtcbiAgICBib3R0b20gPSBcIlxcdTIzYTlcIjtcbiAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gIH0gLy8gR2V0IHRoZSBtZXRyaWNzIG9mIHRoZSBmb3VyIHNlY3Rpb25zXG5cblxuICB2YXIgdG9wTWV0cmljcyA9IGdldE1ldHJpY3ModG9wLCBmb250LCBtb2RlKTtcbiAgdmFyIHRvcEhlaWdodFRvdGFsID0gdG9wTWV0cmljcy5oZWlnaHQgKyB0b3BNZXRyaWNzLmRlcHRoO1xuICB2YXIgcmVwZWF0TWV0cmljcyA9IGdldE1ldHJpY3MocmVwZWF0LCBmb250LCBtb2RlKTtcbiAgdmFyIHJlcGVhdEhlaWdodFRvdGFsID0gcmVwZWF0TWV0cmljcy5oZWlnaHQgKyByZXBlYXRNZXRyaWNzLmRlcHRoO1xuICB2YXIgYm90dG9tTWV0cmljcyA9IGdldE1ldHJpY3MoYm90dG9tLCBmb250LCBtb2RlKTtcbiAgdmFyIGJvdHRvbUhlaWdodFRvdGFsID0gYm90dG9tTWV0cmljcy5oZWlnaHQgKyBib3R0b21NZXRyaWNzLmRlcHRoO1xuICB2YXIgbWlkZGxlSGVpZ2h0VG90YWwgPSAwO1xuICB2YXIgbWlkZGxlRmFjdG9yID0gMTtcblxuICBpZiAobWlkZGxlICE9PSBudWxsKSB7XG4gICAgdmFyIG1pZGRsZU1ldHJpY3MgPSBnZXRNZXRyaWNzKG1pZGRsZSwgZm9udCwgbW9kZSk7XG4gICAgbWlkZGxlSGVpZ2h0VG90YWwgPSBtaWRkbGVNZXRyaWNzLmhlaWdodCArIG1pZGRsZU1ldHJpY3MuZGVwdGg7XG4gICAgbWlkZGxlRmFjdG9yID0gMjsgLy8gcmVwZWF0IHN5bW1ldHJpY2FsbHkgYWJvdmUgYW5kIGJlbG93IG1pZGRsZVxuICB9IC8vIENhbGN1bGF0ZSB0aGUgbWluaW1hbCBoZWlnaHQgdGhhdCB0aGUgZGVsaW1pdGVyIGNhbiBoYXZlLlxuICAvLyBJdCBpcyBhdCBsZWFzdCB0aGUgc2l6ZSBvZiB0aGUgdG9wLCBib3R0b20sIGFuZCBvcHRpb25hbCBtaWRkbGUgY29tYmluZWQuXG5cblxuICB2YXIgbWluSGVpZ2h0ID0gdG9wSGVpZ2h0VG90YWwgKyBib3R0b21IZWlnaHRUb3RhbCArIG1pZGRsZUhlaWdodFRvdGFsOyAvLyBDb21wdXRlIHRoZSBudW1iZXIgb2YgY29waWVzIG9mIHRoZSByZXBlYXQgc3ltYm9sIHdlIHdpbGwgbmVlZFxuXG4gIHZhciByZXBlYXRDb3VudCA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoaGVpZ2h0VG90YWwgLSBtaW5IZWlnaHQpIC8gKG1pZGRsZUZhY3RvciAqIHJlcGVhdEhlaWdodFRvdGFsKSkpOyAvLyBDb21wdXRlIHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIGRlbGltaXRlciBpbmNsdWRpbmcgYWxsIHRoZSBzeW1ib2xzXG5cbiAgdmFyIHJlYWxIZWlnaHRUb3RhbCA9IG1pbkhlaWdodCArIHJlcGVhdENvdW50ICogbWlkZGxlRmFjdG9yICogcmVwZWF0SGVpZ2h0VG90YWw7IC8vIFRoZSBjZW50ZXIgb2YgdGhlIGRlbGltaXRlciBpcyBwbGFjZWQgYXQgdGhlIGNlbnRlciBvZiB0aGUgYXhpcy4gTm90ZVxuICAvLyB0aGF0IGluIHRoaXMgY29udGV4dCwgXCJjZW50ZXJcIiBtZWFucyB0aGF0IHRoZSBkZWxpbWl0ZXIgc2hvdWxkIGJlXG4gIC8vIGNlbnRlcmVkIGFyb3VuZCB0aGUgYXhpcyBpbiB0aGUgY3VycmVudCBzdHlsZSwgd2hpbGUgbm9ybWFsbHkgaXQgaXNcbiAgLy8gY2VudGVyZWQgYXJvdW5kIHRoZSBheGlzIGluIHRleHRzdHlsZS5cblxuICB2YXIgYXhpc0hlaWdodCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0O1xuXG4gIGlmIChjZW50ZXIpIHtcbiAgICBheGlzSGVpZ2h0ICo9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gIH0gLy8gQ2FsY3VsYXRlIHRoZSBkZXB0aFxuXG5cbiAgdmFyIGRlcHRoID0gcmVhbEhlaWdodFRvdGFsIC8gMiAtIGF4aXNIZWlnaHQ7IC8vIE5vdywgd2Ugc3RhcnQgYnVpbGRpbmcgdGhlIHBpZWNlcyB0aGF0IHdpbGwgZ28gaW50byB0aGUgdmxpc3RcbiAgLy8gS2VlcCBhIGxpc3Qgb2YgdGhlIHBpZWNlcyBvZiB0aGUgc3RhY2tlZCBkZWxpbWl0ZXJcblxuICB2YXIgc3RhY2sgPSBbXTtcblxuICBpZiAoc3ZnTGFiZWwubGVuZ3RoID4gMCkge1xuICAgIC8vIEluc3RlYWQgb2Ygc3RhY2tpbmcgZ2x5cGhzLCBjcmVhdGUgYSBzaW5nbGUgU1ZHLlxuICAgIC8vIFRoaXMgZXZhZGVzIGJyb3dzZXIgcHJvYmxlbXMgd2l0aCBpbXByZWNpc2UgcG9zaXRpb25pbmcgb2Ygc3BhbnMuXG4gICAgdmFyIG1pZEhlaWdodCA9IHJlYWxIZWlnaHRUb3RhbCAtIHRvcEhlaWdodFRvdGFsIC0gYm90dG9tSGVpZ2h0VG90YWw7XG4gICAgdmFyIHZpZXdCb3hIZWlnaHQgPSBNYXRoLnJvdW5kKHJlYWxIZWlnaHRUb3RhbCAqIDEwMDApO1xuICAgIHZhciBwYXRoU3RyID0gdGFsbERlbGltKHN2Z0xhYmVsLCBNYXRoLnJvdW5kKG1pZEhlaWdodCAqIDEwMDApKTtcbiAgICB2YXIgcGF0aCA9IG5ldyBQYXRoTm9kZShzdmdMYWJlbCwgcGF0aFN0cik7XG4gICAgdmFyIHdpZHRoID0gKHZpZXdCb3hXaWR0aCAvIDEwMDApLnRvRml4ZWQoMykgKyBcImVtXCI7XG4gICAgdmFyIGhlaWdodCA9ICh2aWV3Qm94SGVpZ2h0IC8gMTAwMCkudG9GaXhlZCgzKSArIFwiZW1cIjtcbiAgICB2YXIgc3ZnID0gbmV3IFN2Z05vZGUoW3BhdGhdLCB7XG4gICAgICBcIndpZHRoXCI6IHdpZHRoLFxuICAgICAgXCJoZWlnaHRcIjogaGVpZ2h0LFxuICAgICAgXCJ2aWV3Qm94XCI6IFwiMCAwIFwiICsgdmlld0JveFdpZHRoICsgXCIgXCIgKyB2aWV3Qm94SGVpZ2h0XG4gICAgfSk7XG4gICAgdmFyIHdyYXBwZXIgPSBidWlsZENvbW1vbi5tYWtlU3ZnU3BhbihbXSwgW3N2Z10sIG9wdGlvbnMpO1xuICAgIHdyYXBwZXIuaGVpZ2h0ID0gdmlld0JveEhlaWdodCAvIDEwMDA7XG4gICAgd3JhcHBlci5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgIHdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHN0YWNrLnB1c2goe1xuICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICBlbGVtOiB3cmFwcGVyXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RhY2sgZ2x5cGhzXG4gICAgLy8gU3RhcnQgYnkgYWRkaW5nIHRoZSBib3R0b20gc3ltYm9sXG4gICAgc3RhY2sucHVzaChtYWtlR2x5cGhTcGFuKGJvdHRvbSwgZm9udCwgbW9kZSkpO1xuICAgIHN0YWNrLnB1c2gobGFwKTsgLy8gb3ZlcmxhcFxuXG4gICAgaWYgKG1pZGRsZSA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhlIG1pZGRsZSBzZWN0aW9uIHdpbGwgYmUgYW4gU1ZHLiBNYWtlIGl0IGFuIGV4dHJhIDAuMDE2ZW0gdGFsbC5cbiAgICAgIC8vIFdlJ2xsIG92ZXJsYXAgYnkgMC4wMDhlbSBhdCB0b3AgYW5kIGJvdHRvbS5cbiAgICAgIHZhciBpbm5lckhlaWdodCA9IHJlYWxIZWlnaHRUb3RhbCAtIHRvcEhlaWdodFRvdGFsIC0gYm90dG9tSGVpZ2h0VG90YWwgKyAyICogbGFwSW5FbXM7XG4gICAgICBzdGFjay5wdXNoKG1ha2VJbm5lcihyZXBlYXQsIGlubmVySGVpZ2h0LCBvcHRpb25zKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gdGhlcmUgaXMgYSBtaWRkbGUgYml0LCB3ZSBuZWVkIHRoZSBtaWRkbGUgcGFydCBhbmQgdHdvIHJlcGVhdGVkXG4gICAgICAvLyBzZWN0aW9uc1xuICAgICAgdmFyIF9pbm5lckhlaWdodCA9IChyZWFsSGVpZ2h0VG90YWwgLSB0b3BIZWlnaHRUb3RhbCAtIGJvdHRvbUhlaWdodFRvdGFsIC0gbWlkZGxlSGVpZ2h0VG90YWwpIC8gMiArIDIgKiBsYXBJbkVtcztcblxuICAgICAgc3RhY2sucHVzaChtYWtlSW5uZXIocmVwZWF0LCBfaW5uZXJIZWlnaHQsIG9wdGlvbnMpKTsgLy8gTm93IGluc2VydCB0aGUgbWlkZGxlIG9mIHRoZSBicmFjZS5cblxuICAgICAgc3RhY2sucHVzaChsYXApO1xuICAgICAgc3RhY2sucHVzaChtYWtlR2x5cGhTcGFuKG1pZGRsZSwgZm9udCwgbW9kZSkpO1xuICAgICAgc3RhY2sucHVzaChsYXApO1xuICAgICAgc3RhY2sucHVzaChtYWtlSW5uZXIocmVwZWF0LCBfaW5uZXJIZWlnaHQsIG9wdGlvbnMpKTtcbiAgICB9IC8vIEFkZCB0aGUgdG9wIHN5bWJvbFxuXG5cbiAgICBzdGFjay5wdXNoKGxhcCk7XG4gICAgc3RhY2sucHVzaChtYWtlR2x5cGhTcGFuKHRvcCwgZm9udCwgbW9kZSkpO1xuICB9IC8vIEZpbmFsbHksIGJ1aWxkIHRoZSB2bGlzdFxuXG5cbiAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ0Jhc2VTdHlsZShTdHlsZSQxLlRFWFQpO1xuICB2YXIgaW5uZXIgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgIHBvc2l0aW9uVHlwZTogXCJib3R0b21cIixcbiAgICBwb3NpdGlvbkRhdGE6IGRlcHRoLFxuICAgIGNoaWxkcmVuOiBzdGFja1xuICB9LCBuZXdPcHRpb25zKTtcbiAgcmV0dXJuIHN0eWxlV3JhcChidWlsZENvbW1vbi5tYWtlU3BhbihbXCJkZWxpbXNpemluZ1wiLCBcIm11bHRcIl0sIFtpbm5lcl0sIG5ld09wdGlvbnMpLCBTdHlsZSQxLlRFWFQsIG9wdGlvbnMsIGNsYXNzZXMpO1xufTsgLy8gQWxsIHN1cmRzIGhhdmUgMC4wOGVtIHBhZGRpbmcgYWJvdmUgdGhlIHZpbmN1bHVtIGluc2lkZSB0aGUgU1ZHLlxuLy8gVGhhdCBrZWVwcyBicm93c2VyIHNwYW4gaGVpZ2h0IHJvdW5kaW5nIGVycm9yIGZyb20gcGluY2hpbmcgdGhlIGxpbmUuXG5cblxudmFyIHZiUGFkID0gODA7IC8vIHBhZGRpbmcgYWJvdmUgdGhlIHN1cmQsIG1lYXN1cmVkIGluc2lkZSB0aGUgdmlld0JveC5cblxudmFyIGVtUGFkID0gMC4wODsgLy8gcGFkZGluZywgaW4gZW1zLCBtZWFzdXJlZCBpbiB0aGUgZG9jdW1lbnQuXG5cbnZhciBzcXJ0U3ZnID0gZnVuY3Rpb24gc3FydFN2ZyhzcXJ0TmFtZSwgaGVpZ2h0LCB2aWV3Qm94SGVpZ2h0LCBleHRyYVZpbmN1bHVtLCBvcHRpb25zKSB7XG4gIHZhciBwYXRoID0gc3FydFBhdGgoc3FydE5hbWUsIGV4dHJhVmluY3VsdW0sIHZpZXdCb3hIZWlnaHQpO1xuICB2YXIgcGF0aE5vZGUgPSBuZXcgUGF0aE5vZGUoc3FydE5hbWUsIHBhdGgpO1xuICB2YXIgc3ZnID0gbmV3IFN2Z05vZGUoW3BhdGhOb2RlXSwge1xuICAgIC8vIE5vdGU6IDEwMDA6MSByYXRpbyBvZiB2aWV3Qm94IHRvIGRvY3VtZW50IGVtIHdpZHRoLlxuICAgIFwid2lkdGhcIjogXCI0MDBlbVwiLFxuICAgIFwiaGVpZ2h0XCI6IG1ha2VFbShoZWlnaHQpLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCA0MDAwMDAgXCIgKyB2aWV3Qm94SGVpZ2h0LFxuICAgIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiOiBcInhNaW5ZTWluIHNsaWNlXCJcbiAgfSk7XG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3ZnU3BhbihbXCJoaWRlLXRhaWxcIl0sIFtzdmddLCBvcHRpb25zKTtcbn07XG4vKipcbiAqIE1ha2UgYSBzcXJ0IGltYWdlIG9mIHRoZSBnaXZlbiBoZWlnaHQsXG4gKi9cblxuXG52YXIgbWFrZVNxcnRJbWFnZSA9IGZ1bmN0aW9uIG1ha2VTcXJ0SW1hZ2UoaGVpZ2h0LCBvcHRpb25zKSB7XG4gIC8vIERlZmluZSBhIG5ld09wdGlvbnMgdGhhdCByZW1vdmVzIHRoZSBlZmZlY3Qgb2Ygc2l6ZSBjaGFuZ2VzIHN1Y2ggYXMgXFxIdWdlLlxuICAvLyBXZSBkb24ndCBwaWNrIGRpZmZlcmVudCBhIGhlaWdodCBzdXJkIGZvciBcXEh1Z2UuIEZvciBpdCwgd2Ugc2NhbGUgdXAuXG4gIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdCYXNlU2l6aW5nKCk7IC8vIFBpY2sgdGhlIGRlc2lyZWQgc3VyZCBnbHlwaCBmcm9tIGEgc2VxdWVuY2Ugb2Ygc3VyZHMuXG5cbiAgdmFyIGRlbGltID0gdHJhdmVyc2VTZXF1ZW5jZShcIlxcXFxzdXJkXCIsIGhlaWdodCAqIG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXIsIHN0YWNrTGFyZ2VEZWxpbWl0ZXJTZXF1ZW5jZSwgbmV3T3B0aW9ucyk7XG4gIHZhciBzaXplTXVsdGlwbGllciA9IG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXI7IC8vIGRlZmF1bHRcbiAgLy8gVGhlIHN0YW5kYXJkIHNxcnQgU1ZHcyBlYWNoIGhhdmUgYSAwLjA0ZW0gdGhpY2sgdmluY3VsdW0uXG4gIC8vIElmIFNldHRpbmdzLm1pblJ1bGVUaGlja25lc3MgaXMgbGFyZ2VyIHRoYW4gdGhhdCwgd2UgYWRkIGV4dHJhVmluY3VsdW0uXG5cbiAgdmFyIGV4dHJhVmluY3VsdW0gPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pblJ1bGVUaGlja25lc3MgLSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuc3FydFJ1bGVUaGlja25lc3MpOyAvLyBDcmVhdGUgYSBzcGFuIGNvbnRhaW5pbmcgYW4gU1ZHIGltYWdlIG9mIGEgc3FydCBzeW1ib2wuXG5cbiAgdmFyIHNwYW47XG4gIHZhciBzcGFuSGVpZ2h0ID0gMDtcbiAgdmFyIHRleEhlaWdodCA9IDA7XG4gIHZhciB2aWV3Qm94SGVpZ2h0ID0gMDtcbiAgdmFyIGFkdmFuY2VXaWR0aDsgLy8gV2UgY3JlYXRlIHZpZXdCb3hlcyB3aXRoIDgwIHVuaXRzIG9mIFwicGFkZGluZ1wiIGFib3ZlIGVhY2ggc3VyZC5cbiAgLy8gVGhlbiBicm93c2VyIHJvdW5kaW5nIGVycm9yIG9uIHRoZSBwYXJlbnQgc3BhbiBoZWlnaHQgd2lsbCBub3RcbiAgLy8gZW5jcm9hY2ggb24gdGhlIGluayBvZiB0aGUgdmluY3VsdW0uIEJ1dCB0aGF0IHBhZGRpbmcgaXMgbm90XG4gIC8vIGluY2x1ZGVkIGluIHRoZSBUZVgtbGlrZSBgaGVpZ2h0YCB1c2VkIGZvciBjYWxjdWxhdGlvbiBvZlxuICAvLyB2ZXJ0aWNhbCBhbGlnbm1lbnQuIFNvIHRleEhlaWdodCA9IHNwYW4uaGVpZ2h0IDwgc3Bhbi5zdHlsZS5oZWlnaHQuXG5cbiAgaWYgKGRlbGltLnR5cGUgPT09IFwic21hbGxcIikge1xuICAgIC8vIEdldCBhbiBTVkcgdGhhdCBpcyBkZXJpdmVkIGZyb20gZ2x5cGggVSsyMjFBIGluIGZvbnQgS2FUZVgtTWFpbi5cbiAgICAvLyAxMDAwIHVuaXQgbm9ybWFsIGdseXBoIGhlaWdodC5cbiAgICB2aWV3Qm94SGVpZ2h0ID0gMTAwMCArIDEwMDAgKiBleHRyYVZpbmN1bHVtICsgdmJQYWQ7XG5cbiAgICBpZiAoaGVpZ2h0IDwgMS4wKSB7XG4gICAgICBzaXplTXVsdGlwbGllciA9IDEuMDsgLy8gbWltaWMgYSBcXHRleHRmb250IHJhZGljYWxcbiAgICB9IGVsc2UgaWYgKGhlaWdodCA8IDEuNCkge1xuICAgICAgc2l6ZU11bHRpcGxpZXIgPSAwLjc7IC8vIG1pbWljIGEgXFxzY3JpcHRmb250IHJhZGljYWxcbiAgICB9XG5cbiAgICBzcGFuSGVpZ2h0ID0gKDEuMCArIGV4dHJhVmluY3VsdW0gKyBlbVBhZCkgLyBzaXplTXVsdGlwbGllcjtcbiAgICB0ZXhIZWlnaHQgPSAoMS4wMCArIGV4dHJhVmluY3VsdW0pIC8gc2l6ZU11bHRpcGxpZXI7XG4gICAgc3BhbiA9IHNxcnRTdmcoXCJzcXJ0TWFpblwiLCBzcGFuSGVpZ2h0LCB2aWV3Qm94SGVpZ2h0LCBleHRyYVZpbmN1bHVtLCBvcHRpb25zKTtcbiAgICBzcGFuLnN0eWxlLm1pbldpZHRoID0gXCIwLjg1M2VtXCI7XG4gICAgYWR2YW5jZVdpZHRoID0gMC44MzMgLyBzaXplTXVsdGlwbGllcjsgLy8gZnJvbSB0aGUgZm9udC5cbiAgfSBlbHNlIGlmIChkZWxpbS50eXBlID09PSBcImxhcmdlXCIpIHtcbiAgICAvLyBUaGVzZSBTVkdzIGNvbWUgZnJvbSBmb250czogS2FUZVhfU2l6ZTEsIF9TaXplMiwgZXRjLlxuICAgIHZpZXdCb3hIZWlnaHQgPSAoMTAwMCArIHZiUGFkKSAqIHNpemVUb01heEhlaWdodFtkZWxpbS5zaXplXTtcbiAgICB0ZXhIZWlnaHQgPSAoc2l6ZVRvTWF4SGVpZ2h0W2RlbGltLnNpemVdICsgZXh0cmFWaW5jdWx1bSkgLyBzaXplTXVsdGlwbGllcjtcbiAgICBzcGFuSGVpZ2h0ID0gKHNpemVUb01heEhlaWdodFtkZWxpbS5zaXplXSArIGV4dHJhVmluY3VsdW0gKyBlbVBhZCkgLyBzaXplTXVsdGlwbGllcjtcbiAgICBzcGFuID0gc3FydFN2ZyhcInNxcnRTaXplXCIgKyBkZWxpbS5zaXplLCBzcGFuSGVpZ2h0LCB2aWV3Qm94SGVpZ2h0LCBleHRyYVZpbmN1bHVtLCBvcHRpb25zKTtcbiAgICBzcGFuLnN0eWxlLm1pbldpZHRoID0gXCIxLjAyZW1cIjtcbiAgICBhZHZhbmNlV2lkdGggPSAxLjAgLyBzaXplTXVsdGlwbGllcjsgLy8gMS4wIGZyb20gdGhlIGZvbnQuXG4gIH0gZWxzZSB7XG4gICAgLy8gVGFsbCBzcXJ0LiBJbiBUZVgsIHRoaXMgd291bGQgYmUgc3RhY2tlZCB1c2luZyBtdWx0aXBsZSBnbHlwaHMuXG4gICAgLy8gV2UnbGwgdXNlIGEgc2luZ2xlIFNWRyB0byBhY2NvbXBsaXNoIHRoZSBzYW1lIHRoaW5nLlxuICAgIHNwYW5IZWlnaHQgPSBoZWlnaHQgKyBleHRyYVZpbmN1bHVtICsgZW1QYWQ7XG4gICAgdGV4SGVpZ2h0ID0gaGVpZ2h0ICsgZXh0cmFWaW5jdWx1bTtcbiAgICB2aWV3Qm94SGVpZ2h0ID0gTWF0aC5mbG9vcigxMDAwICogaGVpZ2h0ICsgZXh0cmFWaW5jdWx1bSkgKyB2YlBhZDtcbiAgICBzcGFuID0gc3FydFN2ZyhcInNxcnRUYWxsXCIsIHNwYW5IZWlnaHQsIHZpZXdCb3hIZWlnaHQsIGV4dHJhVmluY3VsdW0sIG9wdGlvbnMpO1xuICAgIHNwYW4uc3R5bGUubWluV2lkdGggPSBcIjAuNzQyZW1cIjtcbiAgICBhZHZhbmNlV2lkdGggPSAxLjA1NjtcbiAgfVxuXG4gIHNwYW4uaGVpZ2h0ID0gdGV4SGVpZ2h0O1xuICBzcGFuLnN0eWxlLmhlaWdodCA9IG1ha2VFbShzcGFuSGVpZ2h0KTtcbiAgcmV0dXJuIHtcbiAgICBzcGFuLFxuICAgIGFkdmFuY2VXaWR0aCxcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFjdHVhbCBsaW5lIHdpZHRoLlxuICAgIC8vIFRoaXMgYWN0dWFsbHkgc2hvdWxkIGRlcGVuZCBvbiB0aGUgY2hvc2VuIGZvbnQgLS0gZS5nLiBcXGJvbGRtYXRoXG4gICAgLy8gc2hvdWxkIHVzZSB0aGUgdGhpY2tlciBzdXJkIHN5bWJvbHMgZnJvbSBlLmcuIEthVGVYX01haW4tQm9sZCwgYW5kXG4gICAgLy8gaGF2ZSB0aGlja2VyIHJ1bGVzLlxuICAgIHJ1bGVXaWR0aDogKG9wdGlvbnMuZm9udE1ldHJpY3MoKS5zcXJ0UnVsZVRoaWNrbmVzcyArIGV4dHJhVmluY3VsdW0pICogc2l6ZU11bHRpcGxpZXJcbiAgfTtcbn07IC8vIFRoZXJlIGFyZSB0aHJlZSBraW5kcyBvZiBkZWxpbWl0ZXJzLCBkZWxpbWl0ZXJzIHRoYXQgc3RhY2sgd2hlbiB0aGV5IGJlY29tZVxuLy8gdG9vIGxhcmdlXG5cblxudmFyIHN0YWNrTGFyZ2VEZWxpbWl0ZXJzID0gW1wiKFwiLCBcIlxcXFxscGFyZW5cIiwgXCIpXCIsIFwiXFxcXHJwYXJlblwiLCBcIltcIiwgXCJcXFxcbGJyYWNrXCIsIFwiXVwiLCBcIlxcXFxyYnJhY2tcIiwgXCJcXFxce1wiLCBcIlxcXFxsYnJhY2VcIiwgXCJcXFxcfVwiLCBcIlxcXFxyYnJhY2VcIiwgXCJcXFxcbGZsb29yXCIsIFwiXFxcXHJmbG9vclwiLCBcIlxcdTIzMGFcIiwgXCJcXHUyMzBiXCIsIFwiXFxcXGxjZWlsXCIsIFwiXFxcXHJjZWlsXCIsIFwiXFx1MjMwOFwiLCBcIlxcdTIzMDlcIiwgXCJcXFxcc3VyZFwiXTsgLy8gZGVsaW1pdGVycyB0aGF0IGFsd2F5cyBzdGFja1xuXG52YXIgc3RhY2tBbHdheXNEZWxpbWl0ZXJzID0gW1wiXFxcXHVwYXJyb3dcIiwgXCJcXFxcZG93bmFycm93XCIsIFwiXFxcXHVwZG93bmFycm93XCIsIFwiXFxcXFVwYXJyb3dcIiwgXCJcXFxcRG93bmFycm93XCIsIFwiXFxcXFVwZG93bmFycm93XCIsIFwifFwiLCBcIlxcXFx8XCIsIFwiXFxcXHZlcnRcIiwgXCJcXFxcVmVydFwiLCBcIlxcXFxsdmVydFwiLCBcIlxcXFxydmVydFwiLCBcIlxcXFxsVmVydFwiLCBcIlxcXFxyVmVydFwiLCBcIlxcXFxsZ3JvdXBcIiwgXCJcXFxccmdyb3VwXCIsIFwiXFx1MjdlZVwiLCBcIlxcdTI3ZWZcIiwgXCJcXFxcbG1vdXN0YWNoZVwiLCBcIlxcXFxybW91c3RhY2hlXCIsIFwiXFx1MjNiMFwiLCBcIlxcdTIzYjFcIl07IC8vIGFuZCBkZWxpbWl0ZXJzIHRoYXQgbmV2ZXIgc3RhY2tcblxudmFyIHN0YWNrTmV2ZXJEZWxpbWl0ZXJzID0gW1wiPFwiLCBcIj5cIiwgXCJcXFxcbGFuZ2xlXCIsIFwiXFxcXHJhbmdsZVwiLCBcIi9cIiwgXCJcXFxcYmFja3NsYXNoXCIsIFwiXFxcXGx0XCIsIFwiXFxcXGd0XCJdOyAvLyBNZXRyaWNzIG9mIHRoZSBkaWZmZXJlbnQgc2l6ZXMuIEZvdW5kIGJ5IGxvb2tpbmcgYXQgVGVYJ3Mgb3V0cHV0IG9mXG4vLyAkXFxiaWdsfCAvLyBcXEJpZ2x8IFxcYmlnZ2x8IFxcQmlnZ2x8IFxcc2hvd2xpc3RzJFxuLy8gVXNlZCB0byBjcmVhdGUgc3RhY2tlZCBkZWxpbWl0ZXJzIG9mIGFwcHJvcHJpYXRlIHNpemVzIGluIG1ha2VTaXplZERlbGltLlxuXG52YXIgc2l6ZVRvTWF4SGVpZ2h0ID0gWzAsIDEuMiwgMS44LCAyLjQsIDMuMF07XG4vKipcbiAqIFVzZWQgdG8gY3JlYXRlIGEgZGVsaW1pdGVyIG9mIGEgc3BlY2lmaWMgc2l6ZSwgd2hlcmUgYHNpemVgIGlzIDEsIDIsIDMsIG9yIDQuXG4gKi9cblxudmFyIG1ha2VTaXplZERlbGltID0gZnVuY3Rpb24gbWFrZVNpemVkRGVsaW0oZGVsaW0sIHNpemUsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpIHtcbiAgLy8gPCBhbmQgPiB0dXJuIGludG8gXFxsYW5nbGUgYW5kIFxccmFuZ2xlIGluIGRlbGltaXRlcnNcbiAgaWYgKGRlbGltID09PSBcIjxcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbHRcIiB8fCBkZWxpbSA9PT0gXCJcXHUyN2U4XCIpIHtcbiAgICBkZWxpbSA9IFwiXFxcXGxhbmdsZVwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIj5cIiB8fCBkZWxpbSA9PT0gXCJcXFxcZ3RcIiB8fCBkZWxpbSA9PT0gXCJcXHUyN2U5XCIpIHtcbiAgICBkZWxpbSA9IFwiXFxcXHJhbmdsZVwiO1xuICB9IC8vIFNpemVkIGRlbGltaXRlcnMgYXJlIG5ldmVyIGNlbnRlcmVkLlxuXG5cbiAgaWYgKHN0YWNrTGFyZ2VEZWxpbWl0ZXJzLmluY2x1ZGVzKGRlbGltKSB8fCBzdGFja05ldmVyRGVsaW1pdGVycy5pbmNsdWRlcyhkZWxpbSkpIHtcbiAgICByZXR1cm4gbWFrZUxhcmdlRGVsaW0oZGVsaW0sIHNpemUsIGZhbHNlLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgfSBlbHNlIGlmIChzdGFja0Fsd2F5c0RlbGltaXRlcnMuaW5jbHVkZXMoZGVsaW0pKSB7XG4gICAgcmV0dXJuIG1ha2VTdGFja2VkRGVsaW0oZGVsaW0sIHNpemVUb01heEhlaWdodFtzaXplXSwgZmFsc2UsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSWxsZWdhbCBkZWxpbWl0ZXI6ICdcIiArIGRlbGltICsgXCInXCIpO1xuICB9XG59O1xuLyoqXG4gKiBUaGVyZSBhcmUgdGhyZWUgZGlmZmVyZW50IHNlcXVlbmNlcyBvZiBkZWxpbWl0ZXIgc2l6ZXMgdGhhdCB0aGUgZGVsaW1pdGVyc1xuICogZm9sbG93IGRlcGVuZGluZyBvbiB0aGUga2luZCBvZiBkZWxpbWl0ZXIuIFRoaXMgaXMgdXNlZCB3aGVuIGNyZWF0aW5nIGN1c3RvbVxuICogc2l6ZWQgZGVsaW1pdGVycyB0byBkZWNpZGUgd2hldGhlciB0byBjcmVhdGUgYSBzbWFsbCwgbGFyZ2UsIG9yIHN0YWNrZWRcbiAqIGRlbGltaXRlci5cbiAqXG4gKiBJbiByZWFsIFRlWCwgdGhlc2Ugc2VxdWVuY2VzIGFyZW4ndCBleHBsaWNpdGx5IGRlZmluZWQsIGJ1dCBhcmUgaW5zdGVhZFxuICogZGVmaW5lZCBpbnNpZGUgdGhlIGZvbnQgbWV0cmljcy4gU2luY2UgdGhlcmUgYXJlIG9ubHkgdGhyZWUgc2VxdWVuY2VzIHRoYXRcbiAqIGFyZSBwb3NzaWJsZSBmb3IgdGhlIGRlbGltaXRlcnMgdGhhdCBUZVggZGVmaW5lcywgaXQgaXMgZWFzaWVyIHRvIGp1c3QgZW5jb2RlXG4gKiB0aGVtIGV4cGxpY2l0bHkgaGVyZS5cbiAqL1xuXG5cbi8vIERlbGltaXRlcnMgdGhhdCBuZXZlciBzdGFjayB0cnkgc21hbGwgZGVsaW1pdGVycyBhbmQgbGFyZ2UgZGVsaW1pdGVycyBvbmx5XG52YXIgc3RhY2tOZXZlckRlbGltaXRlclNlcXVlbmNlID0gW3tcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogU3R5bGUkMS5TQ1JJUFRTQ1JJUFRcbn0sIHtcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogU3R5bGUkMS5TQ1JJUFRcbn0sIHtcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogU3R5bGUkMS5URVhUXG59LCB7XG4gIHR5cGU6IFwibGFyZ2VcIixcbiAgc2l6ZTogMVxufSwge1xuICB0eXBlOiBcImxhcmdlXCIsXG4gIHNpemU6IDJcbn0sIHtcbiAgdHlwZTogXCJsYXJnZVwiLFxuICBzaXplOiAzXG59LCB7XG4gIHR5cGU6IFwibGFyZ2VcIixcbiAgc2l6ZTogNFxufV07IC8vIERlbGltaXRlcnMgdGhhdCBhbHdheXMgc3RhY2sgdHJ5IHRoZSBzbWFsbCBkZWxpbWl0ZXJzIGZpcnN0LCB0aGVuIHN0YWNrXG5cbnZhciBzdGFja0Fsd2F5c0RlbGltaXRlclNlcXVlbmNlID0gW3tcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogU3R5bGUkMS5TQ1JJUFRTQ1JJUFRcbn0sIHtcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogU3R5bGUkMS5TQ1JJUFRcbn0sIHtcbiAgdHlwZTogXCJzbWFsbFwiLFxuICBzdHlsZTogU3R5bGUkMS5URVhUXG59LCB7XG4gIHR5cGU6IFwic3RhY2tcIlxufV07IC8vIERlbGltaXRlcnMgdGhhdCBzdGFjayB3aGVuIGxhcmdlIHRyeSB0aGUgc21hbGwgYW5kIHRoZW4gbGFyZ2UgZGVsaW1pdGVycywgYW5kXG4vLyBzdGFjayBhZnRlcndhcmRzXG5cbnZhciBzdGFja0xhcmdlRGVsaW1pdGVyU2VxdWVuY2UgPSBbe1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBTdHlsZSQxLlNDUklQVFNDUklQVFxufSwge1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBTdHlsZSQxLlNDUklQVFxufSwge1xuICB0eXBlOiBcInNtYWxsXCIsXG4gIHN0eWxlOiBTdHlsZSQxLlRFWFRcbn0sIHtcbiAgdHlwZTogXCJsYXJnZVwiLFxuICBzaXplOiAxXG59LCB7XG4gIHR5cGU6IFwibGFyZ2VcIixcbiAgc2l6ZTogMlxufSwge1xuICB0eXBlOiBcImxhcmdlXCIsXG4gIHNpemU6IDNcbn0sIHtcbiAgdHlwZTogXCJsYXJnZVwiLFxuICBzaXplOiA0XG59LCB7XG4gIHR5cGU6IFwic3RhY2tcIlxufV07XG4vKipcbiAqIEdldCB0aGUgZm9udCB1c2VkIGluIGEgZGVsaW1pdGVyIGJhc2VkIG9uIHdoYXQga2luZCBvZiBkZWxpbWl0ZXIgaXQgaXMuXG4gKiBUT0RPKCM5NjMpIFVzZSBtb3JlIHNwZWNpZmljIGZvbnQgZmFtaWx5IHJldHVybiB0eXBlIG9uY2UgdGhhdCBpcyBpbnRyb2R1Y2VkLlxuICovXG5cbnZhciBkZWxpbVR5cGVUb0ZvbnQgPSBmdW5jdGlvbiBkZWxpbVR5cGVUb0ZvbnQodHlwZSkge1xuICBpZiAodHlwZS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICByZXR1cm4gXCJNYWluLVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmICh0eXBlLnR5cGUgPT09IFwibGFyZ2VcIikge1xuICAgIHJldHVybiBcIlNpemVcIiArIHR5cGUuc2l6ZSArIFwiLVJlZ3VsYXJcIjtcbiAgfSBlbHNlIGlmICh0eXBlLnR5cGUgPT09IFwic3RhY2tcIikge1xuICAgIHJldHVybiBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBZGQgc3VwcG9ydCBmb3IgZGVsaW0gdHlwZSAnXCIgKyB0eXBlLnR5cGUgKyBcIicgaGVyZS5cIik7XG4gIH1cbn07XG4vKipcbiAqIFRyYXZlcnNlIGEgc2VxdWVuY2Ugb2YgdHlwZXMgb2YgZGVsaW1pdGVycyB0byBkZWNpZGUgd2hhdCBraW5kIG9mIGRlbGltaXRlclxuICogc2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGEgZGVsaW1pdGVyIG9mIHRoZSBnaXZlbiBoZWlnaHQrZGVwdGguXG4gKi9cblxuXG52YXIgdHJhdmVyc2VTZXF1ZW5jZSA9IGZ1bmN0aW9uIHRyYXZlcnNlU2VxdWVuY2UoZGVsaW0sIGhlaWdodCwgc2VxdWVuY2UsIG9wdGlvbnMpIHtcbiAgLy8gSGVyZSwgd2UgY2hvb3NlIHRoZSBpbmRleCB3ZSBzaG91bGQgc3RhcnQgYXQgaW4gdGhlIHNlcXVlbmNlcy4gSW4gc21hbGxlclxuICAvLyBzaXplcyAod2hpY2ggY29ycmVzcG9uZCB0byBsYXJnZXIgbnVtYmVycyBpbiBzdHlsZS5zaXplKSB3ZSBzdGFydCBlYXJsaWVyXG4gIC8vIGluIHRoZSBzZXF1ZW5jZS4gVGh1cywgc2NyaXB0c2NyaXB0IHN0YXJ0cyBhdCBpbmRleCAzLTM9MCwgc2NyaXB0IHN0YXJ0c1xuICAvLyBhdCBpbmRleCAzLTI9MSwgdGV4dCBzdGFydHMgYXQgMy0xPTIsIGFuZCBkaXNwbGF5IHN0YXJ0cyBhdCBtaW4oMiwzLTApPTJcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4oMiwgMyAtIG9wdGlvbnMuc3R5bGUuc2l6ZSk7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc2VxdWVuY2VbaV0udHlwZSA9PT0gXCJzdGFja1wiKSB7XG4gICAgICAvLyBUaGlzIGlzIGFsd2F5cyB0aGUgbGFzdCBkZWxpbWl0ZXIsIHNvIHdlIGp1c3QgYnJlYWsgdGhlIGxvb3Agbm93LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIG1ldHJpY3MgPSBnZXRNZXRyaWNzKGRlbGltLCBkZWxpbVR5cGVUb0ZvbnQoc2VxdWVuY2VbaV0pLCBcIm1hdGhcIik7XG4gICAgdmFyIGhlaWdodERlcHRoID0gbWV0cmljcy5oZWlnaHQgKyBtZXRyaWNzLmRlcHRoOyAvLyBTbWFsbCBkZWxpbWl0ZXJzIGFyZSBzY2FsZWQgZG93biB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBmb250LCBzbyB3ZVxuICAgIC8vIGFjY291bnQgZm9yIHRoZSBzdHlsZSBjaGFuZ2Ugc2l6ZS5cblxuICAgIGlmIChzZXF1ZW5jZVtpXS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdCYXNlU3R5bGUoc2VxdWVuY2VbaV0uc3R5bGUpO1xuICAgICAgaGVpZ2h0RGVwdGggKj0gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICB9IC8vIENoZWNrIGlmIHRoZSBkZWxpbWl0ZXIgYXQgdGhpcyBzaXplIHdvcmtzIGZvciB0aGUgZ2l2ZW4gaGVpZ2h0LlxuXG5cbiAgICBpZiAoaGVpZ2h0RGVwdGggPiBoZWlnaHQpIHtcbiAgICAgIHJldHVybiBzZXF1ZW5jZVtpXTtcbiAgICB9XG4gIH0gLy8gSWYgd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZSwgcmV0dXJuIHRoZSBsYXN0IHNlcXVlbmNlIGVsZW1lbnQuXG5cblxuICByZXR1cm4gc2VxdWVuY2Vbc2VxdWVuY2UubGVuZ3RoIC0gMV07XG59O1xuLyoqXG4gKiBNYWtlIGEgZGVsaW1pdGVyIG9mIGEgZ2l2ZW4gaGVpZ2h0K2RlcHRoLCB3aXRoIG9wdGlvbmFsIGNlbnRlcmluZy4gSGVyZSwgd2VcbiAqIHRyYXZlcnNlIHRoZSBzZXF1ZW5jZXMsIGFuZCBjcmVhdGUgYSBkZWxpbWl0ZXIgdGhhdCB0aGUgc2VxdWVuY2UgdGVsbHMgdXMgdG8uXG4gKi9cblxuXG52YXIgbWFrZUN1c3RvbVNpemVkRGVsaW0gPSBmdW5jdGlvbiBtYWtlQ3VzdG9tU2l6ZWREZWxpbShkZWxpbSwgaGVpZ2h0LCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpIHtcbiAgaWYgKGRlbGltID09PSBcIjxcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbHRcIiB8fCBkZWxpbSA9PT0gXCJcXHUyN2U4XCIpIHtcbiAgICBkZWxpbSA9IFwiXFxcXGxhbmdsZVwiO1xuICB9IGVsc2UgaWYgKGRlbGltID09PSBcIj5cIiB8fCBkZWxpbSA9PT0gXCJcXFxcZ3RcIiB8fCBkZWxpbSA9PT0gXCJcXHUyN2U5XCIpIHtcbiAgICBkZWxpbSA9IFwiXFxcXHJhbmdsZVwiO1xuICB9IC8vIERlY2lkZSB3aGF0IHNlcXVlbmNlIHRvIHVzZVxuXG5cbiAgdmFyIHNlcXVlbmNlO1xuXG4gIGlmIChzdGFja05ldmVyRGVsaW1pdGVycy5pbmNsdWRlcyhkZWxpbSkpIHtcbiAgICBzZXF1ZW5jZSA9IHN0YWNrTmV2ZXJEZWxpbWl0ZXJTZXF1ZW5jZTtcbiAgfSBlbHNlIGlmIChzdGFja0xhcmdlRGVsaW1pdGVycy5pbmNsdWRlcyhkZWxpbSkpIHtcbiAgICBzZXF1ZW5jZSA9IHN0YWNrTGFyZ2VEZWxpbWl0ZXJTZXF1ZW5jZTtcbiAgfSBlbHNlIHtcbiAgICBzZXF1ZW5jZSA9IHN0YWNrQWx3YXlzRGVsaW1pdGVyU2VxdWVuY2U7XG4gIH0gLy8gTG9vayB0aHJvdWdoIHRoZSBzZXF1ZW5jZVxuXG5cbiAgdmFyIGRlbGltVHlwZSA9IHRyYXZlcnNlU2VxdWVuY2UoZGVsaW0sIGhlaWdodCwgc2VxdWVuY2UsIG9wdGlvbnMpOyAvLyBHZXQgdGhlIGRlbGltaXRlciBmcm9tIGZvbnQgZ2x5cGhzLlxuICAvLyBEZXBlbmRpbmcgb24gdGhlIHNlcXVlbmNlIGVsZW1lbnQgd2UgZGVjaWRlZCBvbiwgY2FsbCB0aGVcbiAgLy8gYXBwcm9wcmlhdGUgZnVuY3Rpb24uXG5cbiAgaWYgKGRlbGltVHlwZS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICByZXR1cm4gbWFrZVNtYWxsRGVsaW0oZGVsaW0sIGRlbGltVHlwZS5zdHlsZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgfSBlbHNlIGlmIChkZWxpbVR5cGUudHlwZSA9PT0gXCJsYXJnZVwiKSB7XG4gICAgcmV0dXJuIG1ha2VMYXJnZURlbGltKGRlbGltLCBkZWxpbVR5cGUuc2l6ZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgfSBlbHNlXG4gICAgLyogaWYgKGRlbGltVHlwZS50eXBlID09PSBcInN0YWNrXCIpICovXG4gICAge1xuICAgICAgcmV0dXJuIG1ha2VTdGFja2VkRGVsaW0oZGVsaW0sIGhlaWdodCwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgICB9XG59O1xuLyoqXG4gKiBNYWtlIGEgZGVsaW1pdGVyIGZvciB1c2Ugd2l0aCBgXFxsZWZ0YCBhbmQgYFxccmlnaHRgLCBnaXZlbiBhIGhlaWdodCBhbmQgZGVwdGhcbiAqIG9mIGFuIGV4cHJlc3Npb24gdGhhdCB0aGUgZGVsaW1pdGVycyBzdXJyb3VuZC5cbiAqL1xuXG5cbnZhciBtYWtlTGVmdFJpZ2h0RGVsaW0gPSBmdW5jdGlvbiBtYWtlTGVmdFJpZ2h0RGVsaW0oZGVsaW0sIGhlaWdodCwgZGVwdGgsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpIHtcbiAgLy8gV2UgYWx3YXlzIGNlbnRlciBcXGxlZnQvXFxyaWdodCBkZWxpbWl0ZXJzLCBzbyB0aGUgYXhpcyBpcyBhbHdheXMgc2hpZnRlZFxuICB2YXIgYXhpc0hlaWdodCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0ICogb3B0aW9ucy5zaXplTXVsdGlwbGllcjsgLy8gVGFrZW4gZnJvbSBUZVggc291cmNlLCB0ZXgud2ViLCBmdW5jdGlvbiBtYWtlX2xlZnRfcmlnaHRcblxuICB2YXIgZGVsaW1pdGVyRmFjdG9yID0gOTAxO1xuICB2YXIgZGVsaW1pdGVyRXh0ZW5kID0gNS4wIC8gb3B0aW9ucy5mb250TWV0cmljcygpLnB0UGVyRW07XG4gIHZhciBtYXhEaXN0RnJvbUF4aXMgPSBNYXRoLm1heChoZWlnaHQgLSBheGlzSGVpZ2h0LCBkZXB0aCArIGF4aXNIZWlnaHQpO1xuICB2YXIgdG90YWxIZWlnaHQgPSBNYXRoLm1heCggLy8gSW4gcmVhbCBUZVgsIGNhbGN1bGF0aW9ucyBhcmUgZG9uZSB1c2luZyBpbnRlZ3JhbCB2YWx1ZXMgd2hpY2ggYXJlXG4gIC8vIDY1NTM2IHBlciBwdCwgb3IgNjU1MzYwIHBlciBlbS4gU28sIHRoZSBkaXZpc2lvbiBoZXJlIHRydW5jYXRlcyBpblxuICAvLyBUZVggYnV0IGRvZXNuJ3QgaGVyZSwgcHJvZHVjaW5nIGRpZmZlcmVudCByZXN1bHRzLiBJZiB3ZSB3YW50ZWQgdG9cbiAgLy8gZXhhY3RseSBtYXRjaCBUZVgncyBjYWxjdWxhdGlvbiwgd2UgY291bGQgZG9cbiAgLy8gICBNYXRoLmZsb29yKDY1NTM2MCAqIG1heERpc3RGcm9tQXhpcyAvIDUwMCkgKlxuICAvLyAgICBkZWxpbWl0ZXJGYWN0b3IgLyA2NTUzNjBcbiAgLy8gKFRvIHNlZSB0aGUgZGlmZmVyZW5jZSwgY29tcGFyZVxuICAvLyAgICB4Xnt4XntcXGxlZnQoXFxydWxlezAuMWVtfXswLjY4ZW19XFxyaWdodCl9fVxuICAvLyBpbiBUZVggYW5kIEthVGVYKVxuICBtYXhEaXN0RnJvbUF4aXMgLyA1MDAgKiBkZWxpbWl0ZXJGYWN0b3IsIDIgKiBtYXhEaXN0RnJvbUF4aXMgLSBkZWxpbWl0ZXJFeHRlbmQpOyAvLyBGaW5hbGx5LCB3ZSBkZWZlciB0byBgbWFrZUN1c3RvbVNpemVkRGVsaW1gIHdpdGggb3VyIGNhbGN1bGF0ZWQgdG90YWxcbiAgLy8gaGVpZ2h0XG5cbiAgcmV0dXJuIG1ha2VDdXN0b21TaXplZERlbGltKGRlbGltLCB0b3RhbEhlaWdodCwgdHJ1ZSwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7XG59O1xuXG52YXIgZGVsaW1pdGVyID0ge1xuICBzcXJ0SW1hZ2U6IG1ha2VTcXJ0SW1hZ2UsXG4gIHNpemVkRGVsaW06IG1ha2VTaXplZERlbGltLFxuICBzaXplVG9NYXhIZWlnaHQ6IHNpemVUb01heEhlaWdodCxcbiAgY3VzdG9tU2l6ZWREZWxpbTogbWFrZUN1c3RvbVNpemVkRGVsaW0sXG4gIGxlZnRSaWdodERlbGltOiBtYWtlTGVmdFJpZ2h0RGVsaW1cbn07XG5cbi8vIEV4dHJhIGRhdGEgbmVlZGVkIGZvciB0aGUgZGVsaW1pdGVyIGhhbmRsZXIgZG93biBiZWxvd1xudmFyIGRlbGltaXRlclNpemVzID0ge1xuICBcIlxcXFxiaWdsXCI6IHtcbiAgICBtY2xhc3M6IFwibW9wZW5cIixcbiAgICBzaXplOiAxXG4gIH0sXG4gIFwiXFxcXEJpZ2xcIjoge1xuICAgIG1jbGFzczogXCJtb3BlblwiLFxuICAgIHNpemU6IDJcbiAgfSxcbiAgXCJcXFxcYmlnZ2xcIjoge1xuICAgIG1jbGFzczogXCJtb3BlblwiLFxuICAgIHNpemU6IDNcbiAgfSxcbiAgXCJcXFxcQmlnZ2xcIjoge1xuICAgIG1jbGFzczogXCJtb3BlblwiLFxuICAgIHNpemU6IDRcbiAgfSxcbiAgXCJcXFxcYmlnclwiOiB7XG4gICAgbWNsYXNzOiBcIm1jbG9zZVwiLFxuICAgIHNpemU6IDFcbiAgfSxcbiAgXCJcXFxcQmlnclwiOiB7XG4gICAgbWNsYXNzOiBcIm1jbG9zZVwiLFxuICAgIHNpemU6IDJcbiAgfSxcbiAgXCJcXFxcYmlnZ3JcIjoge1xuICAgIG1jbGFzczogXCJtY2xvc2VcIixcbiAgICBzaXplOiAzXG4gIH0sXG4gIFwiXFxcXEJpZ2dyXCI6IHtcbiAgICBtY2xhc3M6IFwibWNsb3NlXCIsXG4gICAgc2l6ZTogNFxuICB9LFxuICBcIlxcXFxiaWdtXCI6IHtcbiAgICBtY2xhc3M6IFwibXJlbFwiLFxuICAgIHNpemU6IDFcbiAgfSxcbiAgXCJcXFxcQmlnbVwiOiB7XG4gICAgbWNsYXNzOiBcIm1yZWxcIixcbiAgICBzaXplOiAyXG4gIH0sXG4gIFwiXFxcXGJpZ2dtXCI6IHtcbiAgICBtY2xhc3M6IFwibXJlbFwiLFxuICAgIHNpemU6IDNcbiAgfSxcbiAgXCJcXFxcQmlnZ21cIjoge1xuICAgIG1jbGFzczogXCJtcmVsXCIsXG4gICAgc2l6ZTogNFxuICB9LFxuICBcIlxcXFxiaWdcIjoge1xuICAgIG1jbGFzczogXCJtb3JkXCIsXG4gICAgc2l6ZTogMVxuICB9LFxuICBcIlxcXFxCaWdcIjoge1xuICAgIG1jbGFzczogXCJtb3JkXCIsXG4gICAgc2l6ZTogMlxuICB9LFxuICBcIlxcXFxiaWdnXCI6IHtcbiAgICBtY2xhc3M6IFwibW9yZFwiLFxuICAgIHNpemU6IDNcbiAgfSxcbiAgXCJcXFxcQmlnZ1wiOiB7XG4gICAgbWNsYXNzOiBcIm1vcmRcIixcbiAgICBzaXplOiA0XG4gIH1cbn07XG52YXIgZGVsaW1pdGVycyA9IFtcIihcIiwgXCJcXFxcbHBhcmVuXCIsIFwiKVwiLCBcIlxcXFxycGFyZW5cIiwgXCJbXCIsIFwiXFxcXGxicmFja1wiLCBcIl1cIiwgXCJcXFxccmJyYWNrXCIsIFwiXFxcXHtcIiwgXCJcXFxcbGJyYWNlXCIsIFwiXFxcXH1cIiwgXCJcXFxccmJyYWNlXCIsIFwiXFxcXGxmbG9vclwiLCBcIlxcXFxyZmxvb3JcIiwgXCJcXHUyMzBhXCIsIFwiXFx1MjMwYlwiLCBcIlxcXFxsY2VpbFwiLCBcIlxcXFxyY2VpbFwiLCBcIlxcdTIzMDhcIiwgXCJcXHUyMzA5XCIsIFwiPFwiLCBcIj5cIiwgXCJcXFxcbGFuZ2xlXCIsIFwiXFx1MjdlOFwiLCBcIlxcXFxyYW5nbGVcIiwgXCJcXHUyN2U5XCIsIFwiXFxcXGx0XCIsIFwiXFxcXGd0XCIsIFwiXFxcXGx2ZXJ0XCIsIFwiXFxcXHJ2ZXJ0XCIsIFwiXFxcXGxWZXJ0XCIsIFwiXFxcXHJWZXJ0XCIsIFwiXFxcXGxncm91cFwiLCBcIlxcXFxyZ3JvdXBcIiwgXCJcXHUyN2VlXCIsIFwiXFx1MjdlZlwiLCBcIlxcXFxsbW91c3RhY2hlXCIsIFwiXFxcXHJtb3VzdGFjaGVcIiwgXCJcXHUyM2IwXCIsIFwiXFx1MjNiMVwiLCBcIi9cIiwgXCJcXFxcYmFja3NsYXNoXCIsIFwifFwiLCBcIlxcXFx2ZXJ0XCIsIFwiXFxcXHxcIiwgXCJcXFxcVmVydFwiLCBcIlxcXFx1cGFycm93XCIsIFwiXFxcXFVwYXJyb3dcIiwgXCJcXFxcZG93bmFycm93XCIsIFwiXFxcXERvd25hcnJvd1wiLCBcIlxcXFx1cGRvd25hcnJvd1wiLCBcIlxcXFxVcGRvd25hcnJvd1wiLCBcIi5cIl07XG5cbi8vIERlbGltaXRlciBmdW5jdGlvbnNcbmZ1bmN0aW9uIGNoZWNrRGVsaW1pdGVyKGRlbGltLCBjb250ZXh0KSB7XG4gIHZhciBzeW1EZWxpbSA9IGNoZWNrU3ltYm9sTm9kZVR5cGUoZGVsaW0pO1xuXG4gIGlmIChzeW1EZWxpbSAmJiBkZWxpbWl0ZXJzLmluY2x1ZGVzKHN5bURlbGltLnRleHQpKSB7XG4gICAgcmV0dXJuIHN5bURlbGltO1xuICB9IGVsc2UgaWYgKHN5bURlbGltKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIGRlbGltaXRlciAnXCIgKyBzeW1EZWxpbS50ZXh0ICsgXCInIGFmdGVyICdcIiArIGNvbnRleHQuZnVuY05hbWUgKyBcIidcIiwgZGVsaW0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBkZWxpbWl0ZXIgdHlwZSAnXCIgKyBkZWxpbS50eXBlICsgXCInXCIsIGRlbGltKTtcbiAgfVxufVxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZGVsaW1zaXppbmdcIixcbiAgbmFtZXM6IFtcIlxcXFxiaWdsXCIsIFwiXFxcXEJpZ2xcIiwgXCJcXFxcYmlnZ2xcIiwgXCJcXFxcQmlnZ2xcIiwgXCJcXFxcYmlnclwiLCBcIlxcXFxCaWdyXCIsIFwiXFxcXGJpZ2dyXCIsIFwiXFxcXEJpZ2dyXCIsIFwiXFxcXGJpZ21cIiwgXCJcXFxcQmlnbVwiLCBcIlxcXFxiaWdnbVwiLCBcIlxcXFxCaWdnbVwiLCBcIlxcXFxiaWdcIiwgXCJcXFxcQmlnXCIsIFwiXFxcXGJpZ2dcIiwgXCJcXFxcQmlnZ1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJwcmltaXRpdmVcIl1cbiAgfSxcbiAgaGFuZGxlcjogKGNvbnRleHQsIGFyZ3MpID0+IHtcbiAgICB2YXIgZGVsaW0gPSBjaGVja0RlbGltaXRlcihhcmdzWzBdLCBjb250ZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJkZWxpbXNpemluZ1wiLFxuICAgICAgbW9kZTogY29udGV4dC5wYXJzZXIubW9kZSxcbiAgICAgIHNpemU6IGRlbGltaXRlclNpemVzW2NvbnRleHQuZnVuY05hbWVdLnNpemUsXG4gICAgICBtY2xhc3M6IGRlbGltaXRlclNpemVzW2NvbnRleHQuZnVuY05hbWVdLm1jbGFzcyxcbiAgICAgIGRlbGltOiBkZWxpbS50ZXh0XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIGlmIChncm91cC5kZWxpbSA9PT0gXCIuXCIpIHtcbiAgICAgIC8vIEVtcHR5IGRlbGltaXRlcnMgc3RpbGwgY291bnQgYXMgZWxlbWVudHMsIGV2ZW4gdGhvdWdoIHRoZXkgZG9uJ3RcbiAgICAgIC8vIHNob3cgYW55dGhpbmcuXG4gICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW2dyb3VwLm1jbGFzc10pO1xuICAgIH0gLy8gVXNlIGRlbGltaXRlci5zaXplZERlbGltIHRvIGdlbmVyYXRlIHRoZSBkZWxpbWl0ZXIuXG5cblxuICAgIHJldHVybiBkZWxpbWl0ZXIuc2l6ZWREZWxpbShncm91cC5kZWxpbSwgZ3JvdXAuc2l6ZSwgb3B0aW9ucywgZ3JvdXAubW9kZSwgW2dyb3VwLm1jbGFzc10pO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBncm91cCA9PiB7XG4gICAgdmFyIGNoaWxkcmVuID0gW107XG5cbiAgICBpZiAoZ3JvdXAuZGVsaW0gIT09IFwiLlwiKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKG1ha2VUZXh0KGdyb3VwLmRlbGltLCBncm91cC5tb2RlKSk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIGNoaWxkcmVuKTtcblxuICAgIGlmIChncm91cC5tY2xhc3MgPT09IFwibW9wZW5cIiB8fCBncm91cC5tY2xhc3MgPT09IFwibWNsb3NlXCIpIHtcbiAgICAgIC8vIE9ubHkgc29tZSBvZiB0aGUgZGVsaW1zaXppbmcgZnVuY3Rpb25zIGFjdCBhcyBmZW5jZXMsIGFuZCB0aGV5XG4gICAgICAvLyByZXR1cm4gXCJtb3BlblwiIG9yIFwibWNsb3NlXCIgbWNsYXNzLlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV4cGxpY2l0bHkgZGlzYWJsZSBmZW5jaW5nIGlmIGl0J3Mgbm90IGEgZmVuY2UsIHRvIG92ZXJyaWRlIHRoZVxuICAgICAgLy8gZGVmYXVsdHMuXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwiZmFsc2VcIik7XG4gICAgfVxuXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcInRydWVcIik7XG4gICAgdmFyIHNpemUgPSBtYWtlRW0oZGVsaW1pdGVyLnNpemVUb01heEhlaWdodFtncm91cC5zaXplXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtaW5zaXplXCIsIHNpemUpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF4c2l6ZVwiLCBzaXplKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGFzc2VydFBhcnNlZChncm91cCkge1xuICBpZiAoIWdyb3VwLmJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWc6IFRoZSBsZWZ0cmlnaHQgUGFyc2VOb2RlIHdhc24ndCBmdWxseSBwYXJzZWQuXCIpO1xuICB9XG59XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJsZWZ0cmlnaHQtcmlnaHRcIixcbiAgbmFtZXM6IFtcIlxcXFxyaWdodFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIC8vIFxcbGVmdCBjYXNlIGJlbG93IHRyaWdnZXJzIHBhcnNpbmcgb2YgXFxyaWdodCBpblxuICAgIC8vICAgYGNvbnN0IHJpZ2h0ID0gcGFyc2VyLnBhcnNlRnVuY3Rpb24oKTtgXG4gICAgLy8gdXNlcyB0aGlzIHJldHVybiB2YWx1ZS5cbiAgICB2YXIgY29sb3IgPSBjb250ZXh0LnBhcnNlci5ndWxsZXQubWFjcm9zLmdldChcIlxcXFxjdXJyZW50QGNvbG9yXCIpO1xuXG4gICAgaWYgKGNvbG9yICYmIHR5cGVvZiBjb2xvciAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcY3VycmVudEBjb2xvciBzZXQgdG8gbm9uLXN0cmluZyBpbiBcXFxccmlnaHRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGVmdHJpZ2h0LXJpZ2h0XCIsXG4gICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLFxuICAgICAgZGVsaW06IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpLnRleHQsXG4gICAgICBjb2xvciAvLyB1bmRlZmluZWQgaWYgbm90IHNldCB2aWEgXFxjb2xvclxuXG4gICAgfTtcbiAgfVxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibGVmdHJpZ2h0XCIsXG4gIG5hbWVzOiBbXCJcXFxcbGVmdFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIHZhciBkZWxpbSA9IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpO1xuICAgIHZhciBwYXJzZXIgPSBjb250ZXh0LnBhcnNlcjsgLy8gUGFyc2Ugb3V0IHRoZSBpbXBsaWNpdCBib2R5XG5cbiAgICArK3BhcnNlci5sZWZ0cmlnaHREZXB0aDsgLy8gcGFyc2VFeHByZXNzaW9uIHN0b3BzIGJlZm9yZSAnXFxcXHJpZ2h0J1xuXG4gICAgdmFyIGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlKTtcbiAgICAtLXBhcnNlci5sZWZ0cmlnaHREZXB0aDsgLy8gQ2hlY2sgdGhlIG5leHQgdG9rZW5cblxuICAgIHBhcnNlci5leHBlY3QoXCJcXFxccmlnaHRcIiwgZmFsc2UpO1xuICAgIHZhciByaWdodCA9IGFzc2VydE5vZGVUeXBlKHBhcnNlci5wYXJzZUZ1bmN0aW9uKCksIFwibGVmdHJpZ2h0LXJpZ2h0XCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5LFxuICAgICAgbGVmdDogZGVsaW0udGV4dCxcbiAgICAgIHJpZ2h0OiByaWdodC5kZWxpbSxcbiAgICAgIHJpZ2h0Q29sb3I6IHJpZ2h0LmNvbG9yXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIGFzc2VydFBhcnNlZChncm91cCk7IC8vIEJ1aWxkIHRoZSBpbm5lciBleHByZXNzaW9uXG5cbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24kMShncm91cC5ib2R5LCBvcHRpb25zLCB0cnVlLCBbXCJtb3BlblwiLCBcIm1jbG9zZVwiXSk7XG4gICAgdmFyIGlubmVySGVpZ2h0ID0gMDtcbiAgICB2YXIgaW5uZXJEZXB0aCA9IDA7XG4gICAgdmFyIGhhZE1pZGRsZSA9IGZhbHNlOyAvLyBDYWxjdWxhdGUgaXRzIGhlaWdodCBhbmQgZGVwdGhcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFByb3BlcnR5IGBpc01pZGRsZWAgbm90IGRlZmluZWQgb24gYHNwYW5gLiBTZWUgY29tbWVudCBpblxuICAgICAgLy8gXCJtaWRkbGVcIidzIGh0bWxCdWlsZGVyLlxuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgaWYgKGlubmVyW2ldLmlzTWlkZGxlKSB7XG4gICAgICAgIGhhZE1pZGRsZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbm5lckhlaWdodCA9IE1hdGgubWF4KGlubmVyW2ldLmhlaWdodCwgaW5uZXJIZWlnaHQpO1xuICAgICAgICBpbm5lckRlcHRoID0gTWF0aC5tYXgoaW5uZXJbaV0uZGVwdGgsIGlubmVyRGVwdGgpO1xuICAgICAgfVxuICAgIH0gLy8gVGhlIHNpemUgb2YgZGVsaW1pdGVycyBpcyB0aGUgc2FtZSwgcmVnYXJkbGVzcyBvZiB3aGF0IHN0eWxlIHdlIGFyZVxuICAgIC8vIGluLiBUaHVzLCB0byBjb3JyZWN0bHkgY2FsY3VsYXRlIHRoZSBzaXplIG9mIGRlbGltaXRlciB3ZSBuZWVkIGFyb3VuZFxuICAgIC8vIGEgZ3JvdXAsIHdlIHNjYWxlIGRvd24gdGhlIGlubmVyIHNpemUgYmFzZWQgb24gdGhlIHNpemUuXG5cblxuICAgIGlubmVySGVpZ2h0ICo9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgaW5uZXJEZXB0aCAqPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICAgIHZhciBsZWZ0RGVsaW07XG5cbiAgICBpZiAoZ3JvdXAubGVmdCA9PT0gXCIuXCIpIHtcbiAgICAgIC8vIEVtcHR5IGRlbGltaXRlcnMgaW4gXFxsZWZ0IGFuZCBcXHJpZ2h0IG1ha2UgbnVsbCBkZWxpbWl0ZXIgc3BhY2VzLlxuICAgICAgbGVmdERlbGltID0gbWFrZU51bGxEZWxpbWl0ZXIob3B0aW9ucywgW1wibW9wZW5cIl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UsIHVzZSBsZWZ0UmlnaHREZWxpbSB0byBnZW5lcmF0ZSB0aGUgY29ycmVjdCBzaXplZFxuICAgICAgLy8gZGVsaW1pdGVyLlxuICAgICAgbGVmdERlbGltID0gZGVsaW1pdGVyLmxlZnRSaWdodERlbGltKGdyb3VwLmxlZnQsIGlubmVySGVpZ2h0LCBpbm5lckRlcHRoLCBvcHRpb25zLCBncm91cC5tb2RlLCBbXCJtb3BlblwiXSk7XG4gICAgfSAvLyBBZGQgaXQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZXhwcmVzc2lvblxuXG5cbiAgICBpbm5lci51bnNoaWZ0KGxlZnREZWxpbSk7IC8vIEhhbmRsZSBtaWRkbGUgZGVsaW1pdGVyc1xuXG4gICAgaWYgKGhhZE1pZGRsZSkge1xuICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGlubmVyLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgbWlkZGxlRGVsaW0gPSBpbm5lcltfaV07IC8vIFByb3BlcnR5IGBpc01pZGRsZWAgbm90IGRlZmluZWQgb24gYHNwYW5gLiBTZWUgY29tbWVudCBpblxuICAgICAgICAvLyBcIm1pZGRsZVwiJ3MgaHRtbEJ1aWxkZXIuXG4gICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICB2YXIgaXNNaWRkbGUgPSBtaWRkbGVEZWxpbS5pc01pZGRsZTtcblxuICAgICAgICBpZiAoaXNNaWRkbGUpIHtcbiAgICAgICAgICAvLyBBcHBseSB0aGUgb3B0aW9ucyB0aGF0IHdlcmUgYWN0aXZlIHdoZW4gXFxtaWRkbGUgd2FzIGNhbGxlZFxuICAgICAgICAgIGlubmVyW19pXSA9IGRlbGltaXRlci5sZWZ0UmlnaHREZWxpbShpc01pZGRsZS5kZWxpbSwgaW5uZXJIZWlnaHQsIGlubmVyRGVwdGgsIGlzTWlkZGxlLm9wdGlvbnMsIGdyb3VwLm1vZGUsIFtdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByaWdodERlbGltOyAvLyBTYW1lIGZvciB0aGUgcmlnaHQgZGVsaW1pdGVyLCBidXQgdXNpbmcgY29sb3Igc3BlY2lmaWVkIGJ5IFxcY29sb3JcblxuICAgIGlmIChncm91cC5yaWdodCA9PT0gXCIuXCIpIHtcbiAgICAgIHJpZ2h0RGVsaW0gPSBtYWtlTnVsbERlbGltaXRlcihvcHRpb25zLCBbXCJtY2xvc2VcIl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29sb3JPcHRpb25zID0gZ3JvdXAucmlnaHRDb2xvciA/IG9wdGlvbnMud2l0aENvbG9yKGdyb3VwLnJpZ2h0Q29sb3IpIDogb3B0aW9ucztcbiAgICAgIHJpZ2h0RGVsaW0gPSBkZWxpbWl0ZXIubGVmdFJpZ2h0RGVsaW0oZ3JvdXAucmlnaHQsIGlubmVySGVpZ2h0LCBpbm5lckRlcHRoLCBjb2xvck9wdGlvbnMsIGdyb3VwLm1vZGUsIFtcIm1jbG9zZVwiXSk7XG4gICAgfSAvLyBBZGQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgZXhwcmVzc2lvbi5cblxuXG4gICAgaW5uZXIucHVzaChyaWdodERlbGltKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibWlubmVyXCJdLCBpbm5lciwgb3B0aW9ucyk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIGFzc2VydFBhcnNlZChncm91cCk7XG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMpO1xuXG4gICAgaWYgKGdyb3VwLmxlZnQgIT09IFwiLlwiKSB7XG4gICAgICB2YXIgbGVmdE5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChncm91cC5sZWZ0LCBncm91cC5tb2RlKV0pO1xuICAgICAgbGVmdE5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgICAgaW5uZXIudW5zaGlmdChsZWZ0Tm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnJpZ2h0ICE9PSBcIi5cIikge1xuICAgICAgdmFyIHJpZ2h0Tm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLnJpZ2h0LCBncm91cC5tb2RlKV0pO1xuICAgICAgcmlnaHROb2RlLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwidHJ1ZVwiKTtcblxuICAgICAgaWYgKGdyb3VwLnJpZ2h0Q29sb3IpIHtcbiAgICAgICAgcmlnaHROb2RlLnNldEF0dHJpYnV0ZShcIm1hdGhjb2xvclwiLCBncm91cC5yaWdodENvbG9yKTtcbiAgICAgIH1cblxuICAgICAgaW5uZXIucHVzaChyaWdodE5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBtYWtlUm93KGlubmVyKTtcbiAgfVxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWlkZGxlXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWlkZGxlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7XG4gICAgdmFyIGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG5cbiAgICBpZiAoIWNvbnRleHQucGFyc2VyLmxlZnRyaWdodERlcHRoKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFxtaWRkbGUgd2l0aG91dCBwcmVjZWRpbmcgXFxcXGxlZnRcIiwgZGVsaW0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1pZGRsZVwiLFxuICAgICAgbW9kZTogY29udGV4dC5wYXJzZXIubW9kZSxcbiAgICAgIGRlbGltOiBkZWxpbS50ZXh0XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBtaWRkbGVEZWxpbTtcblxuICAgIGlmIChncm91cC5kZWxpbSA9PT0gXCIuXCIpIHtcbiAgICAgIG1pZGRsZURlbGltID0gbWFrZU51bGxEZWxpbWl0ZXIob3B0aW9ucywgW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWRkbGVEZWxpbSA9IGRlbGltaXRlci5zaXplZERlbGltKGdyb3VwLmRlbGltLCAxLCBvcHRpb25zLCBncm91cC5tb2RlLCBbXSk7XG4gICAgICB2YXIgaXNNaWRkbGUgPSB7XG4gICAgICAgIGRlbGltOiBncm91cC5kZWxpbSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTsgLy8gUHJvcGVydHkgYGlzTWlkZGxlYCBub3QgZGVmaW5lZCBvbiBgc3BhbmAuIEl0IGlzIG9ubHkgdXNlZCBpblxuICAgICAgLy8gdGhpcyBmaWxlIGFib3ZlLlxuICAgICAgLy8gVE9ETzogRml4IHRoaXMgdmlvbGF0aW9uIG9mIHRoZSBgc3BhbmAgdHlwZSBhbmQgcG9zc2libHkgcmVuYW1lXG4gICAgICAvLyB0aGluZ3Mgc2luY2UgYGlzTWlkZGxlYCBzb3VuZHMgbGlrZSBhIGJvb2xlYW4sIGJ1dCBpcyBhIHN0cnVjdC5cbiAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgbWlkZGxlRGVsaW0uaXNNaWRkbGUgPSBpc01pZGRsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWlkZGxlRGVsaW07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIC8vIEEgRmlyZWZveCBcXG1pZGRsZSB3aWxsIHN0cmV0Y2ggYSBjaGFyYWN0ZXIgdmVydGljYWxseSBvbmx5IGlmIGl0XG4gICAgLy8gaXMgaW4gdGhlIGZlbmNlIHBhcnQgb2YgdGhlIG9wZXJhdG9yIGRpY3Rpb25hcnkgYXQ6XG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL01hdGhNTDMvYXBwZW5kaXhjLmh0bWwuXG4gICAgLy8gU28gd2UgbmVlZCB0byBhdm9pZCBVKzIyMjMgYW5kIHVzZSBwbGFpbiBcInxcIiBpbnN0ZWFkLlxuICAgIHZhciB0ZXh0Tm9kZSA9IGdyb3VwLmRlbGltID09PSBcIlxcXFx2ZXJ0XCIgfHwgZ3JvdXAuZGVsaW0gPT09IFwifFwiID8gbWFrZVRleHQoXCJ8XCIsIFwidGV4dFwiKSA6IG1ha2VUZXh0KGdyb3VwLmRlbGltLCBncm91cC5tb2RlKTtcbiAgICB2YXIgbWlkZGxlTm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW3RleHROb2RlXSk7XG4gICAgbWlkZGxlTm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7IC8vIE1hdGhNTCBnaXZlcyA1LzE4ZW0gc3BhY2luZyB0byBlYWNoIDxtbz4gZWxlbWVudC5cbiAgICAvLyBcXG1pZGRsZSBzaG91bGQgZ2V0IGRlbGltaXRlciBzcGFjaW5nIGluc3RlYWQuXG5cbiAgICBtaWRkbGVOb2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBcIjAuMDVlbVwiKTtcbiAgICBtaWRkbGVOb2RlLnNldEF0dHJpYnV0ZShcInJzcGFjZVwiLCBcIjAuMDVlbVwiKTtcbiAgICByZXR1cm4gbWlkZGxlTm9kZTtcbiAgfVxufSk7XG5cbnZhciBodG1sQnVpbGRlciQ3ID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIC8vIFxcY2FuY2VsLCBcXGJjYW5jZWwsIFxceGNhbmNlbCwgXFxzb3V0LCBcXGZib3gsIFxcY29sb3Jib3gsIFxcZmNvbG9yYm94LCBcXHBoYXNlXG4gIC8vIFNvbWUgZ3JvdXBzIGNhbiByZXR1cm4gZG9jdW1lbnQgZnJhZ21lbnRzLiAgSGFuZGxlIHRob3NlIGJ5IHdyYXBwaW5nXG4gIC8vIHRoZW0gaW4gYSBzcGFuLlxuICB2YXIgaW5uZXIgPSBidWlsZENvbW1vbi53cmFwRnJhZ21lbnQoYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgdmFyIGxhYmVsID0gZ3JvdXAubGFiZWwuc2xpY2UoMSk7XG4gIHZhciBzY2FsZSA9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gIHZhciBpbWc7XG4gIHZhciBpbWdTaGlmdCA9IDA7IC8vIEluIHRoZSBMYVRlWCBjYW5jZWwgcGFja2FnZSwgbGluZSBnZW9tZXRyeSBpcyBzbGlnaHRseSBkaWZmZXJlbnRcbiAgLy8gZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIHN1YmplY3QgaXMgd2lkZXIgdGhhbiBpdCBpcyB0YWxsLCBvciB2aWNlIHZlcnNhLlxuICAvLyBXZSBkb24ndCBrbm93IHRoZSB3aWR0aCBvZiBhIGdyb3VwLCBzbyBhcyBhIHByb3h5LCB3ZSB0ZXN0IGlmXG4gIC8vIHRoZSBzdWJqZWN0IGlzIGEgc2luZ2xlIGNoYXJhY3Rlci4gVGhpcyBjYXB0dXJlcyBtb3N0IG9mIHRoZVxuICAvLyBzdWJqZWN0cyB0aGF0IHNob3VsZCBnZXQgdGhlIFwidGFsbFwiIHRyZWF0bWVudC5cblxuICB2YXIgaXNTaW5nbGVDaGFyID0gdXRpbHMuaXNDaGFyYWN0ZXJCb3goZ3JvdXAuYm9keSk7XG5cbiAgaWYgKGxhYmVsID09PSBcInNvdXRcIikge1xuICAgIGltZyA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcInN0cmV0Y2h5XCIsIFwic291dFwiXSk7XG4gICAgaW1nLmhlaWdodCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWZhdWx0UnVsZVRoaWNrbmVzcyAvIHNjYWxlO1xuICAgIGltZ1NoaWZ0ID0gLTAuNSAqIG9wdGlvbnMuZm9udE1ldHJpY3MoKS54SGVpZ2h0O1xuICB9IGVsc2UgaWYgKGxhYmVsID09PSBcInBoYXNlXCIpIHtcbiAgICAvLyBTZXQgYSBjb3VwbGUgb2YgZGltZW5zaW9ucyBmcm9tIHRoZSBzdGVpbm1ldHogcGFja2FnZS5cbiAgICB2YXIgbGluZVdlaWdodCA9IGNhbGN1bGF0ZVNpemUoe1xuICAgICAgbnVtYmVyOiAwLjYsXG4gICAgICB1bml0OiBcInB0XCJcbiAgICB9LCBvcHRpb25zKTtcbiAgICB2YXIgY2xlYXJhbmNlID0gY2FsY3VsYXRlU2l6ZSh7XG4gICAgICBudW1iZXI6IDAuMzUsXG4gICAgICB1bml0OiBcImV4XCJcbiAgICB9LCBvcHRpb25zKTsgLy8gUHJldmVudCBzaXplIGNoYW5nZXMgbGlrZSBcXEh1Z2UgZnJvbSBhZmZlY3RpbmcgbGluZSB0aGlja25lc3NcblxuICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdCYXNlU2l6aW5nKCk7XG4gICAgc2NhbGUgPSBzY2FsZSAvIG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgdmFyIGFuZ2xlSGVpZ2h0ID0gaW5uZXIuaGVpZ2h0ICsgaW5uZXIuZGVwdGggKyBsaW5lV2VpZ2h0ICsgY2xlYXJhbmNlOyAvLyBSZXNlcnZlIGEgbGVmdCBwYWQgZm9yIHRoZSBhbmdsZS5cblxuICAgIGlubmVyLnN0eWxlLnBhZGRpbmdMZWZ0ID0gbWFrZUVtKGFuZ2xlSGVpZ2h0IC8gMiArIGxpbmVXZWlnaHQpOyAvLyBDcmVhdGUgYW4gU1ZHXG5cbiAgICB2YXIgdmlld0JveEhlaWdodCA9IE1hdGguZmxvb3IoMTAwMCAqIGFuZ2xlSGVpZ2h0ICogc2NhbGUpO1xuICAgIHZhciBwYXRoID0gcGhhc2VQYXRoKHZpZXdCb3hIZWlnaHQpO1xuICAgIHZhciBzdmdOb2RlID0gbmV3IFN2Z05vZGUoW25ldyBQYXRoTm9kZShcInBoYXNlXCIsIHBhdGgpXSwge1xuICAgICAgXCJ3aWR0aFwiOiBcIjQwMGVtXCIsXG4gICAgICBcImhlaWdodFwiOiBtYWtlRW0odmlld0JveEhlaWdodCAvIDEwMDApLFxuICAgICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDQwMDAwMCBcIiArIHZpZXdCb3hIZWlnaHQsXG4gICAgICBcInByZXNlcnZlQXNwZWN0UmF0aW9cIjogXCJ4TWluWU1pbiBzbGljZVwiXG4gICAgfSk7IC8vIFdyYXAgaXQgaW4gYSBzcGFuIHdpdGggb3ZlcmZsb3c6IGhpZGRlbi5cblxuICAgIGltZyA9IGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFtcImhpZGUtdGFpbFwiXSwgW3N2Z05vZGVdLCBvcHRpb25zKTtcbiAgICBpbWcuc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKGFuZ2xlSGVpZ2h0KTtcbiAgICBpbWdTaGlmdCA9IGlubmVyLmRlcHRoICsgbGluZVdlaWdodCArIGNsZWFyYW5jZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBZGQgaG9yaXpvbnRhbCBwYWRkaW5nXG4gICAgaWYgKC9jYW5jZWwvLnRlc3QobGFiZWwpKSB7XG4gICAgICBpZiAoIWlzU2luZ2xlQ2hhcikge1xuICAgICAgICBpbm5lci5jbGFzc2VzLnB1c2goXCJjYW5jZWwtcGFkXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGFiZWwgPT09IFwiYW5nbFwiKSB7XG4gICAgICBpbm5lci5jbGFzc2VzLnB1c2goXCJhbmdscGFkXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbm5lci5jbGFzc2VzLnB1c2goXCJib3hwYWRcIik7XG4gICAgfSAvLyBBZGQgdmVydGljYWwgcGFkZGluZ1xuXG5cbiAgICB2YXIgdG9wUGFkID0gMDtcbiAgICB2YXIgYm90dG9tUGFkID0gMDtcbiAgICB2YXIgcnVsZVRoaWNrbmVzcyA9IDA7IC8vIHJlZjogY2FuY2VsIHBhY2thZ2U6IFxcYWR2YW5jZVxcdG90YWxoZWlnaHQyXFxwQCAlIFwiKzJcIlxuXG4gICAgaWYgKC9ib3gvLnRlc3QobGFiZWwpKSB7XG4gICAgICBydWxlVGhpY2tuZXNzID0gTWF0aC5tYXgob3B0aW9ucy5mb250TWV0cmljcygpLmZib3hydWxlLCAvLyBkZWZhdWx0XG4gICAgICBvcHRpb25zLm1pblJ1bGVUaGlja25lc3MgLy8gVXNlciBvdmVycmlkZS5cbiAgICAgICk7XG4gICAgICB0b3BQYWQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZmJveHNlcCArIChsYWJlbCA9PT0gXCJjb2xvcmJveFwiID8gMCA6IHJ1bGVUaGlja25lc3MpO1xuICAgICAgYm90dG9tUGFkID0gdG9wUGFkO1xuICAgIH0gZWxzZSBpZiAobGFiZWwgPT09IFwiYW5nbFwiKSB7XG4gICAgICBydWxlVGhpY2tuZXNzID0gTWF0aC5tYXgob3B0aW9ucy5mb250TWV0cmljcygpLmRlZmF1bHRSdWxlVGhpY2tuZXNzLCBvcHRpb25zLm1pblJ1bGVUaGlja25lc3MpO1xuICAgICAgdG9wUGFkID0gNCAqIHJ1bGVUaGlja25lc3M7IC8vIGdhcCA9IDMgw5cgbGluZSwgcGx1cyB0aGUgbGluZSBpdHNlbGYuXG5cbiAgICAgIGJvdHRvbVBhZCA9IE1hdGgubWF4KDAsIDAuMjUgLSBpbm5lci5kZXB0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcFBhZCA9IGlzU2luZ2xlQ2hhciA/IDAuMiA6IDA7XG4gICAgICBib3R0b21QYWQgPSB0b3BQYWQ7XG4gICAgfVxuXG4gICAgaW1nID0gc3RyZXRjaHkuZW5jbG9zZVNwYW4oaW5uZXIsIGxhYmVsLCB0b3BQYWQsIGJvdHRvbVBhZCwgb3B0aW9ucyk7XG5cbiAgICBpZiAoL2Zib3h8Ym94ZWR8ZmNvbG9yYm94Ly50ZXN0KGxhYmVsKSkge1xuICAgICAgaW1nLnN0eWxlLmJvcmRlclN0eWxlID0gXCJzb2xpZFwiO1xuICAgICAgaW1nLnN0eWxlLmJvcmRlcldpZHRoID0gbWFrZUVtKHJ1bGVUaGlja25lc3MpO1xuICAgIH0gZWxzZSBpZiAobGFiZWwgPT09IFwiYW5nbFwiICYmIHJ1bGVUaGlja25lc3MgIT09IDAuMDQ5KSB7XG4gICAgICBpbWcuc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBtYWtlRW0ocnVsZVRoaWNrbmVzcyk7XG4gICAgICBpbWcuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IG1ha2VFbShydWxlVGhpY2tuZXNzKTtcbiAgICB9XG5cbiAgICBpbWdTaGlmdCA9IGlubmVyLmRlcHRoICsgYm90dG9tUGFkO1xuXG4gICAgaWYgKGdyb3VwLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgaW1nLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGdyb3VwLmJhY2tncm91bmRDb2xvcjtcblxuICAgICAgaWYgKGdyb3VwLmJvcmRlckNvbG9yKSB7XG4gICAgICAgIGltZy5zdHlsZS5ib3JkZXJDb2xvciA9IGdyb3VwLmJvcmRlckNvbG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB2bGlzdDtcblxuICBpZiAoZ3JvdXAuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgY2hpbGRyZW46IFsvLyBQdXQgdGhlIGNvbG9yIGJhY2tncm91bmQgYmVoaW5kIGlubmVyO1xuICAgICAge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogaW1nLFxuICAgICAgICBzaGlmdDogaW1nU2hpZnRcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGlubmVyLFxuICAgICAgICBzaGlmdDogMFxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY2xhc3NlcyA9IC9jYW5jZWx8cGhhc2UvLnRlc3QobGFiZWwpID8gW1wic3ZnLWFsaWduXCJdIDogW107XG4gICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgY2hpbGRyZW46IFsvLyBXcml0ZSB0aGUgXFxjYW5jZWwgc3Ryb2tlIG9uIHRvcCBvZiBpbm5lci5cbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGlubmVyLFxuICAgICAgICBzaGlmdDogMFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogaW1nLFxuICAgICAgICBzaGlmdDogaW1nU2hpZnQsXG4gICAgICAgIHdyYXBwZXJDbGFzc2VzOiBjbGFzc2VzXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKC9jYW5jZWwvLnRlc3QobGFiZWwpKSB7XG4gICAgLy8gVGhlIGNhbmNlbCBwYWNrYWdlIGRvY3VtZW50YXRpb24gc2F5cyB0aGF0IGNhbmNlbCBsaW5lcyBhZGQgdGhlaXIgaGVpZ2h0XG4gICAgLy8gdG8gdGhlIGV4cHJlc3Npb24sIGJ1dCB0ZXN0cyBzaG93IHRoYXQgaXNuJ3QgaG93IGl0IGFjdHVhbGx5IHdvcmtzLlxuICAgIHZsaXN0LmhlaWdodCA9IGlubmVyLmhlaWdodDtcbiAgICB2bGlzdC5kZXB0aCA9IGlubmVyLmRlcHRoO1xuICB9XG5cbiAgaWYgKC9jYW5jZWwvLnRlc3QobGFiZWwpICYmICFpc1NpbmdsZUNoYXIpIHtcbiAgICAvLyBjYW5jZWwgZG9lcyBub3QgY3JlYXRlIGhvcml6IHNwYWNlIGZvciBpdHMgbGluZSBleHRlbnNpb24uXG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJjYW5jZWwtbGFwXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiXSwgW3ZsaXN0XSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cbnZhciBtYXRobWxCdWlsZGVyJDYgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgdmFyIGZib3hzZXAgPSAwO1xuICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKGdyb3VwLmxhYmVsLmluZGV4T2YoXCJjb2xvcmJveFwiKSA+IC0xID8gXCJtcGFkZGVkXCIgOiBcIm1lbmNsb3NlXCIsIFtidWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpXSk7XG5cbiAgc3dpdGNoIChncm91cC5sYWJlbCkge1xuICAgIGNhc2UgXCJcXFxcY2FuY2VsXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwidXBkaWFnb25hbHN0cmlrZVwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlxcXFxiY2FuY2VsXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiZG93bmRpYWdvbmFsc3RyaWtlXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiXFxcXHBoYXNlXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwicGhhc29yYW5nbGVcIik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJcXFxcc291dFwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcImhvcml6b250YWxzdHJpa2VcIik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJcXFxcZmJveFwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcImJveFwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIlxcXFxhbmdsXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiYWN0dWFyaWFsXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiXFxcXGZjb2xvcmJveFwiOlxuICAgIGNhc2UgXCJcXFxcY29sb3Jib3hcIjpcbiAgICAgIC8vIDxtZW5jbG9zZT4gZG9lc24ndCBoYXZlIGEgZ29vZCBub3RhdGlvbiBvcHRpb24uIFNvIHVzZSA8bXBhZGRlZD5cbiAgICAgIC8vIGluc3RlYWQuIFNldCBzb21lIGF0dHJpYnV0ZXMgdGhhdCBjb21lIGluY2x1ZGVkIHdpdGggPG1lbmNsb3NlPi5cbiAgICAgIGZib3hzZXAgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZmJveHNlcCAqIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5wdFBlckVtO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIitcIiArIDIgKiBmYm94c2VwICsgXCJwdFwiKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiK1wiICsgMiAqIGZib3hzZXAgKyBcInB0XCIpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgZmJveHNlcCArIFwicHRcIik7IC8vXG5cbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwidm9mZnNldFwiLCBmYm94c2VwICsgXCJwdFwiKTtcblxuICAgICAgaWYgKGdyb3VwLmxhYmVsID09PSBcIlxcXFxmY29sb3Jib3hcIikge1xuICAgICAgICB2YXIgdGhrID0gTWF0aC5tYXgob3B0aW9ucy5mb250TWV0cmljcygpLmZib3hydWxlLCAvLyBkZWZhdWx0XG4gICAgICAgIG9wdGlvbnMubWluUnVsZVRoaWNrbmVzcyAvLyB1c2VyIG92ZXJyaWRlXG4gICAgICAgICk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJib3JkZXI6IFwiICsgdGhrICsgXCJlbSBzb2xpZCBcIiArIFN0cmluZyhncm91cC5ib3JkZXJDb2xvcikpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJcXFxceGNhbmNlbFwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcInVwZGlhZ29uYWxzdHJpa2UgZG93bmRpYWdvbmFsc3RyaWtlXCIpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAoZ3JvdXAuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRoYmFja2dyb3VuZFwiLCBncm91cC5iYWNrZ3JvdW5kQ29sb3IpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXGNvbG9yYm94XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wiY29sb3JcIiwgXCJ0ZXh0XCJdXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIGNvbG9yID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJjb2xvci10b2tlblwiKS5jb2xvcjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDcsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNlxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXGZjb2xvcmJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAzLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcImNvbG9yXCIsIFwiY29sb3JcIiwgXCJ0ZXh0XCJdXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmMiwgYXJncywgb3B0QXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmMjtcbiAgICB2YXIgYm9yZGVyQ29sb3IgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcImNvbG9yLXRva2VuXCIpLmNvbG9yO1xuICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBhc3NlcnROb2RlVHlwZShhcmdzWzFdLCBcImNvbG9yLXRva2VuXCIpLmNvbG9yO1xuICAgIHZhciBib2R5ID0gYXJnc1syXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJhY2tncm91bmRDb2xvcixcbiAgICAgIGJvcmRlckNvbG9yLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDcsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNlxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXGZib3hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wiaGJveFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmMywgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogXCJcXFxcZmJveFwiLFxuICAgICAgYm9keTogYXJnc1swXVxuICAgIH07XG4gIH1cblxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXGNhbmNlbFwiLCBcIlxcXFxiY2FuY2VsXCIsIFwiXFxcXHhjYW5jZWxcIiwgXCJcXFxcc291dFwiLCBcIlxcXFxwaGFzZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmNCwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmNDtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNyxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ2XG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcYW5nbFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJoYm94XCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IGZhbHNlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmNSwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogXCJcXFxcYW5nbFwiLFxuICAgICAgYm9keTogYXJnc1swXVxuICAgIH07XG4gIH1cblxufSk7XG5cbi8qKlxuICogQWxsIHJlZ2lzdGVyZWQgZW52aXJvbm1lbnRzLlxuICogYGVudmlyb25tZW50cy5qc2AgZXhwb3J0cyB0aGlzIHNhbWUgZGljdGlvbmFyeSBhZ2FpbiBhbmQgbWFrZXMgaXQgcHVibGljLlxuICogYFBhcnNlci5qc2AgcmVxdWlyZXMgdGhpcyBkaWN0aW9uYXJ5IHZpYSBgZW52aXJvbm1lbnRzLmpzYC5cbiAqL1xudmFyIF9lbnZpcm9ubWVudHMgPSB7fTtcbmZ1bmN0aW9uIGRlZmluZUVudmlyb25tZW50KF9yZWYpIHtcbiAgdmFyIHtcbiAgICB0eXBlLFxuICAgIG5hbWVzLFxuICAgIHByb3BzLFxuICAgIGhhbmRsZXIsXG4gICAgaHRtbEJ1aWxkZXIsXG4gICAgbWF0aG1sQnVpbGRlclxuICB9ID0gX3JlZjtcbiAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIG9mIGVudmlyb25tZW50cy5cbiAgdmFyIGRhdGEgPSB7XG4gICAgdHlwZSxcbiAgICBudW1BcmdzOiBwcm9wcy5udW1BcmdzIHx8IDAsXG4gICAgYWxsb3dlZEluVGV4dDogZmFsc2UsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAwLFxuICAgIGhhbmRsZXJcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gVE9ETzogVGhlIHZhbHVlIHR5cGUgb2YgX2Vudmlyb25tZW50cyBzaG91bGQgYmUgYSB0eXBlIHVuaW9uIG9mIGFsbFxuICAgIC8vIHBvc3NpYmxlIGBFbnZTcGVjPD5gIHBvc3NpYmlsaXRpZXMgaW5zdGVhZCBvZiBgRW52U3BlYzwqPmAsIHdoaWNoIGlzXG4gICAgLy8gYW4gZXhpc3RlbnRpYWwgdHlwZS5cbiAgICBfZW52aXJvbm1lbnRzW25hbWVzW2ldXSA9IGRhdGE7XG4gIH1cblxuICBpZiAoaHRtbEJ1aWxkZXIpIHtcbiAgICBfaHRtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBodG1sQnVpbGRlcjtcbiAgfVxuXG4gIGlmIChtYXRobWxCdWlsZGVyKSB7XG4gICAgX21hdGhtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBtYXRobWxCdWlsZGVyO1xuICB9XG59XG5cbi8qKlxuICogQWxsIHJlZ2lzdGVyZWQgZ2xvYmFsL2J1aWx0LWluIG1hY3Jvcy5cbiAqIGBtYWNyb3MuanNgIGV4cG9ydHMgdGhpcyBzYW1lIGRpY3Rpb25hcnkgYWdhaW4gYW5kIG1ha2VzIGl0IHB1YmxpYy5cbiAqIGBQYXJzZXIuanNgIHJlcXVpcmVzIHRoaXMgZGljdGlvbmFyeSB2aWEgYG1hY3Jvcy5qc2AuXG4gKi9cbnZhciBfbWFjcm9zID0ge307IC8vIFRoaXMgZnVuY3Rpb24gbWlnaHQgb25lIGRheSBhY2NlcHQgYW4gYWRkaXRpb25hbCBhcmd1bWVudCBhbmQgZG8gbW9yZSB0aGluZ3MuXG5cbmZ1bmN0aW9uIGRlZmluZU1hY3JvKG5hbWUsIGJvZHkpIHtcbiAgX21hY3Jvc1tuYW1lXSA9IGJvZHk7XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnNcbmZ1bmN0aW9uIGdldEhMaW5lcyhwYXJzZXIpIHtcbiAgLy8gUmV0dXJuIGFuIGFycmF5LiBUaGUgYXJyYXkgbGVuZ3RoID0gbnVtYmVyIG9mIGhsaW5lcy5cbiAgLy8gRWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSB0ZWxscyBpZiB0aGUgbGluZSBpcyBkYXNoZWQuXG4gIHZhciBobGluZUluZm8gPSBbXTtcbiAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgdmFyIG54dCA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG5cbiAgaWYgKG54dCA9PT0gXCJcXFxccmVsYXhcIikge1xuICAgIC8vIFxccmVsYXggaXMgYW4gYXJ0aWZhY3Qgb2YgdGhlIFxcY3IgbWFjcm8gYmVsb3dcbiAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gICAgbnh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDtcbiAgfVxuXG4gIHdoaWxlIChueHQgPT09IFwiXFxcXGhsaW5lXCIgfHwgbnh0ID09PSBcIlxcXFxoZGFzaGxpbmVcIikge1xuICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgaGxpbmVJbmZvLnB1c2gobnh0ID09PSBcIlxcXFxoZGFzaGxpbmVcIik7XG4gICAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgICBueHQgPSBwYXJzZXIuZmV0Y2goKS50ZXh0O1xuICB9XG5cbiAgcmV0dXJuIGhsaW5lSW5mbztcbn1cblxudmFyIHZhbGlkYXRlQW1zRW52aXJvbm1lbnRDb250ZXh0ID0gY29udGV4dCA9PiB7XG4gIHZhciBzZXR0aW5ncyA9IGNvbnRleHQucGFyc2VyLnNldHRpbmdzO1xuXG4gIGlmICghc2V0dGluZ3MuZGlzcGxheU1vZGUpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIntcIiArIGNvbnRleHQuZW52TmFtZSArIFwifSBjYW4gYmUgdXNlZCBvbmx5IGluXCIgKyBcIiBkaXNwbGF5IG1vZGUuXCIpO1xuICB9XG59OyAvLyBhdXRvVGFnIChhbiBhcmd1bWVudCB0byBwYXJzZUFycmF5KSBjYW4gYmUgb25lIG9mIHRocmVlIHZhbHVlczpcbi8vICogdW5kZWZpbmVkOiBSZWd1bGFyIChub3QtdG9wLWxldmVsKSBhcnJheTsgbm8gdGFncyBvbiBlYWNoIHJvd1xuLy8gKiB0cnVlOiBBdXRvbWF0aWMgZXF1YXRpb24gbnVtYmVyaW5nLCBvdmVycmlkYWJsZSBieSBcXHRhZ1xuLy8gKiBmYWxzZTogVGFncyBhbGxvd2VkIG9uIGVhY2ggcm93LCBidXQgbm8gYXV0b21hdGljIG51bWJlcmluZ1xuLy8gVGhpcyBmdW5jdGlvbiAqZG9lc24ndCogd29yayB3aXRoIHRoZSBcInNwbGl0XCIgZW52aXJvbm1lbnQgbmFtZS5cblxuXG5mdW5jdGlvbiBnZXRBdXRvVGFnKG5hbWUpIHtcbiAgaWYgKG5hbWUuaW5kZXhPZihcImVkXCIpID09PSAtMSkge1xuICAgIHJldHVybiBuYW1lLmluZGV4T2YoXCIqXCIpID09PSAtMTtcbiAgfSAvLyByZXR1cm4gdW5kZWZpbmVkO1xuXG59XG4vKipcbiAqIFBhcnNlIHRoZSBib2R5IG9mIHRoZSBlbnZpcm9ubWVudCwgd2l0aCByb3dzIGRlbGltaXRlZCBieSBcXFxcIGFuZFxuICogY29sdW1ucyBkZWxpbWl0ZWQgYnkgJiwgYW5kIGNyZWF0ZSBhIG5lc3RlZCBsaXN0IGluIHJvdy1tYWpvciBvcmRlclxuICogd2l0aCBvbmUgZ3JvdXAgcGVyIGNlbGwuICBJZiBnaXZlbiBhbiBvcHRpb25hbCBhcmd1bWVudCBzdHlsZVxuICogKFwidGV4dFwiLCBcImRpc3BsYXlcIiwgZXRjLiksIHRoZW4gZWFjaCBjZWxsIGlzIGNhc3QgaW50byB0aGF0IHN0eWxlLlxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VBcnJheShwYXJzZXIsIF9yZWYsIHN0eWxlKSB7XG4gIHZhciB7XG4gICAgaHNraXBCZWZvcmVBbmRBZnRlcixcbiAgICBhZGRKb3QsXG4gICAgY29scyxcbiAgICBhcnJheXN0cmV0Y2gsXG4gICAgY29sU2VwYXJhdGlvblR5cGUsXG4gICAgYXV0b1RhZyxcbiAgICBzaW5nbGVSb3csXG4gICAgZW1wdHlTaW5nbGVSb3csXG4gICAgbWF4TnVtQ29scyxcbiAgICBsZXFub1xuICB9ID0gX3JlZjtcbiAgcGFyc2VyLmd1bGxldC5iZWdpbkdyb3VwKCk7XG5cbiAgaWYgKCFzaW5nbGVSb3cpIHtcbiAgICAvLyBcXGNyIGlzIGVxdWl2YWxlbnQgdG8gXFxcXCB3aXRob3V0IHRoZSBvcHRpb25hbCBzaXplIGFyZ3VtZW50IChzZWUgYmVsb3cpXG4gICAgLy8gVE9ETzogcHJvdmlkZSBoZWxwZnVsIGVycm9yIHdoZW4gXFxjciBpcyB1c2VkIG91dHNpZGUgYXJyYXkgZW52aXJvbm1lbnRcbiAgICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQoXCJcXFxcY3JcIiwgXCJcXFxcXFxcXFxcXFxyZWxheFwiKTtcbiAgfSAvLyBHZXQgY3VycmVudCBhcnJheXN0cmV0Y2ggaWYgaXQncyBub3Qgc2V0IGJ5IHRoZSBlbnZpcm9ubWVudFxuXG5cbiAgaWYgKCFhcnJheXN0cmV0Y2gpIHtcbiAgICB2YXIgc3RyZXRjaCA9IHBhcnNlci5ndWxsZXQuZXhwYW5kTWFjcm9Bc1RleHQoXCJcXFxcYXJyYXlzdHJldGNoXCIpO1xuXG4gICAgaWYgKHN0cmV0Y2ggPT0gbnVsbCkge1xuICAgICAgLy8gRGVmYXVsdCBcXGFycmF5c3RyZXRjaCBmcm9tIGx0dGFiLmR0eFxuICAgICAgYXJyYXlzdHJldGNoID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyYXlzdHJldGNoID0gcGFyc2VGbG9hdChzdHJldGNoKTtcblxuICAgICAgaWYgKCFhcnJheXN0cmV0Y2ggfHwgYXJyYXlzdHJldGNoIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgXFxcXGFycmF5c3RyZXRjaDogXCIgKyBzdHJldGNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gU3RhcnQgZ3JvdXAgZm9yIGZpcnN0IGNlbGxcblxuXG4gIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICB2YXIgcm93ID0gW107XG4gIHZhciBib2R5ID0gW3Jvd107XG4gIHZhciByb3dHYXBzID0gW107XG4gIHZhciBoTGluZXNCZWZvcmVSb3cgPSBbXTtcbiAgdmFyIHRhZ3MgPSBhdXRvVGFnICE9IG51bGwgPyBbXSA6IHVuZGVmaW5lZDsgLy8gYW1zbWF0aCB1c2VzIFxcZ2xvYmFsXFxAZXFuc3d0cnVlIGFuZCBcXGdsb2JhbFxcQGVxbnN3ZmFsc2UgdG8gcmVwcmVzZW50XG4gIC8vIHdoZXRoZXIgdGhpcyByb3cgc2hvdWxkIGhhdmUgYW4gZXF1YXRpb24gbnVtYmVyLiAgU2ltdWxhdGUgdGhpcyB3aXRoXG4gIC8vIGEgXFxAZXFuc3cgbWFjcm8gc2V0IHRvIDEgb3IgMC5cblxuICBmdW5jdGlvbiBiZWdpblJvdygpIHtcbiAgICBpZiAoYXV0b1RhZykge1xuICAgICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXEBlcW5zd1wiLCBcIjFcIiwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kUm93KCkge1xuICAgIGlmICh0YWdzKSB7XG4gICAgICBpZiAocGFyc2VyLmd1bGxldC5tYWNyb3MuZ2V0KFwiXFxcXGRmQHRhZ1wiKSkge1xuICAgICAgICB0YWdzLnB1c2gocGFyc2VyLnN1YnBhcnNlKFtuZXcgVG9rZW4oXCJcXFxcZGZAdGFnXCIpXSkpO1xuICAgICAgICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQoXCJcXFxcZGZAdGFnXCIsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdzLnB1c2goQm9vbGVhbihhdXRvVGFnKSAmJiBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5nZXQoXCJcXFxcQGVxbnN3XCIpID09PSBcIjFcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYmVnaW5Sb3coKTsgLy8gVGVzdCBmb3IgXFxobGluZSBhdCB0aGUgdG9wIG9mIHRoZSBhcnJheS5cblxuICBoTGluZXNCZWZvcmVSb3cucHVzaChnZXRITGluZXMocGFyc2VyKSk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgIC8vIFBhcnNlIGVhY2ggY2VsbCBpbiBpdHMgb3duIGdyb3VwIChuYW1lc3BhY2UpXG4gICAgdmFyIGNlbGwgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBzaW5nbGVSb3cgPyBcIlxcXFxlbmRcIiA6IFwiXFxcXFxcXFxcIik7XG4gICAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpO1xuICAgIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICAgIGNlbGwgPSB7XG4gICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IGNlbGxcbiAgICB9O1xuXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBjZWxsID0ge1xuICAgICAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIHN0eWxlLFxuICAgICAgICBib2R5OiBbY2VsbF1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcm93LnB1c2goY2VsbCk7XG4gICAgdmFyIG5leHQgPSBwYXJzZXIuZmV0Y2goKS50ZXh0O1xuXG4gICAgaWYgKG5leHQgPT09IFwiJlwiKSB7XG4gICAgICBpZiAobWF4TnVtQ29scyAmJiByb3cubGVuZ3RoID09PSBtYXhOdW1Db2xzKSB7XG4gICAgICAgIGlmIChzaW5nbGVSb3cgfHwgY29sU2VwYXJhdGlvblR5cGUpIHtcbiAgICAgICAgICAvLyB7ZXF1YXRpb259IG9yIHtzcGxpdH1cbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlRvbyBtYW55IHRhYiBjaGFyYWN0ZXJzOiAmXCIsIHBhcnNlci5uZXh0VG9rZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHthcnJheX0gZW52aXJvbm1lbnRcbiAgICAgICAgICBwYXJzZXIuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwidGV4dEVudlwiLCBcIlRvbyBmZXcgY29sdW1ucyBcIiArIFwic3BlY2lmaWVkIGluIHRoZSB7YXJyYXl9IGNvbHVtbiBhcmd1bWVudC5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IFwiXFxcXGVuZFwiKSB7XG4gICAgICBlbmRSb3coKTsgLy8gQXJyYXlzIHRlcm1pbmF0ZSBuZXdsaW5lcyB3aXRoIGBcXGNyY3JgIHdoaWNoIGNvbnN1bWVzIGEgYFxcY3JgIGlmXG4gICAgICAvLyB0aGUgbGFzdCBsaW5lIGlzIGVtcHR5LiAgSG93ZXZlciwgQU1TIGVudmlyb25tZW50cyBrZWVwIHRoZVxuICAgICAgLy8gZW1wdHkgcm93IGlmIGl0J3MgdGhlIG9ubHkgb25lLlxuICAgICAgLy8gTk9URTogQ3VycmVudGx5LCBgY2VsbGAgaXMgdGhlIGxhc3QgaXRlbSBhZGRlZCBpbnRvIGByb3dgLlxuXG4gICAgICBpZiAocm93Lmxlbmd0aCA9PT0gMSAmJiBjZWxsLnR5cGUgPT09IFwic3R5bGluZ1wiICYmIGNlbGwuYm9keVswXS5ib2R5Lmxlbmd0aCA9PT0gMCAmJiAoYm9keS5sZW5ndGggPiAxIHx8ICFlbXB0eVNpbmdsZVJvdykpIHtcbiAgICAgICAgYm9keS5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhMaW5lc0JlZm9yZVJvdy5sZW5ndGggPCBib2R5Lmxlbmd0aCArIDEpIHtcbiAgICAgICAgaExpbmVzQmVmb3JlUm93LnB1c2goW10pO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IFwiXFxcXFxcXFxcIikge1xuICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgIHZhciBzaXplID0gdm9pZCAwOyAvLyBcXGRlZlxcTGV0QHtcXGxldFxcXFxcXG1hdGhAY3J9XG4gICAgICAvLyBcXGRlZlxcbWF0aEBjcnsuLi5cXG1hdGhAY3JAfVxuICAgICAgLy8gXFxkZWZcXG1hdGhAY3JAe1xcbmV3QGlmbmV4dGNoYXJbXFxtYXRoQGNyQEB7XFxtYXRoQGNyQEBbXFx6QF19fVxuICAgICAgLy8gXFxkZWZcXG1hdGhAY3JAQFsjMV17Li4uXFxtYXRoQGNyQEBALi4ufVxuICAgICAgLy8gXFxkZWZcXG1hdGhAY3JAQEB7XFxjcn1cblxuICAgICAgaWYgKHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dCAhPT0gXCIgXCIpIHtcbiAgICAgICAgc2l6ZSA9IHBhcnNlci5wYXJzZVNpemVHcm91cCh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcm93R2Fwcy5wdXNoKHNpemUgPyBzaXplLnZhbHVlIDogbnVsbCk7XG4gICAgICBlbmRSb3coKTsgLy8gY2hlY2sgZm9yIFxcaGxpbmUocykgZm9sbG93aW5nIHRoZSByb3cgc2VwYXJhdG9yXG5cbiAgICAgIGhMaW5lc0JlZm9yZVJvdy5wdXNoKGdldEhMaW5lcyhwYXJzZXIpKTtcbiAgICAgIHJvdyA9IFtdO1xuICAgICAgYm9keS5wdXNoKHJvdyk7XG4gICAgICBiZWdpblJvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkV4cGVjdGVkICYgb3IgXFxcXFxcXFwgb3IgXFxcXGNyIG9yIFxcXFxlbmRcIiwgcGFyc2VyLm5leHRUb2tlbik7XG4gICAgfVxuICB9IC8vIEVuZCBjZWxsIGdyb3VwXG5cblxuICBwYXJzZXIuZ3VsbGV0LmVuZEdyb3VwKCk7IC8vIEVuZCBhcnJheSBncm91cCBkZWZpbmluZyBcXGNyXG5cbiAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICBhZGRKb3QsXG4gICAgYXJyYXlzdHJldGNoLFxuICAgIGJvZHksXG4gICAgY29scyxcbiAgICByb3dHYXBzLFxuICAgIGhza2lwQmVmb3JlQW5kQWZ0ZXIsXG4gICAgaExpbmVzQmVmb3JlUm93LFxuICAgIGNvbFNlcGFyYXRpb25UeXBlLFxuICAgIHRhZ3MsXG4gICAgbGVxbm9cbiAgfTtcbn0gLy8gRGVjaWRlcyBvbiBhIHN0eWxlIGZvciBjZWxscyBpbiBhbiBhcnJheSBhY2NvcmRpbmcgdG8gd2hldGhlciB0aGUgZ2l2ZW5cbi8vIGVudmlyb25tZW50IG5hbWUgc3RhcnRzIHdpdGggdGhlIGxldHRlciAnZCcuXG5cblxuZnVuY3Rpb24gZENlbGxTdHlsZShlbnZOYW1lKSB7XG4gIGlmIChlbnZOYW1lLnNsaWNlKDAsIDEpID09PSBcImRcIikge1xuICAgIHJldHVybiBcImRpc3BsYXlcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJ0ZXh0XCI7XG4gIH1cbn1cblxudmFyIGh0bWxCdWlsZGVyJDYgPSBmdW5jdGlvbiBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICB2YXIgcjtcbiAgdmFyIGM7XG4gIHZhciBuciA9IGdyb3VwLmJvZHkubGVuZ3RoO1xuICB2YXIgaExpbmVzQmVmb3JlUm93ID0gZ3JvdXAuaExpbmVzQmVmb3JlUm93O1xuICB2YXIgbmMgPSAwO1xuICB2YXIgYm9keSA9IG5ldyBBcnJheShucik7XG4gIHZhciBobGluZXMgPSBbXTtcbiAgdmFyIHJ1bGVUaGlja25lc3MgPSBNYXRoLm1heCggLy8gRnJvbSBMYVRlWCBcXHNob3d0aGVcXGFycmF5cnVsZXdpZHRoLiBFcXVhbHMgMC4wNCBlbS5cbiAgb3B0aW9ucy5mb250TWV0cmljcygpLmFycmF5UnVsZVdpZHRoLCBvcHRpb25zLm1pblJ1bGVUaGlja25lc3MgLy8gVXNlciBvdmVycmlkZS5cbiAgKTsgLy8gSG9yaXpvbnRhbCBzcGFjaW5nXG5cbiAgdmFyIHB0ID0gMSAvIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5wdFBlckVtO1xuICB2YXIgYXJyYXljb2xzZXAgPSA1ICogcHQ7IC8vIGRlZmF1bHQgdmFsdWUsIGkuZS4gXFxhcnJheWNvbHNlcCBpbiBhcnRpY2xlLmNsc1xuXG4gIGlmIChncm91cC5jb2xTZXBhcmF0aW9uVHlwZSAmJiBncm91cC5jb2xTZXBhcmF0aW9uVHlwZSA9PT0gXCJzbWFsbFwiKSB7XG4gICAgLy8gV2UncmUgaW4gYSB7c21hbGxtYXRyaXh9LiBEZWZhdWx0IGNvbHVtbiBzcGFjZSBpcyBcXHRoaWNrc3BhY2UsXG4gICAgLy8gaS5lLiA1LzE4ZW0gPSAwLjI3NzhlbSwgcGVyIGFtc21hdGguZHR4IGZvciB7c21hbGxtYXRyaXh9LlxuICAgIC8vIEJ1dCB0aGF0IG5lZWRzIGFkanVzdG1lbnQgYmVjYXVzZSBMYVRlWCBhcHBsaWVzIFxcc2NyaXB0c3R5bGUgdG8gdGhlXG4gICAgLy8gZW50aXJlIGFycmF5LCBpbmNsdWRpbmcgdGhlIGNvbHNwYWNlLCBidXQgdGhpcyBmdW5jdGlvbiBhcHBsaWVzXG4gICAgLy8gXFxzY3JpcHRzdHlsZSBvbmx5IGluc2lkZSBlYWNoIGVsZW1lbnQuXG4gICAgdmFyIGxvY2FsTXVsdGlwbGllciA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoU3R5bGUkMS5TQ1JJUFQpLnNpemVNdWx0aXBsaWVyO1xuICAgIGFycmF5Y29sc2VwID0gMC4yNzc4ICogKGxvY2FsTXVsdGlwbGllciAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXIpO1xuICB9IC8vIFZlcnRpY2FsIHNwYWNpbmdcblxuXG4gIHZhciBiYXNlbGluZXNraXAgPSBncm91cC5jb2xTZXBhcmF0aW9uVHlwZSA9PT0gXCJDRFwiID8gY2FsY3VsYXRlU2l6ZSh7XG4gICAgbnVtYmVyOiAzLFxuICAgIHVuaXQ6IFwiZXhcIlxuICB9LCBvcHRpb25zKSA6IDEyICogcHQ7IC8vIHNlZSBzaXplMTAuY2xvXG4gIC8vIERlZmF1bHQgXFxqb3QgZnJvbSBsdG1hdGguZHR4XG4gIC8vIFRPRE8oZWRlbWFpbmUpOiBhbGxvdyBvdmVycmlkaW5nIFxcam90IHZpYSBcXHNldGxlbmd0aCAoIzY4NylcblxuICB2YXIgam90ID0gMyAqIHB0O1xuICB2YXIgYXJyYXlza2lwID0gZ3JvdXAuYXJyYXlzdHJldGNoICogYmFzZWxpbmVza2lwO1xuICB2YXIgYXJzdHJ1dEhlaWdodCA9IDAuNyAqIGFycmF5c2tpcDsgLy8gXFxzdHJ1dGJveCBpbiBsdGZzc3RyYy5kdHggYW5kXG5cbiAgdmFyIGFyc3RydXREZXB0aCA9IDAuMyAqIGFycmF5c2tpcDsgLy8gXFxAYXJzdHJ1dGJveCBpbiBsdHRhYi5kdHhcblxuICB2YXIgdG90YWxIZWlnaHQgPSAwOyAvLyBTZXQgYSBwb3NpdGlvbiBmb3IgXFxobGluZShzKSBhdCB0aGUgdG9wIG9mIHRoZSBhcnJheSwgaWYgYW55LlxuXG4gIGZ1bmN0aW9uIHNldEhMaW5lUG9zKGhsaW5lc0luR2FwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBobGluZXNJbkdhcC5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IDAuMjU7XG4gICAgICB9XG5cbiAgICAgIGhsaW5lcy5wdXNoKHtcbiAgICAgICAgcG9zOiB0b3RhbEhlaWdodCxcbiAgICAgICAgaXNEYXNoZWQ6IGhsaW5lc0luR2FwW2ldXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBzZXRITGluZVBvcyhoTGluZXNCZWZvcmVSb3dbMF0pO1xuXG4gIGZvciAociA9IDA7IHIgPCBncm91cC5ib2R5Lmxlbmd0aDsgKytyKSB7XG4gICAgdmFyIGlucm93ID0gZ3JvdXAuYm9keVtyXTtcbiAgICB2YXIgaGVpZ2h0ID0gYXJzdHJ1dEhlaWdodDsgLy8gXFxAYXJyYXkgYWRkcyBhbiBcXEBhcnN0cnV0XG5cbiAgICB2YXIgZGVwdGggPSBhcnN0cnV0RGVwdGg7IC8vIHRvIGVhY2ggdG93ICh2aWEgdGhlIHRlbXBsYXRlKVxuXG4gICAgaWYgKG5jIDwgaW5yb3cubGVuZ3RoKSB7XG4gICAgICBuYyA9IGlucm93Lmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgb3V0cm93ID0gbmV3IEFycmF5KGlucm93Lmxlbmd0aCk7XG5cbiAgICBmb3IgKGMgPSAwOyBjIDwgaW5yb3cubGVuZ3RoOyArK2MpIHtcbiAgICAgIHZhciBlbHQgPSBidWlsZEdyb3VwJDEoaW5yb3dbY10sIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoZGVwdGggPCBlbHQuZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSBlbHQuZGVwdGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWlnaHQgPCBlbHQuaGVpZ2h0KSB7XG4gICAgICAgIGhlaWdodCA9IGVsdC5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIG91dHJvd1tjXSA9IGVsdDtcbiAgICB9XG5cbiAgICB2YXIgcm93R2FwID0gZ3JvdXAucm93R2Fwc1tyXTtcbiAgICB2YXIgZ2FwID0gMDtcblxuICAgIGlmIChyb3dHYXApIHtcbiAgICAgIGdhcCA9IGNhbGN1bGF0ZVNpemUocm93R2FwLCBvcHRpb25zKTtcblxuICAgICAgaWYgKGdhcCA+IDApIHtcbiAgICAgICAgLy8gXFxAYXJnYXJyYXljclxuICAgICAgICBnYXAgKz0gYXJzdHJ1dERlcHRoO1xuXG4gICAgICAgIGlmIChkZXB0aCA8IGdhcCkge1xuICAgICAgICAgIGRlcHRoID0gZ2FwOyAvLyBcXEB4YXJnYXJyYXljclxuICAgICAgICB9XG5cbiAgICAgICAgZ2FwID0gMDtcbiAgICAgIH1cbiAgICB9IC8vIEluIEFNUyBtdWx0aWxpbmUgZW52aXJvbm1lbnRzIHN1Y2ggYXMgYWxpZ25lZCBhbmQgZ2F0aGVyZWQsIHJvd3NcbiAgICAvLyBjb3JyZXNwb25kIHRvIGxpbmVzIHRoYXQgaGF2ZSBhZGRpdGlvbmFsIFxcam90IGFkZGVkIHRvIHRoZVxuICAgIC8vIFxcYmFzZWxpbmVza2lwIHZpYSBcXG9wZW51cC5cblxuXG4gICAgaWYgKGdyb3VwLmFkZEpvdCkge1xuICAgICAgZGVwdGggKz0gam90O1xuICAgIH1cblxuICAgIG91dHJvdy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgb3V0cm93LmRlcHRoID0gZGVwdGg7XG4gICAgdG90YWxIZWlnaHQgKz0gaGVpZ2h0O1xuICAgIG91dHJvdy5wb3MgPSB0b3RhbEhlaWdodDtcbiAgICB0b3RhbEhlaWdodCArPSBkZXB0aCArIGdhcDsgLy8gXFxAeWFyZ2FycmF5Y3JcblxuICAgIGJvZHlbcl0gPSBvdXRyb3c7IC8vIFNldCBhIHBvc2l0aW9uIGZvciBcXGhsaW5lKHMpLCBpZiBhbnkuXG5cbiAgICBzZXRITGluZVBvcyhoTGluZXNCZWZvcmVSb3dbciArIDFdKTtcbiAgfVxuXG4gIHZhciBvZmZzZXQgPSB0b3RhbEhlaWdodCAvIDIgKyBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDtcbiAgdmFyIGNvbERlc2NyaXB0aW9ucyA9IGdyb3VwLmNvbHMgfHwgW107XG4gIHZhciBjb2xzID0gW107XG4gIHZhciBjb2xTZXA7XG4gIHZhciBjb2xEZXNjck51bTtcbiAgdmFyIHRhZ1NwYW5zID0gW107XG5cbiAgaWYgKGdyb3VwLnRhZ3MgJiYgZ3JvdXAudGFncy5zb21lKHRhZyA9PiB0YWcpKSB7XG4gICAgLy8gQW4gZW52aXJvbm1lbnQgd2l0aCBtYW51YWwgdGFncyBhbmQvb3IgYXV0b21hdGljIGVxdWF0aW9uIG51bWJlcnMuXG4gICAgLy8gQ3JlYXRlIG5vZGUocyksIHRoZSBsYXR0ZXIgb2Ygd2hpY2ggdHJpZ2dlciBDU1MgY291bnRlciBpbmNyZW1lbnQuXG4gICAgZm9yIChyID0gMDsgciA8IG5yOyArK3IpIHtcbiAgICAgIHZhciBydyA9IGJvZHlbcl07XG4gICAgICB2YXIgc2hpZnQgPSBydy5wb3MgLSBvZmZzZXQ7XG4gICAgICB2YXIgdGFnID0gZ3JvdXAudGFnc1tyXTtcbiAgICAgIHZhciB0YWdTcGFuID0gdm9pZCAwO1xuXG4gICAgICBpZiAodGFnID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGF1dG9tYXRpYyBudW1iZXJpbmdcbiAgICAgICAgdGFnU3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImVxbi1udW1cIl0sIFtdLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSBmYWxzZSkge1xuICAgICAgICAvLyBcXG5vbnVtYmVyL1xcbm90YWcgb3Igc3RhcnJlZCBlbnZpcm9ubWVudFxuICAgICAgICB0YWdTcGFuID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW10sIFtdLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1hbnVhbCBcXHRhZ1xuICAgICAgICB0YWdTcGFuID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW10sIGJ1aWxkRXhwcmVzc2lvbiQxKHRhZywgb3B0aW9ucywgdHJ1ZSksIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB0YWdTcGFuLmRlcHRoID0gcncuZGVwdGg7XG4gICAgICB0YWdTcGFuLmhlaWdodCA9IHJ3LmhlaWdodDtcbiAgICAgIHRhZ1NwYW5zLnB1c2goe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogdGFnU3BhbixcbiAgICAgICAgc2hpZnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoYyA9IDAsIGNvbERlc2NyTnVtID0gMDsgLy8gQ29udGludWUgd2hpbGUgZWl0aGVyIHRoZXJlIGFyZSBtb3JlIGNvbHVtbnMgb3IgbW9yZSBjb2x1bW5cbiAgLy8gZGVzY3JpcHRpb25zLCBzbyB0cmFpbGluZyBzZXBhcmF0b3JzIGRvbid0IGdldCBsb3N0LlxuICBjIDwgbmMgfHwgY29sRGVzY3JOdW0gPCBjb2xEZXNjcmlwdGlvbnMubGVuZ3RoOyArK2MsICsrY29sRGVzY3JOdW0pIHtcbiAgICB2YXIgY29sRGVzY3IgPSBjb2xEZXNjcmlwdGlvbnNbY29sRGVzY3JOdW1dIHx8IHt9O1xuICAgIHZhciBmaXJzdFNlcGFyYXRvciA9IHRydWU7XG5cbiAgICB3aGlsZSAoY29sRGVzY3IudHlwZSA9PT0gXCJzZXBhcmF0b3JcIikge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBzZXBhcmF0b3IgaW4gYSByb3csIGFkZCBhIHNwYWNlXG4gICAgICAvLyBiZXR3ZWVuIHRoZW0uXG4gICAgICBpZiAoIWZpcnN0U2VwYXJhdG9yKSB7XG4gICAgICAgIGNvbFNlcCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImFycmF5Y29sc2VwXCJdLCBbXSk7XG4gICAgICAgIGNvbFNlcC5zdHlsZS53aWR0aCA9IG1ha2VFbShvcHRpb25zLmZvbnRNZXRyaWNzKCkuZG91YmxlUnVsZVNlcCk7XG4gICAgICAgIGNvbHMucHVzaChjb2xTZXApO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29sRGVzY3Iuc2VwYXJhdG9yID09PSBcInxcIiB8fCBjb2xEZXNjci5zZXBhcmF0b3IgPT09IFwiOlwiKSB7XG4gICAgICAgIHZhciBsaW5lVHlwZSA9IGNvbERlc2NyLnNlcGFyYXRvciA9PT0gXCJ8XCIgPyBcInNvbGlkXCIgOiBcImRhc2hlZFwiO1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1widmVydGljYWwtc2VwYXJhdG9yXCJdLCBbXSwgb3B0aW9ucyk7XG4gICAgICAgIHNlcGFyYXRvci5zdHlsZS5oZWlnaHQgPSBtYWtlRW0odG90YWxIZWlnaHQpO1xuICAgICAgICBzZXBhcmF0b3Iuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IG1ha2VFbShydWxlVGhpY2tuZXNzKTtcbiAgICAgICAgc2VwYXJhdG9yLnN0eWxlLmJvcmRlclJpZ2h0U3R5bGUgPSBsaW5lVHlwZTtcbiAgICAgICAgc2VwYXJhdG9yLnN0eWxlLm1hcmdpbiA9IFwiMCBcIiArIG1ha2VFbSgtcnVsZVRoaWNrbmVzcyAvIDIpO1xuXG4gICAgICAgIHZhciBfc2hpZnQgPSB0b3RhbEhlaWdodCAtIG9mZnNldDtcblxuICAgICAgICBpZiAoX3NoaWZ0KSB7XG4gICAgICAgICAgc2VwYXJhdG9yLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBtYWtlRW0oLV9zaGlmdCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb2xzLnB1c2goc2VwYXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBzZXBhcmF0b3IgdHlwZTogXCIgKyBjb2xEZXNjci5zZXBhcmF0b3IpO1xuICAgICAgfVxuXG4gICAgICBjb2xEZXNjck51bSsrO1xuICAgICAgY29sRGVzY3IgPSBjb2xEZXNjcmlwdGlvbnNbY29sRGVzY3JOdW1dIHx8IHt9O1xuICAgICAgZmlyc3RTZXBhcmF0b3IgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYyA+PSBuYykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHNlcHdpZHRoID0gdm9pZCAwO1xuXG4gICAgaWYgKGMgPiAwIHx8IGdyb3VwLmhza2lwQmVmb3JlQW5kQWZ0ZXIpIHtcbiAgICAgIHNlcHdpZHRoID0gdXRpbHMuZGVmbHQoY29sRGVzY3IucHJlZ2FwLCBhcnJheWNvbHNlcCk7XG5cbiAgICAgIGlmIChzZXB3aWR0aCAhPT0gMCkge1xuICAgICAgICBjb2xTZXAgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJhcnJheWNvbHNlcFwiXSwgW10pO1xuICAgICAgICBjb2xTZXAuc3R5bGUud2lkdGggPSBtYWtlRW0oc2Vwd2lkdGgpO1xuICAgICAgICBjb2xzLnB1c2goY29sU2VwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29sID0gW107XG5cbiAgICBmb3IgKHIgPSAwOyByIDwgbnI7ICsrcikge1xuICAgICAgdmFyIHJvdyA9IGJvZHlbcl07XG4gICAgICB2YXIgZWxlbSA9IHJvd1tjXTtcblxuICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3NoaWZ0MiA9IHJvdy5wb3MgLSBvZmZzZXQ7XG5cbiAgICAgIGVsZW0uZGVwdGggPSByb3cuZGVwdGg7XG4gICAgICBlbGVtLmhlaWdodCA9IHJvdy5oZWlnaHQ7XG4gICAgICBjb2wucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBlbGVtLFxuICAgICAgICBzaGlmdDogX3NoaWZ0MlxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29sID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgIGNoaWxkcmVuOiBjb2xcbiAgICB9LCBvcHRpb25zKTtcbiAgICBjb2wgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJjb2wtYWxpZ24tXCIgKyAoY29sRGVzY3IuYWxpZ24gfHwgXCJjXCIpXSwgW2NvbF0pO1xuICAgIGNvbHMucHVzaChjb2wpO1xuXG4gICAgaWYgKGMgPCBuYyAtIDEgfHwgZ3JvdXAuaHNraXBCZWZvcmVBbmRBZnRlcikge1xuICAgICAgc2Vwd2lkdGggPSB1dGlscy5kZWZsdChjb2xEZXNjci5wb3N0Z2FwLCBhcnJheWNvbHNlcCk7XG5cbiAgICAgIGlmIChzZXB3aWR0aCAhPT0gMCkge1xuICAgICAgICBjb2xTZXAgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJhcnJheWNvbHNlcFwiXSwgW10pO1xuICAgICAgICBjb2xTZXAuc3R5bGUud2lkdGggPSBtYWtlRW0oc2Vwd2lkdGgpO1xuICAgICAgICBjb2xzLnB1c2goY29sU2VwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBib2R5ID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibXRhYmxlXCJdLCBjb2xzKTsgLy8gQWRkIFxcaGxpbmUocyksIGlmIGFueS5cblxuICBpZiAoaGxpbmVzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbGluZSA9IGJ1aWxkQ29tbW9uLm1ha2VMaW5lU3BhbihcImhsaW5lXCIsIG9wdGlvbnMsIHJ1bGVUaGlja25lc3MpO1xuICAgIHZhciBkYXNoZXMgPSBidWlsZENvbW1vbi5tYWtlTGluZVNwYW4oXCJoZGFzaGxpbmVcIiwgb3B0aW9ucywgcnVsZVRoaWNrbmVzcyk7XG4gICAgdmFyIHZMaXN0RWxlbXMgPSBbe1xuICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICBlbGVtOiBib2R5LFxuICAgICAgc2hpZnQ6IDBcbiAgICB9XTtcblxuICAgIHdoaWxlIChobGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGhsaW5lID0gaGxpbmVzLnBvcCgpO1xuICAgICAgdmFyIGxpbmVTaGlmdCA9IGhsaW5lLnBvcyAtIG9mZnNldDtcblxuICAgICAgaWYgKGhsaW5lLmlzRGFzaGVkKSB7XG4gICAgICAgIHZMaXN0RWxlbXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogZGFzaGVzLFxuICAgICAgICAgIHNoaWZ0OiBsaW5lU2hpZnRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2TGlzdEVsZW1zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IGxpbmUsXG4gICAgICAgICAgc2hpZnQ6IGxpbmVTaGlmdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBib2R5ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgIGNoaWxkcmVuOiB2TGlzdEVsZW1zXG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAodGFnU3BhbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIl0sIFtib2R5XSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVxbk51bUNvbCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiaW5kaXZpZHVhbFNoaWZ0XCIsXG4gICAgICBjaGlsZHJlbjogdGFnU3BhbnNcbiAgICB9LCBvcHRpb25zKTtcbiAgICBlcW5OdW1Db2wgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJ0YWdcIl0sIFtlcW5OdW1Db2xdLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KFtib2R5LCBlcW5OdW1Db2xdKTtcbiAgfVxufTtcblxudmFyIGFsaWduTWFwID0ge1xuICBjOiBcImNlbnRlciBcIixcbiAgbDogXCJsZWZ0IFwiLFxuICByOiBcInJpZ2h0IFwiXG59O1xuXG52YXIgbWF0aG1sQnVpbGRlciQ1ID0gZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICB2YXIgdGJsID0gW107XG4gIHZhciBnbHVlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW10sIFtcIm10ci1nbHVlXCJdKTtcbiAgdmFyIHRhZyA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtdLCBbXCJtbWwtZXFuLW51bVwiXSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJ3ID0gZ3JvdXAuYm9keVtpXTtcbiAgICB2YXIgcm93ID0gW107XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJ3Lmxlbmd0aDsgaisrKSB7XG4gICAgICByb3cucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZFwiLCBbYnVpbGRHcm91cChyd1tqXSwgb3B0aW9ucyldKSk7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnRhZ3MgJiYgZ3JvdXAudGFnc1tpXSkge1xuICAgICAgcm93LnVuc2hpZnQoZ2x1ZSk7XG4gICAgICByb3cucHVzaChnbHVlKTtcblxuICAgICAgaWYgKGdyb3VwLmxlcW5vKSB7XG4gICAgICAgIHJvdy51bnNoaWZ0KHRhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3cucHVzaCh0YWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRibC5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRyXCIsIHJvdykpO1xuICB9XG5cbiAgdmFyIHRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGFibGVcIiwgdGJsKTsgLy8gU2V0IGNvbHVtbiBhbGlnbm1lbnQsIHJvdyBzcGFjaW5nLCBjb2x1bW4gc3BhY2luZywgYW5kXG4gIC8vIGFycmF5IGxpbmVzIGJ5IHNldHRpbmcgYXR0cmlidXRlcyBvbiB0aGUgdGFibGUgZWxlbWVudC5cbiAgLy8gU2V0IHRoZSByb3cgc3BhY2luZy4gSW4gTWF0aE1MLCB3ZSBzcGVjaWZ5IGEgZ2FwIGRpc3RhbmNlLlxuICAvLyBXZSBkbyBub3QgdXNlIHJvd0dhcFtdIGJlY2F1c2UgTWF0aE1MIGF1dG9tYXRpY2FsbHkgaW5jcmVhc2VzXG4gIC8vIGNlbGwgaGVpZ2h0IHdpdGggdGhlIGhlaWdodC9kZXB0aCBvZiB0aGUgZWxlbWVudCBjb250ZW50LlxuICAvLyBMYVRlWCBcXGFycmF5c3RyZXRjaCBtdWx0aXBsaWVzIHRoZSByb3cgYmFzZWxpbmUtdG8tYmFzZWxpbmUgZGlzdGFuY2UuXG4gIC8vIFdlIHNpbXVsYXRlIHRoaXMgYnkgYWRkaW5nIChhcnJheXN0cmV0Y2ggLSAxKWVtIHRvIHRoZSBnYXAuIFRoaXNcbiAgLy8gZG9lcyBhIHJlYXNvbmFibGUgam9iIG9mIGFkanVzdGluZyBhcnJheXMgY29udGFpbmluZyAxIGVtIHRhbGwgY29udGVudC5cbiAgLy8gVGhlIDAuMTYgYW5kIDAuMDkgdmFsdWVzIGFyZSBmb3VuZCBlbXBpcmljYWxseS4gVGhleSBwcm9kdWNlIGFuIGFycmF5XG4gIC8vIHNpbWlsYXIgdG8gTGFUZVggYW5kIGluIHdoaWNoIGNvbnRlbnQgZG9lcyBub3QgaW50ZXJmZXJlIHdpdGggXFxobGluZXMuXG5cbiAgdmFyIGdhcCA9IGdyb3VwLmFycmF5c3RyZXRjaCA9PT0gMC41ID8gMC4xIC8vIHtzbWFsbG1hdHJpeH0sIHtzdWJhcnJheX1cbiAgOiAwLjE2ICsgZ3JvdXAuYXJyYXlzdHJldGNoIC0gMSArIChncm91cC5hZGRKb3QgPyAwLjA5IDogMCk7XG4gIHRhYmxlLnNldEF0dHJpYnV0ZShcInJvd3NwYWNpbmdcIiwgbWFrZUVtKGdhcCkpOyAvLyBNYXRoTUwgdGFibGUgbGluZXMgZ28gb25seSBiZXR3ZWVuIGNlbGxzLlxuICAvLyBUbyBwbGFjZSBhIGxpbmUgb24gYW4gZWRnZSB3ZSdsbCB1c2UgPG1lbmNsb3NlPiwgaWYgbmVjZXNzYXJ5LlxuXG4gIHZhciBtZW5jbG9zZSA9IFwiXCI7XG4gIHZhciBhbGlnbiA9IFwiXCI7XG5cbiAgaWYgKGdyb3VwLmNvbHMgJiYgZ3JvdXAuY29scy5sZW5ndGggPiAwKSB7XG4gICAgLy8gRmluZCBjb2x1bW4gYWxpZ25tZW50LCBjb2x1bW4gc3BhY2luZywgYW5kICB2ZXJ0aWNhbCBsaW5lcy5cbiAgICB2YXIgY29scyA9IGdyb3VwLmNvbHM7XG4gICAgdmFyIGNvbHVtbkxpbmVzID0gXCJcIjtcbiAgICB2YXIgcHJldlR5cGVXYXNBbGlnbiA9IGZhbHNlO1xuICAgIHZhciBpU3RhcnQgPSAwO1xuICAgIHZhciBpRW5kID0gY29scy5sZW5ndGg7XG5cbiAgICBpZiAoY29sc1swXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICBtZW5jbG9zZSArPSBcInRvcCBcIjtcbiAgICAgIGlTdGFydCA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGNvbHNbY29scy5sZW5ndGggLSAxXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICBtZW5jbG9zZSArPSBcImJvdHRvbSBcIjtcbiAgICAgIGlFbmQgLT0gMTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IGlTdGFydDsgX2kgPCBpRW5kOyBfaSsrKSB7XG4gICAgICBpZiAoY29sc1tfaV0udHlwZSA9PT0gXCJhbGlnblwiKSB7XG4gICAgICAgIGFsaWduICs9IGFsaWduTWFwW2NvbHNbX2ldLmFsaWduXTtcblxuICAgICAgICBpZiAocHJldlR5cGVXYXNBbGlnbikge1xuICAgICAgICAgIGNvbHVtbkxpbmVzICs9IFwibm9uZSBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZUeXBlV2FzQWxpZ24gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChjb2xzW19pXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICAgIC8vIE1hdGhNTCBhY2NlcHRzIG9ubHkgc2luZ2xlIGxpbmVzIGJldHdlZW4gY2VsbHMuXG4gICAgICAgIC8vIFNvIHdlIHJlYWQgb25seSB0aGUgZmlyc3Qgb2YgY29uc2VjdXRpdmUgc2VwYXJhdG9ycy5cbiAgICAgICAgaWYgKHByZXZUeXBlV2FzQWxpZ24pIHtcbiAgICAgICAgICBjb2x1bW5MaW5lcyArPSBjb2xzW19pXS5zZXBhcmF0b3IgPT09IFwifFwiID8gXCJzb2xpZCBcIiA6IFwiZGFzaGVkIFwiO1xuICAgICAgICAgIHByZXZUeXBlV2FzQWxpZ24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbmFsaWduXCIsIGFsaWduLnRyaW0oKSk7XG5cbiAgICBpZiAoL1tzZF0vLnRlc3QoY29sdW1uTGluZXMpKSB7XG4gICAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJjb2x1bW5saW5lc1wiLCBjb2x1bW5MaW5lcy50cmltKCkpO1xuICAgIH1cbiAgfSAvLyBTZXQgY29sdW1uIHNwYWNpbmcuXG5cblxuICBpZiAoZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgPT09IFwiYWxpZ25cIikge1xuICAgIHZhciBfY29scyA9IGdyb3VwLmNvbHMgfHwgW107XG5cbiAgICB2YXIgc3BhY2luZyA9IFwiXCI7XG5cbiAgICBmb3IgKHZhciBfaTIgPSAxOyBfaTIgPCBfY29scy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICBzcGFjaW5nICs9IF9pMiAlIDIgPyBcIjBlbSBcIiA6IFwiMWVtIFwiO1xuICAgIH1cblxuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbnNwYWNpbmdcIiwgc3BhY2luZy50cmltKCkpO1xuICB9IGVsc2UgaWYgKGdyb3VwLmNvbFNlcGFyYXRpb25UeXBlID09PSBcImFsaWduYXRcIiB8fCBncm91cC5jb2xTZXBhcmF0aW9uVHlwZSA9PT0gXCJnYXRoZXJcIikge1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbnNwYWNpbmdcIiwgXCIwZW1cIik7XG4gIH0gZWxzZSBpZiAoZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgPT09IFwic21hbGxcIikge1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbnNwYWNpbmdcIiwgXCIwLjI3NzhlbVwiKTtcbiAgfSBlbHNlIGlmIChncm91cC5jb2xTZXBhcmF0aW9uVHlwZSA9PT0gXCJDRFwiKSB7XG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwiY29sdW1uc3BhY2luZ1wiLCBcIjAuNWVtXCIpO1xuICB9IGVsc2Uge1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbnNwYWNpbmdcIiwgXCIxZW1cIik7XG4gIH0gLy8gQWRkcmVzcyBcXGhsaW5lIGFuZCBcXGhkYXNobGluZVxuXG5cbiAgdmFyIHJvd0xpbmVzID0gXCJcIjtcbiAgdmFyIGhsaW5lcyA9IGdyb3VwLmhMaW5lc0JlZm9yZVJvdztcbiAgbWVuY2xvc2UgKz0gaGxpbmVzWzBdLmxlbmd0aCA+IDAgPyBcImxlZnQgXCIgOiBcIlwiO1xuICBtZW5jbG9zZSArPSBobGluZXNbaGxpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCA+IDAgPyBcInJpZ2h0IFwiIDogXCJcIjtcblxuICBmb3IgKHZhciBfaTMgPSAxOyBfaTMgPCBobGluZXMubGVuZ3RoIC0gMTsgX2kzKyspIHtcbiAgICByb3dMaW5lcyArPSBobGluZXNbX2kzXS5sZW5ndGggPT09IDAgPyBcIm5vbmUgXCIgLy8gTWF0aE1MIGFjY2VwdHMgb25seSBhIHNpbmdsZSBsaW5lIGJldHdlZW4gcm93cy4gUmVhZCBvbmUgZWxlbWVudC5cbiAgICA6IGhsaW5lc1tfaTNdWzBdID8gXCJkYXNoZWQgXCIgOiBcInNvbGlkIFwiO1xuICB9XG5cbiAgaWYgKC9bc2RdLy50ZXN0KHJvd0xpbmVzKSkge1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcInJvd2xpbmVzXCIsIHJvd0xpbmVzLnRyaW0oKSk7XG4gIH1cblxuICBpZiAobWVuY2xvc2UgIT09IFwiXCIpIHtcbiAgICB0YWJsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWVuY2xvc2VcIiwgW3RhYmxlXSk7XG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgbWVuY2xvc2UudHJpbSgpKTtcbiAgfVxuXG4gIGlmIChncm91cC5hcnJheXN0cmV0Y2ggJiYgZ3JvdXAuYXJyYXlzdHJldGNoIDwgMSkge1xuICAgIC8vIEEgc21hbGwgYXJyYXkuIFdyYXAgaW4gc2NyaXB0c3R5bGUgc28gcm93IGdhcCBpcyBub3QgdG9vIGxhcmdlLlxuICAgIHRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3R5bGVcIiwgW3RhYmxlXSk7XG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgXCIxXCIpO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufTsgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGFsaWduLCBhbGlnbiosIGFsaWduZWQsIGFsaWduYXQsIGFsaWduYXQqLCBhbGlnbmVkYXQuXG5cblxudmFyIGFsaWduZWRIYW5kbGVyID0gZnVuY3Rpb24gYWxpZ25lZEhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICBpZiAoY29udGV4dC5lbnZOYW1lLmluZGV4T2YoXCJlZFwiKSA9PT0gLTEpIHtcbiAgICB2YWxpZGF0ZUFtc0Vudmlyb25tZW50Q29udGV4dChjb250ZXh0KTtcbiAgfVxuXG4gIHZhciBjb2xzID0gW107XG4gIHZhciBzZXBhcmF0aW9uVHlwZSA9IGNvbnRleHQuZW52TmFtZS5pbmRleE9mKFwiYXRcIikgPiAtMSA/IFwiYWxpZ25hdFwiIDogXCJhbGlnblwiO1xuICB2YXIgaXNTcGxpdCA9IGNvbnRleHQuZW52TmFtZSA9PT0gXCJzcGxpdFwiO1xuICB2YXIgcmVzID0gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwge1xuICAgIGNvbHMsXG4gICAgYWRkSm90OiB0cnVlLFxuICAgIGF1dG9UYWc6IGlzU3BsaXQgPyB1bmRlZmluZWQgOiBnZXRBdXRvVGFnKGNvbnRleHQuZW52TmFtZSksXG4gICAgZW1wdHlTaW5nbGVSb3c6IHRydWUsXG4gICAgY29sU2VwYXJhdGlvblR5cGU6IHNlcGFyYXRpb25UeXBlLFxuICAgIG1heE51bUNvbHM6IGlzU3BsaXQgPyAyIDogdW5kZWZpbmVkLFxuICAgIGxlcW5vOiBjb250ZXh0LnBhcnNlci5zZXR0aW5ncy5sZXFub1xuICB9LCBcImRpc3BsYXlcIik7IC8vIERldGVybWluaW5nIG51bWJlciBvZiBjb2x1bW5zLlxuICAvLyAxLiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgZ2l2ZW4sIHdlIHVzZSBpdCBhcyBhIG51bWJlciBvZiBjb2x1bW5zLFxuICAvLyAgICBhbmQgbWFrZXMgc3VyZSB0aGF0IGVhY2ggcm93IGRvZXNuJ3QgZXhjZWVkIHRoYXQgbnVtYmVyLlxuICAvLyAyLiBPdGhlcndpc2UsIGp1c3QgY291bnQgbnVtYmVyIG9mIGNvbHVtbnMgPSBtYXhpbXVtIG51bWJlclxuICAvLyAgICBvZiBjZWxscyBpbiBlYWNoIHJvdyAoXCJhbGlnbmVkXCIgbW9kZSAtLSBpc0FsaWduZWQgd2lsbCBiZSB0cnVlKS5cbiAgLy9cbiAgLy8gQXQgdGhlIHNhbWUgdGltZSwgcHJlcGVuZCBlbXB0eSBncm91cCB7fSBhdCBiZWdpbm5pbmcgb2YgZXZlcnkgc2Vjb25kXG4gIC8vIGNlbGwgaW4gZWFjaCByb3cgKHN0YXJ0aW5nIHdpdGggc2Vjb25kIGNlbGwpIHNvIHRoYXQgb3BlcmF0b3JzIGJlY29tZVxuICAvLyBiaW5hcnkuICBUaGlzIGJlaGF2aW9yIGlzIGltcGxlbWVudGVkIGluIGFtc21hdGgncyBcXHN0YXJ0QGFsaWduZWQuXG5cbiAgdmFyIG51bU1hdGhzO1xuICB2YXIgbnVtQ29scyA9IDA7XG4gIHZhciBlbXB0eUdyb3VwID0ge1xuICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICBtb2RlOiBjb250ZXh0Lm1vZGUsXG4gICAgYm9keTogW11cbiAgfTtcblxuICBpZiAoYXJnc1swXSAmJiBhcmdzWzBdLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgIHZhciBhcmcwID0gXCJcIjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnc1swXS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGV4dG9yZCA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0uYm9keVtpXSwgXCJ0ZXh0b3JkXCIpO1xuICAgICAgYXJnMCArPSB0ZXh0b3JkLnRleHQ7XG4gICAgfVxuXG4gICAgbnVtTWF0aHMgPSBOdW1iZXIoYXJnMCk7XG4gICAgbnVtQ29scyA9IG51bU1hdGhzICogMjtcbiAgfVxuXG4gIHZhciBpc0FsaWduZWQgPSAhbnVtQ29scztcbiAgcmVzLmJvZHkuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgZm9yICh2YXIgX2k0ID0gMTsgX2k0IDwgcm93Lmxlbmd0aDsgX2k0ICs9IDIpIHtcbiAgICAgIC8vIE1vZGlmeSBvcmRncm91cCBub2RlIHdpdGhpbiBzdHlsaW5nIG5vZGVcbiAgICAgIHZhciBzdHlsaW5nID0gYXNzZXJ0Tm9kZVR5cGUocm93W19pNF0sIFwic3R5bGluZ1wiKTtcbiAgICAgIHZhciBvcmRncm91cCA9IGFzc2VydE5vZGVUeXBlKHN0eWxpbmcuYm9keVswXSwgXCJvcmRncm91cFwiKTtcbiAgICAgIG9yZGdyb3VwLmJvZHkudW5zaGlmdChlbXB0eUdyb3VwKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQWxpZ25lZCkge1xuICAgICAgLy8gQ2FzZSAxXG4gICAgICB2YXIgY3VyTWF0aHMgPSByb3cubGVuZ3RoIC8gMjtcblxuICAgICAgaWYgKG51bU1hdGhzIDwgY3VyTWF0aHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJUb28gbWFueSBtYXRoIGluIGEgcm93OiBcIiArIChcImV4cGVjdGVkIFwiICsgbnVtTWF0aHMgKyBcIiwgYnV0IGdvdCBcIiArIGN1ck1hdGhzKSwgcm93WzBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG51bUNvbHMgPCByb3cubGVuZ3RoKSB7XG4gICAgICAvLyBDYXNlIDJcbiAgICAgIG51bUNvbHMgPSByb3cubGVuZ3RoO1xuICAgIH1cbiAgfSk7IC8vIEFkanVzdGluZyBhbGlnbm1lbnQuXG4gIC8vIEluIGFsaWduZWQgbW9kZSwgd2UgYWRkIG9uZSBcXHFxdWFkIGJldHdlZW4gY29sdW1ucztcbiAgLy8gb3RoZXJ3aXNlIHdlIGFkZCBub3RoaW5nLlxuXG4gIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG51bUNvbHM7ICsrX2k1KSB7XG4gICAgdmFyIGFsaWduID0gXCJyXCI7XG4gICAgdmFyIHByZWdhcCA9IDA7XG5cbiAgICBpZiAoX2k1ICUgMiA9PT0gMSkge1xuICAgICAgYWxpZ24gPSBcImxcIjtcbiAgICB9IGVsc2UgaWYgKF9pNSA+IDAgJiYgaXNBbGlnbmVkKSB7XG4gICAgICAvLyBcImFsaWduZWRcIiBtb2RlLlxuICAgICAgcHJlZ2FwID0gMTsgLy8gYWRkIG9uZSBcXHF1YWRcbiAgICB9XG5cbiAgICBjb2xzW19pNV0gPSB7XG4gICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICBhbGlnbjogYWxpZ24sXG4gICAgICBwcmVnYXA6IHByZWdhcCxcbiAgICAgIHBvc3RnYXA6IDBcbiAgICB9O1xuICB9XG5cbiAgcmVzLmNvbFNlcGFyYXRpb25UeXBlID0gaXNBbGlnbmVkID8gXCJhbGlnblwiIDogXCJhbGlnbmF0XCI7XG4gIHJldHVybiByZXM7XG59OyAvLyBBcnJheXMgYXJlIHBhcnQgb2YgTGFUZVgsIGRlZmluZWQgaW4gbHR0YWIuZHR4IHNvIGl0cyBkb2N1bWVudGF0aW9uXG4vLyBpcyBwYXJ0IG9mIHRoZSBzb3VyY2UyZS5wZGYgZmlsZSBvZiBMYVRlWDJlIHNvdXJjZSBkb2N1bWVudGF0aW9uLlxuLy8ge2RhcnJheX0gaXMgYW4ge2FycmF5fSBlbnZpcm9ubWVudCB3aGVyZSBjZWxscyBhcmUgc2V0IGluIFxcZGlzcGxheXN0eWxlLFxuLy8gYXMgZGVmaW5lZCBpbiBuY2NtYXRoLnN0eS5cblxuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImFycmF5XCIsIFwiZGFycmF5XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAvLyBTaW5jZSBubyB0eXBlcyBhcmUgc3BlY2lmaWVkIGFib3ZlLCB0aGUgdHdvIHBvc3NpYmlsaXRpZXMgYXJlXG4gICAgLy8gLSBUaGUgYXJndW1lbnQgaXMgd3JhcHBlZCBpbiB7fSBvciBbXSwgaW4gd2hpY2ggY2FzZSBQYXJzZXInc1xuICAgIC8vICAgcGFyc2VHcm91cCgpIHJldHVybnMgYW4gXCJvcmRncm91cFwiIHdyYXBwaW5nIHNvbWUgc3ltYm9sIG5vZGUuXG4gICAgLy8gLSBUaGUgYXJndW1lbnQgaXMgYSBiYXJlIHN5bWJvbCBub2RlLlxuICAgIHZhciBzeW1Ob2RlID0gY2hlY2tTeW1ib2xOb2RlVHlwZShhcmdzWzBdKTtcbiAgICB2YXIgY29sYWxpZ24gPSBzeW1Ob2RlID8gW2FyZ3NbMF1dIDogYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJvcmRncm91cFwiKS5ib2R5O1xuICAgIHZhciBjb2xzID0gY29sYWxpZ24ubWFwKGZ1bmN0aW9uIChuZGUpIHtcbiAgICAgIHZhciBub2RlID0gYXNzZXJ0U3ltYm9sTm9kZVR5cGUobmRlKTtcbiAgICAgIHZhciBjYSA9IG5vZGUudGV4dDtcblxuICAgICAgaWYgKFwibGNyXCIuaW5kZXhPZihjYSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgICAgIGFsaWduOiBjYVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChjYSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInNlcGFyYXRvclwiLFxuICAgICAgICAgIHNlcGFyYXRvcjogXCJ8XCJcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoY2EgPT09IFwiOlwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzZXBhcmF0b3JcIixcbiAgICAgICAgICBzZXBhcmF0b3I6IFwiOlwiXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVW5rbm93biBjb2x1bW4gYWxpZ25tZW50OiBcIiArIGNhLCBuZGUpO1xuICAgIH0pO1xuICAgIHZhciByZXMgPSB7XG4gICAgICBjb2xzLFxuICAgICAgaHNraXBCZWZvcmVBbmRBZnRlcjogdHJ1ZSxcbiAgICAgIC8vIFxcQHByZWFtYmxlIGluIGx0dGFiLmR0eFxuICAgICAgbWF4TnVtQ29sczogY29scy5sZW5ndGhcbiAgICB9O1xuICAgIHJldHVybiBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIGRDZWxsU3R5bGUoY29udGV4dC5lbnZOYW1lKSk7XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDYsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNVxufSk7IC8vIFRoZSBtYXRyaXggZW52aXJvbm1lbnRzIG9mIGFtc21hdGggYnVpbGRzIG9uIHRoZSBhcnJheSBlbnZpcm9ubWVudFxuLy8gb2YgTGFUZVgsIHdoaWNoIGlzIGRpc2N1c3NlZCBhYm92ZS5cbi8vIFRoZSBtYXRodG9vbHMgcGFja2FnZSBhZGRzIHN0YXJyZWQgdmVyc2lvbnMgb2YgdGhlIHNhbWUgZW52aXJvbm1lbnRzLlxuLy8gVGhlc2UgaGF2ZSBhbiBvcHRpb25hbCBhcmd1bWVudCB0byBjaG9vc2UgbGVmdHxjZW50ZXJ8cmlnaHQganVzdGlmaWNhdGlvbi5cblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJtYXRyaXhcIiwgXCJwbWF0cml4XCIsIFwiYm1hdHJpeFwiLCBcIkJtYXRyaXhcIiwgXCJ2bWF0cml4XCIsIFwiVm1hdHJpeFwiLCBcIm1hdHJpeCpcIiwgXCJwbWF0cml4KlwiLCBcImJtYXRyaXgqXCIsIFwiQm1hdHJpeCpcIiwgXCJ2bWF0cml4KlwiLCBcIlZtYXRyaXgqXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICB2YXIgZGVsaW1pdGVycyA9IHtcbiAgICAgIFwibWF0cml4XCI6IG51bGwsXG4gICAgICBcInBtYXRyaXhcIjogW1wiKFwiLCBcIilcIl0sXG4gICAgICBcImJtYXRyaXhcIjogW1wiW1wiLCBcIl1cIl0sXG4gICAgICBcIkJtYXRyaXhcIjogW1wiXFxcXHtcIiwgXCJcXFxcfVwiXSxcbiAgICAgIFwidm1hdHJpeFwiOiBbXCJ8XCIsIFwifFwiXSxcbiAgICAgIFwiVm1hdHJpeFwiOiBbXCJcXFxcVmVydFwiLCBcIlxcXFxWZXJ0XCJdXG4gICAgfVtjb250ZXh0LmVudk5hbWUucmVwbGFjZShcIipcIiwgXCJcIildOyAvLyBcXGhza2lwIC1cXGFycmF5Y29sc2VwIGluIGFtc21hdGhcblxuICAgIHZhciBjb2xBbGlnbiA9IFwiY1wiO1xuICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgaHNraXBCZWZvcmVBbmRBZnRlcjogZmFsc2UsXG4gICAgICBjb2xzOiBbe1xuICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgIGFsaWduOiBjb2xBbGlnblxuICAgICAgfV1cbiAgICB9O1xuXG4gICAgaWYgKGNvbnRleHQuZW52TmFtZS5jaGFyQXQoY29udGV4dC5lbnZOYW1lLmxlbmd0aCAtIDEpID09PSBcIipcIikge1xuICAgICAgLy8gSXQncyBvbmUgb2YgdGhlIG1hdGh0b29scyBzdGFycmVkIGZ1bmN0aW9ucy5cbiAgICAgIC8vIFBhcnNlIHRoZSBvcHRpb25hbCBhbGlnbm1lbnQgYXJndW1lbnQuXG4gICAgICB2YXIgcGFyc2VyID0gY29udGV4dC5wYXJzZXI7XG4gICAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuXG4gICAgICBpZiAocGFyc2VyLmZldGNoKCkudGV4dCA9PT0gXCJbXCIpIHtcbiAgICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgICAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgICAgICAgY29sQWxpZ24gPSBwYXJzZXIuZmV0Y2goKS50ZXh0O1xuXG4gICAgICAgIGlmIChcImxjclwiLmluZGV4T2YoY29sQWxpZ24pID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgbCBvciBjIG9yIHJcIiwgcGFyc2VyLm5leHRUb2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgICAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgICAgICBwYXJzZXIuZXhwZWN0KFwiXVwiKTtcbiAgICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgICAgcGF5bG9hZC5jb2xzID0gW3tcbiAgICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgICAgYWxpZ246IGNvbEFsaWduXG4gICAgICAgIH1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCBwYXlsb2FkLCBkQ2VsbFN0eWxlKGNvbnRleHQuZW52TmFtZSkpOyAvLyBQb3B1bGF0ZSBjb2xzIHdpdGggdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGNvbHVtbiBhbGlnbm1lbnQgc3BlY3MuXG5cbiAgICB2YXIgbnVtQ29scyA9IE1hdGgubWF4KDAsIC4uLnJlcy5ib2R5Lm1hcChyb3cgPT4gcm93Lmxlbmd0aCkpO1xuICAgIHJlcy5jb2xzID0gbmV3IEFycmF5KG51bUNvbHMpLmZpbGwoe1xuICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgYWxpZ246IGNvbEFsaWduXG4gICAgfSk7XG4gICAgcmV0dXJuIGRlbGltaXRlcnMgPyB7XG4gICAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgICAgbW9kZTogY29udGV4dC5tb2RlLFxuICAgICAgYm9keTogW3Jlc10sXG4gICAgICBsZWZ0OiBkZWxpbWl0ZXJzWzBdLFxuICAgICAgcmlnaHQ6IGRlbGltaXRlcnNbMV0sXG4gICAgICByaWdodENvbG9yOiB1bmRlZmluZWQgLy8gXFxyaWdodCB1bmluZmx1ZW5jZWQgYnkgXFxjb2xvciBpbiBhcnJheVxuXG4gICAgfSA6IHJlcztcbiAgfSxcblxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNixcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ1XG59KTtcbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wic21hbGxtYXRyaXhcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgYXJyYXlzdHJldGNoOiAwLjVcbiAgICB9O1xuICAgIHZhciByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCBwYXlsb2FkLCBcInNjcmlwdFwiKTtcbiAgICByZXMuY29sU2VwYXJhdGlvblR5cGUgPSBcInNtYWxsXCI7XG4gICAgcmV0dXJuIHJlcztcbiAgfSxcblxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNixcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ1XG59KTtcbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wic3ViYXJyYXlcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuXG4gIGhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICAgIC8vIFBhcnNpbmcgb2Yge3N1YmFycmF5fSBpcyBzaW1pbGFyIHRvIHthcnJheX1cbiAgICB2YXIgc3ltTm9kZSA9IGNoZWNrU3ltYm9sTm9kZVR5cGUoYXJnc1swXSk7XG4gICAgdmFyIGNvbGFsaWduID0gc3ltTm9kZSA/IFthcmdzWzBdXSA6IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwib3JkZ3JvdXBcIikuYm9keTtcbiAgICB2YXIgY29scyA9IGNvbGFsaWduLm1hcChmdW5jdGlvbiAobmRlKSB7XG4gICAgICB2YXIgbm9kZSA9IGFzc2VydFN5bWJvbE5vZGVUeXBlKG5kZSk7XG4gICAgICB2YXIgY2EgPSBub2RlLnRleHQ7IC8vIHtzdWJhcnJheX0gb25seSByZWNvZ25pemVzIFwibFwiICYgXCJjXCJcblxuICAgICAgaWYgKFwibGNcIi5pbmRleE9mKGNhKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgICAgYWxpZ246IGNhXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVW5rbm93biBjb2x1bW4gYWxpZ25tZW50OiBcIiArIGNhLCBuZGUpO1xuICAgIH0pO1xuXG4gICAgaWYgKGNvbHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJ7c3ViYXJyYXl9IGNhbiBjb250YWluIG9ubHkgb25lIGNvbHVtblwiKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0ge1xuICAgICAgY29scyxcbiAgICAgIGhza2lwQmVmb3JlQW5kQWZ0ZXI6IGZhbHNlLFxuICAgICAgYXJyYXlzdHJldGNoOiAwLjVcbiAgICB9O1xuICAgIHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHJlcywgXCJzY3JpcHRcIik7XG5cbiAgICBpZiAocmVzLmJvZHkubGVuZ3RoID4gMCAmJiByZXMuYm9keVswXS5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIntzdWJhcnJheX0gY2FuIGNvbnRhaW4gb25seSBvbmUgY29sdW1uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDYsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNVxufSk7IC8vIEEgY2FzZXMgZW52aXJvbm1lbnQgKGluIGFtc21hdGguc3R5KSBpcyBhbG1vc3QgZXF1aXZhbGVudCB0b1xuLy8gXFxkZWZcXGFycmF5c3RyZXRjaHsxLjJ9JVxuLy8gXFxsZWZ0XFx7XFxiZWdpbnthcnJheX17QHt9bEB7XFxxdWFkfWxAe319IOKApiBcXGVuZHthcnJheX1cXHJpZ2h0LlxuLy8ge2RjYXNlc30gaXMgYSB7Y2FzZXN9IGVudmlyb25tZW50IHdoZXJlIGNlbGxzIGFyZSBzZXQgaW4gXFxkaXNwbGF5c3R5bGUsXG4vLyBhcyBkZWZpbmVkIGluIG1hdGh0b29scy5zdHkuXG4vLyB7cmNhc2VzfSBpcyBhbm90aGVyIG1hdGh0b29scyBlbnZpcm9ubWVudC4gSXQncyBicmFjZSBpcyBvbiB0aGUgcmlnaHQgc2lkZS5cblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJjYXNlc1wiLCBcImRjYXNlc1wiLCBcInJjYXNlc1wiLCBcImRyY2FzZXNcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgYXJyYXlzdHJldGNoOiAxLjIsXG4gICAgICBjb2xzOiBbe1xuICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgIGFsaWduOiBcImxcIixcbiAgICAgICAgcHJlZ2FwOiAwLFxuICAgICAgICAvLyBUT0RPKGtldmluYikgZ2V0IHRoZSBjdXJyZW50IHN0eWxlLlxuICAgICAgICAvLyBGb3Igbm93IHdlIHVzZSB0aGUgbWV0cmljcyBmb3IgVEVYVCBzdHlsZSB3aGljaCBpcyB3aGF0IHdlIHdlcmVcbiAgICAgICAgLy8gZG9pbmcgYmVmb3JlLiAgQmVmb3JlIGF0dGVtcHRpbmcgdG8gZ2V0IHRoZSBjdXJyZW50IHN0eWxlIHdlXG4gICAgICAgIC8vIHNob3VsZCBsb29rIGF0IFRlWCdzIGJlaGF2aW9yIGVzcGVjaWFsbHkgZm9yIFxcb3ZlciBhbmQgbWF0cmljZXMuXG4gICAgICAgIHBvc3RnYXA6IDEuMFxuICAgICAgICAvKiAxZW0gcXVhZCAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgYWxpZ246IFwibFwiLFxuICAgICAgICBwcmVnYXA6IDAsXG4gICAgICAgIHBvc3RnYXA6IDBcbiAgICAgIH1dXG4gICAgfTtcbiAgICB2YXIgcmVzID0gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcGF5bG9hZCwgZENlbGxTdHlsZShjb250ZXh0LmVudk5hbWUpKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsZWZ0cmlnaHRcIixcbiAgICAgIG1vZGU6IGNvbnRleHQubW9kZSxcbiAgICAgIGJvZHk6IFtyZXNdLFxuICAgICAgbGVmdDogY29udGV4dC5lbnZOYW1lLmluZGV4T2YoXCJyXCIpID4gLTEgPyBcIi5cIiA6IFwiXFxcXHtcIixcbiAgICAgIHJpZ2h0OiBjb250ZXh0LmVudk5hbWUuaW5kZXhPZihcInJcIikgPiAtMSA/IFwiXFxcXH1cIiA6IFwiLlwiLFxuICAgICAgcmlnaHRDb2xvcjogdW5kZWZpbmVkXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNixcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ1XG59KTsgLy8gSW4gdGhlIGFsaWduIGVudmlyb25tZW50LCBvbmUgdXNlcyBhbXBlcnNhbmRzLCAmLCB0byBzcGVjaWZ5IG51bWJlciBvZlxuLy8gY29sdW1ucyBpbiBlYWNoIHJvdywgYW5kIHRvIGxvY2F0ZSBzcGFjaW5nIGJldHdlZW4gZWFjaCBjb2x1bW4uXG4vLyBhbGlnbiBnZXRzIGF1dG9tYXRpYyBudW1iZXJpbmcuIGFsaWduKiBhbmQgYWxpZ25lZCBkbyBub3QuXG4vLyBUaGUgYWxpZ25lZGF0IGVudmlyb25tZW50IGNhbiBiZSB1c2VkIGluIG1hdGggbW9kZS5cbi8vIE5vdGUgdGhhdCB3ZSBhc3N1bWUgXFxub21hbGxpbmVza2lwbGltaXQgdG8gYmUgemVybyxcbi8vIHNvIHRoYXQgXFxzdHJ1dEAgaXMgdGhlIHNhbWUgYXMgXFxzdHJ1dC5cblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJhbGlnblwiLCBcImFsaWduKlwiLCBcImFsaWduZWRcIiwgXCJzcGxpdFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXI6IGFsaWduZWRIYW5kbGVyLFxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNixcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ1XG59KTsgLy8gQSBnYXRoZXJlZCBlbnZpcm9ubWVudCBpcyBsaWtlIGFuIGFycmF5IGVudmlyb25tZW50IHdpdGggb25lIGNlbnRlcmVkXG4vLyBjb2x1bW4sIGJ1dCB3aGVyZSByb3dzIGFyZSBjb25zaWRlcmVkIGxpbmVzIHNvIGdldCBcXGpvdCBsaW5lIHNwYWNpbmdcbi8vIGFuZCBjb250ZW50cyBhcmUgc2V0IGluIFxcZGlzcGxheXN0eWxlLlxuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImdhdGhlcmVkXCIsIFwiZ2F0aGVyXCIsIFwiZ2F0aGVyKlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG5cbiAgaGFuZGxlcihjb250ZXh0KSB7XG4gICAgaWYgKFtcImdhdGhlclwiLCBcImdhdGhlcipcIl0uaW5jbHVkZXMoY29udGV4dC5lbnZOYW1lKSkge1xuICAgICAgdmFsaWRhdGVBbXNFbnZpcm9ubWVudENvbnRleHQoY29udGV4dCk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIGNvbHM6IFt7XG4gICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgYWxpZ246IFwiY1wiXG4gICAgICB9XSxcbiAgICAgIGFkZEpvdDogdHJ1ZSxcbiAgICAgIGNvbFNlcGFyYXRpb25UeXBlOiBcImdhdGhlclwiLFxuICAgICAgYXV0b1RhZzogZ2V0QXV0b1RhZyhjb250ZXh0LmVudk5hbWUpLFxuICAgICAgZW1wdHlTaW5nbGVSb3c6IHRydWUsXG4gICAgICBsZXFubzogY29udGV4dC5wYXJzZXIuc2V0dGluZ3MubGVxbm9cbiAgICB9O1xuICAgIHJldHVybiBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIFwiZGlzcGxheVwiKTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNixcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ1XG59KTsgLy8gYWxpZ25hdCBlbnZpcm9ubWVudCBpcyBsaWtlIGFuIGFsaWduIGVudmlyb25tZW50LCBidXQgb25lIG11c3QgZXhwbGljaXRseVxuLy8gc3BlY2lmeSBtYXhpbXVtIG51bWJlciBvZiBjb2x1bW5zIGluIGVhY2ggcm93LCBhbmQgY2FuIGFkanVzdCBzcGFjaW5nIGJldHdlZW5cbi8vIGVhY2ggY29sdW1ucy5cblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJhbGlnbmF0XCIsIFwiYWxpZ25hdCpcIiwgXCJhbGlnbmVkYXRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiBhbGlnbmVkSGFuZGxlcixcbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDYsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNVxufSk7XG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImVxdWF0aW9uXCIsIFwiZXF1YXRpb24qXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICB2YWxpZGF0ZUFtc0Vudmlyb25tZW50Q29udGV4dChjb250ZXh0KTtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgYXV0b1RhZzogZ2V0QXV0b1RhZyhjb250ZXh0LmVudk5hbWUpLFxuICAgICAgZW1wdHlTaW5nbGVSb3c6IHRydWUsXG4gICAgICBzaW5nbGVSb3c6IHRydWUsXG4gICAgICBtYXhOdW1Db2xzOiAxLFxuICAgICAgbGVxbm86IGNvbnRleHQucGFyc2VyLnNldHRpbmdzLmxlcW5vXG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcmVzLCBcImRpc3BsYXlcIik7XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDYsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNVxufSk7XG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcIkNEXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcblxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICB2YWxpZGF0ZUFtc0Vudmlyb25tZW50Q29udGV4dChjb250ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VDRChjb250ZXh0LnBhcnNlcik7XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDYsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNVxufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxub251bWJlclwiLCBcIlxcXFxnZGVmXFxcXEBlcW5zd3swfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5vdGFnXCIsIFwiXFxcXG5vbnVtYmVyXCIpOyAvLyBDYXRjaCBcXGhsaW5lIG91dHNpZGUgYXJyYXkgZW52aXJvbm1lbnRcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInRleHRcIixcbiAgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGlzIGlzLlxuICBuYW1lczogW1wiXFxcXGhsaW5lXCIsIFwiXFxcXGhkYXNobGluZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluTWF0aDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGNvbnRleHQuZnVuY05hbWUgKyBcIiB2YWxpZCBvbmx5IHdpdGhpbiBhcnJheSBlbnZpcm9ubWVudFwiKTtcbiAgfVxuXG59KTtcblxudmFyIGVudmlyb25tZW50cyA9IF9lbnZpcm9ubWVudHM7XG5cbi8vIGRlZmluZUVudmlyb25tZW50IGRlZmluaXRpb25zLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW52aXJvbm1lbnRcIixcbiAgbmFtZXM6IFtcIlxcXFxiZWdpblwiLCBcIlxcXFxlbmRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widGV4dFwiXVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIHZhciBuYW1lR3JvdXAgPSBhcmdzWzBdO1xuXG4gICAgaWYgKG5hbWVHcm91cC50eXBlICE9PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBlbnZpcm9ubWVudCBuYW1lXCIsIG5hbWVHcm91cCk7XG4gICAgfVxuXG4gICAgdmFyIGVudk5hbWUgPSBcIlwiO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lR3JvdXAuYm9keS5sZW5ndGg7ICsraSkge1xuICAgICAgZW52TmFtZSArPSBhc3NlcnROb2RlVHlwZShuYW1lR3JvdXAuYm9keVtpXSwgXCJ0ZXh0b3JkXCIpLnRleHQ7XG4gICAgfVxuXG4gICAgaWYgKGZ1bmNOYW1lID09PSBcIlxcXFxiZWdpblwiKSB7XG4gICAgICAvLyBiZWdpbi4uLmVuZCBpcyBzaW1pbGFyIHRvIGxlZnQuLi5yaWdodFxuICAgICAgaWYgKCFlbnZpcm9ubWVudHMuaGFzT3duUHJvcGVydHkoZW52TmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJObyBzdWNoIGVudmlyb25tZW50OiBcIiArIGVudk5hbWUsIG5hbWVHcm91cCk7XG4gICAgICB9IC8vIEJ1aWxkIHRoZSBlbnZpcm9ubWVudCBvYmplY3QuIEFyZ3VtZW50cyBhbmQgb3RoZXIgaW5mb3JtYXRpb24gd2lsbFxuICAgICAgLy8gYmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGJlZ2luIGFuZCBlbmQgbWV0aG9kcyB1c2luZyBwcm9wZXJ0aWVzLlxuXG5cbiAgICAgIHZhciBlbnYgPSBlbnZpcm9ubWVudHNbZW52TmFtZV07XG4gICAgICB2YXIge1xuICAgICAgICBhcmdzOiBfYXJncyxcbiAgICAgICAgb3B0QXJnc1xuICAgICAgfSA9IHBhcnNlci5wYXJzZUFyZ3VtZW50cyhcIlxcXFxiZWdpbntcIiArIGVudk5hbWUgKyBcIn1cIiwgZW52KTtcbiAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgICAgZW52TmFtZSxcbiAgICAgICAgcGFyc2VyXG4gICAgICB9O1xuICAgICAgdmFyIHJlc3VsdCA9IGVudi5oYW5kbGVyKGNvbnRleHQsIF9hcmdzLCBvcHRBcmdzKTtcbiAgICAgIHBhcnNlci5leHBlY3QoXCJcXFxcZW5kXCIsIGZhbHNlKTtcbiAgICAgIHZhciBlbmROYW1lVG9rZW4gPSBwYXJzZXIubmV4dFRva2VuO1xuICAgICAgdmFyIGVuZCA9IGFzc2VydE5vZGVUeXBlKHBhcnNlci5wYXJzZUZ1bmN0aW9uKCksIFwiZW52aXJvbm1lbnRcIik7XG5cbiAgICAgIGlmIChlbmQubmFtZSAhPT0gZW52TmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIk1pc21hdGNoOiBcXFxcYmVnaW57XCIgKyBlbnZOYW1lICsgXCJ9IG1hdGNoZWQgYnkgXFxcXGVuZHtcIiArIGVuZC5uYW1lICsgXCJ9XCIsIGVuZE5hbWVUb2tlbik7XG4gICAgICB9IC8vICRGbG93Rml4TWUsIFwiZW52aXJvbm1lbnRcIiBoYW5kbGVyIHJldHVybnMgYW4gZW52aXJvbm1lbnQgUGFyc2VOb2RlXG5cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbnZpcm9ubWVudFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBuYW1lOiBlbnZOYW1lLFxuICAgICAgbmFtZUdyb3VwXG4gICAgfTtcbiAgfVxuXG59KTtcblxuLy8gVE9ETyhrZXZpbmIpOiBpbXBsZW1lbnQgXFxcXHNsIGFuZCBcXFxcc2NcblxudmFyIGh0bWxCdWlsZGVyJDUgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgdmFyIGZvbnQgPSBncm91cC5mb250O1xuICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aEZvbnQoZm9udCk7XG4gIHJldHVybiBidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgbmV3T3B0aW9ucyk7XG59O1xuXG52YXIgbWF0aG1sQnVpbGRlciQ0ID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIHZhciBmb250ID0gZ3JvdXAuZm9udDtcbiAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLndpdGhGb250KGZvbnQpO1xuICByZXR1cm4gYnVpbGRHcm91cChncm91cC5ib2R5LCBuZXdPcHRpb25zKTtcbn07XG5cbnZhciBmb250QWxpYXNlcyA9IHtcbiAgXCJcXFxcQmJiXCI6IFwiXFxcXG1hdGhiYlwiLFxuICBcIlxcXFxib2xkXCI6IFwiXFxcXG1hdGhiZlwiLFxuICBcIlxcXFxmcmFrXCI6IFwiXFxcXG1hdGhmcmFrXCIsXG4gIFwiXFxcXGJtXCI6IFwiXFxcXGJvbGRzeW1ib2xcIlxufTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJmb250XCIsXG4gIG5hbWVzOiBbLy8gc3R5bGVzLCBleGNlcHQgXFxib2xkc3ltYm9sIGRlZmluZWQgYmVsb3dcbiAgXCJcXFxcbWF0aHJtXCIsIFwiXFxcXG1hdGhpdFwiLCBcIlxcXFxtYXRoYmZcIiwgXCJcXFxcbWF0aG5vcm1hbFwiLCBcIlxcXFxtYXRoc2ZpdFwiLCAvLyBmYW1pbGllc1xuICBcIlxcXFxtYXRoYmJcIiwgXCJcXFxcbWF0aGNhbFwiLCBcIlxcXFxtYXRoZnJha1wiLCBcIlxcXFxtYXRoc2NyXCIsIFwiXFxcXG1hdGhzZlwiLCBcIlxcXFxtYXRodHRcIiwgLy8gYWxpYXNlcywgZXhjZXB0IFxcYm0gZGVmaW5lZCBiZWxvd1xuICBcIlxcXFxCYmJcIiwgXCJcXFxcYm9sZFwiLCBcIlxcXFxmcmFrXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MpID0+IHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgYm9keSA9IG5vcm1hbGl6ZUFyZ3VtZW50KGFyZ3NbMF0pO1xuICAgIHZhciBmdW5jID0gZnVuY05hbWU7XG5cbiAgICBpZiAoZnVuYyBpbiBmb250QWxpYXNlcykge1xuICAgICAgZnVuYyA9IGZvbnRBbGlhc2VzW2Z1bmNdO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImZvbnRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZm9udDogZnVuYy5zbGljZSgxKSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ0XG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtY2xhc3NcIixcbiAgbmFtZXM6IFtcIlxcXFxib2xkc3ltYm9sXCIsIFwiXFxcXGJtXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYyLCBhcmdzKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmMjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgdmFyIGlzQ2hhcmFjdGVyQm94ID0gdXRpbHMuaXNDaGFyYWN0ZXJCb3goYm9keSk7IC8vIGFtc2JzeS5zdHkncyBcXGJvbGRzeW1ib2wgdXNlcyBcXGJpbnJlbCBzcGFjaW5nIHRvIGluaGVyaXQgdGhlXG4gICAgLy8gYXJndW1lbnQncyBiaW58cmVsfG9yZCBzdGF0dXNcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1jbGFzc1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBtY2xhc3M6IGJpbnJlbENsYXNzKGJvZHkpLFxuICAgICAgYm9keTogW3tcbiAgICAgICAgdHlwZTogXCJmb250XCIsXG4gICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICBmb250OiBcImJvbGRzeW1ib2xcIixcbiAgICAgICAgYm9keVxuICAgICAgfV0sXG4gICAgICBpc0NoYXJhY3RlckJveDogaXNDaGFyYWN0ZXJCb3hcbiAgICB9O1xuICB9XG59KTsgLy8gT2xkIGZvbnQgY2hhbmdpbmcgZnVuY3Rpb25zXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJmb250XCIsXG4gIG5hbWVzOiBbXCJcXFxccm1cIiwgXCJcXFxcc2ZcIiwgXCJcXFxcdHRcIiwgXCJcXFxcYmZcIiwgXCJcXFxcaXRcIiwgXCJcXFxcY2FsXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZjMsIGFyZ3MpID0+IHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWUsXG4gICAgICBicmVha09uVG9rZW5UZXh0XG4gICAgfSA9IF9yZWYzO1xuICAgIHZhciB7XG4gICAgICBtb2RlXG4gICAgfSA9IHBhcnNlcjtcbiAgICB2YXIgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgYnJlYWtPblRva2VuVGV4dCk7XG4gICAgdmFyIHN0eWxlID0gXCJtYXRoXCIgKyBmdW5jTmFtZS5zbGljZSgxKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmb250XCIsXG4gICAgICBtb2RlOiBtb2RlLFxuICAgICAgZm9udDogc3R5bGUsXG4gICAgICBib2R5OiB7XG4gICAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIGJvZHlcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ0XG59KTtcblxudmFyIGFkanVzdFN0eWxlID0gKHNpemUsIG9yaWdpbmFsU3R5bGUpID0+IHtcbiAgLy8gRmlndXJlIG91dCB3aGF0IHN0eWxlIHRoaXMgZnJhY3Rpb24gc2hvdWxkIGJlIGluIGJhc2VkIG9uIHRoZVxuICAvLyBmdW5jdGlvbiB1c2VkXG4gIHZhciBzdHlsZSA9IG9yaWdpbmFsU3R5bGU7XG5cbiAgaWYgKHNpemUgPT09IFwiZGlzcGxheVwiKSB7XG4gICAgLy8gR2V0IGRpc3BsYXkgc3R5bGUgYXMgYSBkZWZhdWx0LlxuICAgIC8vIElmIGluY29taW5nIHN0eWxlIGlzIHN1Yi9zdXAsIHVzZSBzdHlsZS50ZXh0KCkgdG8gZ2V0IGNvcnJlY3Qgc2l6ZS5cbiAgICBzdHlsZSA9IHN0eWxlLmlkID49IFN0eWxlJDEuU0NSSVBULmlkID8gc3R5bGUudGV4dCgpIDogU3R5bGUkMS5ESVNQTEFZO1xuICB9IGVsc2UgaWYgKHNpemUgPT09IFwidGV4dFwiICYmIHN0eWxlLnNpemUgPT09IFN0eWxlJDEuRElTUExBWS5zaXplKSB7XG4gICAgLy8gV2UncmUgaW4gYSBcXHRmcmFjIGJ1dCBpbmNvbWluZyBzdHlsZSBpcyBkaXNwbGF5c3R5bGUsIHNvOlxuICAgIHN0eWxlID0gU3R5bGUkMS5URVhUO1xuICB9IGVsc2UgaWYgKHNpemUgPT09IFwic2NyaXB0XCIpIHtcbiAgICBzdHlsZSA9IFN0eWxlJDEuU0NSSVBUO1xuICB9IGVsc2UgaWYgKHNpemUgPT09IFwic2NyaXB0c2NyaXB0XCIpIHtcbiAgICBzdHlsZSA9IFN0eWxlJDEuU0NSSVBUU0NSSVBUO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxudmFyIGh0bWxCdWlsZGVyJDQgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgLy8gRnJhY3Rpb25zIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIG9uIHBhZ2VzIDQ0NC00NDUsIHJ1bGVzIDE1KGEtZSkuXG4gIHZhciBzdHlsZSA9IGFkanVzdFN0eWxlKGdyb3VwLnNpemUsIG9wdGlvbnMuc3R5bGUpO1xuICB2YXIgbnN0eWxlID0gc3R5bGUuZnJhY051bSgpO1xuICB2YXIgZHN0eWxlID0gc3R5bGUuZnJhY0RlbigpO1xuICB2YXIgbmV3T3B0aW9ucztcbiAgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUobnN0eWxlKTtcbiAgdmFyIG51bWVybSA9IGJ1aWxkR3JvdXAkMShncm91cC5udW1lciwgbmV3T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgaWYgKGdyb3VwLmNvbnRpbnVlZCkge1xuICAgIC8vIFxcY2ZyYWMgaW5zZXJ0cyBhIFxcc3RydXQgaW50byB0aGUgbnVtZXJhdG9yLlxuICAgIC8vIEdldCBcXHN0cnV0IGRpbWVuc2lvbnMgZnJvbSBUZVhib29rIHBhZ2UgMzUzLlxuICAgIHZhciBoU3RydXQgPSA4LjUgLyBvcHRpb25zLmZvbnRNZXRyaWNzKCkucHRQZXJFbTtcbiAgICB2YXIgZFN0cnV0ID0gMy41IC8gb3B0aW9ucy5mb250TWV0cmljcygpLnB0UGVyRW07XG4gICAgbnVtZXJtLmhlaWdodCA9IG51bWVybS5oZWlnaHQgPCBoU3RydXQgPyBoU3RydXQgOiBudW1lcm0uaGVpZ2h0O1xuICAgIG51bWVybS5kZXB0aCA9IG51bWVybS5kZXB0aCA8IGRTdHJ1dCA/IGRTdHJ1dCA6IG51bWVybS5kZXB0aDtcbiAgfVxuXG4gIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKGRzdHlsZSk7XG4gIHZhciBkZW5vbW0gPSBidWlsZEdyb3VwJDEoZ3JvdXAuZGVub20sIG5ld09wdGlvbnMsIG9wdGlvbnMpO1xuICB2YXIgcnVsZTtcbiAgdmFyIHJ1bGVXaWR0aDtcbiAgdmFyIHJ1bGVTcGFjaW5nO1xuXG4gIGlmIChncm91cC5oYXNCYXJMaW5lKSB7XG4gICAgaWYgKGdyb3VwLmJhclNpemUpIHtcbiAgICAgIHJ1bGVXaWR0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuYmFyU2l6ZSwgb3B0aW9ucyk7XG4gICAgICBydWxlID0gYnVpbGRDb21tb24ubWFrZUxpbmVTcGFuKFwiZnJhYy1saW5lXCIsIG9wdGlvbnMsIHJ1bGVXaWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ1bGUgPSBidWlsZENvbW1vbi5tYWtlTGluZVNwYW4oXCJmcmFjLWxpbmVcIiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcnVsZVdpZHRoID0gcnVsZS5oZWlnaHQ7XG4gICAgcnVsZVNwYWNpbmcgPSBydWxlLmhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICBydWxlID0gbnVsbDtcbiAgICBydWxlV2lkdGggPSAwO1xuICAgIHJ1bGVTcGFjaW5nID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlZmF1bHRSdWxlVGhpY2tuZXNzO1xuICB9IC8vIFJ1bGUgMTViXG5cblxuICB2YXIgbnVtU2hpZnQ7XG4gIHZhciBjbGVhcmFuY2U7XG4gIHZhciBkZW5vbVNoaWZ0O1xuXG4gIGlmIChzdHlsZS5zaXplID09PSBTdHlsZSQxLkRJU1BMQVkuc2l6ZSB8fCBncm91cC5zaXplID09PSBcImRpc3BsYXlcIikge1xuICAgIG51bVNoaWZ0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLm51bTE7XG5cbiAgICBpZiAocnVsZVdpZHRoID4gMCkge1xuICAgICAgY2xlYXJhbmNlID0gMyAqIHJ1bGVTcGFjaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhcmFuY2UgPSA3ICogcnVsZVNwYWNpbmc7XG4gICAgfVxuXG4gICAgZGVub21TaGlmdCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZW5vbTE7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJ1bGVXaWR0aCA+IDApIHtcbiAgICAgIG51bVNoaWZ0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLm51bTI7XG4gICAgICBjbGVhcmFuY2UgPSBydWxlU3BhY2luZztcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtU2hpZnQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkubnVtMztcbiAgICAgIGNsZWFyYW5jZSA9IDMgKiBydWxlU3BhY2luZztcbiAgICB9XG5cbiAgICBkZW5vbVNoaWZ0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlbm9tMjtcbiAgfVxuXG4gIHZhciBmcmFjO1xuXG4gIGlmICghcnVsZSkge1xuICAgIC8vIFJ1bGUgMTVjXG4gICAgdmFyIGNhbmRpZGF0ZUNsZWFyYW5jZSA9IG51bVNoaWZ0IC0gbnVtZXJtLmRlcHRoIC0gKGRlbm9tbS5oZWlnaHQgLSBkZW5vbVNoaWZ0KTtcblxuICAgIGlmIChjYW5kaWRhdGVDbGVhcmFuY2UgPCBjbGVhcmFuY2UpIHtcbiAgICAgIG51bVNoaWZ0ICs9IDAuNSAqIChjbGVhcmFuY2UgLSBjYW5kaWRhdGVDbGVhcmFuY2UpO1xuICAgICAgZGVub21TaGlmdCArPSAwLjUgKiAoY2xlYXJhbmNlIC0gY2FuZGlkYXRlQ2xlYXJhbmNlKTtcbiAgICB9XG5cbiAgICBmcmFjID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogZGVub21tLFxuICAgICAgICBzaGlmdDogZGVub21TaGlmdFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogbnVtZXJtLFxuICAgICAgICBzaGlmdDogLW51bVNoaWZ0XG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIFJ1bGUgMTVkXG4gICAgdmFyIGF4aXNIZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDtcblxuICAgIGlmIChudW1TaGlmdCAtIG51bWVybS5kZXB0aCAtIChheGlzSGVpZ2h0ICsgMC41ICogcnVsZVdpZHRoKSA8IGNsZWFyYW5jZSkge1xuICAgICAgbnVtU2hpZnQgKz0gY2xlYXJhbmNlIC0gKG51bVNoaWZ0IC0gbnVtZXJtLmRlcHRoIC0gKGF4aXNIZWlnaHQgKyAwLjUgKiBydWxlV2lkdGgpKTtcbiAgICB9XG5cbiAgICBpZiAoYXhpc0hlaWdodCAtIDAuNSAqIHJ1bGVXaWR0aCAtIChkZW5vbW0uaGVpZ2h0IC0gZGVub21TaGlmdCkgPCBjbGVhcmFuY2UpIHtcbiAgICAgIGRlbm9tU2hpZnQgKz0gY2xlYXJhbmNlIC0gKGF4aXNIZWlnaHQgLSAwLjUgKiBydWxlV2lkdGggLSAoZGVub21tLmhlaWdodCAtIGRlbm9tU2hpZnQpKTtcbiAgICB9XG5cbiAgICB2YXIgbWlkU2hpZnQgPSAtKGF4aXNIZWlnaHQgLSAwLjUgKiBydWxlV2lkdGgpO1xuICAgIGZyYWMgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBkZW5vbW0sXG4gICAgICAgIHNoaWZ0OiBkZW5vbVNoaWZ0XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBydWxlLFxuICAgICAgICBzaGlmdDogbWlkU2hpZnRcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IG51bWVybSxcbiAgICAgICAgc2hpZnQ6IC1udW1TaGlmdFxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgfSAvLyBTaW5jZSB3ZSBtYW51YWxseSBjaGFuZ2UgdGhlIHN0eWxlIHNvbWV0aW1lcyAod2l0aCBcXGRmcmFjIG9yIFxcdGZyYWMpLFxuICAvLyBhY2NvdW50IGZvciB0aGUgcG9zc2libGUgc2l6ZSBjaGFuZ2UgaGVyZS5cblxuXG4gIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlKTtcbiAgZnJhYy5oZWlnaHQgKj0gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllciAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gIGZyYWMuZGVwdGggKj0gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllciAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7IC8vIFJ1bGUgMTVlXG5cbiAgdmFyIGRlbGltU2l6ZTtcblxuICBpZiAoc3R5bGUuc2l6ZSA9PT0gU3R5bGUkMS5ESVNQTEFZLnNpemUpIHtcbiAgICBkZWxpbVNpemUgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVsaW0xO1xuICB9IGVsc2UgaWYgKHN0eWxlLnNpemUgPT09IFN0eWxlJDEuU0NSSVBUU0NSSVBULnNpemUpIHtcbiAgICBkZWxpbVNpemUgPSBvcHRpb25zLmhhdmluZ1N0eWxlKFN0eWxlJDEuU0NSSVBUKS5mb250TWV0cmljcygpLmRlbGltMjtcbiAgfSBlbHNlIHtcbiAgICBkZWxpbVNpemUgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVsaW0yO1xuICB9XG5cbiAgdmFyIGxlZnREZWxpbTtcbiAgdmFyIHJpZ2h0RGVsaW07XG5cbiAgaWYgKGdyb3VwLmxlZnREZWxpbSA9PSBudWxsKSB7XG4gICAgbGVmdERlbGltID0gbWFrZU51bGxEZWxpbWl0ZXIob3B0aW9ucywgW1wibW9wZW5cIl0pO1xuICB9IGVsc2Uge1xuICAgIGxlZnREZWxpbSA9IGRlbGltaXRlci5jdXN0b21TaXplZERlbGltKGdyb3VwLmxlZnREZWxpbSwgZGVsaW1TaXplLCB0cnVlLCBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlKSwgZ3JvdXAubW9kZSwgW1wibW9wZW5cIl0pO1xuICB9XG5cbiAgaWYgKGdyb3VwLmNvbnRpbnVlZCkge1xuICAgIHJpZ2h0RGVsaW0gPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXSk7IC8vIHplcm8gd2lkdGggZm9yIFxcY2ZyYWNcbiAgfSBlbHNlIGlmIChncm91cC5yaWdodERlbGltID09IG51bGwpIHtcbiAgICByaWdodERlbGltID0gbWFrZU51bGxEZWxpbWl0ZXIob3B0aW9ucywgW1wibWNsb3NlXCJdKTtcbiAgfSBlbHNlIHtcbiAgICByaWdodERlbGltID0gZGVsaW1pdGVyLmN1c3RvbVNpemVkRGVsaW0oZ3JvdXAucmlnaHREZWxpbSwgZGVsaW1TaXplLCB0cnVlLCBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlKSwgZ3JvdXAubW9kZSwgW1wibWNsb3NlXCJdKTtcbiAgfVxuXG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCJdLmNvbmNhdChuZXdPcHRpb25zLnNpemluZ0NsYXNzZXMob3B0aW9ucykpLCBbbGVmdERlbGltLCBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtZnJhY1wiXSwgW2ZyYWNdKSwgcmlnaHREZWxpbV0sIG9wdGlvbnMpO1xufTtcblxudmFyIG1hdGhtbEJ1aWxkZXIkMyA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWZyYWNcIiwgW2J1aWxkR3JvdXAoZ3JvdXAubnVtZXIsIG9wdGlvbnMpLCBidWlsZEdyb3VwKGdyb3VwLmRlbm9tLCBvcHRpb25zKV0pO1xuXG4gIGlmICghZ3JvdXAuaGFzQmFyTGluZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibGluZXRoaWNrbmVzc1wiLCBcIjBweFwiKTtcbiAgfSBlbHNlIGlmIChncm91cC5iYXJTaXplKSB7XG4gICAgdmFyIHJ1bGVXaWR0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuYmFyU2l6ZSwgb3B0aW9ucyk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5ldGhpY2tuZXNzXCIsIG1ha2VFbShydWxlV2lkdGgpKTtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IGFkanVzdFN0eWxlKGdyb3VwLnNpemUsIG9wdGlvbnMuc3R5bGUpO1xuXG4gIGlmIChzdHlsZS5zaXplICE9PSBvcHRpb25zLnN0eWxlLnNpemUpIHtcbiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3R5bGVcIiwgW25vZGVdKTtcbiAgICB2YXIgaXNEaXNwbGF5ID0gc3R5bGUuc2l6ZSA9PT0gU3R5bGUkMS5ESVNQTEFZLnNpemUgPyBcInRydWVcIiA6IFwiZmFsc2VcIjtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImRpc3BsYXlzdHlsZVwiLCBpc0Rpc3BsYXkpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgXCIwXCIpO1xuICB9XG5cbiAgaWYgKGdyb3VwLmxlZnREZWxpbSAhPSBudWxsIHx8IGdyb3VwLnJpZ2h0RGVsaW0gIT0gbnVsbCkge1xuICAgIHZhciB3aXRoRGVsaW1zID0gW107XG5cbiAgICBpZiAoZ3JvdXAubGVmdERlbGltICE9IG51bGwpIHtcbiAgICAgIHZhciBsZWZ0T3AgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShncm91cC5sZWZ0RGVsaW0ucmVwbGFjZShcIlxcXFxcIiwgXCJcIikpXSk7XG4gICAgICBsZWZ0T3Auc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgICAgd2l0aERlbGltcy5wdXNoKGxlZnRPcCk7XG4gICAgfVxuXG4gICAgd2l0aERlbGltcy5wdXNoKG5vZGUpO1xuXG4gICAgaWYgKGdyb3VwLnJpZ2h0RGVsaW0gIT0gbnVsbCkge1xuICAgICAgdmFyIHJpZ2h0T3AgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShncm91cC5yaWdodERlbGltLnJlcGxhY2UoXCJcXFxcXCIsIFwiXCIpKV0pO1xuICAgICAgcmlnaHRPcC5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG4gICAgICB3aXRoRGVsaW1zLnB1c2gocmlnaHRPcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ha2VSb3cod2l0aERlbGltcyk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJnZW5mcmFjXCIsXG4gIG5hbWVzOiBbXCJcXFxcZGZyYWNcIiwgXCJcXFxcZnJhY1wiLCBcIlxcXFx0ZnJhY1wiLCBcIlxcXFxkYmlub21cIiwgXCJcXFxcYmlub21cIiwgXCJcXFxcdGJpbm9tXCIsIFwiXFxcXFxcXFxhdG9wZnJhY1wiLCAvLyBjYW7igJl0IGJlIGVudGVyZWQgZGlyZWN0bHlcbiAgXCJcXFxcXFxcXGJyYWNlZnJhY1wiLCBcIlxcXFxcXFxcYnJhY2tmcmFjXCIgLy8gZGl0dG9cbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIG51bWVyID0gYXJnc1swXTtcbiAgICB2YXIgZGVub20gPSBhcmdzWzFdO1xuICAgIHZhciBoYXNCYXJMaW5lO1xuICAgIHZhciBsZWZ0RGVsaW0gPSBudWxsO1xuICAgIHZhciByaWdodERlbGltID0gbnVsbDtcbiAgICB2YXIgc2l6ZSA9IFwiYXV0b1wiO1xuXG4gICAgc3dpdGNoIChmdW5jTmFtZSkge1xuICAgICAgY2FzZSBcIlxcXFxkZnJhY1wiOlxuICAgICAgY2FzZSBcIlxcXFxmcmFjXCI6XG4gICAgICBjYXNlIFwiXFxcXHRmcmFjXCI6XG4gICAgICAgIGhhc0JhckxpbmUgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFxcXFxcYXRvcGZyYWNcIjpcbiAgICAgICAgaGFzQmFyTGluZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFxkYmlub21cIjpcbiAgICAgIGNhc2UgXCJcXFxcYmlub21cIjpcbiAgICAgIGNhc2UgXCJcXFxcdGJpbm9tXCI6XG4gICAgICAgIGhhc0JhckxpbmUgPSBmYWxzZTtcbiAgICAgICAgbGVmdERlbGltID0gXCIoXCI7XG4gICAgICAgIHJpZ2h0RGVsaW0gPSBcIilcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcXFxcXGJyYWNlZnJhY1wiOlxuICAgICAgICBoYXNCYXJMaW5lID0gZmFsc2U7XG4gICAgICAgIGxlZnREZWxpbSA9IFwiXFxcXHtcIjtcbiAgICAgICAgcmlnaHREZWxpbSA9IFwiXFxcXH1cIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcXFxcXGJyYWNrZnJhY1wiOlxuICAgICAgICBoYXNCYXJMaW5lID0gZmFsc2U7XG4gICAgICAgIGxlZnREZWxpbSA9IFwiW1wiO1xuICAgICAgICByaWdodERlbGltID0gXCJdXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZ2VuZnJhYyBjb21tYW5kXCIpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZnVuY05hbWUpIHtcbiAgICAgIGNhc2UgXCJcXFxcZGZyYWNcIjpcbiAgICAgIGNhc2UgXCJcXFxcZGJpbm9tXCI6XG4gICAgICAgIHNpemUgPSBcImRpc3BsYXlcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcdGZyYWNcIjpcbiAgICAgIGNhc2UgXCJcXFxcdGJpbm9tXCI6XG4gICAgICAgIHNpemUgPSBcInRleHRcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBjb250aW51ZWQ6IGZhbHNlLFxuICAgICAgbnVtZXIsXG4gICAgICBkZW5vbSxcbiAgICAgIGhhc0JhckxpbmUsXG4gICAgICBsZWZ0RGVsaW0sXG4gICAgICByaWdodERlbGltLFxuICAgICAgc2l6ZSxcbiAgICAgIGJhclNpemU6IG51bGxcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNCxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQzXG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJnZW5mcmFjXCIsXG4gIG5hbWVzOiBbXCJcXFxcY2ZyYWNcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMlxuICB9LFxuICBoYW5kbGVyOiAoX3JlZjIsIGFyZ3MpID0+IHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjI7XG4gICAgdmFyIG51bWVyID0gYXJnc1swXTtcbiAgICB2YXIgZGVub20gPSBhcmdzWzFdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImdlbmZyYWNcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgY29udGludWVkOiB0cnVlLFxuICAgICAgbnVtZXIsXG4gICAgICBkZW5vbSxcbiAgICAgIGhhc0JhckxpbmU6IHRydWUsXG4gICAgICBsZWZ0RGVsaW06IG51bGwsXG4gICAgICByaWdodERlbGltOiBudWxsLFxuICAgICAgc2l6ZTogXCJkaXNwbGF5XCIsXG4gICAgICBiYXJTaXplOiBudWxsXG4gICAgfTtcbiAgfVxufSk7IC8vIEluZml4IGdlbmVyYWxpemVkIGZyYWN0aW9ucyAtLSB0aGVzZSBhcmUgbm90IHJlbmRlcmVkIGRpcmVjdGx5LCBidXQgcmVwbGFjZWRcbi8vIGltbWVkaWF0ZWx5IGJ5IG9uZSBvZiB0aGUgdmFyaWFudHMgYWJvdmUuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbmZpeFwiLFxuICBuYW1lczogW1wiXFxcXG92ZXJcIiwgXCJcXFxcY2hvb3NlXCIsIFwiXFxcXGF0b3BcIiwgXCJcXFxcYnJhY2VcIiwgXCJcXFxcYnJhY2tcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBpbmZpeDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjMpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWUsXG4gICAgICB0b2tlblxuICAgIH0gPSBfcmVmMztcbiAgICB2YXIgcmVwbGFjZVdpdGg7XG5cbiAgICBzd2l0Y2ggKGZ1bmNOYW1lKSB7XG4gICAgICBjYXNlIFwiXFxcXG92ZXJcIjpcbiAgICAgICAgcmVwbGFjZVdpdGggPSBcIlxcXFxmcmFjXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXGNob29zZVwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXGJpbm9tXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXGF0b3BcIjpcbiAgICAgICAgcmVwbGFjZVdpdGggPSBcIlxcXFxcXFxcYXRvcGZyYWNcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcYnJhY2VcIjpcbiAgICAgICAgcmVwbGFjZVdpdGggPSBcIlxcXFxcXFxcYnJhY2VmcmFjXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXGJyYWNrXCI6XG4gICAgICAgIHJlcGxhY2VXaXRoID0gXCJcXFxcXFxcXGJyYWNrZnJhY1wiO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGluZml4IGdlbmZyYWMgY29tbWFuZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbmZpeFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICByZXBsYWNlV2l0aCxcbiAgICAgIHRva2VuXG4gICAgfTtcbiAgfVxuXG59KTtcbnZhciBzdHlsQXJyYXkgPSBbXCJkaXNwbGF5XCIsIFwidGV4dFwiLCBcInNjcmlwdFwiLCBcInNjcmlwdHNjcmlwdFwiXTtcblxudmFyIGRlbGltRnJvbVZhbHVlID0gZnVuY3Rpb24gZGVsaW1Gcm9tVmFsdWUoZGVsaW1TdHJpbmcpIHtcbiAgdmFyIGRlbGltID0gbnVsbDtcblxuICBpZiAoZGVsaW1TdHJpbmcubGVuZ3RoID4gMCkge1xuICAgIGRlbGltID0gZGVsaW1TdHJpbmc7XG4gICAgZGVsaW0gPSBkZWxpbSA9PT0gXCIuXCIgPyBudWxsIDogZGVsaW07XG4gIH1cblxuICByZXR1cm4gZGVsaW07XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICBuYW1lczogW1wiXFxcXGdlbmZyYWNcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogNixcbiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wibWF0aFwiLCBcIm1hdGhcIiwgXCJzaXplXCIsIFwidGV4dFwiLCBcIm1hdGhcIiwgXCJtYXRoXCJdXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmNCwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjQ7XG4gICAgdmFyIG51bWVyID0gYXJnc1s0XTtcbiAgICB2YXIgZGVub20gPSBhcmdzWzVdOyAvLyBMb29rIGludG8gdGhlIHBhcnNlIG5vZGVzIHRvIGdldCB0aGUgZGVzaXJlZCBkZWxpbWl0ZXJzLlxuXG4gICAgdmFyIGxlZnROb2RlID0gbm9ybWFsaXplQXJndW1lbnQoYXJnc1swXSk7XG4gICAgdmFyIGxlZnREZWxpbSA9IGxlZnROb2RlLnR5cGUgPT09IFwiYXRvbVwiICYmIGxlZnROb2RlLmZhbWlseSA9PT0gXCJvcGVuXCIgPyBkZWxpbUZyb21WYWx1ZShsZWZ0Tm9kZS50ZXh0KSA6IG51bGw7XG4gICAgdmFyIHJpZ2h0Tm9kZSA9IG5vcm1hbGl6ZUFyZ3VtZW50KGFyZ3NbMV0pO1xuICAgIHZhciByaWdodERlbGltID0gcmlnaHROb2RlLnR5cGUgPT09IFwiYXRvbVwiICYmIHJpZ2h0Tm9kZS5mYW1pbHkgPT09IFwiY2xvc2VcIiA/IGRlbGltRnJvbVZhbHVlKHJpZ2h0Tm9kZS50ZXh0KSA6IG51bGw7XG4gICAgdmFyIGJhck5vZGUgPSBhc3NlcnROb2RlVHlwZShhcmdzWzJdLCBcInNpemVcIik7XG4gICAgdmFyIGhhc0JhckxpbmU7XG4gICAgdmFyIGJhclNpemUgPSBudWxsO1xuXG4gICAgaWYgKGJhck5vZGUuaXNCbGFuaykge1xuICAgICAgLy8gXFxnZW5mcmFjIGFjdHMgZGlmZmVyZW50bHkgdGhhbiBcXGFib3ZlLlxuICAgICAgLy8gXFxnZW5mcmFjIHRyZWF0cyBhbiBlbXB0eSBzaXplIGdyb3VwIGFzIGEgc2lnbmFsIHRvIHVzZSBhXG4gICAgICAvLyBzdGFuZGFyZCBiYXIgc2l6ZS4gXFxhYm92ZSB3b3VsZCBzZWUgc2l6ZSA9IDAgYW5kIG9taXQgdGhlIGJhci5cbiAgICAgIGhhc0JhckxpbmUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXJTaXplID0gYmFyTm9kZS52YWx1ZTtcbiAgICAgIGhhc0JhckxpbmUgPSBiYXJTaXplLm51bWJlciA+IDA7XG4gICAgfSAvLyBGaW5kIG91dCBpZiB3ZSB3YW50IGRpc3BsYXlzdHlsZSwgdGV4dHN0eWxlLCBldGMuXG5cblxuICAgIHZhciBzaXplID0gXCJhdXRvXCI7XG4gICAgdmFyIHN0eWwgPSBhcmdzWzNdO1xuXG4gICAgaWYgKHN0eWwudHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgICBpZiAoc3R5bC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHRleHRPcmQgPSBhc3NlcnROb2RlVHlwZShzdHlsLmJvZHlbMF0sIFwidGV4dG9yZFwiKTtcbiAgICAgICAgc2l6ZSA9IHN0eWxBcnJheVtOdW1iZXIodGV4dE9yZC50ZXh0KV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWwgPSBhc3NlcnROb2RlVHlwZShzdHlsLCBcInRleHRvcmRcIik7XG4gICAgICBzaXplID0gc3R5bEFycmF5W051bWJlcihzdHlsLnRleHQpXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJnZW5mcmFjXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG51bWVyLFxuICAgICAgZGVub20sXG4gICAgICBjb250aW51ZWQ6IGZhbHNlLFxuICAgICAgaGFzQmFyTGluZSxcbiAgICAgIGJhclNpemUsXG4gICAgICBsZWZ0RGVsaW0sXG4gICAgICByaWdodERlbGltLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDQsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkM1xufSk7IC8vIFxcYWJvdmUgaXMgYW4gaW5maXggZnJhY3Rpb24gdGhhdCBhbHNvIGRlZmluZXMgYSBmcmFjdGlvbiBiYXIgc2l6ZS5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImluZml4XCIsXG4gIG5hbWVzOiBbXCJcXFxcYWJvdmVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiXSxcbiAgICBpbmZpeDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjUsIGFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWUsXG4gICAgICB0b2tlblxuICAgIH0gPSBfcmVmNTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbmZpeFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICByZXBsYWNlV2l0aDogXCJcXFxcXFxcXGFib3ZlZnJhY1wiLFxuICAgICAgc2l6ZTogYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJzaXplXCIpLnZhbHVlLFxuICAgICAgdG9rZW5cbiAgICB9O1xuICB9XG5cbn0pO1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImdlbmZyYWNcIixcbiAgbmFtZXM6IFtcIlxcXFxcXFxcYWJvdmVmcmFjXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDMsXG4gICAgYXJnVHlwZXM6IFtcIm1hdGhcIiwgXCJzaXplXCIsIFwibWF0aFwiXVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZjYsIGFyZ3MpID0+IHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjY7XG4gICAgdmFyIG51bWVyID0gYXJnc1swXTtcbiAgICB2YXIgYmFyU2l6ZSA9IGFzc2VydChhc3NlcnROb2RlVHlwZShhcmdzWzFdLCBcImluZml4XCIpLnNpemUpO1xuICAgIHZhciBkZW5vbSA9IGFyZ3NbMl07XG4gICAgdmFyIGhhc0JhckxpbmUgPSBiYXJTaXplLm51bWJlciA+IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBudW1lcixcbiAgICAgIGRlbm9tLFxuICAgICAgY29udGludWVkOiBmYWxzZSxcbiAgICAgIGhhc0JhckxpbmUsXG4gICAgICBiYXJTaXplLFxuICAgICAgbGVmdERlbGltOiBudWxsLFxuICAgICAgcmlnaHREZWxpbTogbnVsbCxcbiAgICAgIHNpemU6IFwiYXV0b1wiXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDQsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkM1xufSk7XG5cbi8vIE5PVEU6IFVubGlrZSBtb3N0IGBodG1sQnVpbGRlcmBzLCB0aGlzIG9uZSBoYW5kbGVzIG5vdCBvbmx5IFwiaG9yaXpCcmFjZVwiLCBidXRcbi8vIGFsc28gXCJzdXBzdWJcIiBzaW5jZSBhbiBvdmVyL3VuZGVyYnJhY2UgY2FuIGFmZmVjdCBzdXBlci9zdWJzY3JpcHRpbmcuXG52YXIgaHRtbEJ1aWxkZXIkMyA9IChncnAsIG9wdGlvbnMpID0+IHtcbiAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTsgLy8gUHVsbCBvdXQgdGhlIGBQYXJzZU5vZGU8XCJob3JpekJyYWNlXCI+YCBpZiBgZ3JwYCBpcyBhIFwic3Vwc3ViXCIgbm9kZS5cblxuICB2YXIgc3VwU3ViR3JvdXA7XG4gIHZhciBncm91cDtcblxuICBpZiAoZ3JwLnR5cGUgPT09IFwic3Vwc3ViXCIpIHtcbiAgICAvLyBSZWY6IExhVGVYIHNvdXJjZTJlOiB9fX19XFxsaW1pdHN9XG4gICAgLy8gaS5lLiBMYVRlWCB0cmVhdHMgdGhlIGJyYWNlIHNpbWlsYXIgdG8gYW4gb3AgYW5kIHBhc3NlcyBpdFxuICAgIC8vIHdpdGggXFxsaW1pdHMsIHNvIHdlIG5lZWQgdG8gYXNzaWduIHN1cHN1YiBzdHlsZS5cbiAgICBzdXBTdWJHcm91cCA9IGdycC5zdXAgPyBidWlsZEdyb3VwJDEoZ3JwLnN1cCwgb3B0aW9ucy5oYXZpbmdTdHlsZShzdHlsZS5zdXAoKSksIG9wdGlvbnMpIDogYnVpbGRHcm91cCQxKGdycC5zdWIsIG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUuc3ViKCkpLCBvcHRpb25zKTtcbiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKGdycC5iYXNlLCBcImhvcml6QnJhY2VcIik7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShncnAsIFwiaG9yaXpCcmFjZVwiKTtcbiAgfSAvLyBCdWlsZCB0aGUgYmFzZSBncm91cFxuXG5cbiAgdmFyIGJvZHkgPSBidWlsZEdyb3VwJDEoZ3JvdXAuYmFzZSwgb3B0aW9ucy5oYXZpbmdCYXNlU3R5bGUoU3R5bGUkMS5ESVNQTEFZKSk7IC8vIENyZWF0ZSB0aGUgc3RyZXRjaHkgZWxlbWVudFxuXG4gIHZhciBicmFjZUJvZHkgPSBzdHJldGNoeS5zdmdTcGFuKGdyb3VwLCBvcHRpb25zKTsgLy8gR2VuZXJhdGUgdGhlIHZsaXN0LCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBrZXJucyAgICAgICAg4pSP4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSTXG4gIC8vIFRoaXMgZmlyc3Qgdmxpc3QgY29udGFpbnMgdGhlIGNvbnRlbnQgYW5kIHRoZSBicmFjZTogICBlcXVhdGlvblxuXG4gIHZhciB2bGlzdDtcblxuICBpZiAoZ3JvdXAuaXNPdmVyKSB7XG4gICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYm9keVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogMC4xXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBicmFjZUJvZHlcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7IC8vICRGbG93Rml4TWU6IFJlcGxhY2UgdGhpcyB3aXRoIHBhc3NpbmcgXCJzdmctYWxpZ25cIiBpbnRvIG1ha2VWTGlzdC5cblxuICAgIHZsaXN0LmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzFdLmNsYXNzZXMucHVzaChcInN2Zy1hbGlnblwiKTtcbiAgfSBlbHNlIHtcbiAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiYm90dG9tXCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IGJvZHkuZGVwdGggKyAwLjEgKyBicmFjZUJvZHkuaGVpZ2h0LFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBicmFjZUJvZHlcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IDAuMVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogYm9keVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTsgLy8gJEZsb3dGaXhNZTogUmVwbGFjZSB0aGlzIHdpdGggcGFzc2luZyBcInN2Zy1hbGlnblwiIGludG8gbWFrZVZMaXN0LlxuXG4gICAgdmxpc3QuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uY2xhc3Nlcy5wdXNoKFwic3ZnLWFsaWduXCIpO1xuICB9XG5cbiAgaWYgKHN1cFN1Ykdyb3VwKSB7XG4gICAgLy8gVG8gd3JpdGUgdGhlIHN1cHN1Yiwgd3JhcCB0aGUgZmlyc3Qgdmxpc3QgaW4gYW5vdGhlciB2bGlzdDpcbiAgICAvLyBUaGV5IGNhbid0IGFsbCBnbyBpbiB0aGUgc2FtZSB2bGlzdCwgYmVjYXVzZSB0aGUgbm90ZSBtaWdodCBiZVxuICAgIC8vIHdpZGVyIHRoYW4gdGhlIGVxdWF0aW9uLiBXZSB3YW50IHRoZSBlcXVhdGlvbiB0byBjb250cm9sIHRoZVxuICAgIC8vIGJyYWNlIHdpZHRoLlxuICAgIC8vICAgICAgbm90ZSAgICAgICAgICBsb25nIG5vdGUgICAgICAgICAgIGxvbmcgbm90ZVxuICAgIC8vICAg4pSP4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSTICAgb3IgICAg4pSP4pSB4pSB4pSB4pSTICAgICBub3QgICAg4pSP4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSB4pSTXG4gICAgLy8gICAgZXF1YXRpb24gICAgICAgICAgIGVxbiAgICAgICAgICAgICAgICAgZXFuXG4gICAgdmFyIHZTcGFuID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBncm91cC5pc092ZXIgPyBcIm1vdmVyXCIgOiBcIm11bmRlclwiXSwgW3ZsaXN0XSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoZ3JvdXAuaXNPdmVyKSB7XG4gICAgICB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJmaXJzdEJhc2VsaW5lXCIsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHZTcGFuXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgICBzaXplOiAwLjJcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHN1cFN1Ykdyb3VwXG4gICAgICAgIH1dXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwiYm90dG9tXCIsXG4gICAgICAgIHBvc2l0aW9uRGF0YTogdlNwYW4uZGVwdGggKyAwLjIgKyBzdXBTdWJHcm91cC5oZWlnaHQgKyBzdXBTdWJHcm91cC5kZXB0aCxcbiAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogc3VwU3ViR3JvdXBcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICAgIHNpemU6IDAuMlxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgICAgZWxlbTogdlNwYW5cbiAgICAgICAgfV1cbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIGdyb3VwLmlzT3ZlciA/IFwibW92ZXJcIiA6IFwibXVuZGVyXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbn07XG5cbnZhciBtYXRobWxCdWlsZGVyJDIgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgdmFyIGFjY2VudE5vZGUgPSBzdHJldGNoeS5tYXRoTUxub2RlKGdyb3VwLmxhYmVsKTtcbiAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKGdyb3VwLmlzT3ZlciA/IFwibW92ZXJcIiA6IFwibXVuZGVyXCIsIFtidWlsZEdyb3VwKGdyb3VwLmJhc2UsIG9wdGlvbnMpLCBhY2NlbnROb2RlXSk7XG59OyAvLyBIb3Jpem9udGFsIHN0cmV0Y2h5IGJyYWNlc1xuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJob3JpekJyYWNlXCIsXG4gIG5hbWVzOiBbXCJcXFxcb3ZlcmJyYWNlXCIsIFwiXFxcXHVuZGVyYnJhY2VcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhvcml6QnJhY2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgaXNPdmVyOiAvXlxcXFxvdmVyLy50ZXN0KGZ1bmNOYW1lKSxcbiAgICAgIGJhc2U6IGFyZ3NbMF1cbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQzLFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDJcbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaHJlZlwiLFxuICBuYW1lczogW1wiXFxcXGhyZWZcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhcmdUeXBlczogW1widXJsXCIsIFwib3JpZ2luYWxcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4ge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMV07XG4gICAgdmFyIGhyZWYgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInVybFwiKS51cmw7XG5cbiAgICBpZiAoIXBhcnNlci5zZXR0aW5ncy5pc1RydXN0ZWQoe1xuICAgICAgY29tbWFuZDogXCJcXFxcaHJlZlwiLFxuICAgICAgdXJsOiBocmVmXG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBwYXJzZXIuZm9ybWF0VW5zdXBwb3J0ZWRDbWQoXCJcXFxcaHJlZlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJocmVmXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGhyZWYsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgZWxlbWVudHMgPSBidWlsZEV4cHJlc3Npb24kMShncm91cC5ib2R5LCBvcHRpb25zLCBmYWxzZSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VBbmNob3IoZ3JvdXAuaHJlZiwgW10sIGVsZW1lbnRzLCBvcHRpb25zKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIG1hdGggPSBidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIShtYXRoIGluc3RhbmNlb2YgTWF0aE5vZGUpKSB7XG4gICAgICBtYXRoID0gbmV3IE1hdGhOb2RlKFwibXJvd1wiLCBbbWF0aF0pO1xuICAgIH1cblxuICAgIG1hdGguc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBncm91cC5ocmVmKTtcbiAgICByZXR1cm4gbWF0aDtcbiAgfVxufSk7XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaHJlZlwiLFxuICBuYW1lczogW1wiXFxcXHVybFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJ1cmxcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZjIsIGFyZ3MpID0+IHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWYyO1xuICAgIHZhciBocmVmID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJ1cmxcIikudXJsO1xuXG4gICAgaWYgKCFwYXJzZXIuc2V0dGluZ3MuaXNUcnVzdGVkKHtcbiAgICAgIGNvbW1hbmQ6IFwiXFxcXHVybFwiLFxuICAgICAgdXJsOiBocmVmXG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBwYXJzZXIuZm9ybWF0VW5zdXBwb3J0ZWRDbWQoXCJcXFxcdXJsXCIpO1xuICAgIH1cblxuICAgIHZhciBjaGFycyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBocmVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGhyZWZbaV07XG5cbiAgICAgIGlmIChjID09PSBcIn5cIikge1xuICAgICAgICBjID0gXCJcXFxcdGV4dGFzY2lpdGlsZGVcIjtcbiAgICAgIH1cblxuICAgICAgY2hhcnMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgdGV4dDogY1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGJvZHkgPSB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZm9udDogXCJcXFxcdGV4dHR0XCIsXG4gICAgICBib2R5OiBjaGFyc1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaHJlZlwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBocmVmLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9XG59KTtcblxuLy8gSW4gTGFUZVgsIFxcdmNlbnRlciBjYW4gYWN0IG9ubHkgb24gYSBib3gsIGFzIGluXG4vLyBcXHZjZW50ZXJ7XFxoYm94eyRcXGZyYWN7YStifXtcXGRmcmFje2N9e2R9fSR9fVxuLy8gVGhpcyBmdW5jdGlvbiBieSBpdHNlbGYgZG9lc24ndCBkbyBhbnl0aGluZyBidXQgcHJldmVudCBhIHNvZnQgbGluZSBicmVhay5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImhib3hcIixcbiAgbmFtZXM6IFtcIlxcXFxoYm94XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInRleHRcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaGJveFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChhcmdzWzBdKVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBidWlsZEV4cHJlc3Npb24kMShncm91cC5ib2R5LCBvcHRpb25zLCBmYWxzZSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChlbGVtZW50cyk7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG9wdGlvbnMpKTtcbiAgfVxuXG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImh0bWxcIixcbiAgbmFtZXM6IFtcIlxcXFxodG1sQ2xhc3NcIiwgXCJcXFxcaHRtbElkXCIsIFwiXFxcXGh0bWxTdHlsZVwiLCBcIlxcXFxodG1sRGF0YVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFyZ1R5cGVzOiBbXCJyYXdcIiwgXCJvcmlnaW5hbFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lLFxuICAgICAgdG9rZW5cbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgdmFsdWUgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzFdO1xuXG4gICAgaWYgKHBhcnNlci5zZXR0aW5ncy5zdHJpY3QpIHtcbiAgICAgIHBhcnNlci5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoXCJodG1sRXh0ZW5zaW9uXCIsIFwiSFRNTCBleHRlbnNpb24gaXMgZGlzYWJsZWQgb24gc3RyaWN0IG1vZGVcIik7XG4gICAgfVxuXG4gICAgdmFyIHRydXN0Q29udGV4dDtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuXG4gICAgc3dpdGNoIChmdW5jTmFtZSkge1xuICAgICAgY2FzZSBcIlxcXFxodG1sQ2xhc3NcIjpcbiAgICAgICAgYXR0cmlidXRlcy5jbGFzcyA9IHZhbHVlO1xuICAgICAgICB0cnVzdENvbnRleHQgPSB7XG4gICAgICAgICAgY29tbWFuZDogXCJcXFxcaHRtbENsYXNzXCIsXG4gICAgICAgICAgY2xhc3M6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiXFxcXGh0bWxJZFwiOlxuICAgICAgICBhdHRyaWJ1dGVzLmlkID0gdmFsdWU7XG4gICAgICAgIHRydXN0Q29udGV4dCA9IHtcbiAgICAgICAgICBjb21tYW5kOiBcIlxcXFxodG1sSWRcIixcbiAgICAgICAgICBpZDogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJcXFxcaHRtbFN0eWxlXCI6XG4gICAgICAgIGF0dHJpYnV0ZXMuc3R5bGUgPSB2YWx1ZTtcbiAgICAgICAgdHJ1c3RDb250ZXh0ID0ge1xuICAgICAgICAgIGNvbW1hbmQ6IFwiXFxcXGh0bWxTdHlsZVwiLFxuICAgICAgICAgIHN0eWxlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlxcXFxodG1sRGF0YVwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB2YWx1ZS5zcGxpdChcIixcIik7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHZhciBmaXJzdEVxdWFscyA9IGl0ZW0uaW5kZXhPZihcIj1cIik7XG5cbiAgICAgICAgICAgIGlmIChmaXJzdEVxdWFscyA8IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcaHRtbERhdGEga2V5L3ZhbHVlICdcIiArIGl0ZW0gKyBcIidcIiArIFwiIG1pc3NpbmcgZXF1YWxzIHNpZ25cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBrZXkgPSBpdGVtLnNsaWNlKDAsIGZpcnN0RXF1YWxzKTtcblxuICAgICAgICAgICAgdmFyIF92YWx1ZSA9IGl0ZW0uc2xpY2UoZmlyc3RFcXVhbHMgKyAxKTtcblxuICAgICAgICAgICAgYXR0cmlidXRlc1tcImRhdGEtXCIgKyBrZXkudHJpbSgpXSA9IF92YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cnVzdENvbnRleHQgPSB7XG4gICAgICAgICAgICBjb21tYW5kOiBcIlxcXFxodG1sRGF0YVwiLFxuICAgICAgICAgICAgYXR0cmlidXRlc1xuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGh0bWwgY29tbWFuZFwiKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcnNlci5zZXR0aW5ncy5pc1RydXN0ZWQodHJ1c3RDb250ZXh0KSkge1xuICAgICAgcmV0dXJuIHBhcnNlci5mb3JtYXRVbnN1cHBvcnRlZENtZChmdW5jTmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaHRtbFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uJDEoZ3JvdXAuYm9keSwgb3B0aW9ucywgZmFsc2UpO1xuICAgIHZhciBjbGFzc2VzID0gW1wiZW5jbG9zaW5nXCJdO1xuXG4gICAgaWYgKGdyb3VwLmF0dHJpYnV0ZXMuY2xhc3MpIHtcbiAgICAgIGNsYXNzZXMucHVzaCguLi5ncm91cC5hdHRyaWJ1dGVzLmNsYXNzLnRyaW0oKS5zcGxpdCgvXFxzKy8pKTtcbiAgICB9XG5cbiAgICB2YXIgc3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKGNsYXNzZXMsIGVsZW1lbnRzLCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIGF0dHIgaW4gZ3JvdXAuYXR0cmlidXRlcykge1xuICAgICAgaWYgKGF0dHIgIT09IFwiY2xhc3NcIiAmJiBncm91cC5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGF0dHIsIGdyb3VwLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzcGFuO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIG9wdGlvbnMpO1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImh0bWxtYXRobWxcIixcbiAgbmFtZXM6IFtcIlxcXFxodG1sQG1hdGhtbFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MpID0+IHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaHRtbG1hdGhtbFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBodG1sOiBvcmRhcmd1bWVudChhcmdzWzBdKSxcbiAgICAgIG1hdGhtbDogb3JkYXJndW1lbnQoYXJnc1sxXSlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uJDEoZ3JvdXAuaHRtbCwgb3B0aW9ucywgZmFsc2UpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoZWxlbWVudHMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLm1hdGhtbCwgb3B0aW9ucyk7XG4gIH1cbn0pO1xuXG52YXIgc2l6ZURhdGEgPSBmdW5jdGlvbiBzaXplRGF0YShzdHIpIHtcbiAgaWYgKC9eWy0rXT8gKihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKSQvLnRlc3Qoc3RyKSkge1xuICAgIC8vIHN0ciBpcyBhIG51bWJlciB3aXRoIG5vIHVuaXQgc3BlY2lmaWVkLlxuICAgIC8vIGRlZmF1bHQgdW5pdCBpcyBicCwgcGVyIGdyYXBoaXggcGFja2FnZS5cbiAgICByZXR1cm4ge1xuICAgICAgbnVtYmVyOiArc3RyLFxuICAgICAgdW5pdDogXCJicFwiXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWF0Y2ggPSAvKFstK10/KSAqKFxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykgKihbYS16XXsyfSkvLmV4ZWMoc3RyKTtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBzaXplOiAnXCIgKyBzdHIgKyBcIicgaW4gXFxcXGluY2x1ZGVncmFwaGljc1wiKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIG51bWJlcjogKyhtYXRjaFsxXSArIG1hdGNoWzJdKSxcbiAgICAgIC8vIHNpZ24gKyBtYWduaXR1ZGUsIGNhc3QgdG8gbnVtYmVyXG4gICAgICB1bml0OiBtYXRjaFszXVxuICAgIH07XG5cbiAgICBpZiAoIXZhbGlkVW5pdChkYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIHVuaXQ6ICdcIiArIGRhdGEudW5pdCArIFwiJyBpbiBcXFxcaW5jbHVkZWdyYXBoaWNzLlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImluY2x1ZGVncmFwaGljc1wiLFxuICBuYW1lczogW1wiXFxcXGluY2x1ZGVncmFwaGljc1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wicmF3XCIsIFwidXJsXCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IGZhbHNlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzLCBvcHRBcmdzKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIHZhciB3aWR0aCA9IHtcbiAgICAgIG51bWJlcjogMCxcbiAgICAgIHVuaXQ6IFwiZW1cIlxuICAgIH07XG4gICAgdmFyIGhlaWdodCA9IHtcbiAgICAgIG51bWJlcjogMC45LFxuICAgICAgdW5pdDogXCJlbVwiXG4gICAgfTsgLy8gc29ydGEgY2hhcmFjdGVyIHNpemVkLlxuXG4gICAgdmFyIHRvdGFsaGVpZ2h0ID0ge1xuICAgICAgbnVtYmVyOiAwLFxuICAgICAgdW5pdDogXCJlbVwiXG4gICAgfTtcbiAgICB2YXIgYWx0ID0gXCJcIjtcblxuICAgIGlmIChvcHRBcmdzWzBdKSB7XG4gICAgICB2YXIgYXR0cmlidXRlU3RyID0gYXNzZXJ0Tm9kZVR5cGUob3B0QXJnc1swXSwgXCJyYXdcIikuc3RyaW5nOyAvLyBQYXJzZXIuanMgZG9lcyBub3QgcGFyc2Uga2V5L3ZhbHVlIHBhaXJzLiBXZSBnZXQgYSBzdHJpbmcuXG5cbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gYXR0cmlidXRlU3RyLnNwbGl0KFwiLFwiKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXlWYWwgPSBhdHRyaWJ1dGVzW2ldLnNwbGl0KFwiPVwiKTtcblxuICAgICAgICBpZiAoa2V5VmFsLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHZhciBzdHIgPSBrZXlWYWxbMV0udHJpbSgpO1xuXG4gICAgICAgICAgc3dpdGNoIChrZXlWYWxbMF0udHJpbSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiYWx0XCI6XG4gICAgICAgICAgICAgIGFsdCA9IHN0cjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJ3aWR0aFwiOlxuICAgICAgICAgICAgICB3aWR0aCA9IHNpemVEYXRhKHN0cik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiaGVpZ2h0XCI6XG4gICAgICAgICAgICAgIGhlaWdodCA9IHNpemVEYXRhKHN0cik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwidG90YWxoZWlnaHRcIjpcbiAgICAgICAgICAgICAgdG90YWxoZWlnaHQgPSBzaXplRGF0YShzdHIpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIGtleTogJ1wiICsga2V5VmFsWzBdICsgXCInIGluIFxcXFxpbmNsdWRlZ3JhcGhpY3MuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzcmMgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInVybFwiKS51cmw7XG5cbiAgICBpZiAoYWx0ID09PSBcIlwiKSB7XG4gICAgICAvLyBObyBhbHQgZ2l2ZW4uIFVzZSB0aGUgZmlsZSBuYW1lLiBTdHJpcCBhd2F5IHRoZSBwYXRoLlxuICAgICAgYWx0ID0gc3JjO1xuICAgICAgYWx0ID0gYWx0LnJlcGxhY2UoL14uKltcXFxcL10vLCAnJyk7XG4gICAgICBhbHQgPSBhbHQuc3Vic3RyaW5nKDAsIGFsdC5sYXN0SW5kZXhPZignLicpKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcnNlci5zZXR0aW5ncy5pc1RydXN0ZWQoe1xuICAgICAgY29tbWFuZDogXCJcXFxcaW5jbHVkZWdyYXBoaWNzXCIsXG4gICAgICB1cmw6IHNyY1xuICAgIH0pKSB7XG4gICAgICByZXR1cm4gcGFyc2VyLmZvcm1hdFVuc3VwcG9ydGVkQ21kKFwiXFxcXGluY2x1ZGVncmFwaGljc1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbmNsdWRlZ3JhcGhpY3NcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYWx0OiBhbHQsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHRvdGFsaGVpZ2h0OiB0b3RhbGhlaWdodCxcbiAgICAgIHNyYzogc3JjXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBoZWlnaHQgPSBjYWxjdWxhdGVTaXplKGdyb3VwLmhlaWdodCwgb3B0aW9ucyk7XG4gICAgdmFyIGRlcHRoID0gMDtcblxuICAgIGlmIChncm91cC50b3RhbGhlaWdodC5udW1iZXIgPiAwKSB7XG4gICAgICBkZXB0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAudG90YWxoZWlnaHQsIG9wdGlvbnMpIC0gaGVpZ2h0O1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IDA7XG5cbiAgICBpZiAoZ3JvdXAud2lkdGgubnVtYmVyID4gMCkge1xuICAgICAgd2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLndpZHRoLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSB7XG4gICAgICBoZWlnaHQ6IG1ha2VFbShoZWlnaHQgKyBkZXB0aClcbiAgICB9O1xuXG4gICAgaWYgKHdpZHRoID4gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSBtYWtlRW0od2lkdGgpO1xuICAgIH1cblxuICAgIGlmIChkZXB0aCA+IDApIHtcbiAgICAgIHN0eWxlLnZlcnRpY2FsQWxpZ24gPSBtYWtlRW0oLWRlcHRoKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IG5ldyBJbWcoZ3JvdXAuc3JjLCBncm91cC5hbHQsIHN0eWxlKTtcbiAgICBub2RlLmhlaWdodCA9IGhlaWdodDtcbiAgICBub2RlLmRlcHRoID0gZGVwdGg7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtZ2x5cGhcIiwgW10pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiYWx0XCIsIGdyb3VwLmFsdCk7XG4gICAgdmFyIGhlaWdodCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuaGVpZ2h0LCBvcHRpb25zKTtcbiAgICB2YXIgZGVwdGggPSAwO1xuXG4gICAgaWYgKGdyb3VwLnRvdGFsaGVpZ2h0Lm51bWJlciA+IDApIHtcbiAgICAgIGRlcHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC50b3RhbGhlaWdodCwgb3B0aW9ucykgLSBoZWlnaHQ7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInZhbGlnblwiLCBtYWtlRW0oLWRlcHRoKSk7XG4gICAgfVxuXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgbWFrZUVtKGhlaWdodCArIGRlcHRoKSk7XG5cbiAgICBpZiAoZ3JvdXAud2lkdGgubnVtYmVyID4gMCkge1xuICAgICAgdmFyIHdpZHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC53aWR0aCwgb3B0aW9ucyk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIG1ha2VFbSh3aWR0aCkpO1xuICAgIH1cblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic3JjXCIsIGdyb3VwLnNyYyk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG4vLyBIb3Jpem9udGFsIHNwYWNpbmcgY29tbWFuZHNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImtlcm5cIixcbiAgbmFtZXM6IFtcIlxcXFxrZXJuXCIsIFwiXFxcXG1rZXJuXCIsIFwiXFxcXGhza2lwXCIsIFwiXFxcXG1za2lwXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInNpemVcIl0sXG4gICAgcHJpbWl0aXZlOiB0cnVlLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgc2l6ZSA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwic2l6ZVwiKTtcblxuICAgIGlmIChwYXJzZXIuc2V0dGluZ3Muc3RyaWN0KSB7XG4gICAgICB2YXIgbWF0aEZ1bmN0aW9uID0gZnVuY05hbWVbMV0gPT09ICdtJzsgLy8gXFxta2VybiwgXFxtc2tpcFxuXG4gICAgICB2YXIgbXVVbml0ID0gc2l6ZS52YWx1ZS51bml0ID09PSAnbXUnO1xuXG4gICAgICBpZiAobWF0aEZ1bmN0aW9uKSB7XG4gICAgICAgIGlmICghbXVVbml0KSB7XG4gICAgICAgICAgcGFyc2VyLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcIm1hdGhWc1RleHRVbml0c1wiLCBcIkxhVGVYJ3MgXCIgKyBmdW5jTmFtZSArIFwiIHN1cHBvcnRzIG9ubHkgbXUgdW5pdHMsIFwiICsgKFwibm90IFwiICsgc2l6ZS52YWx1ZS51bml0ICsgXCIgdW5pdHNcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlci5tb2RlICE9PSBcIm1hdGhcIikge1xuICAgICAgICAgIHBhcnNlci5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoXCJtYXRoVnNUZXh0VW5pdHNcIiwgXCJMYVRlWCdzIFwiICsgZnVuY05hbWUgKyBcIiB3b3JrcyBvbmx5IGluIG1hdGggbW9kZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gIW1hdGhGdW5jdGlvblxuICAgICAgICBpZiAobXVVbml0KSB7XG4gICAgICAgICAgcGFyc2VyLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcIm1hdGhWc1RleHRVbml0c1wiLCBcIkxhVGVYJ3MgXCIgKyBmdW5jTmFtZSArIFwiIGRvZXNuJ3Qgc3VwcG9ydCBtdSB1bml0c1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZGltZW5zaW9uOiBzaXplLnZhbHVlXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlR2x1ZShncm91cC5kaW1lbnNpb24sIG9wdGlvbnMpO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGltZW5zaW9uID0gY2FsY3VsYXRlU2l6ZShncm91cC5kaW1lbnNpb24sIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5TcGFjZU5vZGUoZGltZW5zaW9uKTtcbiAgfVxuXG59KTtcblxuLy8gSG9yaXpvbnRhbCBvdmVybGFwIGZ1bmN0aW9uc1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImxhcFwiLFxuICBuYW1lczogW1wiXFxcXG1hdGhsbGFwXCIsIFwiXFxcXG1hdGhybGFwXCIsIFwiXFxcXG1hdGhjbGFwXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4ge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmO1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsYXBcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYWxpZ25tZW50OiBmdW5jTmFtZS5zbGljZSg1KSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgLy8gbWF0aGxsYXAsIG1hdGhybGFwLCBtYXRoY2xhcFxuICAgIHZhciBpbm5lcjtcblxuICAgIGlmIChncm91cC5hbGlnbm1lbnQgPT09IFwiY2xhcFwiKSB7XG4gICAgICAvLyByZWY6IGh0dHBzOi8vd3d3Lm1hdGgubHN1LmVkdS9+YXBlcmxpcy9wdWJsaWNhdGlvbnMvbWF0aGNsYXAvXG4gICAgICBpbm5lciA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtdLCBbYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG9wdGlvbnMpXSk7IC8vIHdyYXAsIHNpbmNlIENTUyB3aWxsIGNlbnRlciBhIC5jbGFwID4gLmlubmVyID4gc3BhblxuXG4gICAgICBpbm5lciA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImlubmVyXCJdLCBbaW5uZXJdLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5uZXIgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJpbm5lclwiXSwgW2J1aWxkR3JvdXAkMShncm91cC5ib2R5LCBvcHRpb25zKV0pO1xuICAgIH1cblxuICAgIHZhciBmaXggPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJmaXhcIl0sIFtdKTtcbiAgICB2YXIgbm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtncm91cC5hbGlnbm1lbnRdLCBbaW5uZXIsIGZpeF0sIG9wdGlvbnMpOyAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIGNvcnJlY3RseSBzZXQgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgdGhlXG4gICAgLy8gdHdvIGl0ZW1zIGludm9sdmVkIGluIHRoZSBsYXAuXG4gICAgLy8gTmV4dCwgdXNlIGEgc3RydXQgdG8gc2V0IHRoZSBoZWlnaHQgb2YgdGhlIEhUTUwgYm91bmRpbmcgYm94LlxuICAgIC8vIE90aGVyd2lzZSwgYSB0YWxsIGFyZ3VtZW50IG1heSBiZSBtaXNwbGFjZWQuXG4gICAgLy8gVGhpcyBjb2RlIHJlc29sdmVkIGlzc3VlICMxMTUzXG5cbiAgICB2YXIgc3RydXQgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJzdHJ1dFwiXSk7XG4gICAgc3RydXQuc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKG5vZGUuaGVpZ2h0ICsgbm9kZS5kZXB0aCk7XG5cbiAgICBpZiAobm9kZS5kZXB0aCkge1xuICAgICAgc3RydXQuc3R5bGUudmVydGljYWxBbGlnbiA9IG1ha2VFbSgtbm9kZS5kZXB0aCk7XG4gICAgfVxuXG4gICAgbm9kZS5jaGlsZHJlbi51bnNoaWZ0KHN0cnV0KTsgLy8gTmV4dCwgcHJldmVudCB2ZXJ0aWNhbCBtaXNwbGFjZW1lbnQgd2hlbiBuZXh0IHRvIHNvbWV0aGluZyB0YWxsLlxuICAgIC8vIFRoaXMgY29kZSByZXNvbHZlcyBpc3N1ZSAjMTIzNFxuXG4gICAgbm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcInRoaW5ib3hcIl0sIFtub2RlXSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJ2Ym94XCJdLCBbbm9kZV0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICAvLyBtYXRobGxhcCwgbWF0aHJsYXAsIG1hdGhjbGFwXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucyldKTtcblxuICAgIGlmIChncm91cC5hbGlnbm1lbnQgIT09IFwicmxhcFwiKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gZ3JvdXAuYWxpZ25tZW50ID09PSBcImxsYXBcIiA/IFwiLTFcIiA6IFwiLTAuNVwiO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgb2Zmc2V0ICsgXCJ3aWR0aFwiKTtcbiAgICB9XG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMHB4XCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInN0eWxpbmdcIixcbiAgbmFtZXM6IFtcIlxcXFwoXCIsIFwiJFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluTWF0aDogZmFsc2VcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgZnVuY05hbWUsXG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgb3V0ZXJNb2RlID0gcGFyc2VyLm1vZGU7XG4gICAgcGFyc2VyLnN3aXRjaE1vZGUoXCJtYXRoXCIpO1xuICAgIHZhciBjbG9zZSA9IGZ1bmNOYW1lID09PSBcIlxcXFwoXCIgPyBcIlxcXFwpXCIgOiBcIiRcIjtcbiAgICB2YXIgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIGNsb3NlKTtcbiAgICBwYXJzZXIuZXhwZWN0KGNsb3NlKTtcbiAgICBwYXJzZXIuc3dpdGNoTW9kZShvdXRlck1vZGUpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgc3R5bGU6IFwidGV4dFwiLFxuICAgICAgYm9keVxuICAgIH07XG4gIH1cblxufSk7IC8vIENoZWNrIGZvciBleHRyYSBjbG9zaW5nIG1hdGggZGVsaW1pdGVyc1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidGV4dFwiLFxuICAvLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoaXMgaXMuXG4gIG5hbWVzOiBbXCJcXFxcKVwiLCBcIlxcXFxdXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5NYXRoOiBmYWxzZVxuICB9LFxuXG4gIGhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiTWlzbWF0Y2hlZCBcIiArIGNvbnRleHQuZnVuY05hbWUpO1xuICB9XG5cbn0pO1xuXG52YXIgY2hvb3NlTWF0aFN0eWxlID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIHN3aXRjaCAob3B0aW9ucy5zdHlsZS5zaXplKSB7XG4gICAgY2FzZSBTdHlsZSQxLkRJU1BMQVkuc2l6ZTpcbiAgICAgIHJldHVybiBncm91cC5kaXNwbGF5O1xuXG4gICAgY2FzZSBTdHlsZSQxLlRFWFQuc2l6ZTpcbiAgICAgIHJldHVybiBncm91cC50ZXh0O1xuXG4gICAgY2FzZSBTdHlsZSQxLlNDUklQVC5zaXplOlxuICAgICAgcmV0dXJuIGdyb3VwLnNjcmlwdDtcblxuICAgIGNhc2UgU3R5bGUkMS5TQ1JJUFRTQ1JJUFQuc2l6ZTpcbiAgICAgIHJldHVybiBncm91cC5zY3JpcHRzY3JpcHQ7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGdyb3VwLnRleHQ7XG4gIH1cbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtYXRoY2hvaWNlXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWF0aGNob2ljZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiA0LFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4ge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtYXRoY2hvaWNlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGRpc3BsYXk6IG9yZGFyZ3VtZW50KGFyZ3NbMF0pLFxuICAgICAgdGV4dDogb3JkYXJndW1lbnQoYXJnc1sxXSksXG4gICAgICBzY3JpcHQ6IG9yZGFyZ3VtZW50KGFyZ3NbMl0pLFxuICAgICAgc2NyaXB0c2NyaXB0OiBvcmRhcmd1bWVudChhcmdzWzNdKVxuICAgIH07XG4gIH0sXG4gIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgYm9keSA9IGNob29zZU1hdGhTdHlsZShncm91cCwgb3B0aW9ucyk7XG4gICAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uJDEoYm9keSwgb3B0aW9ucywgZmFsc2UpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoZWxlbWVudHMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgYm9keSA9IGNob29zZU1hdGhTdHlsZShncm91cCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGJ1aWxkRXhwcmVzc2lvblJvdyhib2R5LCBvcHRpb25zKTtcbiAgfVxufSk7XG5cbnZhciBhc3NlbWJsZVN1cFN1YiA9IChiYXNlLCBzdXBHcm91cCwgc3ViR3JvdXAsIG9wdGlvbnMsIHN0eWxlLCBzbGFudCwgYmFzZVNoaWZ0KSA9PiB7XG4gIGJhc2UgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXSwgW2Jhc2VdKTtcbiAgdmFyIHN1YklzU2luZ2xlQ2hhcmFjdGVyID0gc3ViR3JvdXAgJiYgdXRpbHMuaXNDaGFyYWN0ZXJCb3goc3ViR3JvdXApO1xuICB2YXIgc3ViO1xuICB2YXIgc3VwOyAvLyBXZSBtYW51YWxseSBoYXZlIHRvIGhhbmRsZSB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzLiBUaGlzLFxuICAvLyBhc2lkZSBmcm9tIHRoZSBrZXJuIGNhbGN1bGF0aW9ucywgaXMgY29waWVkIGZyb20gc3Vwc3ViLlxuXG4gIGlmIChzdXBHcm91cCkge1xuICAgIHZhciBlbGVtID0gYnVpbGRHcm91cCQxKHN1cEdyb3VwLCBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlLnN1cCgpKSwgb3B0aW9ucyk7XG4gICAgc3VwID0ge1xuICAgICAgZWxlbSxcbiAgICAgIGtlcm46IE1hdGgubWF4KG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmcxLCBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nMyAtIGVsZW0uZGVwdGgpXG4gICAgfTtcbiAgfVxuXG4gIGlmIChzdWJHcm91cCkge1xuICAgIHZhciBfZWxlbSA9IGJ1aWxkR3JvdXAkMShzdWJHcm91cCwgb3B0aW9ucy5oYXZpbmdTdHlsZShzdHlsZS5zdWIoKSksIG9wdGlvbnMpO1xuXG4gICAgc3ViID0ge1xuICAgICAgZWxlbTogX2VsZW0sXG4gICAgICBrZXJuOiBNYXRoLm1heChvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nMiwgb3B0aW9ucy5mb250TWV0cmljcygpLmJpZ09wU3BhY2luZzQgLSBfZWxlbS5oZWlnaHQpXG4gICAgfTtcbiAgfSAvLyBCdWlsZCB0aGUgZmluYWwgZ3JvdXAgYXMgYSB2bGlzdCBvZiB0aGUgcG9zc2libGUgc3Vic2NyaXB0LCBiYXNlLFxuICAvLyBhbmQgcG9zc2libGUgc3VwZXJzY3JpcHQuXG5cblxuICB2YXIgZmluYWxHcm91cDtcblxuICBpZiAoc3VwICYmIHN1Yikge1xuICAgIHZhciBib3R0b20gPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nNSArIHN1Yi5lbGVtLmhlaWdodCArIHN1Yi5lbGVtLmRlcHRoICsgc3ViLmtlcm4gKyBiYXNlLmRlcHRoICsgYmFzZVNoaWZ0O1xuICAgIGZpbmFsR3JvdXAgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImJvdHRvbVwiLFxuICAgICAgcG9zaXRpb25EYXRhOiBib3R0b20sXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmc1XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBzdWIuZWxlbSxcbiAgICAgICAgbWFyZ2luTGVmdDogbWFrZUVtKC1zbGFudClcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IHN1Yi5rZXJuXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBiYXNlXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBzdXAua2VyblxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogc3VwLmVsZW0sXG4gICAgICAgIG1hcmdpbkxlZnQ6IG1ha2VFbShzbGFudClcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmc1XG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKHN1Yikge1xuICAgIHZhciB0b3AgPSBiYXNlLmhlaWdodCAtIGJhc2VTaGlmdDsgLy8gU2hpZnQgdGhlIGxpbWl0cyBieSB0aGUgc2xhbnQgb2YgdGhlIHN5bWJvbC4gTm90ZVxuICAgIC8vIHRoYXQgd2UgYXJlIHN1cHBvc2VkIHRvIHNoaWZ0IHRoZSBsaW1pdHMgYnkgMS8yIG9mIHRoZSBzbGFudCxcbiAgICAvLyBidXQgc2luY2Ugd2UgYXJlIGNlbnRlcmluZyB0aGUgbGltaXRzIGFkZGluZyBhIGZ1bGwgc2xhbnQgb2ZcbiAgICAvLyBtYXJnaW4gd2lsbCBzaGlmdCBieSAxLzIgdGhhdC5cblxuICAgIGZpbmFsR3JvdXAgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcInRvcFwiLFxuICAgICAgcG9zaXRpb25EYXRhOiB0b3AsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmc1XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBzdWIuZWxlbSxcbiAgICAgICAgbWFyZ2luTGVmdDogbWFrZUVtKC1zbGFudClcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IHN1Yi5rZXJuXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBiYXNlXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKHN1cCkge1xuICAgIHZhciBfYm90dG9tID0gYmFzZS5kZXB0aCArIGJhc2VTaGlmdDtcblxuICAgIGZpbmFsR3JvdXAgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImJvdHRvbVwiLFxuICAgICAgcG9zaXRpb25EYXRhOiBfYm90dG9tLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBiYXNlXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBzdXAua2VyblxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogc3VwLmVsZW0sXG4gICAgICAgIG1hcmdpbkxlZnQ6IG1ha2VFbShzbGFudClcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICAgIHNpemU6IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmc1XG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgY2FzZSBwcm9iYWJseSBzaG91bGRuJ3Qgb2NjdXIgKHRoaXMgd291bGQgbWVhbiB0aGVcbiAgICAvLyBzdXBzdWIgd2FzIHNlbmRpbmcgdXMgYSBncm91cCB3aXRoIG5vIHN1cGVyc2NyaXB0IG9yXG4gICAgLy8gc3Vic2NyaXB0KSBidXQgYmUgc2FmZS5cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIHZhciBwYXJ0cyA9IFtmaW5hbEdyb3VwXTtcblxuICBpZiAoc3ViICYmIHNsYW50ICE9PSAwICYmICFzdWJJc1NpbmdsZUNoYXJhY3Rlcikge1xuICAgIC8vIEEgbmVnYXRpdmUgbWFyZ2luLWxlZnQgd2FzIGFwcGxpZWQgdG8gdGhlIGxvd2VyIGxpbWl0LlxuICAgIC8vIEF2b2lkIGFuIG92ZXJsYXAgYnkgcGxhY2luZyBhIHNwYWNlciBvbiB0aGUgbGVmdCBvbiB0aGUgZ3JvdXAuXG4gICAgdmFyIHNwYWNlciA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1zcGFjZVwiXSwgW10sIG9wdGlvbnMpO1xuICAgIHNwYWNlci5zdHlsZS5tYXJnaW5SaWdodCA9IG1ha2VFbShzbGFudCk7XG4gICAgcGFydHMudW5zaGlmdChzcGFjZXIpO1xuICB9XG5cbiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcFwiLCBcIm9wLWxpbWl0c1wiXSwgcGFydHMsIG9wdGlvbnMpO1xufTtcblxuLy8gTGltaXRzLCBzeW1ib2xzXG4vLyBNb3N0IG9wZXJhdG9ycyBoYXZlIGEgbGFyZ2Ugc3VjY2Vzc29yIHN5bWJvbCwgYnV0IHRoZXNlIGRvbid0LlxudmFyIG5vU3VjY2Vzc29yID0gW1wiXFxcXHNtYWxsaW50XCJdOyAvLyBOT1RFOiBVbmxpa2UgbW9zdCBgaHRtbEJ1aWxkZXJgcywgdGhpcyBvbmUgaGFuZGxlcyBub3Qgb25seSBcIm9wXCIsIGJ1dCBhbHNvXG4vLyBcInN1cHN1YlwiIHNpbmNlIHNvbWUgb2YgdGhlbSAobGlrZSBcXGludCkgY2FuIGFmZmVjdCBzdXBlci9zdWJzY3JpcHRpbmcuXG5cbnZhciBodG1sQnVpbGRlciQyID0gKGdycCwgb3B0aW9ucykgPT4ge1xuICAvLyBPcGVyYXRvcnMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgcGcuIDQ0My00NDQsIHJ1bGUgMTMoYSkuXG4gIHZhciBzdXBHcm91cDtcbiAgdmFyIHN1Ykdyb3VwO1xuICB2YXIgaGFzTGltaXRzID0gZmFsc2U7XG4gIHZhciBncm91cDtcblxuICBpZiAoZ3JwLnR5cGUgPT09IFwic3Vwc3ViXCIpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGxpbWl0cywgc3Vwc3ViIHdpbGwgcGFzcyB1cyBpdHMgZ3JvdXAgdG8gaGFuZGxlLiBQdWxsXG4gICAgLy8gb3V0IHRoZSBzdXBlcnNjcmlwdCBhbmQgc3Vic2NyaXB0IGFuZCBzZXQgdGhlIGdyb3VwIHRvIHRoZSBvcCBpblxuICAgIC8vIGl0cyBiYXNlLlxuICAgIHN1cEdyb3VwID0gZ3JwLnN1cDtcbiAgICBzdWJHcm91cCA9IGdycC5zdWI7XG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShncnAuYmFzZSwgXCJvcFwiKTtcbiAgICBoYXNMaW1pdHMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoZ3JwLCBcIm9wXCIpO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgdmFyIGxhcmdlID0gZmFsc2U7XG5cbiAgaWYgKHN0eWxlLnNpemUgPT09IFN0eWxlJDEuRElTUExBWS5zaXplICYmIGdyb3VwLnN5bWJvbCAmJiAhbm9TdWNjZXNzb3IuaW5jbHVkZXMoZ3JvdXAubmFtZSkpIHtcbiAgICAvLyBNb3N0IHN5bWJvbCBvcGVyYXRvcnMgZ2V0IGxhcmdlciBpbiBkaXNwbGF5c3R5bGUgKHJ1bGUgMTMpXG4gICAgbGFyZ2UgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGJhc2U7XG5cbiAgaWYgKGdyb3VwLnN5bWJvbCkge1xuICAgIC8vIElmIHRoaXMgaXMgYSBzeW1ib2wsIGNyZWF0ZSB0aGUgc3ltYm9sLlxuICAgIHZhciBmb250TmFtZSA9IGxhcmdlID8gXCJTaXplMi1SZWd1bGFyXCIgOiBcIlNpemUxLVJlZ3VsYXJcIjtcbiAgICB2YXIgc3Rhc2ggPSBcIlwiO1xuXG4gICAgaWYgKGdyb3VwLm5hbWUgPT09IFwiXFxcXG9paW50XCIgfHwgZ3JvdXAubmFtZSA9PT0gXCJcXFxcb2lpaW50XCIpIHtcbiAgICAgIC8vIE5vIGZvbnQgZ2x5cGhzIHlldCwgc28gdXNlIGEgZ2x5cGggdy9vIHRoZSBvdmFsLlxuICAgICAgLy8gVE9ETzogV2hlbiBmb250IGdseXBocyBhcmUgYXZhaWxhYmxlLCBkZWxldGUgdGhpcyBjb2RlLlxuICAgICAgc3Rhc2ggPSBncm91cC5uYW1lLnNsaWNlKDEpO1xuICAgICAgZ3JvdXAubmFtZSA9IHN0YXNoID09PSBcIm9paW50XCIgPyBcIlxcXFxpaW50XCIgOiBcIlxcXFxpaWludFwiO1xuICAgIH1cblxuICAgIGJhc2UgPSBidWlsZENvbW1vbi5tYWtlU3ltYm9sKGdyb3VwLm5hbWUsIGZvbnROYW1lLCBcIm1hdGhcIiwgb3B0aW9ucywgW1wibW9wXCIsIFwib3Atc3ltYm9sXCIsIGxhcmdlID8gXCJsYXJnZS1vcFwiIDogXCJzbWFsbC1vcFwiXSk7XG5cbiAgICBpZiAoc3Rhc2gubGVuZ3RoID4gMCkge1xuICAgICAgLy8gV2UncmUgaW4gXFxvaWludCBvciBcXG9paWludC4gT3ZlcmxheSB0aGUgb3ZhbC5cbiAgICAgIC8vIFRPRE86IFdoZW4gZm9udCBnbHlwaHMgYXJlIGF2YWlsYWJsZSwgZGVsZXRlIHRoaXMgY29kZS5cbiAgICAgIHZhciBpdGFsaWMgPSBiYXNlLml0YWxpYztcbiAgICAgIHZhciBvdmFsID0gYnVpbGRDb21tb24uc3RhdGljU3ZnKHN0YXNoICsgXCJTaXplXCIgKyAobGFyZ2UgPyBcIjJcIiA6IFwiMVwiKSwgb3B0aW9ucyk7XG4gICAgICBiYXNlID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgICAgcG9zaXRpb25UeXBlOiBcImluZGl2aWR1YWxTaGlmdFwiLFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBiYXNlLFxuICAgICAgICAgIHNoaWZ0OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiBvdmFsLFxuICAgICAgICAgIHNoaWZ0OiBsYXJnZSA/IDAuMDggOiAwXG4gICAgICAgIH1dXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICAgIGdyb3VwLm5hbWUgPSBcIlxcXFxcIiArIHN0YXNoO1xuICAgICAgYmFzZS5jbGFzc2VzLnVuc2hpZnQoXCJtb3BcIik7IC8vICRGbG93Rml4TWVcblxuICAgICAgYmFzZS5pdGFsaWMgPSBpdGFsaWM7XG4gICAgfVxuICB9IGVsc2UgaWYgKGdyb3VwLmJvZHkpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgbGlzdCwgY29tcG9zZSB0aGF0IGxpc3QuXG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uJDEoZ3JvdXAuYm9keSwgb3B0aW9ucywgdHJ1ZSk7XG5cbiAgICBpZiAoaW5uZXIubGVuZ3RoID09PSAxICYmIGlubmVyWzBdIGluc3RhbmNlb2YgU3ltYm9sTm9kZSkge1xuICAgICAgYmFzZSA9IGlubmVyWzBdO1xuICAgICAgYmFzZS5jbGFzc2VzWzBdID0gXCJtb3BcIjsgLy8gcmVwbGFjZSBvbGQgbWNsYXNzXG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3BcIl0sIGlubmVyLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGlzIGEgdGV4dCBvcGVyYXRvci4gQnVpbGQgdGhlIHRleHQgZnJvbSB0aGVcbiAgICAvLyBvcGVyYXRvcidzIG5hbWUuXG4gICAgdmFyIG91dHB1dCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBncm91cC5uYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvdXRwdXQucHVzaChidWlsZENvbW1vbi5tYXRoc3ltKGdyb3VwLm5hbWVbaV0sIGdyb3VwLm1vZGUsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBiYXNlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9wXCJdLCBvdXRwdXQsIG9wdGlvbnMpO1xuICB9IC8vIElmIGNvbnRlbnQgb2Ygb3AgaXMgYSBzaW5nbGUgc3ltYm9sLCBzaGlmdCBpdCB2ZXJ0aWNhbGx5LlxuXG5cbiAgdmFyIGJhc2VTaGlmdCA9IDA7XG4gIHZhciBzbGFudCA9IDA7XG5cbiAgaWYgKChiYXNlIGluc3RhbmNlb2YgU3ltYm9sTm9kZSB8fCBncm91cC5uYW1lID09PSBcIlxcXFxvaWludFwiIHx8IGdyb3VwLm5hbWUgPT09IFwiXFxcXG9paWludFwiKSAmJiAhZ3JvdXAuc3VwcHJlc3NCYXNlU2hpZnQpIHtcbiAgICAvLyBXZSBzdXBwcmVzcyB0aGUgc2hpZnQgb2YgdGhlIGJhc2Ugb2YgXFxvdmVyc2V0IGFuZCBcXHVuZGVyc2V0LiBPdGhlcndpc2UsXG4gICAgLy8gc2hpZnQgdGhlIHN5bWJvbCBzbyBpdHMgY2VudGVyIGxpZXMgb24gdGhlIGF4aXMgKHJ1bGUgMTMpLiBJdFxuICAgIC8vIGFwcGVhcnMgdGhhdCBvdXIgZm9udHMgaGF2ZSB0aGUgY2VudGVycyBvZiB0aGUgc3ltYm9scyBhbHJlYWR5XG4gICAgLy8gYWxtb3N0IG9uIHRoZSBheGlzLCBzbyB0aGVzZSBudW1iZXJzIGFyZSB2ZXJ5IHNtYWxsLiBOb3RlIHdlXG4gICAgLy8gZG9uJ3QgYWN0dWFsbHkgYXBwbHkgdGhpcyBoZXJlLCBidXQgaW5zdGVhZCBpdCBpcyB1c2VkIGVpdGhlciBpblxuICAgIC8vIHRoZSB2bGlzdCBjcmVhdGlvbiBvciBzZXBhcmF0ZWx5IHdoZW4gdGhlcmUgYXJlIG5vIGxpbWl0cy5cbiAgICBiYXNlU2hpZnQgPSAoYmFzZS5oZWlnaHQgLSBiYXNlLmRlcHRoKSAvIDIgLSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDsgLy8gVGhlIHNsYW50IG9mIHRoZSBzeW1ib2wgaXMganVzdCBpdHMgaXRhbGljIGNvcnJlY3Rpb24uXG4gICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgc2xhbnQgPSBiYXNlLml0YWxpYztcbiAgfVxuXG4gIGlmIChoYXNMaW1pdHMpIHtcbiAgICByZXR1cm4gYXNzZW1ibGVTdXBTdWIoYmFzZSwgc3VwR3JvdXAsIHN1Ykdyb3VwLCBvcHRpb25zLCBzdHlsZSwgc2xhbnQsIGJhc2VTaGlmdCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJhc2VTaGlmdCkge1xuICAgICAgYmFzZS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgIGJhc2Uuc3R5bGUudG9wID0gbWFrZUVtKGJhc2VTaGlmdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbn07XG5cbnZhciBtYXRobWxCdWlsZGVyJDEgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgdmFyIG5vZGU7XG5cbiAgaWYgKGdyb3VwLnN5bWJvbCkge1xuICAgIC8vIFRoaXMgaXMgYSBzeW1ib2wuIEp1c3QgYWRkIHRoZSBzeW1ib2wuXG4gICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChncm91cC5uYW1lLCBncm91cC5tb2RlKV0pO1xuXG4gICAgaWYgKG5vU3VjY2Vzc29yLmluY2x1ZGVzKGdyb3VwLm5hbWUpKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxhcmdlb3BcIiwgXCJmYWxzZVwiKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ3JvdXAuYm9keSkge1xuICAgIC8vIFRoaXMgaXMgYW4gb3BlcmF0b3Igd2l0aCBjaGlsZHJlbi4gQWRkIHRoZW0uXG4gICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1vXCIsIGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBvcHRpb25zKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIHRleHQgb3BlcmF0b3IuIEFkZCBhbGwgb2YgdGhlIGNoYXJhY3RlcnMgZnJvbSB0aGVcbiAgICAvLyBvcGVyYXRvcidzIG5hbWUuXG4gICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1pXCIsIFtuZXcgVGV4dE5vZGUoZ3JvdXAubmFtZS5zbGljZSgxKSldKTsgLy8gQXBwZW5kIGFuIDxtbz4mQXBwbHlGdW5jdGlvbjs8L21vPi5cbiAgICAvLyByZWY6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9SRUMtTWF0aE1ML2NoYXAzXzIuaHRtbCNzZWMzLjIuNFxuXG4gICAgdmFyIG9wZXJhdG9yID0gbmV3IE1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KFwiXFx1MjA2MVwiLCBcInRleHRcIildKTtcblxuICAgIGlmIChncm91cC5wYXJlbnRJc1N1cFN1Yikge1xuICAgICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1yb3dcIiwgW25vZGUsIG9wZXJhdG9yXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBuZXdEb2N1bWVudEZyYWdtZW50KFtub2RlLCBvcGVyYXRvcl0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTtcblxudmFyIHNpbmdsZUNoYXJCaWdPcHMgPSB7XG4gIFwiXFx1MjIwRlwiOiBcIlxcXFxwcm9kXCIsXG4gIFwiXFx1MjIxMFwiOiBcIlxcXFxjb3Byb2RcIixcbiAgXCJcXHUyMjExXCI6IFwiXFxcXHN1bVwiLFxuICBcIlxcdTIyYzBcIjogXCJcXFxcYmlnd2VkZ2VcIixcbiAgXCJcXHUyMmMxXCI6IFwiXFxcXGJpZ3ZlZVwiLFxuICBcIlxcdTIyYzJcIjogXCJcXFxcYmlnY2FwXCIsXG4gIFwiXFx1MjJjM1wiOiBcIlxcXFxiaWdjdXBcIixcbiAgXCJcXHUyYTAwXCI6IFwiXFxcXGJpZ29kb3RcIixcbiAgXCJcXHUyYTAxXCI6IFwiXFxcXGJpZ29wbHVzXCIsXG4gIFwiXFx1MmEwMlwiOiBcIlxcXFxiaWdvdGltZXNcIixcbiAgXCJcXHUyYTA0XCI6IFwiXFxcXGJpZ3VwbHVzXCIsXG4gIFwiXFx1MmEwNlwiOiBcIlxcXFxiaWdzcWN1cFwiXG59O1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wXCIsXG4gIG5hbWVzOiBbXCJcXFxcY29wcm9kXCIsIFwiXFxcXGJpZ3ZlZVwiLCBcIlxcXFxiaWd3ZWRnZVwiLCBcIlxcXFxiaWd1cGx1c1wiLCBcIlxcXFxiaWdjYXBcIiwgXCJcXFxcYmlnY3VwXCIsIFwiXFxcXGludG9wXCIsIFwiXFxcXHByb2RcIiwgXCJcXFxcc3VtXCIsIFwiXFxcXGJpZ290aW1lc1wiLCBcIlxcXFxiaWdvcGx1c1wiLCBcIlxcXFxiaWdvZG90XCIsIFwiXFxcXGJpZ3NxY3VwXCIsIFwiXFxcXHNtYWxsaW50XCIsIFwiXFx1MjIwRlwiLCBcIlxcdTIyMTBcIiwgXCJcXHUyMjExXCIsIFwiXFx1MjJjMFwiLCBcIlxcdTIyYzFcIiwgXCJcXHUyMmMyXCIsIFwiXFx1MjJjM1wiLCBcIlxcdTJhMDBcIiwgXCJcXHUyYTAxXCIsIFwiXFx1MmEwMlwiLCBcIlxcdTJhMDRcIiwgXCJcXHUyYTA2XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MpID0+IHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgZk5hbWUgPSBmdW5jTmFtZTtcblxuICAgIGlmIChmTmFtZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZOYW1lID0gc2luZ2xlQ2hhckJpZ09wc1tmTmFtZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiB0cnVlLFxuICAgICAgbmFtZTogZk5hbWVcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkMixcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQxXG59KTsgLy8gTm90ZTogY2FsbGluZyBkZWZpbmVGdW5jdGlvbiB3aXRoIGEgdHlwZSB0aGF0J3MgYWxyZWFkeSBiZWVuIGRlZmluZWQgb25seVxuLy8gd29ya3MgYmVjYXVzZSB0aGUgc2FtZSBodG1sQnVpbGRlciBhbmQgbWF0aG1sQnVpbGRlciBhcmUgYmVpbmcgdXNlZC5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWF0aG9wXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmMiwgYXJncykgPT4ge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjI7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IGZhbHNlLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkMixcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQxXG59KTsgLy8gVGhlcmUgYXJlIDIgZmxhZ3MgZm9yIG9wZXJhdG9yczsgd2hldGhlciB0aGV5IHByb2R1Y2UgbGltaXRzIGluXG4vLyBkaXNwbGF5c3R5bGUsIGFuZCB3aGV0aGVyIHRoZXkgYXJlIHN5bWJvbHMgYW5kIHNob3VsZCBncm93IGluXG4vLyBkaXNwbGF5c3R5bGUuIFRoZXNlIGZvdXIgZ3JvdXBzIGNvdmVyIHRoZSBmb3VyIHBvc3NpYmxlIGNob2ljZXMuXG5cbnZhciBzaW5nbGVDaGFySW50ZWdyYWxzID0ge1xuICBcIlxcdTIyMmJcIjogXCJcXFxcaW50XCIsXG4gIFwiXFx1MjIyY1wiOiBcIlxcXFxpaW50XCIsXG4gIFwiXFx1MjIyZFwiOiBcIlxcXFxpaWludFwiLFxuICBcIlxcdTIyMmVcIjogXCJcXFxcb2ludFwiLFxuICBcIlxcdTIyMmZcIjogXCJcXFxcb2lpbnRcIixcbiAgXCJcXHUyMjMwXCI6IFwiXFxcXG9paWludFwiXG59OyAvLyBObyBsaW1pdHMsIG5vdCBzeW1ib2xzXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcFwiLFxuICBuYW1lczogW1wiXFxcXGFyY3NpblwiLCBcIlxcXFxhcmNjb3NcIiwgXCJcXFxcYXJjdGFuXCIsIFwiXFxcXGFyY3RnXCIsIFwiXFxcXGFyY2N0Z1wiLCBcIlxcXFxhcmdcIiwgXCJcXFxcY2hcIiwgXCJcXFxcY29zXCIsIFwiXFxcXGNvc2VjXCIsIFwiXFxcXGNvc2hcIiwgXCJcXFxcY290XCIsIFwiXFxcXGNvdGdcIiwgXCJcXFxcY290aFwiLCBcIlxcXFxjc2NcIiwgXCJcXFxcY3RnXCIsIFwiXFxcXGN0aFwiLCBcIlxcXFxkZWdcIiwgXCJcXFxcZGltXCIsIFwiXFxcXGV4cFwiLCBcIlxcXFxob21cIiwgXCJcXFxca2VyXCIsIFwiXFxcXGxnXCIsIFwiXFxcXGxuXCIsIFwiXFxcXGxvZ1wiLCBcIlxcXFxzZWNcIiwgXCJcXFxcc2luXCIsIFwiXFxcXHNpbmhcIiwgXCJcXFxcc2hcIiwgXCJcXFxcdGFuXCIsIFwiXFxcXHRhbmhcIiwgXCJcXFxcdGdcIiwgXCJcXFxcdGhcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZjMpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyLFxuICAgICAgZnVuY05hbWVcbiAgICB9ID0gX3JlZjM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiBmYWxzZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICBuYW1lOiBmdW5jTmFtZVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDIsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkMVxufSk7IC8vIExpbWl0cywgbm90IHN5bWJvbHNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wXCIsXG4gIG5hbWVzOiBbXCJcXFxcZGV0XCIsIFwiXFxcXGdjZFwiLCBcIlxcXFxpbmZcIiwgXCJcXFxcbGltXCIsIFwiXFxcXG1heFwiLCBcIlxcXFxtaW5cIiwgXCJcXFxcUHJcIiwgXCJcXFxcc3VwXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcblxuICBoYW5kbGVyKF9yZWY0KSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY0O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxpbWl0czogdHJ1ZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICBuYW1lOiBmdW5jTmFtZVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDIsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkMVxufSk7IC8vIE5vIGxpbWl0cywgc3ltYm9sc1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BcIixcbiAgbmFtZXM6IFtcIlxcXFxpbnRcIiwgXCJcXFxcaWludFwiLCBcIlxcXFxpaWludFwiLCBcIlxcXFxvaW50XCIsIFwiXFxcXG9paW50XCIsIFwiXFxcXG9paWludFwiLCBcIlxcdTIyMmJcIiwgXCJcXHUyMjJjXCIsIFwiXFx1MjIyZFwiLCBcIlxcdTIyMmVcIiwgXCJcXHUyMjJmXCIsIFwiXFx1MjIzMFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmNSkge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXIsXG4gICAgICBmdW5jTmFtZVxuICAgIH0gPSBfcmVmNTtcbiAgICB2YXIgZk5hbWUgPSBmdW5jTmFtZTtcblxuICAgIGlmIChmTmFtZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZOYW1lID0gc2luZ2xlQ2hhckludGVncmFsc1tmTmFtZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiBmYWxzZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogdHJ1ZSxcbiAgICAgIG5hbWU6IGZOYW1lXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkMixcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQxXG59KTtcblxuLy8gTk9URTogVW5saWtlIG1vc3QgYGh0bWxCdWlsZGVyYHMsIHRoaXMgb25lIGhhbmRsZXMgbm90IG9ubHlcbi8vIFwib3BlcmF0b3JuYW1lXCIsIGJ1dCBhbHNvICBcInN1cHN1YlwiIHNpbmNlIFxcb3BlcmF0b3JuYW1lKiBjYW5cbi8vIGFmZmVjdCBzdXBlci9zdWJzY3JpcHRpbmcuXG52YXIgaHRtbEJ1aWxkZXIkMSA9IChncnAsIG9wdGlvbnMpID0+IHtcbiAgLy8gT3BlcmF0b3JzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnLiA0NDMtNDQ0LCBydWxlIDEzKGEpLlxuICB2YXIgc3VwR3JvdXA7XG4gIHZhciBzdWJHcm91cDtcbiAgdmFyIGhhc0xpbWl0cyA9IGZhbHNlO1xuICB2YXIgZ3JvdXA7XG5cbiAgaWYgKGdycC50eXBlID09PSBcInN1cHN1YlwiKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBsaW1pdHMsIHN1cHN1YiB3aWxsIHBhc3MgdXMgaXRzIGdyb3VwIHRvIGhhbmRsZS4gUHVsbFxuICAgIC8vIG91dCB0aGUgc3VwZXJzY3JpcHQgYW5kIHN1YnNjcmlwdCBhbmQgc2V0IHRoZSBncm91cCB0byB0aGUgb3AgaW5cbiAgICAvLyBpdHMgYmFzZS5cbiAgICBzdXBHcm91cCA9IGdycC5zdXA7XG4gICAgc3ViR3JvdXAgPSBncnAuc3ViO1xuICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoZ3JwLmJhc2UsIFwib3BlcmF0b3JuYW1lXCIpO1xuICAgIGhhc0xpbWl0cyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAgPSBhc3NlcnROb2RlVHlwZShncnAsIFwib3BlcmF0b3JuYW1lXCIpO1xuICB9XG5cbiAgdmFyIGJhc2U7XG5cbiAgaWYgKGdyb3VwLmJvZHkubGVuZ3RoID4gMCkge1xuICAgIHZhciBib2R5ID0gZ3JvdXAuYm9keS5tYXAoY2hpbGQgPT4ge1xuICAgICAgLy8gJEZsb3dGaXhNZTogQ2hlY2sgaWYgdGhlIG5vZGUgaGFzIGEgc3RyaW5nIGB0ZXh0YCBwcm9wZXJ0eS5cbiAgICAgIHZhciBjaGlsZFRleHQgPSBjaGlsZC50ZXh0O1xuXG4gICAgICBpZiAodHlwZW9mIGNoaWxkVGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICAgIG1vZGU6IGNoaWxkLm1vZGUsXG4gICAgICAgICAgdGV4dDogY2hpbGRUZXh0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG4gICAgfSk7IC8vIENvbnNvbGlkYXRlIGZ1bmN0aW9uIG5hbWVzIGludG8gc3ltYm9sIGNoYXJhY3RlcnMuXG5cbiAgICB2YXIgZXhwcmVzc2lvbiA9IGJ1aWxkRXhwcmVzc2lvbiQxKGJvZHksIG9wdGlvbnMud2l0aEZvbnQoXCJtYXRocm1cIiksIHRydWUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBleHByZXNzaW9uW2ldO1xuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBTeW1ib2xOb2RlKSB7XG4gICAgICAgIC8vIFBlciBhbXNvcG4gcGFja2FnZSxcbiAgICAgICAgLy8gY2hhbmdlIG1pbnVzIHRvIGh5cGhlbiBhbmQgXFxhc3QgdG8gYXN0ZXJpc2tcbiAgICAgICAgY2hpbGQudGV4dCA9IGNoaWxkLnRleHQucmVwbGFjZSgvXFx1MjIxMi8sIFwiLVwiKS5yZXBsYWNlKC9cXHUyMjE3LywgXCIqXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJhc2UgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3BcIl0sIGV4cHJlc3Npb24sIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGJhc2UgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3BcIl0sIFtdLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChoYXNMaW1pdHMpIHtcbiAgICByZXR1cm4gYXNzZW1ibGVTdXBTdWIoYmFzZSwgc3VwR3JvdXAsIHN1Ykdyb3VwLCBvcHRpb25zLCBvcHRpb25zLnN0eWxlLCAwLCAwKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxufTtcblxudmFyIG1hdGhtbEJ1aWxkZXIgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgLy8gVGhlIHN0ZXBzIHRha2VuIGhlcmUgYXJlIHNpbWlsYXIgdG8gdGhlIGh0bWwgdmVyc2lvbi5cbiAgdmFyIGV4cHJlc3Npb24gPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoRm9udChcIm1hdGhybVwiKSk7IC8vIElzIGV4cHJlc3Npb24gYSBzdHJpbmcgb3IgaGFzIGl0IHNvbWV0aGluZyBsaWtlIGEgZnJhY3Rpb24/XG5cbiAgdmFyIGlzQWxsU3RyaW5nID0gdHJ1ZTsgLy8gZGVmYXVsdFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gZXhwcmVzc2lvbltpXTtcblxuICAgIGlmIChub2RlIGluc3RhbmNlb2YgbWF0aE1MVHJlZS5TcGFjZU5vZGUpIDsgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIG1hdGhNTFRyZWUuTWF0aE5vZGUpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJtaVwiOlxuICAgICAgICBjYXNlIFwibW5cIjpcbiAgICAgICAgY2FzZSBcIm1zXCI6XG4gICAgICAgIGNhc2UgXCJtc3BhY2VcIjpcbiAgICAgICAgY2FzZSBcIm10ZXh0XCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgeWV0LlxuXG4gICAgICAgIGNhc2UgXCJtb1wiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZCBpbnN0YW5jZW9mIG1hdGhNTFRyZWUuVGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgY2hpbGQudGV4dCA9IGNoaWxkLnRleHQucmVwbGFjZSgvXFx1MjIxMi8sIFwiLVwiKS5yZXBsYWNlKC9cXHUyMjE3LywgXCIqXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXNBbGxTdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaXNBbGxTdHJpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXNBbGxTdHJpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNBbGxTdHJpbmcpIHtcbiAgICAvLyBXcml0ZSBhIHNpbmdsZSBUZXh0Tm9kZSBpbnN0ZWFkIG9mIG11bHRpcGxlIG5lc3RlZCB0YWdzLlxuICAgIHZhciB3b3JkID0gZXhwcmVzc2lvbi5tYXAobm9kZSA9PiBub2RlLnRvVGV4dCgpKS5qb2luKFwiXCIpO1xuICAgIGV4cHJlc3Npb24gPSBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUod29yZCldO1xuICB9XG5cbiAgdmFyIGlkZW50aWZpZXIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIGV4cHJlc3Npb24pO1xuICBpZGVudGlmaWVyLnNldEF0dHJpYnV0ZShcIm1hdGh2YXJpYW50XCIsIFwibm9ybWFsXCIpOyAvLyBcXHUyMDYxIGlzIHRoZSBzYW1lIGFzICZBcHBseUZ1bmN0aW9uO1xuICAvLyByZWY6IGh0dHBzOi8vd3d3Lnczc2Nob29scy5jb20vY2hhcnNldHMvcmVmX2h0bWxfZW50aXRpZXNfYS5hc3BcblxuICB2YXIgb3BlcmF0b3IgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChcIlxcdTIwNjFcIiwgXCJ0ZXh0XCIpXSk7XG5cbiAgaWYgKGdyb3VwLnBhcmVudElzU3VwU3ViKSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbaWRlbnRpZmllciwgb3BlcmF0b3JdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWF0aE1MVHJlZS5uZXdEb2N1bWVudEZyYWdtZW50KFtpZGVudGlmaWVyLCBvcGVyYXRvcl0pO1xuICB9XG59OyAvLyBcXG9wZXJhdG9ybmFtZVxuLy8gYW1zb3BuLmR0eDogXFxtYXRob3B7IzFcXGtlcm5cXHpAXFxvcGVyYXRvckBmb250IzN9XFxuZXdtY29kZXNAXG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wZXJhdG9ybmFtZVwiLFxuICBuYW1lczogW1wiXFxcXG9wZXJhdG9ybmFtZUBcIiwgXCJcXFxcb3BlcmF0b3JuYW1ld2l0aGxpbWl0c1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wZXJhdG9ybmFtZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KSxcbiAgICAgIGFsd2F5c0hhbmRsZVN1cFN1YjogZnVuY05hbWUgPT09IFwiXFxcXG9wZXJhdG9ybmFtZXdpdGhsaW1pdHNcIixcbiAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2VcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkMSxcbiAgbWF0aG1sQnVpbGRlclxufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxvcGVyYXRvcm5hbWVcIiwgXCJcXFxcQGlmc3RhclxcXFxvcGVyYXRvcm5hbWV3aXRobGltaXRzXFxcXG9wZXJhdG9ybmFtZUBcIik7XG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcIm9yZGdyb3VwXCIsXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoZ3JvdXAuc2VtaXNpbXBsZSkge1xuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChidWlsZEV4cHJlc3Npb24kMShncm91cC5ib2R5LCBvcHRpb25zLCBmYWxzZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCJdLCBidWlsZEV4cHJlc3Npb24kMShncm91cC5ib2R5LCBvcHRpb25zLCB0cnVlKSwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgb3B0aW9ucywgdHJ1ZSk7XG4gIH1cblxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvdmVybGluZVwiLFxuICBuYW1lczogW1wiXFxcXG92ZXJsaW5lXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm92ZXJsaW5lXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gT3ZlcmxpbmVzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnIDQ0MywgUnVsZSA5LlxuICAgIC8vIEJ1aWxkIHRoZSBpbm5lciBncm91cCBpbiB0aGUgY3JhbXBlZCBzdHlsZS5cbiAgICB2YXIgaW5uZXJHcm91cCA9IGJ1aWxkR3JvdXAkMShncm91cC5ib2R5LCBvcHRpb25zLmhhdmluZ0NyYW1wZWRTdHlsZSgpKTsgLy8gQ3JlYXRlIHRoZSBsaW5lIGFib3ZlIHRoZSBib2R5XG5cbiAgICB2YXIgbGluZSA9IGJ1aWxkQ29tbW9uLm1ha2VMaW5lU3BhbihcIm92ZXJsaW5lLWxpbmVcIiwgb3B0aW9ucyk7IC8vIEdlbmVyYXRlIHRoZSB2bGlzdCwgd2l0aCB0aGUgYXBwcm9wcmlhdGUga2VybnNcblxuICAgIHZhciBkZWZhdWx0UnVsZVRoaWNrbmVzcyA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWZhdWx0UnVsZVRoaWNrbmVzcztcbiAgICB2YXIgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogaW5uZXJHcm91cFxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogMyAqIGRlZmF1bHRSdWxlVGhpY2tuZXNzXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBsaW5lXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBkZWZhdWx0UnVsZVRoaWNrbmVzc1xuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibW9yZFwiLCBcIm92ZXJsaW5lXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG9wZXJhdG9yID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoXCJcXHUyMDNlXCIpXSk7XG4gICAgb3BlcmF0b3Iuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJ0cnVlXCIpO1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb3ZlclwiLCBbYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKSwgb3BlcmF0b3JdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudFwiLCBcInRydWVcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJwaGFudG9tXCIsXG4gIG5hbWVzOiBbXCJcXFxccGhhbnRvbVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MpID0+IHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInBoYW50b21cIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uJDEoZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoUGhhbnRvbSgpLCBmYWxzZSk7IC8vIFxccGhhbnRvbSBpc24ndCBzdXBwb3NlZCB0byBhZmZlY3QgdGhlIGVsZW1lbnRzIGl0IGNvbnRhaW5zLlxuICAgIC8vIFNlZSBcImNvbG9yXCIgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoZWxlbWVudHMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBoYW50b21cIiwgaW5uZXIpO1xuICB9XG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJocGhhbnRvbVwiLFxuICBuYW1lczogW1wiXFxcXGhwaGFudG9tXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZjIsIGFyZ3MpID0+IHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWYyO1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJocGhhbnRvbVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBub2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW10sIFtidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoUGhhbnRvbSgpKV0pO1xuICAgIG5vZGUuaGVpZ2h0ID0gMDtcbiAgICBub2RlLmRlcHRoID0gMDtcblxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5oZWlnaHQgPSAwO1xuICAgICAgICBub2RlLmNoaWxkcmVuW2ldLmRlcHRoID0gMDtcbiAgICAgIH1cbiAgICB9IC8vIFNlZSBzbWFzaCBmb3IgY29tbWVudCByZTogdXNlIG9mIG1ha2VWTGlzdFxuXG5cbiAgICBub2RlID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJmaXJzdEJhc2VsaW5lXCIsXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IG5vZGVcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7IC8vIEZvciBzcGFjaW5nLCBUZVggdHJlYXRzIFxcc21hc2ggYXMgYSBtYXRoIGdyb3VwIChzYW1lIHNwYWNpbmcgYXMgb3JkKS5cblxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCJdLCBbbm9kZV0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24ob3JkYXJndW1lbnQoZ3JvdXAuYm9keSksIG9wdGlvbnMpO1xuICAgIHZhciBwaGFudG9tID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGhhbnRvbVwiLCBpbm5lcik7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW3BoYW50b21dKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjBweFwiKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImRlcHRoXCIsIFwiMHB4XCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ2cGhhbnRvbVwiLFxuICBuYW1lczogW1wiXFxcXHZwaGFudG9tXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZjMsIGFyZ3MpID0+IHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWYzO1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ2cGhhbnRvbVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBpbm5lciA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcImlubmVyXCJdLCBbYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG9wdGlvbnMud2l0aFBoYW50b20oKSldKTtcbiAgICB2YXIgZml4ID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wiZml4XCJdLCBbXSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJybGFwXCJdLCBbaW5uZXIsIGZpeF0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24ob3JkYXJndW1lbnQoZ3JvdXAuYm9keSksIG9wdGlvbnMpO1xuICAgIHZhciBwaGFudG9tID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGhhbnRvbVwiLCBpbm5lcik7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW3BoYW50b21dKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMHB4XCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInJhaXNlYm94XCIsXG4gIG5hbWVzOiBbXCJcXFxccmFpc2Vib3hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiLCBcImhib3hcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgYW1vdW50ID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJzaXplXCIpLnZhbHVlO1xuICAgIHZhciBib2R5ID0gYXJnc1sxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJyYWlzZWJveFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBkeTogYW1vdW50LFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgYm9keSA9IGJ1aWxkR3JvdXAkMShncm91cC5ib2R5LCBvcHRpb25zKTtcbiAgICB2YXIgZHkgPSBjYWxjdWxhdGVTaXplKGdyb3VwLmR5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVZMaXN0KHtcbiAgICAgIHBvc2l0aW9uVHlwZTogXCJzaGlmdFwiLFxuICAgICAgcG9zaXRpb25EYXRhOiAtZHksXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJvZHlcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtidWlsZEdyb3VwKGdyb3VwLmJvZHksIG9wdGlvbnMpXSk7XG4gICAgdmFyIGR5ID0gZ3JvdXAuZHkubnVtYmVyICsgZ3JvdXAuZHkudW5pdDtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcInZvZmZzZXRcIiwgZHkpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcIlxcXFxyZWxheFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKF9yZWYpIHtcbiAgICB2YXIge1xuICAgICAgcGFyc2VyXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlXG4gICAgfTtcbiAgfVxuXG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInJ1bGVcIixcbiAgbmFtZXM6IFtcIlxcXFxydWxlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluTWF0aDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiLCBcInNpemVcIiwgXCJzaXplXCJdXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIHZhciBzaGlmdCA9IG9wdEFyZ3NbMF07XG4gICAgdmFyIHdpZHRoID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJzaXplXCIpO1xuICAgIHZhciBoZWlnaHQgPSBhc3NlcnROb2RlVHlwZShhcmdzWzFdLCBcInNpemVcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicnVsZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBzaGlmdDogc2hpZnQgJiYgYXNzZXJ0Tm9kZVR5cGUoc2hpZnQsIFwic2l6ZVwiKS52YWx1ZSxcbiAgICAgIHdpZHRoOiB3aWR0aC52YWx1ZSxcbiAgICAgIGhlaWdodDogaGVpZ2h0LnZhbHVlXG4gICAgfTtcbiAgfSxcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIE1ha2UgYW4gZW1wdHkgc3BhbiBmb3IgdGhlIHJ1bGVcbiAgICB2YXIgcnVsZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJydWxlXCJdLCBbXSwgb3B0aW9ucyk7IC8vIENhbGN1bGF0ZSB0aGUgc2hpZnQsIHdpZHRoLCBhbmQgaGVpZ2h0IG9mIHRoZSBydWxlLCBhbmQgYWNjb3VudCBmb3IgdW5pdHNcblxuICAgIHZhciB3aWR0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAud2lkdGgsIG9wdGlvbnMpO1xuICAgIHZhciBoZWlnaHQgPSBjYWxjdWxhdGVTaXplKGdyb3VwLmhlaWdodCwgb3B0aW9ucyk7XG4gICAgdmFyIHNoaWZ0ID0gZ3JvdXAuc2hpZnQgPyBjYWxjdWxhdGVTaXplKGdyb3VwLnNoaWZ0LCBvcHRpb25zKSA6IDA7IC8vIFN0eWxlIHRoZSBydWxlIHRvIHRoZSByaWdodCBzaXplXG5cbiAgICBydWxlLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSBtYWtlRW0od2lkdGgpO1xuICAgIHJ1bGUuc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBtYWtlRW0oaGVpZ2h0KTtcbiAgICBydWxlLnN0eWxlLmJvdHRvbSA9IG1ha2VFbShzaGlmdCk7IC8vIFJlY29yZCB0aGUgaGVpZ2h0IGFuZCB3aWR0aFxuXG4gICAgcnVsZS53aWR0aCA9IHdpZHRoO1xuICAgIHJ1bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgc2hpZnQ7XG4gICAgcnVsZS5kZXB0aCA9IC1zaGlmdDsgLy8gRm9udCBzaXplIGlzIHRoZSBudW1iZXIgbGFyZ2UgZW5vdWdoIHRoYXQgdGhlIGJyb3dzZXIgd2lsbFxuICAgIC8vIHJlc2VydmUgYXQgbGVhc3QgYGFic0hlaWdodGAgc3BhY2UgYWJvdmUgdGhlIGJhc2VsaW5lLlxuICAgIC8vIFRoZSAxLjEyNSBmYWN0b3Igd2FzIGVtcGlyaWNhbGx5IGRldGVybWluZWRcblxuICAgIHJ1bGUubWF4Rm9udFNpemUgPSBoZWlnaHQgKiAxLjEyNSAqIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciB3aWR0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAud2lkdGgsIG9wdGlvbnMpO1xuICAgIHZhciBoZWlnaHQgPSBjYWxjdWxhdGVTaXplKGdyb3VwLmhlaWdodCwgb3B0aW9ucyk7XG4gICAgdmFyIHNoaWZ0ID0gZ3JvdXAuc2hpZnQgPyBjYWxjdWxhdGVTaXplKGdyb3VwLnNoaWZ0LCBvcHRpb25zKSA6IDA7XG4gICAgdmFyIGNvbG9yID0gb3B0aW9ucy5jb2xvciAmJiBvcHRpb25zLmdldENvbG9yKCkgfHwgXCJibGFja1wiO1xuICAgIHZhciBydWxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgcnVsZS5zZXRBdHRyaWJ1dGUoXCJtYXRoYmFja2dyb3VuZFwiLCBjb2xvcik7XG4gICAgcnVsZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBtYWtlRW0od2lkdGgpKTtcbiAgICBydWxlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBtYWtlRW0oaGVpZ2h0KSk7XG4gICAgdmFyIHdyYXBwZXIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW3J1bGVdKTtcblxuICAgIGlmIChzaGlmdCA+PSAwKSB7XG4gICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBtYWtlRW0oc2hpZnQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgbWFrZUVtKHNoaWZ0KSk7XG4gICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcImRlcHRoXCIsIG1ha2VFbSgtc2hpZnQpKTtcbiAgICB9XG5cbiAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcInZvZmZzZXRcIiwgbWFrZUVtKHNoaWZ0KSk7XG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIHNpemluZ0dyb3VwKHZhbHVlLCBvcHRpb25zLCBiYXNlT3B0aW9ucykge1xuICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24kMSh2YWx1ZSwgb3B0aW9ucywgZmFsc2UpO1xuICB2YXIgbXVsdGlwbGllciA9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXIgLyBiYXNlT3B0aW9ucy5zaXplTXVsdGlwbGllcjsgLy8gQWRkIHNpemUtcmVzZXR0aW5nIGNsYXNzZXMgdG8gdGhlIGlubmVyIGxpc3QgYW5kIHNldCBtYXhGb250U2l6ZVxuICAvLyBtYW51YWxseS4gSGFuZGxlIG5lc3RlZCBzaXplIGNoYW5nZXMuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbm5lci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwb3MgPSBpbm5lcltpXS5jbGFzc2VzLmluZGV4T2YoXCJzaXppbmdcIik7XG5cbiAgICBpZiAocG9zIDwgMCkge1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaW5uZXJbaV0uY2xhc3Nlcywgb3B0aW9ucy5zaXppbmdDbGFzc2VzKGJhc2VPcHRpb25zKSk7XG4gICAgfSBlbHNlIGlmIChpbm5lcltpXS5jbGFzc2VzW3BvcyArIDFdID09PSBcInJlc2V0LXNpemVcIiArIG9wdGlvbnMuc2l6ZSkge1xuICAgICAgLy8gVGhpcyBpcyBhIG5lc3RlZCBzaXplIGNoYW5nZTogZS5nLiwgaW5uZXJbaV0gaXMgdGhlIFwiYlwiIGluXG4gICAgICAvLyBgXFxIdWdlIGEgXFxzbWFsbCBiYC4gT3ZlcnJpZGUgdGhlIG9sZCBzaXplICh0aGUgYHJlc2V0LWAgY2xhc3MpXG4gICAgICAvLyBidXQgbm90IHRoZSBuZXcgc2l6ZS5cbiAgICAgIGlubmVyW2ldLmNsYXNzZXNbcG9zICsgMV0gPSBcInJlc2V0LXNpemVcIiArIGJhc2VPcHRpb25zLnNpemU7XG4gICAgfVxuXG4gICAgaW5uZXJbaV0uaGVpZ2h0ICo9IG11bHRpcGxpZXI7XG4gICAgaW5uZXJbaV0uZGVwdGggKj0gbXVsdGlwbGllcjtcbiAgfVxuXG4gIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoaW5uZXIpO1xufVxudmFyIHNpemVGdW5jcyA9IFtcIlxcXFx0aW55XCIsIFwiXFxcXHNpeHB0c2l6ZVwiLCBcIlxcXFxzY3JpcHRzaXplXCIsIFwiXFxcXGZvb3Rub3Rlc2l6ZVwiLCBcIlxcXFxzbWFsbFwiLCBcIlxcXFxub3JtYWxzaXplXCIsIFwiXFxcXGxhcmdlXCIsIFwiXFxcXExhcmdlXCIsIFwiXFxcXExBUkdFXCIsIFwiXFxcXGh1Z2VcIiwgXCJcXFxcSHVnZVwiXTtcbnZhciBodG1sQnVpbGRlciA9IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAvLyBIYW5kbGUgc2l6aW5nIG9wZXJhdG9ycyBsaWtlIFxcSHVnZS4gUmVhbCBUZVggZG9lc24ndCBhY3R1YWxseSBhbGxvd1xuICAvLyB0aGVzZSBmdW5jdGlvbnMgaW5zaWRlIG9mIG1hdGggZXhwcmVzc2lvbnMsIHNvIHdlIGRvIHNvbWUgc3BlY2lhbFxuICAvLyBoYW5kbGluZy5cbiAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1NpemUoZ3JvdXAuc2l6ZSk7XG4gIHJldHVybiBzaXppbmdHcm91cChncm91cC5ib2R5LCBuZXdPcHRpb25zLCBvcHRpb25zKTtcbn07XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic2l6aW5nXCIsXG4gIG5hbWVzOiBzaXplRnVuY3MsXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIGJyZWFrT25Ub2tlblRleHQsXG4gICAgICBmdW5jTmFtZSxcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIHZhciBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgYnJlYWtPblRva2VuVGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic2l6aW5nXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCBzaXplIHRvIHVzZSBiYXNlZCBvbiB0aGUgbGlzdCBvZiBmdW5jdGlvbnMgYWJvdmVcbiAgICAgIHNpemU6IHNpemVGdW5jcy5pbmRleE9mKGZ1bmNOYW1lKSArIDEsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTaXplKGdyb3VwLnNpemUpO1xuICAgIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBuZXdPcHRpb25zKTtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXN0eWxlXCIsIGlubmVyKTsgLy8gVE9ETyhlbWlseSk6IFRoaXMgZG9lc24ndCBwcm9kdWNlIHRoZSBjb3JyZWN0IHNpemUgZm9yIG5lc3RlZCBzaXplXG4gICAgLy8gY2hhbmdlcywgYmVjYXVzZSB3ZSBkb24ndCBrZWVwIHN0YXRlIG9mIHdoYXQgc3R5bGUgd2UncmUgY3VycmVudGx5XG4gICAgLy8gaW4sIHNvIHdlIGNhbid0IHJlc2V0IHRoZSBzaXplIHRvIG5vcm1hbCBiZWZvcmUgY2hhbmdpbmcgaXQuICBOb3dcbiAgICAvLyB0aGF0IHdlJ3JlIHBhc3NpbmcgYW4gb3B0aW9ucyBwYXJhbWV0ZXIgd2Ugc2hvdWxkIGJlIGFibGUgdG8gZml4XG4gICAgLy8gdGhpcy5cblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHNpemVcIiwgbWFrZUVtKG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXIpKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbi8vIHNtYXNoLCB3aXRoIG9wdGlvbmFsIFt0Yl0sIGFzIGluIEFNU1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInNtYXNoXCIsXG4gIG5hbWVzOiBbXCJcXFxcc21hc2hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoX3JlZiwgYXJncywgb3B0QXJncykgPT4ge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgc21hc2hIZWlnaHQgPSBmYWxzZTtcbiAgICB2YXIgc21hc2hEZXB0aCA9IGZhbHNlO1xuICAgIHZhciB0YkFyZyA9IG9wdEFyZ3NbMF0gJiYgYXNzZXJ0Tm9kZVR5cGUob3B0QXJnc1swXSwgXCJvcmRncm91cFwiKTtcblxuICAgIGlmICh0YkFyZykge1xuICAgICAgLy8gT3B0aW9uYWwgW3RiXSBhcmd1bWVudCBpcyBlbmdhZ2VkLlxuICAgICAgLy8gcmVmOiBhbXNtYXRoOiBcXHJlbmV3Y29tbWFuZHtcXHNtYXNofVsxXVt0Yl17JVxuICAgICAgLy8gICAgICAgICAgICAgICBkZWZcXG1iQHR7XFxodH1cXGRlZlxcbWJAYntcXGRwfVxcZGVmXFxtYkB0YntcXGh0XFx6QFxcekBcXGRwfSVcbiAgICAgIHZhciBsZXR0ZXIgPSBcIlwiO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRiQXJnLmJvZHkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0YkFyZy5ib2R5W2ldOyAvLyAkRmxvd0ZpeE1lOiBOb3QgZXZlcnkgbm9kZSB0eXBlIGhhcyBhIGB0ZXh0YCBwcm9wZXJ0eS5cblxuICAgICAgICBsZXR0ZXIgPSBub2RlLnRleHQ7XG5cbiAgICAgICAgaWYgKGxldHRlciA9PT0gXCJ0XCIpIHtcbiAgICAgICAgICBzbWFzaEhlaWdodCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcImJcIikge1xuICAgICAgICAgIHNtYXNoRGVwdGggPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNtYXNoSGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgc21hc2hEZXB0aCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNtYXNoSGVpZ2h0ID0gdHJ1ZTtcbiAgICAgIHNtYXNoRGVwdGggPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzbWFzaFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5LFxuICAgICAgc21hc2hIZWlnaHQsXG4gICAgICBzbWFzaERlcHRoXG4gICAgfTtcbiAgfSxcbiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBub2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW10sIFtidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgb3B0aW9ucyldKTtcblxuICAgIGlmICghZ3JvdXAuc21hc2hIZWlnaHQgJiYgIWdyb3VwLnNtYXNoRGVwdGgpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGlmIChncm91cC5zbWFzaEhlaWdodCkge1xuICAgICAgbm9kZS5oZWlnaHQgPSAwOyAvLyBJbiBvcmRlciB0byBpbmZsdWVuY2UgbWFrZVZMaXN0LCB3ZSBoYXZlIHRvIHJlc2V0IHRoZSBjaGlsZHJlbi5cblxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5oZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnNtYXNoRGVwdGgpIHtcbiAgICAgIG5vZGUuZGVwdGggPSAwO1xuXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuW19pXS5kZXB0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEF0IHRoaXMgcG9pbnQsIHdlJ3ZlIHJlc2V0IHRoZSBUZVgtbGlrZSBoZWlnaHQgYW5kIGRlcHRoIHZhbHVlcy5cbiAgICAvLyBCdXQgdGhlIHNwYW4gc3RpbGwgaGFzIGFuIEhUTUwgbGluZSBoZWlnaHQuXG4gICAgLy8gbWFrZVZMaXN0IGFwcGxpZXMgXCJkaXNwbGF5OiB0YWJsZS1jZWxsXCIsIHdoaWNoIHByZXZlbnRzIHRoZSBicm93c2VyXG4gICAgLy8gZnJvbSBhY3Rpbmcgb24gdGhhdCBsaW5lIGhlaWdodC4gU28gd2UnbGwgY2FsbCBtYWtlVkxpc3Qgbm93LlxuXG5cbiAgICB2YXIgc21hc2hlZE5vZGUgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgcG9zaXRpb25UeXBlOiBcImZpcnN0QmFzZWxpbmVcIixcbiAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogbm9kZVxuICAgICAgfV1cbiAgICB9LCBvcHRpb25zKTsgLy8gRm9yIHNwYWNpbmcsIFRlWCB0cmVhdHMgXFxocGhhbnRvbSBhcyBhIG1hdGggZ3JvdXAgKHNhbWUgc3BhY2luZyBhcyBvcmQpLlxuXG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIl0sIFtzbWFzaGVkTm9kZV0sIG9wdGlvbnMpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbYnVpbGRHcm91cChncm91cC5ib2R5LCBvcHRpb25zKV0pO1xuXG4gICAgaWYgKGdyb3VwLnNtYXNoSGVpZ2h0KSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjBweFwiKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuc21hc2hEZXB0aCkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkZXB0aFwiLCBcIjBweFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJzcXJ0XCIsXG4gIG5hbWVzOiBbXCJcXFxcc3FydFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncywgb3B0QXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgaW5kZXggPSBvcHRBcmdzWzBdO1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzcXJ0XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHksXG4gICAgICBpbmRleFxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBTcXVhcmUgcm9vdHMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgcGcuIDQ0MywgUnVsZSAxMS5cbiAgICAvLyBGaXJzdCwgd2UgZG8gdGhlIHNhbWUgc3RlcHMgYXMgaW4gb3ZlcmxpbmUgdG8gYnVpbGQgdGhlIGlubmVyIGdyb3VwXG4gICAgLy8gYW5kIGxpbmVcbiAgICB2YXIgaW5uZXIgPSBidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgb3B0aW9ucy5oYXZpbmdDcmFtcGVkU3R5bGUoKSk7XG5cbiAgICBpZiAoaW5uZXIuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAvLyBSZW5kZXIgYSBzbWFsbCBzdXJkLlxuICAgICAgaW5uZXIuaGVpZ2h0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLnhIZWlnaHQ7XG4gICAgfSAvLyBTb21lIGdyb3VwcyBjYW4gcmV0dXJuIGRvY3VtZW50IGZyYWdtZW50cy4gIEhhbmRsZSB0aG9zZSBieSB3cmFwcGluZ1xuICAgIC8vIHRoZW0gaW4gYSBzcGFuLlxuXG5cbiAgICBpbm5lciA9IGJ1aWxkQ29tbW9uLndyYXBGcmFnbWVudChpbm5lciwgb3B0aW9ucyk7IC8vIENhbGN1bGF0ZSB0aGUgbWluaW11bSBzaXplIGZvciB0aGUgXFxzdXJkIGRlbGltaXRlclxuXG4gICAgdmFyIG1ldHJpY3MgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCk7XG4gICAgdmFyIHRoZXRhID0gbWV0cmljcy5kZWZhdWx0UnVsZVRoaWNrbmVzcztcbiAgICB2YXIgcGhpID0gdGhldGE7XG5cbiAgICBpZiAob3B0aW9ucy5zdHlsZS5pZCA8IFN0eWxlJDEuVEVYVC5pZCkge1xuICAgICAgcGhpID0gb3B0aW9ucy5mb250TWV0cmljcygpLnhIZWlnaHQ7XG4gICAgfSAvLyBDYWxjdWxhdGUgdGhlIGNsZWFyYW5jZSBiZXR3ZWVuIHRoZSBib2R5IGFuZCBsaW5lXG5cblxuICAgIHZhciBsaW5lQ2xlYXJhbmNlID0gdGhldGEgKyBwaGkgLyA0O1xuICAgIHZhciBtaW5EZWxpbWl0ZXJIZWlnaHQgPSBpbm5lci5oZWlnaHQgKyBpbm5lci5kZXB0aCArIGxpbmVDbGVhcmFuY2UgKyB0aGV0YTsgLy8gQ3JlYXRlIGEgc3FydCBTVkcgb2YgdGhlIHJlcXVpcmVkIG1pbmltdW0gc2l6ZVxuXG4gICAgdmFyIHtcbiAgICAgIHNwYW46IGltZyxcbiAgICAgIHJ1bGVXaWR0aCxcbiAgICAgIGFkdmFuY2VXaWR0aFxuICAgIH0gPSBkZWxpbWl0ZXIuc3FydEltYWdlKG1pbkRlbGltaXRlckhlaWdodCwgb3B0aW9ucyk7XG4gICAgdmFyIGRlbGltRGVwdGggPSBpbWcuaGVpZ2h0IC0gcnVsZVdpZHRoOyAvLyBBZGp1c3QgdGhlIGNsZWFyYW5jZSBiYXNlZCBvbiB0aGUgZGVsaW1pdGVyIHNpemVcblxuICAgIGlmIChkZWxpbURlcHRoID4gaW5uZXIuaGVpZ2h0ICsgaW5uZXIuZGVwdGggKyBsaW5lQ2xlYXJhbmNlKSB7XG4gICAgICBsaW5lQ2xlYXJhbmNlID0gKGxpbmVDbGVhcmFuY2UgKyBkZWxpbURlcHRoIC0gaW5uZXIuaGVpZ2h0IC0gaW5uZXIuZGVwdGgpIC8gMjtcbiAgICB9IC8vIFNoaWZ0IHRoZSBzcXJ0IGltYWdlXG5cblxuICAgIHZhciBpbWdTaGlmdCA9IGltZy5oZWlnaHQgLSBpbm5lci5oZWlnaHQgLSBsaW5lQ2xlYXJhbmNlIC0gcnVsZVdpZHRoO1xuICAgIGlubmVyLnN0eWxlLnBhZGRpbmdMZWZ0ID0gbWFrZUVtKGFkdmFuY2VXaWR0aCk7IC8vIE92ZXJsYXkgdGhlIGltYWdlIGFuZCB0aGUgYXJndW1lbnQuXG5cbiAgICB2YXIgYm9keSA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwiZmlyc3RCYXNlbGluZVwiLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbm5lcixcbiAgICAgICAgd3JhcHBlckNsYXNzZXM6IFtcInN2Zy1hbGlnblwiXVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogLShpbm5lci5oZWlnaHQgKyBpbWdTaGlmdClcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGltZ1xuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogcnVsZVdpZHRoXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKCFncm91cC5pbmRleCkge1xuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJzcXJ0XCJdLCBbYm9keV0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIYW5kbGUgdGhlIG9wdGlvbmFsIHJvb3QgaW5kZXhcbiAgICAgIC8vIFRoZSBpbmRleCBpcyBhbHdheXMgaW4gc2NyaXB0c2NyaXB0IHN0eWxlXG4gICAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoU3R5bGUkMS5TQ1JJUFRTQ1JJUFQpO1xuICAgICAgdmFyIHJvb3RtID0gYnVpbGRHcm91cCQxKGdyb3VwLmluZGV4LCBuZXdPcHRpb25zLCBvcHRpb25zKTsgLy8gVGhlIGFtb3VudCB0aGUgaW5kZXggaXMgc2hpZnRlZCBieS4gVGhpcyBpcyB0YWtlbiBmcm9tIHRoZSBUZVhcbiAgICAgIC8vIHNvdXJjZSwgaW4gdGhlIGRlZmluaXRpb24gb2YgYFxcckBAdGAuXG5cbiAgICAgIHZhciB0b1NoaWZ0ID0gMC42ICogKGJvZHkuaGVpZ2h0IC0gYm9keS5kZXB0aCk7IC8vIEJ1aWxkIGEgVkxpc3Qgd2l0aCB0aGUgc3VwZXJzY3JpcHQgc2hpZnRlZCB1cCBjb3JyZWN0bHlcblxuICAgICAgdmFyIHJvb3RWTGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJzaGlmdFwiLFxuICAgICAgICBwb3NpdGlvbkRhdGE6IC10b1NoaWZ0LFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgICBlbGVtOiByb290bVxuICAgICAgICB9XVxuICAgICAgfSwgb3B0aW9ucyk7IC8vIEFkZCBhIGNsYXNzIHN1cnJvdW5kaW5nIGl0IHNvIHdlIGNhbiBhZGQgb24gdGhlIGFwcHJvcHJpYXRlXG4gICAgICAvLyBrZXJuaW5nXG5cbiAgICAgIHZhciByb290Vkxpc3RXcmFwID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wicm9vdFwiXSwgW3Jvb3RWTGlzdF0pO1xuICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJzcXJ0XCJdLCBbcm9vdFZMaXN0V3JhcCwgYm9keV0sIG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIHtcbiAgICAgIGJvZHksXG4gICAgICBpbmRleFxuICAgIH0gPSBncm91cDtcbiAgICByZXR1cm4gaW5kZXggPyBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb290XCIsIFtidWlsZEdyb3VwKGJvZHksIG9wdGlvbnMpLCBidWlsZEdyb3VwKGluZGV4LCBvcHRpb25zKV0pIDogbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3FydFwiLCBbYnVpbGRHcm91cChib2R5LCBvcHRpb25zKV0pO1xuICB9XG5cbn0pO1xuXG52YXIgc3R5bGVNYXAgPSB7XG4gIFwiZGlzcGxheVwiOiBTdHlsZSQxLkRJU1BMQVksXG4gIFwidGV4dFwiOiBTdHlsZSQxLlRFWFQsXG4gIFwic2NyaXB0XCI6IFN0eWxlJDEuU0NSSVBULFxuICBcInNjcmlwdHNjcmlwdFwiOiBTdHlsZSQxLlNDUklQVFNDUklQVFxufTtcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJzdHlsaW5nXCIsXG4gIG5hbWVzOiBbXCJcXFxcZGlzcGxheXN0eWxlXCIsIFwiXFxcXHRleHRzdHlsZVwiLCBcIlxcXFxzY3JpcHRzdHlsZVwiLCBcIlxcXFxzY3JpcHRzY3JpcHRzdHlsZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIGJyZWFrT25Ub2tlblRleHQsXG4gICAgICBmdW5jTmFtZSxcbiAgICAgIHBhcnNlclxuICAgIH0gPSBfcmVmO1xuICAgIC8vIHBhcnNlIG91dCB0aGUgaW1wbGljaXQgYm9keVxuICAgIHZhciBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbih0cnVlLCBicmVha09uVG9rZW5UZXh0KTsgLy8gVE9ETzogUmVmYWN0b3IgdG8gYXZvaWQgZHVwbGljYXRpbmcgc3R5bGVNYXAgaW4gbXVsdGlwbGUgcGxhY2VzIChlLmcuXG4gICAgLy8gaGVyZSBhbmQgaW4gYnVpbGRIVE1MIGFuZCBkZS1kdXBlIHRoZSBlbnVtZXJhdGlvbiBvZiBhbGwgdGhlIHN0eWxlcykuXG4gICAgLy8gJEZsb3dGaXhNZTogVGhlIG5hbWVzIGFib3ZlIGV4YWN0bHkgbWF0Y2ggdGhlIHN0eWxlcy5cblxuICAgIHZhciBzdHlsZSA9IGZ1bmNOYW1lLnNsaWNlKDEsIGZ1bmNOYW1lLmxlbmd0aCAtIDUpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgLy8gRmlndXJlIG91dCB3aGF0IHN0eWxlIHRvIHVzZSBieSBwdWxsaW5nIG91dCB0aGUgc3R5bGUgZnJvbVxuICAgICAgLy8gdGhlIGZ1bmN0aW9uIG5hbWVcbiAgICAgIHN0eWxlLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBTdHlsZSBjaGFuZ2VzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIG9uIHBnLiA0NDIsIFJ1bGUgMy5cbiAgICB2YXIgbmV3U3R5bGUgPSBzdHlsZU1hcFtncm91cC5zdHlsZV07XG4gICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKG5ld1N0eWxlKS53aXRoRm9udCgnJyk7XG4gICAgcmV0dXJuIHNpemluZ0dyb3VwKGdyb3VwLmJvZHksIG5ld09wdGlvbnMsIG9wdGlvbnMpO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBGaWd1cmUgb3V0IHdoYXQgc3R5bGUgd2UncmUgY2hhbmdpbmcgdG8uXG4gICAgdmFyIG5ld1N0eWxlID0gc3R5bGVNYXBbZ3JvdXAuc3R5bGVdO1xuICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShuZXdTdHlsZSk7XG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG5ld09wdGlvbnMpO1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3R5bGVcIiwgaW5uZXIpO1xuICAgIHZhciBzdHlsZUF0dHJpYnV0ZXMgPSB7XG4gICAgICBcImRpc3BsYXlcIjogW1wiMFwiLCBcInRydWVcIl0sXG4gICAgICBcInRleHRcIjogW1wiMFwiLCBcImZhbHNlXCJdLFxuICAgICAgXCJzY3JpcHRcIjogW1wiMVwiLCBcImZhbHNlXCJdLFxuICAgICAgXCJzY3JpcHRzY3JpcHRcIjogW1wiMlwiLCBcImZhbHNlXCJdXG4gICAgfTtcbiAgICB2YXIgYXR0ciA9IHN0eWxlQXR0cmlidXRlc1tncm91cC5zdHlsZV07XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBhdHRyWzBdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImRpc3BsYXlzdHlsZVwiLCBhdHRyWzFdKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBTb21ldGltZXMsIGdyb3VwcyBwZXJmb3JtIHNwZWNpYWwgcnVsZXMgd2hlbiB0aGV5IGhhdmUgc3VwZXJzY3JpcHRzIG9yXG4gKiBzdWJzY3JpcHRzIGF0dGFjaGVkIHRvIHRoZW0uIFRoaXMgZnVuY3Rpb24gbGV0cyB0aGUgYHN1cHN1YmAgZ3JvdXAga25vdyB0aGF0XG4gKiBTb21ldGltZXMsIGdyb3VwcyBwZXJmb3JtIHNwZWNpYWwgcnVsZXMgd2hlbiB0aGV5IGhhdmUgc3VwZXJzY3JpcHRzIG9yXG4gKiBpdHMgaW5uZXIgZWxlbWVudCBzaG91bGQgaGFuZGxlIHRoZSBzdXBlcnNjcmlwdHMgYW5kIHN1YnNjcmlwdHMgaW5zdGVhZCBvZlxuICogaGFuZGxpbmcgdGhlbSBpdHNlbGYuXG4gKi9cbnZhciBodG1sQnVpbGRlckRlbGVnYXRlID0gZnVuY3Rpb24gaHRtbEJ1aWxkZXJEZWxlZ2F0ZShncm91cCwgb3B0aW9ucykge1xuICB2YXIgYmFzZSA9IGdyb3VwLmJhc2U7XG5cbiAgaWYgKCFiYXNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoYmFzZS50eXBlID09PSBcIm9wXCIpIHtcbiAgICAvLyBPcGVyYXRvcnMgaGFuZGxlIHN1cHN1YnMgZGlmZmVyZW50bHkgd2hlbiB0aGV5IGhhdmUgbGltaXRzXG4gICAgLy8gKGUuZy4gYFxcZGlzcGxheXN0eWxlXFxzdW1fMl4zYClcbiAgICB2YXIgZGVsZWdhdGUgPSBiYXNlLmxpbWl0cyAmJiAob3B0aW9ucy5zdHlsZS5zaXplID09PSBTdHlsZSQxLkRJU1BMQVkuc2l6ZSB8fCBiYXNlLmFsd2F5c0hhbmRsZVN1cFN1Yik7XG4gICAgcmV0dXJuIGRlbGVnYXRlID8gaHRtbEJ1aWxkZXIkMiA6IG51bGw7XG4gIH0gZWxzZSBpZiAoYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiKSB7XG4gICAgdmFyIF9kZWxlZ2F0ZSA9IGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViICYmIChvcHRpb25zLnN0eWxlLnNpemUgPT09IFN0eWxlJDEuRElTUExBWS5zaXplIHx8IGJhc2UubGltaXRzKTtcblxuICAgIHJldHVybiBfZGVsZWdhdGUgPyBodG1sQnVpbGRlciQxIDogbnVsbDtcbiAgfSBlbHNlIGlmIChiYXNlLnR5cGUgPT09IFwiYWNjZW50XCIpIHtcbiAgICByZXR1cm4gdXRpbHMuaXNDaGFyYWN0ZXJCb3goYmFzZS5iYXNlKSA/IGh0bWxCdWlsZGVyJGEgOiBudWxsO1xuICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gXCJob3JpekJyYWNlXCIpIHtcbiAgICB2YXIgaXNTdXAgPSAhZ3JvdXAuc3ViO1xuICAgIHJldHVybiBpc1N1cCA9PT0gYmFzZS5pc092ZXIgPyBodG1sQnVpbGRlciQzIDogbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTsgLy8gU3VwZXIgc2NyaXB0cyBhbmQgc3Vic2NyaXB0cywgd2hvc2UgcHJlY2lzZSBwbGFjZW1lbnQgY2FuIGRlcGVuZCBvbiBvdGhlclxuLy8gZnVuY3Rpb25zIHRoYXQgcHJlY2VkZSB0aGVtLlxuXG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcInN1cHN1YlwiLFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gU3VwZXJzY3JpcHQgYW5kIHN1YnNjcmlwdHMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgb24gcGFnZVxuICAgIC8vIDQ0NS00NDYsIHJ1bGVzIDE4KGEtZikuXG4gICAgLy8gSGVyZSBpcyB3aGVyZSB3ZSBkZWZlciB0byB0aGUgaW5uZXIgZ3JvdXAgaWYgaXQgc2hvdWxkIGhhbmRsZVxuICAgIC8vIHN1cGVyc2NyaXB0cyBhbmQgc3Vic2NyaXB0cyBpdHNlbGYuXG4gICAgdmFyIGJ1aWxkZXJEZWxlZ2F0ZSA9IGh0bWxCdWlsZGVyRGVsZWdhdGUoZ3JvdXAsIG9wdGlvbnMpO1xuXG4gICAgaWYgKGJ1aWxkZXJEZWxlZ2F0ZSkge1xuICAgICAgcmV0dXJuIGJ1aWxkZXJEZWxlZ2F0ZShncm91cCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGJhc2U6IHZhbHVlQmFzZSxcbiAgICAgIHN1cDogdmFsdWVTdXAsXG4gICAgICBzdWI6IHZhbHVlU3ViXG4gICAgfSA9IGdyb3VwO1xuICAgIHZhciBiYXNlID0gYnVpbGRHcm91cCQxKHZhbHVlQmFzZSwgb3B0aW9ucyk7XG4gICAgdmFyIHN1cG07XG4gICAgdmFyIHN1Ym07XG4gICAgdmFyIG1ldHJpY3MgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCk7IC8vIFJ1bGUgMThhXG5cbiAgICB2YXIgc3VwU2hpZnQgPSAwO1xuICAgIHZhciBzdWJTaGlmdCA9IDA7XG4gICAgdmFyIGlzQ2hhcmFjdGVyQm94ID0gdmFsdWVCYXNlICYmIHV0aWxzLmlzQ2hhcmFjdGVyQm94KHZhbHVlQmFzZSk7XG5cbiAgICBpZiAodmFsdWVTdXApIHtcbiAgICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShvcHRpb25zLnN0eWxlLnN1cCgpKTtcbiAgICAgIHN1cG0gPSBidWlsZEdyb3VwJDEodmFsdWVTdXAsIG5ld09wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIWlzQ2hhcmFjdGVyQm94KSB7XG4gICAgICAgIHN1cFNoaWZ0ID0gYmFzZS5oZWlnaHQgLSBuZXdPcHRpb25zLmZvbnRNZXRyaWNzKCkuc3VwRHJvcCAqIG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXIgLyBvcHRpb25zLnNpemVNdWx0aXBsaWVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2YWx1ZVN1Yikge1xuICAgICAgdmFyIF9uZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShvcHRpb25zLnN0eWxlLnN1YigpKTtcblxuICAgICAgc3VibSA9IGJ1aWxkR3JvdXAkMSh2YWx1ZVN1YiwgX25ld09wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIWlzQ2hhcmFjdGVyQm94KSB7XG4gICAgICAgIHN1YlNoaWZ0ID0gYmFzZS5kZXB0aCArIF9uZXdPcHRpb25zLmZvbnRNZXRyaWNzKCkuc3ViRHJvcCAqIF9uZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICAgIH1cbiAgICB9IC8vIFJ1bGUgMThjXG5cblxuICAgIHZhciBtaW5TdXBTaGlmdDtcblxuICAgIGlmIChvcHRpb25zLnN0eWxlID09PSBTdHlsZSQxLkRJU1BMQVkpIHtcbiAgICAgIG1pblN1cFNoaWZ0ID0gbWV0cmljcy5zdXAxO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zdHlsZS5jcmFtcGVkKSB7XG4gICAgICBtaW5TdXBTaGlmdCA9IG1ldHJpY3Muc3VwMztcbiAgICB9IGVsc2Uge1xuICAgICAgbWluU3VwU2hpZnQgPSBtZXRyaWNzLnN1cDI7XG4gICAgfSAvLyBzY3JpcHRzcGFjZSBpcyBhIGZvbnQtc2l6ZS1pbmRlcGVuZGVudCBzaXplLCBzbyBzY2FsZSBpdFxuICAgIC8vIGFwcHJvcHJpYXRlbHkgZm9yIHVzZSBhcyB0aGUgbWFyZ2luUmlnaHQuXG5cblxuICAgIHZhciBtdWx0aXBsaWVyID0gb3B0aW9ucy5zaXplTXVsdGlwbGllcjtcbiAgICB2YXIgbWFyZ2luUmlnaHQgPSBtYWtlRW0oMC41IC8gbWV0cmljcy5wdFBlckVtIC8gbXVsdGlwbGllcik7XG4gICAgdmFyIG1hcmdpbkxlZnQgPSBudWxsO1xuXG4gICAgaWYgKHN1Ym0pIHtcbiAgICAgIC8vIFN1YnNjcmlwdHMgc2hvdWxkbid0IGJlIHNoaWZ0ZWQgYnkgdGhlIGJhc2UncyBpdGFsaWMgY29ycmVjdGlvbi5cbiAgICAgIC8vIEFjY291bnQgZm9yIHRoYXQgYnkgc2hpZnRpbmcgdGhlIHN1YnNjcmlwdCBiYWNrIHRoZSBhcHByb3ByaWF0ZVxuICAgICAgLy8gYW1vdW50LiBOb3RlIHdlIG9ubHkgZG8gdGhpcyB3aGVuIHRoZSBiYXNlIGlzIGEgc2luZ2xlIHN5bWJvbC5cbiAgICAgIHZhciBpc09paW50ID0gZ3JvdXAuYmFzZSAmJiBncm91cC5iYXNlLnR5cGUgPT09IFwib3BcIiAmJiBncm91cC5iYXNlLm5hbWUgJiYgKGdyb3VwLmJhc2UubmFtZSA9PT0gXCJcXFxcb2lpbnRcIiB8fCBncm91cC5iYXNlLm5hbWUgPT09IFwiXFxcXG9paWludFwiKTtcblxuICAgICAgaWYgKGJhc2UgaW5zdGFuY2VvZiBTeW1ib2xOb2RlIHx8IGlzT2lpbnQpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICBtYXJnaW5MZWZ0ID0gbWFrZUVtKC1iYXNlLml0YWxpYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN1cHN1YjtcblxuICAgIGlmIChzdXBtICYmIHN1Ym0pIHtcbiAgICAgIHN1cFNoaWZ0ID0gTWF0aC5tYXgoc3VwU2hpZnQsIG1pblN1cFNoaWZ0LCBzdXBtLmRlcHRoICsgMC4yNSAqIG1ldHJpY3MueEhlaWdodCk7XG4gICAgICBzdWJTaGlmdCA9IE1hdGgubWF4KHN1YlNoaWZ0LCBtZXRyaWNzLnN1YjIpO1xuICAgICAgdmFyIHJ1bGVXaWR0aCA9IG1ldHJpY3MuZGVmYXVsdFJ1bGVUaGlja25lc3M7IC8vIFJ1bGUgMThlXG5cbiAgICAgIHZhciBtYXhXaWR0aCA9IDQgKiBydWxlV2lkdGg7XG5cbiAgICAgIGlmIChzdXBTaGlmdCAtIHN1cG0uZGVwdGggLSAoc3VibS5oZWlnaHQgLSBzdWJTaGlmdCkgPCBtYXhXaWR0aCkge1xuICAgICAgICBzdWJTaGlmdCA9IG1heFdpZHRoIC0gKHN1cFNoaWZ0IC0gc3VwbS5kZXB0aCkgKyBzdWJtLmhlaWdodDtcbiAgICAgICAgdmFyIHBzaSA9IDAuOCAqIG1ldHJpY3MueEhlaWdodCAtIChzdXBTaGlmdCAtIHN1cG0uZGVwdGgpO1xuXG4gICAgICAgIGlmIChwc2kgPiAwKSB7XG4gICAgICAgICAgc3VwU2hpZnQgKz0gcHNpO1xuICAgICAgICAgIHN1YlNoaWZ0IC09IHBzaTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmxpc3RFbGVtID0gW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IHN1Ym0sXG4gICAgICAgIHNoaWZ0OiBzdWJTaGlmdCxcbiAgICAgICAgbWFyZ2luUmlnaHQsXG4gICAgICAgIG1hcmdpbkxlZnRcbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IHN1cG0sXG4gICAgICAgIHNoaWZ0OiAtc3VwU2hpZnQsXG4gICAgICAgIG1hcmdpblJpZ2h0XG4gICAgICB9XTtcbiAgICAgIHN1cHN1YiA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICAgIHBvc2l0aW9uVHlwZTogXCJpbmRpdmlkdWFsU2hpZnRcIixcbiAgICAgICAgY2hpbGRyZW46IHZsaXN0RWxlbVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChzdWJtKSB7XG4gICAgICAvLyBSdWxlIDE4YlxuICAgICAgc3ViU2hpZnQgPSBNYXRoLm1heChzdWJTaGlmdCwgbWV0cmljcy5zdWIxLCBzdWJtLmhlaWdodCAtIDAuOCAqIG1ldHJpY3MueEhlaWdodCk7XG4gICAgICB2YXIgX3ZsaXN0RWxlbSA9IFt7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBzdWJtLFxuICAgICAgICBtYXJnaW5MZWZ0LFxuICAgICAgICBtYXJnaW5SaWdodFxuICAgICAgfV07XG4gICAgICBzdXBzdWIgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwic2hpZnRcIixcbiAgICAgICAgcG9zaXRpb25EYXRhOiBzdWJTaGlmdCxcbiAgICAgICAgY2hpbGRyZW46IF92bGlzdEVsZW1cbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoc3VwbSkge1xuICAgICAgLy8gUnVsZSAxOGMsIGRcbiAgICAgIHN1cFNoaWZ0ID0gTWF0aC5tYXgoc3VwU2hpZnQsIG1pblN1cFNoaWZ0LCBzdXBtLmRlcHRoICsgMC4yNSAqIG1ldHJpY3MueEhlaWdodCk7XG4gICAgICBzdXBzdWIgPSBidWlsZENvbW1vbi5tYWtlVkxpc3Qoe1xuICAgICAgICBwb3NpdGlvblR5cGU6IFwic2hpZnRcIixcbiAgICAgICAgcG9zaXRpb25EYXRhOiAtc3VwU2hpZnQsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICAgIGVsZW06IHN1cG0sXG4gICAgICAgICAgbWFyZ2luUmlnaHRcbiAgICAgICAgfV1cbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdXBzdWIgbXVzdCBoYXZlIGVpdGhlciBzdXAgb3Igc3ViLlwiKTtcbiAgICB9IC8vIFdyYXAgdGhlIHN1cHN1YiB2bGlzdCBpbiBhIHNwYW4ubXN1cHN1YiB0byByZXNldCB0ZXh0LWFsaWduLlxuXG5cbiAgICB2YXIgbWNsYXNzID0gZ2V0VHlwZU9mRG9tVHJlZShiYXNlLCBcInJpZ2h0XCIpIHx8IFwibW9yZFwiO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbbWNsYXNzXSwgW2Jhc2UsIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1zdXBzdWJcIl0sIFtzdXBzdWJdKV0sIG9wdGlvbnMpO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBJcyB0aGUgaW5uZXIgZ3JvdXAgYSByZWxldmFudCBob3Jpem9udGFsIGJyYWNlP1xuICAgIHZhciBpc0JyYWNlID0gZmFsc2U7XG4gICAgdmFyIGlzT3ZlcjtcbiAgICB2YXIgaXNTdXA7XG5cbiAgICBpZiAoZ3JvdXAuYmFzZSAmJiBncm91cC5iYXNlLnR5cGUgPT09IFwiaG9yaXpCcmFjZVwiKSB7XG4gICAgICBpc1N1cCA9ICEhZ3JvdXAuc3VwO1xuXG4gICAgICBpZiAoaXNTdXAgPT09IGdyb3VwLmJhc2UuaXNPdmVyKSB7XG4gICAgICAgIGlzQnJhY2UgPSB0cnVlO1xuICAgICAgICBpc092ZXIgPSBncm91cC5iYXNlLmlzT3ZlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuYmFzZSAmJiAoZ3JvdXAuYmFzZS50eXBlID09PSBcIm9wXCIgfHwgZ3JvdXAuYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiKSkge1xuICAgICAgZ3JvdXAuYmFzZS5wYXJlbnRJc1N1cFN1YiA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gW2J1aWxkR3JvdXAoZ3JvdXAuYmFzZSwgb3B0aW9ucyldO1xuXG4gICAgaWYgKGdyb3VwLnN1Yikge1xuICAgICAgY2hpbGRyZW4ucHVzaChidWlsZEdyb3VwKGdyb3VwLnN1Yiwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIGlmIChncm91cC5zdXApIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRHcm91cChncm91cC5zdXAsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZVR5cGU7XG5cbiAgICBpZiAoaXNCcmFjZSkge1xuICAgICAgbm9kZVR5cGUgPSBpc092ZXIgPyBcIm1vdmVyXCIgOiBcIm11bmRlclwiO1xuICAgIH0gZWxzZSBpZiAoIWdyb3VwLnN1Yikge1xuICAgICAgdmFyIGJhc2UgPSBncm91cC5iYXNlO1xuXG4gICAgICBpZiAoYmFzZSAmJiBiYXNlLnR5cGUgPT09IFwib3BcIiAmJiBiYXNlLmxpbWl0cyAmJiAob3B0aW9ucy5zdHlsZSA9PT0gU3R5bGUkMS5ESVNQTEFZIHx8IGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKSkge1xuICAgICAgICBub2RlVHlwZSA9IFwibW92ZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoYmFzZSAmJiBiYXNlLnR5cGUgPT09IFwib3BlcmF0b3JuYW1lXCIgJiYgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgJiYgKGJhc2UubGltaXRzIHx8IG9wdGlvbnMuc3R5bGUgPT09IFN0eWxlJDEuRElTUExBWSkpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1vdmVyXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlVHlwZSA9IFwibXN1cFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWdyb3VwLnN1cCkge1xuICAgICAgdmFyIF9iYXNlID0gZ3JvdXAuYmFzZTtcblxuICAgICAgaWYgKF9iYXNlICYmIF9iYXNlLnR5cGUgPT09IFwib3BcIiAmJiBfYmFzZS5saW1pdHMgJiYgKG9wdGlvbnMuc3R5bGUgPT09IFN0eWxlJDEuRElTUExBWSB8fCBfYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIpKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtdW5kZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoX2Jhc2UgJiYgX2Jhc2UudHlwZSA9PT0gXCJvcGVyYXRvcm5hbWVcIiAmJiBfYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgJiYgKF9iYXNlLmxpbWl0cyB8fCBvcHRpb25zLnN0eWxlID09PSBTdHlsZSQxLkRJU1BMQVkpKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtdW5kZXJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtc3ViXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfYmFzZTIgPSBncm91cC5iYXNlO1xuXG4gICAgICBpZiAoX2Jhc2UyICYmIF9iYXNlMi50eXBlID09PSBcIm9wXCIgJiYgX2Jhc2UyLmxpbWl0cyAmJiBvcHRpb25zLnN0eWxlID09PSBTdHlsZSQxLkRJU1BMQVkpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm11bmRlcm92ZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoX2Jhc2UyICYmIF9iYXNlMi50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiICYmIF9iYXNlMi5hbHdheXNIYW5kbGVTdXBTdWIgJiYgKG9wdGlvbnMuc3R5bGUgPT09IFN0eWxlJDEuRElTUExBWSB8fCBfYmFzZTIubGltaXRzKSkge1xuICAgICAgICBub2RlVHlwZSA9IFwibXVuZGVyb3ZlclwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdWJzdXBcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUobm9kZVR5cGUsIGNoaWxkcmVuKTtcbiAgfVxuXG59KTtcblxuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwiYXRvbVwiLFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1hdGhzeW0oZ3JvdXAudGV4dCwgZ3JvdXAubW9kZSwgb3B0aW9ucywgW1wibVwiICsgZ3JvdXAuZmFtaWx5XSk7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudGV4dCwgZ3JvdXAubW9kZSldKTtcblxuICAgIGlmIChncm91cC5mYW1pbHkgPT09IFwiYmluXCIpIHtcbiAgICAgIHZhciB2YXJpYW50ID0gZ2V0VmFyaWFudChncm91cCwgb3B0aW9ucyk7XG5cbiAgICAgIGlmICh2YXJpYW50ID09PSBcImJvbGQtaXRhbGljXCIpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCB2YXJpYW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdyb3VwLmZhbWlseSA9PT0gXCJwdW5jdFwiKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInNlcGFyYXRvclwiLCBcInRydWVcIik7XG4gICAgfSBlbHNlIGlmIChncm91cC5mYW1pbHkgPT09IFwib3BlblwiIHx8IGdyb3VwLmZhbWlseSA9PT0gXCJjbG9zZVwiKSB7XG4gICAgICAvLyBEZWxpbXMgYnVpbHQgaGVyZSBzaG91bGQgbm90IHN0cmV0Y2ggdmVydGljYWxseS5cbiAgICAgIC8vIFNlZSBkZWxpbXNpemluZy5qcyBmb3Igc3RyZXRjaHkgZGVsaW1zLlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcImZhbHNlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuXG4vLyBcIm1hdGhvcmRcIiBhbmQgXCJ0ZXh0b3JkXCIgUGFyc2VOb2RlcyBjcmVhdGVkIGluIFBhcnNlci5qcyBmcm9tIHN5bWJvbCBHcm91cHMgaW5cbi8vIHNyYy9zeW1ib2xzLmpzLlxudmFyIGRlZmF1bHRWYXJpYW50ID0ge1xuICBcIm1pXCI6IFwiaXRhbGljXCIsXG4gIFwibW5cIjogXCJub3JtYWxcIixcbiAgXCJtdGV4dFwiOiBcIm5vcm1hbFwiXG59O1xuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwibWF0aG9yZFwiLFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwibWF0aG9yZFwiKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIFttYWtlVGV4dChncm91cC50ZXh0LCBncm91cC5tb2RlLCBvcHRpb25zKV0pO1xuICAgIHZhciB2YXJpYW50ID0gZ2V0VmFyaWFudChncm91cCwgb3B0aW9ucykgfHwgXCJpdGFsaWNcIjtcblxuICAgIGlmICh2YXJpYW50ICE9PSBkZWZhdWx0VmFyaWFudFtub2RlLnR5cGVdKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGh2YXJpYW50XCIsIHZhcmlhbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwidGV4dG9yZFwiLFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwidGV4dG9yZFwiKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIHRleHQgPSBtYWtlVGV4dChncm91cC50ZXh0LCBncm91cC5tb2RlLCBvcHRpb25zKTtcbiAgICB2YXIgdmFyaWFudCA9IGdldFZhcmlhbnQoZ3JvdXAsIG9wdGlvbnMpIHx8IFwibm9ybWFsXCI7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAoZ3JvdXAubW9kZSA9PT0gJ3RleHQnKSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbdGV4dF0pO1xuICAgIH0gZWxzZSBpZiAoL1swLTldLy50ZXN0KGdyb3VwLnRleHQpKSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtblwiLCBbdGV4dF0pO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudGV4dCA9PT0gXCJcXFxccHJpbWVcIikge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW3RleHRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgW3RleHRdKTtcbiAgICB9XG5cbiAgICBpZiAodmFyaWFudCAhPT0gZGVmYXVsdFZhcmlhbnRbbm9kZS50eXBlXSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCB2YXJpYW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG59KTtcblxudmFyIGNzc1NwYWNlID0ge1xuICBcIlxcXFxub2JyZWFrXCI6IFwibm9icmVha1wiLFxuICBcIlxcXFxhbGxvd2JyZWFrXCI6IFwiYWxsb3dicmVha1wiXG59OyAvLyBBIGxvb2t1cCB0YWJsZSB0byBkZXRlcm1pbmUgd2hldGhlciBhIHNwYWNpbmcgZnVuY3Rpb24vc3ltYm9sIHNob3VsZCBiZVxuLy8gdHJlYXRlZCBsaWtlIGEgcmVndWxhciBzcGFjZSBjaGFyYWN0ZXIuICBJZiBhIHN5bWJvbCBvciBjb21tYW5kIGlzIGEga2V5XG4vLyBpbiB0aGlzIHRhYmxlLCB0aGVuIGl0IHNob3VsZCBiZSBhIHJlZ3VsYXIgc3BhY2UgY2hhcmFjdGVyLiAgRnVydGhlcm1vcmUsXG4vLyB0aGUgYXNzb2NpYXRlZCB2YWx1ZSBtYXkgaGF2ZSBhIGBjbGFzc05hbWVgIHNwZWNpZnlpbmcgYW4gZXh0cmEgQ1NTIGNsYXNzXG4vLyB0byBhZGQgdG8gdGhlIGNyZWF0ZWQgYHNwYW5gLlxuXG52YXIgcmVndWxhclNwYWNlID0ge1xuICBcIiBcIjoge30sXG4gIFwiXFxcXCBcIjoge30sXG4gIFwiflwiOiB7XG4gICAgY2xhc3NOYW1lOiBcIm5vYnJlYWtcIlxuICB9LFxuICBcIlxcXFxzcGFjZVwiOiB7fSxcbiAgXCJcXFxcbm9icmVha3NwYWNlXCI6IHtcbiAgICBjbGFzc05hbWU6IFwibm9icmVha1wiXG4gIH1cbn07IC8vIFBhcnNlTm9kZTxcInNwYWNpbmdcIj4gY3JlYXRlZCBpbiBQYXJzZXIuanMgZnJvbSB0aGUgXCJzcGFjaW5nXCIgc3ltYm9sIEdyb3VwcyBpblxuLy8gc3JjL3N5bWJvbHMuanMuXG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcInNwYWNpbmdcIixcblxuICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIGlmIChyZWd1bGFyU3BhY2UuaGFzT3duUHJvcGVydHkoZ3JvdXAudGV4dCkpIHtcbiAgICAgIHZhciBjbGFzc05hbWUgPSByZWd1bGFyU3BhY2VbZ3JvdXAudGV4dF0uY2xhc3NOYW1lIHx8IFwiXCI7IC8vIFNwYWNlcyBhcmUgZ2VuZXJhdGVkIGJ5IGFkZGluZyBhbiBhY3R1YWwgc3BhY2UuIEVhY2ggb2YgdGhlc2VcbiAgICAgIC8vIHRoaW5ncyBoYXMgYW4gZW50cnkgaW4gdGhlIHN5bWJvbHMgdGFibGUsIHNvIHRoZXNlIHdpbGwgYmUgdHVybmVkXG4gICAgICAvLyBpbnRvIGFwcHJvcHJpYXRlIG91dHB1dHMuXG5cbiAgICAgIGlmIChncm91cC5tb2RlID09PSBcInRleHRcIikge1xuICAgICAgICB2YXIgb3JkID0gYnVpbGRDb21tb24ubWFrZU9yZChncm91cCwgb3B0aW9ucywgXCJ0ZXh0b3JkXCIpO1xuICAgICAgICBvcmQuY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XG4gICAgICAgIHJldHVybiBvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibXNwYWNlXCIsIGNsYXNzTmFtZV0sIFtidWlsZENvbW1vbi5tYXRoc3ltKGdyb3VwLnRleHQsIGdyb3VwLm1vZGUsIG9wdGlvbnMpXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjc3NTcGFjZS5oYXNPd25Qcm9wZXJ0eShncm91cC50ZXh0KSkge1xuICAgICAgLy8gU3BhY2VzIGJhc2VkIG9uIGp1c3QgYSBDU1MgY2xhc3MuXG4gICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wibXNwYWNlXCIsIGNzc1NwYWNlW2dyb3VwLnRleHRdXSwgW10sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVua25vd24gdHlwZSBvZiBzcGFjZSBcXFwiXCIgKyBncm91cC50ZXh0ICsgXCJcXFwiXCIpO1xuICAgIH1cbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAocmVndWxhclNwYWNlLmhhc093blByb3BlcnR5KGdyb3VwLnRleHQpKSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoXCJcXHUwMGEwXCIpXSk7XG4gICAgfSBlbHNlIGlmIChjc3NTcGFjZS5oYXNPd25Qcm9wZXJ0eShncm91cC50ZXh0KSkge1xuICAgICAgLy8gQ1NTLWJhc2VkIE1hdGhNTCBzcGFjZXMgKFxcbm9icmVhaywgXFxhbGxvd2JyZWFrKSBhcmUgaWdub3JlZFxuICAgICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVua25vd24gdHlwZSBvZiBzcGFjZSBcXFwiXCIgKyBncm91cC50ZXh0ICsgXCJcXFwiXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbn0pO1xuXG52YXIgcGFkID0gKCkgPT4ge1xuICB2YXIgcGFkTm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtdKTtcbiAgcGFkTm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjUwJVwiKTtcbiAgcmV0dXJuIHBhZE5vZGU7XG59O1xuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJ0YWdcIixcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIHRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGFibGVcIiwgW25ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRyXCIsIFtwYWQoKSwgbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW2J1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBvcHRpb25zKV0pLCBwYWQoKSwgbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW2J1aWxkRXhwcmVzc2lvblJvdyhncm91cC50YWcsIG9wdGlvbnMpXSldKV0pO1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMTAwJVwiKTtcbiAgICByZXR1cm4gdGFibGU7IC8vIFRPRE86IExlZnQtYWxpZ25lZCB0YWdzLlxuICAgIC8vIEN1cnJlbnRseSwgdGhlIGdyb3VwIGFuZCBvcHRpb25zIHBhc3NlZCBoZXJlIGRvIG5vdCBjb250YWluXG4gICAgLy8gZW5vdWdoIGluZm8gdG8gc2V0IHRhZyBhbGlnbm1lbnQuIGBsZXFub2AgaXMgaW4gU2V0dGluZ3MgYnV0IGl0IGlzXG4gICAgLy8gbm90IHBhc3NlZCB0byBPcHRpb25zLiBPbiB0aGUgSFRNTCBzaWRlLCBsZXFubyBpc1xuICAgIC8vIHNldCBieSBhIENTUyBjbGFzcyBhcHBsaWVkIGluIGJ1aWxkVHJlZS5qcy4gVGhhdCB3b3VsZCBoYXZlIHdvcmtlZFxuICAgIC8vIGluIE1hdGhNTCBpZiBicm93c2VycyBzdXBwb3J0ZWQgPG1sYWJlbGVkdHI+LiBTaW5jZSB0aGV5IGRvbid0LCB3ZVxuICAgIC8vIG5lZWQgdG8gcmV3cml0ZSB0aGUgd2F5IHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICB9XG5cbn0pO1xuXG52YXIgdGV4dEZvbnRGYW1pbGllcyA9IHtcbiAgXCJcXFxcdGV4dFwiOiB1bmRlZmluZWQsXG4gIFwiXFxcXHRleHRybVwiOiBcInRleHRybVwiLFxuICBcIlxcXFx0ZXh0c2ZcIjogXCJ0ZXh0c2ZcIixcbiAgXCJcXFxcdGV4dHR0XCI6IFwidGV4dHR0XCIsXG4gIFwiXFxcXHRleHRub3JtYWxcIjogXCJ0ZXh0cm1cIlxufTtcbnZhciB0ZXh0Rm9udFdlaWdodHMgPSB7XG4gIFwiXFxcXHRleHRiZlwiOiBcInRleHRiZlwiLFxuICBcIlxcXFx0ZXh0bWRcIjogXCJ0ZXh0bWRcIlxufTtcbnZhciB0ZXh0Rm9udFNoYXBlcyA9IHtcbiAgXCJcXFxcdGV4dGl0XCI6IFwidGV4dGl0XCIsXG4gIFwiXFxcXHRleHR1cFwiOiBcInRleHR1cFwiXG59O1xuXG52YXIgb3B0aW9uc1dpdGhGb250ID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7XG4gIHZhciBmb250ID0gZ3JvdXAuZm9udDsgLy8gQ2hlY2tzIGlmIHRoZSBhcmd1bWVudCBpcyBhIGZvbnQgZmFtaWx5IG9yIGEgZm9udCBzdHlsZS5cblxuICBpZiAoIWZvbnQpIHtcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfSBlbHNlIGlmICh0ZXh0Rm9udEZhbWlsaWVzW2ZvbnRdKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMud2l0aFRleHRGb250RmFtaWx5KHRleHRGb250RmFtaWxpZXNbZm9udF0pO1xuICB9IGVsc2UgaWYgKHRleHRGb250V2VpZ2h0c1tmb250XSkge1xuICAgIHJldHVybiBvcHRpb25zLndpdGhUZXh0Rm9udFdlaWdodCh0ZXh0Rm9udFdlaWdodHNbZm9udF0pO1xuICB9IGVsc2UgaWYgKGZvbnQgPT09IFwiXFxcXGVtcGhcIikge1xuICAgIHJldHVybiBvcHRpb25zLmZvbnRTaGFwZSA9PT0gXCJ0ZXh0aXRcIiA/IG9wdGlvbnMud2l0aFRleHRGb250U2hhcGUoXCJ0ZXh0dXBcIikgOiBvcHRpb25zLndpdGhUZXh0Rm9udFNoYXBlKFwidGV4dGl0XCIpO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnMud2l0aFRleHRGb250U2hhcGUodGV4dEZvbnRTaGFwZXNbZm9udF0pO1xufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInRleHRcIixcbiAgbmFtZXM6IFsvLyBGb250IGZhbWlsaWVzXG4gIFwiXFxcXHRleHRcIiwgXCJcXFxcdGV4dHJtXCIsIFwiXFxcXHRleHRzZlwiLCBcIlxcXFx0ZXh0dHRcIiwgXCJcXFxcdGV4dG5vcm1hbFwiLCAvLyBGb250IHdlaWdodHNcbiAgXCJcXFxcdGV4dGJmXCIsIFwiXFxcXHRleHRtZFwiLCAvLyBGb250IFNoYXBlc1xuICBcIlxcXFx0ZXh0aXRcIiwgXCJcXFxcdGV4dHVwXCIsIFwiXFxcXGVtcGhcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widGV4dFwiXSxcbiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBhcnNlcixcbiAgICAgIGZ1bmNOYW1lXG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSksXG4gICAgICBmb250OiBmdW5jTmFtZVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnNXaXRoRm9udChncm91cCwgb3B0aW9ucyk7XG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uJDEoZ3JvdXAuYm9keSwgbmV3T3B0aW9ucywgdHJ1ZSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJ0ZXh0XCJdLCBpbm5lciwgbmV3T3B0aW9ucyk7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9uc1dpdGhGb250KGdyb3VwLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIG5ld09wdGlvbnMpO1xuICB9XG5cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidW5kZXJsaW5lXCIsXG4gIG5hbWVzOiBbXCJcXFxcdW5kZXJsaW5lXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ1bmRlcmxpbmVcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogYXJnc1swXVxuICAgIH07XG4gIH0sXG5cbiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBVbmRlcmxpbmVzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnIDQ0MywgUnVsZSAxMC5cbiAgICAvLyBCdWlsZCB0aGUgaW5uZXIgZ3JvdXAuXG4gICAgdmFyIGlubmVyR3JvdXAgPSBidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgb3B0aW9ucyk7IC8vIENyZWF0ZSB0aGUgbGluZSB0byBnbyBiZWxvdyB0aGUgYm9keVxuXG4gICAgdmFyIGxpbmUgPSBidWlsZENvbW1vbi5tYWtlTGluZVNwYW4oXCJ1bmRlcmxpbmUtbGluZVwiLCBvcHRpb25zKTsgLy8gR2VuZXJhdGUgdGhlIHZsaXN0LCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBrZXJuc1xuXG4gICAgdmFyIGRlZmF1bHRSdWxlVGhpY2tuZXNzID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlZmF1bHRSdWxlVGhpY2tuZXNzO1xuICAgIHZhciB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwidG9wXCIsXG4gICAgICBwb3NpdGlvbkRhdGE6IGlubmVyR3JvdXAuaGVpZ2h0LFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBzaXplOiBkZWZhdWx0UnVsZVRoaWNrbmVzc1xuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImVsZW1cIixcbiAgICAgICAgZWxlbTogbGluZVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgICAgc2l6ZTogMyAqIGRlZmF1bHRSdWxlVGhpY2tuZXNzXG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwiZWxlbVwiLFxuICAgICAgICBlbGVtOiBpbm5lckdyb3VwXG4gICAgICB9XVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbXCJtb3JkXCIsIFwidW5kZXJsaW5lXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG9wZXJhdG9yID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoXCJcXHUyMDNlXCIpXSk7XG4gICAgb3BlcmF0b3Iuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJ0cnVlXCIpO1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdW5kZXJcIiwgW2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucyksIG9wZXJhdG9yXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJhY2NlbnR1bmRlclwiLCBcInRydWVcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ2Y2VudGVyXCIsXG4gIG5hbWVzOiBbXCJcXFxcdmNlbnRlclwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJvcmlnaW5hbFwiXSxcbiAgICAvLyBJbiBMYVRlWCwgXFx2Y2VudGVyIGNhbiBhY3Qgb25seSBvbiBhIGJveC5cbiAgICBhbGxvd2VkSW5UZXh0OiBmYWxzZVxuICB9LFxuXG4gIGhhbmRsZXIoX3JlZiwgYXJncykge1xuICAgIHZhciB7XG4gICAgICBwYXJzZXJcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ2Y2VudGVyXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IGFyZ3NbMF1cbiAgICB9O1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGJvZHkgPSBidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgb3B0aW9ucyk7XG4gICAgdmFyIGF4aXNIZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDtcbiAgICB2YXIgZHkgPSAwLjUgKiAoYm9keS5oZWlnaHQgLSBheGlzSGVpZ2h0IC0gKGJvZHkuZGVwdGggKyBheGlzSGVpZ2h0KSk7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7XG4gICAgICBwb3NpdGlvblR5cGU6IFwic2hpZnRcIixcbiAgICAgIHBvc2l0aW9uRGF0YTogZHksXG4gICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdHlwZTogXCJlbGVtXCIsXG4gICAgICAgIGVsZW06IGJvZHlcbiAgICAgIH1dXG4gICAgfSwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIFRoZXJlIGlzIG5vIHdheSB0byBkbyB0aGlzIGluIE1hdGhNTC5cbiAgICAvLyBXcml0ZSBhIGNsYXNzIGFzIGEgYnJlYWRjcnVtYiBpbiBjYXNlIHNvbWUgcG9zdC1wcm9jZXNzb3Igd2FudHNcbiAgICAvLyB0byBwZXJmb3JtIGEgdmNlbnRlciBhZGp1c3RtZW50LlxuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW2J1aWxkR3JvdXAoZ3JvdXAuYm9keSwgb3B0aW9ucyldLCBbXCJ2Y2VudGVyXCJdKTtcbiAgfVxuXG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInZlcmJcIixcbiAgbmFtZXM6IFtcIlxcXFx2ZXJiXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoY29udGV4dCwgYXJncywgb3B0QXJncykge1xuICAgIC8vIFxcdmVyYiBhbmQgXFx2ZXJiKiBhcmUgZGVhbHQgd2l0aCBkaXJlY3RseSBpbiBQYXJzZXIuanMuXG4gICAgLy8gSWYgd2UgZW5kIHVwIGhlcmUsIGl0J3MgYmVjYXVzZSBvZiBhIGZhaWx1cmUgdG8gbWF0Y2ggdGhlIHR3byBkZWxpbWl0ZXJzXG4gICAgLy8gaW4gdGhlIHJlZ2V4IGluIExleGVyLmpzLiAgTGFUZVggcmFpc2VzIHRoZSBmb2xsb3dpbmcgZXJyb3Igd2hlbiBcXHZlcmIgaXNcbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBsaW5lIChvciBmaWxlKS5cbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFx2ZXJiIGVuZGVkIGJ5IGVuZCBvZiBsaW5lIGluc3RlYWQgb2YgbWF0Y2hpbmcgZGVsaW1pdGVyXCIpO1xuICB9LFxuXG4gIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIHRleHQgPSBtYWtlVmVyYihncm91cCk7XG4gICAgdmFyIGJvZHkgPSBbXTsgLy8gXFx2ZXJiIGVudGVycyB0ZXh0IG1vZGUgYW5kIHRoZXJlZm9yZSBpcyBzaXplZCBsaWtlIFxcdGV4dHN0eWxlXG5cbiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUob3B0aW9ucy5zdHlsZS50ZXh0KCkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHRleHRbaV07XG5cbiAgICAgIGlmIChjID09PSAnficpIHtcbiAgICAgICAgYyA9ICdcXFxcdGV4dGFzY2lpdGlsZGUnO1xuICAgICAgfVxuXG4gICAgICBib2R5LnB1c2goYnVpbGRDb21tb24ubWFrZVN5bWJvbChjLCBcIlR5cGV3cml0ZXItUmVndWxhclwiLCBncm91cC5tb2RlLCBuZXdPcHRpb25zLCBbXCJtb3JkXCIsIFwidGV4dHR0XCJdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtcIm1vcmRcIiwgXCJ0ZXh0XCJdLmNvbmNhdChuZXdPcHRpb25zLnNpemluZ0NsYXNzZXMob3B0aW9ucykpLCBidWlsZENvbW1vbi50cnlDb21iaW5lQ2hhcnMoYm9keSksIG5ld09wdGlvbnMpO1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGV4dCA9IG5ldyBtYXRoTUxUcmVlLlRleHROb2RlKG1ha2VWZXJiKGdyb3VwKSk7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFt0ZXh0XSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCBcIm1vbm9zcGFjZVwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG59KTtcbi8qKlxuICogQ29udmVydHMgdmVyYiBncm91cCBpbnRvIGJvZHkgc3RyaW5nLlxuICpcbiAqIFxcdmVyYiogcmVwbGFjZXMgZWFjaCBzcGFjZSB3aXRoIGFuIG9wZW4gYm94IFxcdTI0MjNcbiAqIFxcdmVyYiByZXBsYWNlcyBlYWNoIHNwYWNlIHdpdGggYSBuby1icmVhayBzcGFjZSBcXHhBMFxuICovXG5cbnZhciBtYWtlVmVyYiA9IGdyb3VwID0+IGdyb3VwLmJvZHkucmVwbGFjZSgvIC9nLCBncm91cC5zdGFyID8gJ1xcdTI0MjMnIDogJ1xceEEwJyk7XG5cbi8qKiBJbmNsdWRlIHRoaXMgdG8gZW5zdXJlIHRoYXQgYWxsIGZ1bmN0aW9ucyBhcmUgZGVmaW5lZC4gKi9cbnZhciBmdW5jdGlvbnMgPSBfZnVuY3Rpb25zO1xuXG4vKipcbiAqIFRoZSBMZXhlciBjbGFzcyBoYW5kbGVzIHRva2VuaXppbmcgdGhlIGlucHV0IGluIHZhcmlvdXMgd2F5cy4gU2luY2Ugb3VyXG4gKiBwYXJzZXIgZXhwZWN0cyB1cyB0byBiZSBhYmxlIHRvIGJhY2t0cmFjaywgdGhlIGxleGVyIGFsbG93cyBsZXhpbmcgZnJvbSBhbnlcbiAqIGdpdmVuIHN0YXJ0aW5nIHBvaW50LlxuICpcbiAqIEl0cyBtYWluIGV4cG9zZWQgZnVuY3Rpb24gaXMgdGhlIGBsZXhgIGZ1bmN0aW9uLCB3aGljaCB0YWtlcyBhIHBvc2l0aW9uIHRvXG4gKiBsZXggZnJvbSBhbmQgYSB0eXBlIG9mIHRva2VuIHRvIGxleC4gSXQgZGVmZXJzIHRvIHRoZSBhcHByb3ByaWF0ZSBgX2lubmVyTGV4YFxuICogZnVuY3Rpb24uXG4gKlxuICogVGhlIHZhcmlvdXMgYF9pbm5lckxleGAgZnVuY3Rpb25zIHBlcmZvcm0gdGhlIGFjdHVhbCBsZXhpbmcgb2YgZGlmZmVyZW50XG4gKiBraW5kcy5cbiAqL1xuXG4vKiBUaGUgZm9sbG93aW5nIHRva2VuUmVnZXhcbiAqIC0gbWF0Y2hlcyB0eXBpY2FsIHdoaXRlc3BhY2UgKGJ1dCBub3QgTkJTUCBldGMuKSB1c2luZyBpdHMgZmlyc3QgZ3JvdXBcbiAqIC0gZG9lcyBub3QgbWF0Y2ggYW55IGNvbnRyb2wgY2hhcmFjdGVyIFxceDAwLVxceDFmIGV4Y2VwdCB3aGl0ZXNwYWNlXG4gKiAtIGRvZXMgbm90IG1hdGNoIGEgYmFyZSBiYWNrc2xhc2hcbiAqIC0gbWF0Y2hlcyBhbnkgQVNDSUkgY2hhcmFjdGVyIGV4Y2VwdCB0aG9zZSBqdXN0IG1lbnRpb25lZFxuICogLSBkb2VzIG5vdCBtYXRjaCB0aGUgQk1QIHByaXZhdGUgdXNlIGFyZWEgXFx1RTAwMC1cXHVGOEZGXG4gKiAtIGRvZXMgbm90IG1hdGNoIGJhcmUgc3Vycm9nYXRlIGNvZGUgdW5pdHNcbiAqIC0gbWF0Y2hlcyBhbnkgQk1QIGNoYXJhY3RlciBleGNlcHQgZm9yIHRob3NlIGp1c3QgZGVzY3JpYmVkXG4gKiAtIG1hdGNoZXMgYW55IHZhbGlkIFVuaWNvZGUgc3Vycm9nYXRlIHBhaXJcbiAqIC0gbWF0Y2hlcyBhIGJhY2tzbGFzaCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcbiAqIC0gbWF0Y2hlcyBhIGJhY2tzbGFzaCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBsZXR0ZXJzIHRoZW4gd2hpdGVzcGFjZVxuICogLSBtYXRjaGVzIGEgYmFja3NsYXNoIGZvbGxvd2VkIGJ5IGFueSBCTVAgY2hhcmFjdGVyXG4gKiBDYXB0dXJpbmcgZ3JvdXBzOlxuICogICBbMV0gcmVndWxhciB3aGl0ZXNwYWNlXG4gKiAgIFsyXSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgd2hpdGVzcGFjZVxuICogICBbM10gYW55dGhpbmcgZWxzZSwgd2hpY2ggbWF5IGluY2x1ZGU6XG4gKiAgICAgWzRdIGxlZnQgY2hhcmFjdGVyIG9mIFxcdmVyYipcbiAqICAgICBbNV0gbGVmdCBjaGFyYWN0ZXIgb2YgXFx2ZXJiXG4gKiAgICAgWzZdIGJhY2tzbGFzaCBmb2xsb3dlZCBieSB3b3JkLCBleGNsdWRpbmcgYW55IHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAqIEp1c3QgYmVjYXVzZSB0aGUgTGV4ZXIgbWF0Y2hlcyBzb21ldGhpbmcgZG9lc24ndCBtZWFuIGl0J3MgdmFsaWQgaW5wdXQ6XG4gKiBJZiB0aGVyZSBpcyBubyBtYXRjaGluZyBmdW5jdGlvbiBvciBzeW1ib2wgZGVmaW5pdGlvbiwgdGhlIFBhcnNlciB3aWxsXG4gKiBzdGlsbCByZWplY3QgdGhlIGlucHV0LlxuICovXG52YXIgc3BhY2VSZWdleFN0cmluZyA9IFwiWyBcXHJcXG5cXHRdXCI7XG52YXIgY29udHJvbFdvcmRSZWdleFN0cmluZyA9IFwiXFxcXFxcXFxbYS16QS1aQF0rXCI7XG52YXIgY29udHJvbFN5bWJvbFJlZ2V4U3RyaW5nID0gXCJcXFxcXFxcXFteXFx1RDgwMC1cXHVERkZGXVwiO1xudmFyIGNvbnRyb2xXb3JkV2hpdGVzcGFjZVJlZ2V4U3RyaW5nID0gXCIoXCIgKyBjb250cm9sV29yZFJlZ2V4U3RyaW5nICsgXCIpXCIgKyBzcGFjZVJlZ2V4U3RyaW5nICsgXCIqXCI7XG52YXIgY29udHJvbFNwYWNlUmVnZXhTdHJpbmcgPSBcIlxcXFxcXFxcKFxcbnxbIFxcclxcdF0rXFxuPylbIFxcclxcdF0qXCI7XG52YXIgY29tYmluaW5nRGlhY3JpdGljYWxNYXJrU3RyaW5nID0gXCJbXFx1MDMwMC1cXHUwMzZmXVwiO1xudmFyIGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya3NFbmRSZWdleCA9IG5ldyBSZWdFeHAoY29tYmluaW5nRGlhY3JpdGljYWxNYXJrU3RyaW5nICsgXCIrJFwiKTtcbnZhciB0b2tlblJlZ2V4U3RyaW5nID0gXCIoXCIgKyBzcGFjZVJlZ2V4U3RyaW5nICsgXCIrKXxcIiArICggLy8gd2hpdGVzcGFjZVxuY29udHJvbFNwYWNlUmVnZXhTdHJpbmcgKyBcInxcIikgKyAvLyBcXHdoaXRlc3BhY2VcblwiKFshLVxcXFxbXFxcXF0tXFx1MjAyN1xcdTIwMkEtXFx1RDdGRlxcdUY5MDAtXFx1RkZGRl1cIiArICggLy8gc2luZ2xlIGNvZGVwb2ludFxuY29tYmluaW5nRGlhY3JpdGljYWxNYXJrU3RyaW5nICsgXCIqXCIpICsgLy8gLi4ucGx1cyBhY2NlbnRzXG5cInxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdXCIgKyAoIC8vIHN1cnJvZ2F0ZSBwYWlyXG5jb21iaW5pbmdEaWFjcml0aWNhbE1hcmtTdHJpbmcgKyBcIipcIikgKyAvLyAuLi5wbHVzIGFjY2VudHNcblwifFxcXFxcXFxcdmVyYlxcXFwqKFteXSkuKj9cXFxcNFwiICsgLy8gXFx2ZXJiKlxuXCJ8XFxcXFxcXFx2ZXJiKFteKmEtekEtWl0pLio/XFxcXDVcIiArICggLy8gXFx2ZXJiIHVuc3RhcnJlZFxuXCJ8XCIgKyBjb250cm9sV29yZFdoaXRlc3BhY2VSZWdleFN0cmluZykgKyAoIC8vIFxcbWFjcm9OYW1lICsgc3BhY2VzXG5cInxcIiArIGNvbnRyb2xTeW1ib2xSZWdleFN0cmluZyArIFwiKVwiKTsgLy8gXFxcXCwgXFwnLCBldGMuXG5cbi8qKiBNYWluIExleGVyIGNsYXNzICovXG5cbmNsYXNzIExleGVyIHtcbiAgLy8gQ2F0ZWdvcnkgY29kZXMuIFRoZSBsZXhlciBvbmx5IHN1cHBvcnRzIGNvbW1lbnQgY2hhcmFjdGVycyAoMTQpIGZvciBub3cuXG4gIC8vIE1hY3JvRXhwYW5kZXIgYWRkaXRpb25hbGx5IGRpc3Rpbmd1aXNoZXMgYWN0aXZlICgxMykuXG4gIGNvbnN0cnVjdG9yKGlucHV0LCBzZXR0aW5ncykge1xuICAgIHRoaXMuaW5wdXQgPSB2b2lkIDA7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHZvaWQgMDtcbiAgICB0aGlzLnRva2VuUmVnZXggPSB2b2lkIDA7XG4gICAgdGhpcy5jYXRjb2RlcyA9IHZvaWQgMDtcbiAgICAvLyBTZXBhcmF0ZSBhY2NlbnRzIGZyb20gY2hhcmFjdGVyc1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy50b2tlblJlZ2V4ID0gbmV3IFJlZ0V4cCh0b2tlblJlZ2V4U3RyaW5nLCAnZycpO1xuICAgIHRoaXMuY2F0Y29kZXMgPSB7XG4gICAgICBcIiVcIjogMTQsXG4gICAgICAvLyBjb21tZW50IGNoYXJhY3RlclxuICAgICAgXCJ+XCI6IDEzIC8vIGFjdGl2ZSBjaGFyYWN0ZXJcblxuICAgIH07XG4gIH1cblxuICBzZXRDYXRjb2RlKGNoYXIsIGNvZGUpIHtcbiAgICB0aGlzLmNhdGNvZGVzW2NoYXJdID0gY29kZTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBsZXhlcyBhIHNpbmdsZSB0b2tlbi5cbiAgICovXG5cblxuICBsZXgoKSB7XG4gICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgICB2YXIgcG9zID0gdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleDtcblxuICAgIGlmIChwb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihcIkVPRlwiLCBuZXcgU291cmNlTG9jYXRpb24odGhpcywgcG9zLCBwb3MpKTtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2ggPSB0aGlzLnRva2VuUmVnZXguZXhlYyhpbnB1dCk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwgfHwgbWF0Y2guaW5kZXggIT09IHBvcykge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlcjogJ1wiICsgaW5wdXRbcG9zXSArIFwiJ1wiLCBuZXcgVG9rZW4oaW5wdXRbcG9zXSwgbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHBvcywgcG9zICsgMSkpKTtcbiAgICB9XG5cbiAgICB2YXIgdGV4dCA9IG1hdGNoWzZdIHx8IG1hdGNoWzNdIHx8IChtYXRjaFsyXSA/IFwiXFxcXCBcIiA6IFwiIFwiKTtcblxuICAgIGlmICh0aGlzLmNhdGNvZGVzW3RleHRdID09PSAxNCkge1xuICAgICAgLy8gY29tbWVudCBjaGFyYWN0ZXJcbiAgICAgIHZhciBubEluZGV4ID0gaW5wdXQuaW5kZXhPZignXFxuJywgdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleCk7XG5cbiAgICAgIGlmIChubEluZGV4ID09PSAtMSkge1xuICAgICAgICB0aGlzLnRva2VuUmVnZXgubGFzdEluZGV4ID0gaW5wdXQubGVuZ3RoOyAvLyBFT0ZcblxuICAgICAgICB0aGlzLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcImNvbW1lbnRBdEVuZFwiLCBcIiUgY29tbWVudCBoYXMgbm8gdGVybWluYXRpbmcgbmV3bGluZTsgTGFUZVggd291bGQgXCIgKyBcImZhaWwgYmVjYXVzZSBvZiBjb21tZW50aW5nIHRoZSBlbmQgb2YgbWF0aCBtb2RlIChlLmcuICQpXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleCA9IG5sSW5kZXggKyAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5sZXgoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRva2VuKHRleHQsIG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBwb3MsIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXgpKTtcbiAgfVxuXG59XG5cbi8qKlxuICogQSBgTmFtZXNwYWNlYCByZWZlcnMgdG8gYSBzcGFjZSBvZiBuYW1lYWJsZSB0aGluZ3MgbGlrZSBtYWNyb3Mgb3IgbGVuZ3RocyxcbiAqIHdoaWNoIGNhbiBiZSBgc2V0YCBlaXRoZXIgZ2xvYmFsbHkgb3IgbG9jYWwgdG8gYSBuZXN0ZWQgZ3JvdXAsIHVzaW5nIGFuXG4gKiB1bmRvIHN0YWNrIHNpbWlsYXIgdG8gaG93IFRlWCBpbXBsZW1lbnRzIHRoaXMgZnVuY3Rpb25hbGl0eS5cbiAqIFBlcmZvcm1hbmNlLXdpc2UsIGBnZXRgIGFuZCBsb2NhbCBgc2V0YCB0YWtlIGNvbnN0YW50IHRpbWUsIHdoaWxlIGdsb2JhbFxuICogYHNldGAgdGFrZXMgdGltZSBwcm9wb3J0aW9uYWwgdG8gdGhlIGRlcHRoIG9mIGdyb3VwIG5lc3RpbmcuXG4gKi9cbmNsYXNzIE5hbWVzcGFjZSB7XG4gIC8qKlxuICAgKiBCb3RoIGFyZ3VtZW50cyBhcmUgb3B0aW9uYWwuICBUaGUgZmlyc3QgYXJndW1lbnQgaXMgYW4gb2JqZWN0IG9mXG4gICAqIGJ1aWx0LWluIG1hcHBpbmdzIHdoaWNoIG5ldmVyIGNoYW5nZS4gIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gICAqIG9mIGluaXRpYWwgKGdsb2JhbC1sZXZlbCkgbWFwcGluZ3MsIHdoaWNoIHdpbGwgY29uc3RhbnRseSBjaGFuZ2VcbiAgICogYWNjb3JkaW5nIHRvIGFueSBnbG9iYWwvdG9wLWxldmVsIGBzZXRgcyBkb25lLlxuICAgKi9cbiAgY29uc3RydWN0b3IoYnVpbHRpbnMsIGdsb2JhbE1hY3Jvcykge1xuICAgIGlmIChidWlsdGlucyA9PT0gdm9pZCAwKSB7XG4gICAgICBidWlsdGlucyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChnbG9iYWxNYWNyb3MgPT09IHZvaWQgMCkge1xuICAgICAgZ2xvYmFsTWFjcm9zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuYnVpbHRpbnMgPSB2b2lkIDA7XG4gICAgdGhpcy51bmRlZlN0YWNrID0gdm9pZCAwO1xuICAgIHRoaXMuY3VycmVudCA9IGdsb2JhbE1hY3JvcztcbiAgICB0aGlzLmJ1aWx0aW5zID0gYnVpbHRpbnM7XG4gICAgdGhpcy51bmRlZlN0YWNrID0gW107XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IGEgbmV3IG5lc3RlZCBncm91cCwgYWZmZWN0aW5nIGZ1dHVyZSBsb2NhbCBgc2V0YHMuXG4gICAqL1xuXG5cbiAgYmVnaW5Hcm91cCgpIHtcbiAgICB0aGlzLnVuZGVmU3RhY2sucHVzaCh7fSk7XG4gIH1cbiAgLyoqXG4gICAqIEVuZCBjdXJyZW50IG5lc3RlZCBncm91cCwgcmVzdG9yaW5nIHZhbHVlcyBiZWZvcmUgdGhlIGdyb3VwIGJlZ2FuLlxuICAgKi9cblxuXG4gIGVuZEdyb3VwKCkge1xuICAgIGlmICh0aGlzLnVuZGVmU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVuYmFsYW5jZWQgbmFtZXNwYWNlIGRlc3RydWN0aW9uOiBhdHRlbXB0IFwiICsgXCJ0byBwb3AgZ2xvYmFsIG5hbWVzcGFjZTsgcGxlYXNlIHJlcG9ydCB0aGlzIGFzIGEgYnVnXCIpO1xuICAgIH1cblxuICAgIHZhciB1bmRlZnMgPSB0aGlzLnVuZGVmU3RhY2sucG9wKCk7XG5cbiAgICBmb3IgKHZhciB1bmRlZiBpbiB1bmRlZnMpIHtcbiAgICAgIGlmICh1bmRlZnMuaGFzT3duUHJvcGVydHkodW5kZWYpKSB7XG4gICAgICAgIGlmICh1bmRlZnNbdW5kZWZdID09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5jdXJyZW50W3VuZGVmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRbdW5kZWZdID0gdW5kZWZzW3VuZGVmXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRW5kcyBhbGwgY3VycmVudGx5IG5lc3RlZCBncm91cHMgKGlmIGFueSksIHJlc3RvcmluZyB2YWx1ZXMgYmVmb3JlIHRoZVxuICAgKiBncm91cHMgYmVnYW4uICBVc2VmdWwgaW4gY2FzZSBvZiBhbiBlcnJvciBpbiB0aGUgbWlkZGxlIG9mIHBhcnNpbmcuXG4gICAqL1xuXG5cbiAgZW5kR3JvdXBzKCkge1xuICAgIHdoaWxlICh0aGlzLnVuZGVmU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5lbmRHcm91cCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGV0ZWN0IHdoZXRoZXIgYG5hbWVgIGhhcyBhIGRlZmluaXRpb24uICBFcXVpdmFsZW50IHRvXG4gICAqIGBnZXQobmFtZSkgIT0gbnVsbGAuXG4gICAqL1xuXG5cbiAgaGFzKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50Lmhhc093blByb3BlcnR5KG5hbWUpIHx8IHRoaXMuYnVpbHRpbnMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIG5hbWUsIG9yIGB1bmRlZmluZWRgIGlmIHRoZXJlIGlzIG5vIHZhbHVlLlxuICAgKlxuICAgKiBOb3RlOiBEbyBub3QgdXNlIGBpZiAobmFtZXNwYWNlLmdldCguLi4pKWAgdG8gZGV0ZWN0IHdoZXRoZXIgYSBtYWNyb1xuICAgKiBpcyBkZWZpbmVkLCBhcyB0aGUgZGVmaW5pdGlvbiBtYXkgYmUgdGhlIGVtcHR5IHN0cmluZyB3aGljaCBldmFsdWF0ZXNcbiAgICogdG8gYGZhbHNlYCBpbiBKYXZhU2NyaXB0LiAgVXNlIGBpZiAobmFtZXNwYWNlLmdldCguLi4pICE9IG51bGwpYCBvclxuICAgKiBgaWYgKG5hbWVzcGFjZS5oYXMoLi4uKSlgLlxuICAgKi9cblxuXG4gIGdldChuYW1lKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFtuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuYnVpbHRpbnNbbmFtZV07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBuYW1lLCBhbmQgb3B0aW9uYWxseSBzZXQgaXQgZ2xvYmFsbHkgdG9vLlxuICAgKiBMb2NhbCBzZXQoKSBzZXRzIHRoZSBjdXJyZW50IHZhbHVlIGFuZCAod2hlbiBhcHByb3ByaWF0ZSkgYWRkcyBhbiB1bmRvXG4gICAqIG9wZXJhdGlvbiB0byB0aGUgdW5kbyBzdGFjay4gIEdsb2JhbCBzZXQoKSBtYXkgY2hhbmdlIHRoZSB1bmRvXG4gICAqIG9wZXJhdGlvbiBhdCBldmVyeSBsZXZlbCwgc28gdGFrZXMgdGltZSBsaW5lYXIgaW4gdGhlaXIgbnVtYmVyLlxuICAgKiBBIHZhbHVlIG9mIHVuZGVmaW5lZCBtZWFucyB0byBkZWxldGUgZXhpc3RpbmcgZGVmaW5pdGlvbnMuXG4gICAqL1xuXG5cbiAgc2V0KG5hbWUsIHZhbHVlLCBnbG9iYWwpIHtcbiAgICBpZiAoZ2xvYmFsID09PSB2b2lkIDApIHtcbiAgICAgIGdsb2JhbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChnbG9iYWwpIHtcbiAgICAgIC8vIEdsb2JhbCBzZXQgaXMgZXF1aXZhbGVudCB0byBzZXR0aW5nIGluIGFsbCBncm91cHMuICBTaW11bGF0ZSB0aGlzXG4gICAgICAvLyBieSBkZXN0cm95aW5nIGFueSB1bmRvcyBjdXJyZW50bHkgc2NoZWR1bGVkIGZvciB0aGlzIG5hbWUsXG4gICAgICAvLyBhbmQgYWRkaW5nIGFuIHVuZG8gd2l0aCB0aGUgKm5ldyogdmFsdWUgKGluIGNhc2UgaXQgbGF0ZXIgZ2V0c1xuICAgICAgLy8gbG9jYWxseSByZXNldCB3aXRoaW4gdGhpcyBlbnZpcm9ubWVudCkuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudW5kZWZTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWxldGUgdGhpcy51bmRlZlN0YWNrW2ldW25hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy51bmRlZlN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy51bmRlZlN0YWNrW3RoaXMudW5kZWZTdGFjay5sZW5ndGggLSAxXVtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVbmRvIHRoaXMgc2V0IGF0IGVuZCBvZiB0aGlzIGdyb3VwIChwb3NzaWJseSB0byBgdW5kZWZpbmVkYCksXG4gICAgICAvLyB1bmxlc3MgYW4gdW5kbyBpcyBhbHJlYWR5IGluIHBsYWNlLCBpbiB3aGljaCBjYXNlIHRoYXQgb2xkZXJcbiAgICAgIC8vIHZhbHVlIGlzIHRoZSBjb3JyZWN0IG9uZS5cbiAgICAgIHZhciB0b3AgPSB0aGlzLnVuZGVmU3RhY2tbdGhpcy51bmRlZlN0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAodG9wICYmICF0b3AuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdG9wW25hbWVdID0gdGhpcy5jdXJyZW50W25hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWxldGUgdGhpcy5jdXJyZW50W25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxufVxuXG4vKipcbiAqIFByZWRlZmluZWQgbWFjcm9zIGZvciBLYVRlWC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIHNvbWUgY29tbWFuZHMgaW4gdGVybXMgb2Ygb3RoZXJzLlxuICovXG52YXIgbWFjcm9zID0gX21hY3Jvcztcbi8vIG1hY3JvIHRvb2xzXG5cbmRlZmluZU1hY3JvKFwiXFxcXG5vZXhwYW5kXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIC8vIFRoZSBleHBhbnNpb24gaXMgdGhlIHRva2VuIGl0c2VsZjsgYnV0IHRoYXQgdG9rZW4gaXMgaW50ZXJwcmV0ZWRcbiAgLy8gYXMgaWYgaXRzIG1lYW5pbmcgd2VyZSDigJhcXHJlbGF44oCZIGlmIGl0IGlzIGEgY29udHJvbCBzZXF1ZW5jZSB0aGF0XG4gIC8vIHdvdWxkIG9yZGluYXJpbHkgYmUgZXhwYW5kZWQgYnkgVGVY4oCZcyBleHBhbnNpb24gcnVsZXMuXG4gIHZhciB0ID0gY29udGV4dC5wb3BUb2tlbigpO1xuXG4gIGlmIChjb250ZXh0LmlzRXhwYW5kYWJsZSh0LnRleHQpKSB7XG4gICAgdC5ub2V4cGFuZCA9IHRydWU7XG4gICAgdC50cmVhdEFzUmVsYXggPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b2tlbnM6IFt0XSxcbiAgICBudW1BcmdzOiAwXG4gIH07XG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXGV4cGFuZGFmdGVyXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIC8vIFRlWCBmaXJzdCByZWFkcyB0aGUgdG9rZW4gdGhhdCBjb21lcyBpbW1lZGlhdGVseSBhZnRlciBcXGV4cGFuZGFmdGVyLFxuICAvLyB3aXRob3V0IGV4cGFuZGluZyBpdDsgbGV04oCZcyBjYWxsIHRoaXMgdG9rZW4gdC4gVGhlbiBUZVggcmVhZHMgdGhlXG4gIC8vIHRva2VuIHRoYXQgY29tZXMgYWZ0ZXIgdCAoYW5kIHBvc3NpYmx5IG1vcmUgdG9rZW5zLCBpZiB0aGF0IHRva2VuXG4gIC8vIGhhcyBhbiBhcmd1bWVudCksIHJlcGxhY2luZyBpdCBieSBpdHMgZXhwYW5zaW9uLiBGaW5hbGx5IFRlWCBwdXRzXG4gIC8vIHQgYmFjayBpbiBmcm9udCBvZiB0aGF0IGV4cGFuc2lvbi5cbiAgdmFyIHQgPSBjb250ZXh0LnBvcFRva2VuKCk7XG4gIGNvbnRleHQuZXhwYW5kT25jZSh0cnVlKTsgLy8gZXhwYW5kIG9ubHkgYW4gZXhwYW5kYWJsZSB0b2tlblxuXG4gIHJldHVybiB7XG4gICAgdG9rZW5zOiBbdF0sXG4gICAgbnVtQXJnczogMFxuICB9O1xufSk7IC8vIExhVGVYJ3MgXFxAZmlyc3RvZnR3b3sjMX17IzJ9IGV4cGFuZHMgdG8gIzEsIHNraXBwaW5nICMyXG4vLyBUZVggc291cmNlOiBcXGxvbmdcXGRlZlxcQGZpcnN0b2Z0d28jMSMyeyMxfVxuXG5kZWZpbmVNYWNybyhcIlxcXFxAZmlyc3RvZnR3b1wiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgYXJncyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMik7XG4gIHJldHVybiB7XG4gICAgdG9rZW5zOiBhcmdzWzBdLFxuICAgIG51bUFyZ3M6IDBcbiAgfTtcbn0pOyAvLyBMYVRlWCdzIFxcQHNlY29uZG9mdHdveyMxfXsjMn0gZXhwYW5kcyB0byAjMiwgc2tpcHBpbmcgIzFcbi8vIFRlWCBzb3VyY2U6IFxcbG9uZ1xcZGVmXFxAc2Vjb25kb2Z0d28jMSMyeyMyfVxuXG5kZWZpbmVNYWNybyhcIlxcXFxAc2Vjb25kb2Z0d29cIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIGFyZ3MgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDIpO1xuICByZXR1cm4ge1xuICAgIHRva2VuczogYXJnc1sxXSxcbiAgICBudW1BcmdzOiAwXG4gIH07XG59KTsgLy8gTGFUZVgncyBcXEBpZm5leHRjaGFyeyMxfXsjMn17IzN9IGxvb2tzIGFoZWFkIHRvIHRoZSBuZXh0ICh1bmV4cGFuZGVkKVxuLy8gc3ltYm9sIHRoYXQgaXNuJ3QgYSBzcGFjZSwgY29uc3VtaW5nIGFueSBzcGFjZXMgYnV0IG5vdCBjb25zdW1pbmcgdGhlXG4vLyBmaXJzdCBub25zcGFjZSBjaGFyYWN0ZXIuICBJZiB0aGF0IG5vbnNwYWNlIGNoYXJhY3RlciBtYXRjaGVzICMxLCB0aGVuXG4vLyB0aGUgbWFjcm8gZXhwYW5kcyB0byAjMjsgb3RoZXJ3aXNlLCBpdCBleHBhbmRzIHRvICMzLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxAaWZuZXh0Y2hhclwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgYXJncyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMyk7IC8vIHN5bWJvbCwgaWYsIGVsc2VcblxuICBjb250ZXh0LmNvbnN1bWVTcGFjZXMoKTtcbiAgdmFyIG5leHRUb2tlbiA9IGNvbnRleHQuZnV0dXJlKCk7XG5cbiAgaWYgKGFyZ3NbMF0ubGVuZ3RoID09PSAxICYmIGFyZ3NbMF1bMF0udGV4dCA9PT0gbmV4dFRva2VuLnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5zOiBhcmdzWzFdLFxuICAgICAgbnVtQXJnczogMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuczogYXJnc1syXSxcbiAgICAgIG51bUFyZ3M6IDBcbiAgICB9O1xuICB9XG59KTsgLy8gTGFUZVgncyBcXEBpZnN0YXJ7IzF9eyMyfSBsb29rcyBhaGVhZCB0byB0aGUgbmV4dCAodW5leHBhbmRlZCkgc3ltYm9sLlxuLy8gSWYgaXQgaXMgYCpgLCB0aGVuIGl0IGNvbnN1bWVzIHRoZSBzeW1ib2wsIGFuZCB0aGUgbWFjcm8gZXhwYW5kcyB0byAjMTtcbi8vIG90aGVyd2lzZSwgdGhlIG1hY3JvIGV4cGFuZHMgdG8gIzIgKHdpdGhvdXQgY29uc3VtaW5nIHRoZSBzeW1ib2wpLlxuLy8gVGVYIHNvdXJjZTogXFxkZWZcXEBpZnN0YXIjMXtcXEBpZm5leHRjaGFyICp7XFxAZmlyc3RvZnR3b3sjMX19fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxAaWZzdGFyXCIsIFwiXFxcXEBpZm5leHRjaGFyICp7XFxcXEBmaXJzdG9mdHdveyMxfX1cIik7IC8vIExhVGVYJ3MgXFxUZXh0T3JNYXRoeyMxfXsjMn0gZXhwYW5kcyB0byAjMSBpbiB0ZXh0IG1vZGUsICMyIGluIG1hdGggbW9kZVxuXG5kZWZpbmVNYWNybyhcIlxcXFxUZXh0T3JNYXRoXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHZhciBhcmdzID0gY29udGV4dC5jb25zdW1lQXJncygyKTtcblxuICBpZiAoY29udGV4dC5tb2RlID09PSAndGV4dCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5zOiBhcmdzWzBdLFxuICAgICAgbnVtQXJnczogMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuczogYXJnc1sxXSxcbiAgICAgIG51bUFyZ3M6IDBcbiAgICB9O1xuICB9XG59KTsgLy8gTG9va3VwIHRhYmxlIGZvciBwYXJzaW5nIG51bWJlcnMgaW4gYmFzZSA4IHRocm91Z2ggMTZcblxudmFyIGRpZ2l0VG9OdW1iZXIgPSB7XG4gIFwiMFwiOiAwLFxuICBcIjFcIjogMSxcbiAgXCIyXCI6IDIsXG4gIFwiM1wiOiAzLFxuICBcIjRcIjogNCxcbiAgXCI1XCI6IDUsXG4gIFwiNlwiOiA2LFxuICBcIjdcIjogNyxcbiAgXCI4XCI6IDgsXG4gIFwiOVwiOiA5LFxuICBcImFcIjogMTAsXG4gIFwiQVwiOiAxMCxcbiAgXCJiXCI6IDExLFxuICBcIkJcIjogMTEsXG4gIFwiY1wiOiAxMixcbiAgXCJDXCI6IDEyLFxuICBcImRcIjogMTMsXG4gIFwiRFwiOiAxMyxcbiAgXCJlXCI6IDE0LFxuICBcIkVcIjogMTQsXG4gIFwiZlwiOiAxNSxcbiAgXCJGXCI6IDE1XG59OyAvLyBUZVggXFxjaGFyIG1ha2VzIGEgbGl0ZXJhbCBjaGFyYWN0ZXIgKGNhdGNvZGUgMTIpIHVzaW5nIHRoZSBmb2xsb3dpbmcgZm9ybXM6XG4vLyAoc2VlIFRoZSBUZVhCb29rLCBwLiA0Mylcbi8vICAgXFxjaGFyMTIzICAtLSBkZWNpbWFsXG4vLyAgIFxcY2hhcicxMjMgLS0gb2N0YWxcbi8vICAgXFxjaGFyXCIxMjMgLS0gaGV4XG4vLyAgIFxcY2hhcmB4ICAgLS0gY2hhcmFjdGVyIHRoYXQgY2FuIGJlIHdyaXR0ZW4gKGkuZS4gaXNuJ3QgYWN0aXZlKVxuLy8gICBcXGNoYXJgXFx4ICAtLSBjaGFyYWN0ZXIgdGhhdCBjYW5ub3QgYmUgd3JpdHRlbiAoZS5nLiAlKVxuLy8gVGhlc2UgYWxsIHJlZmVyIHRvIGNoYXJhY3RlcnMgZnJvbSB0aGUgZm9udCwgc28gd2UgdHVybiB0aGVtIGludG8gc3BlY2lhbFxuLy8gY2FsbHMgdG8gYSBmdW5jdGlvbiBcXEBjaGFyIGRlYWx0IHdpdGggaW4gdGhlIFBhcnNlci5cblxuZGVmaW5lTWFjcm8oXCJcXFxcY2hhclwiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgdG9rZW4gPSBjb250ZXh0LnBvcFRva2VuKCk7XG4gIHZhciBiYXNlO1xuICB2YXIgbnVtYmVyID0gJyc7XG5cbiAgaWYgKHRva2VuLnRleHQgPT09IFwiJ1wiKSB7XG4gICAgYmFzZSA9IDg7XG4gICAgdG9rZW4gPSBjb250ZXh0LnBvcFRva2VuKCk7XG4gIH0gZWxzZSBpZiAodG9rZW4udGV4dCA9PT0gJ1wiJykge1xuICAgIGJhc2UgPSAxNjtcbiAgICB0b2tlbiA9IGNvbnRleHQucG9wVG9rZW4oKTtcbiAgfSBlbHNlIGlmICh0b2tlbi50ZXh0ID09PSBcImBcIikge1xuICAgIHRva2VuID0gY29udGV4dC5wb3BUb2tlbigpO1xuXG4gICAgaWYgKHRva2VuLnRleHRbMF0gPT09IFwiXFxcXFwiKSB7XG4gICAgICBudW1iZXIgPSB0b2tlbi50ZXh0LmNoYXJDb2RlQXQoMSk7XG4gICAgfSBlbHNlIGlmICh0b2tlbi50ZXh0ID09PSBcIkVPRlwiKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFxjaGFyYCBtaXNzaW5nIGFyZ3VtZW50XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1iZXIgPSB0b2tlbi50ZXh0LmNoYXJDb2RlQXQoMCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJhc2UgPSAxMDtcbiAgfVxuXG4gIGlmIChiYXNlKSB7XG4gICAgLy8gUGFyc2UgYSBudW1iZXIgaW4gdGhlIGdpdmVuIGJhc2UsIHN0YXJ0aW5nIHdpdGggZmlyc3QgYHRva2VuYC5cbiAgICBudW1iZXIgPSBkaWdpdFRvTnVtYmVyW3Rva2VuLnRleHRdO1xuXG4gICAgaWYgKG51bWJlciA9PSBudWxsIHx8IG51bWJlciA+PSBiYXNlKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgYmFzZS1cIiArIGJhc2UgKyBcIiBkaWdpdCBcIiArIHRva2VuLnRleHQpO1xuICAgIH1cblxuICAgIHZhciBkaWdpdDtcblxuICAgIHdoaWxlICgoZGlnaXQgPSBkaWdpdFRvTnVtYmVyW2NvbnRleHQuZnV0dXJlKCkudGV4dF0pICE9IG51bGwgJiYgZGlnaXQgPCBiYXNlKSB7XG4gICAgICBudW1iZXIgKj0gYmFzZTtcbiAgICAgIG51bWJlciArPSBkaWdpdDtcbiAgICAgIGNvbnRleHQucG9wVG9rZW4oKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gXCJcXFxcQGNoYXJ7XCIgKyBudW1iZXIgKyBcIn1cIjtcbn0pOyAvLyBcXG5ld2NvbW1hbmR7XFxtYWNyb31bYXJnc117ZGVmaW5pdGlvbn1cbi8vIFxccmVuZXdjb21tYW5ke1xcbWFjcm99W2FyZ3Nde2RlZmluaXRpb259XG4vLyBUT0RPOiBPcHRpb25hbCBhcmd1bWVudHM6IFxcbmV3Y29tbWFuZHtcXG1hY3JvfVthcmdzXVtkZWZhdWx0XXtkZWZpbml0aW9ufVxuXG52YXIgbmV3Y29tbWFuZCA9IChjb250ZXh0LCBleGlzdHNPSywgbm9uZXhpc3RzT0ssIHNraXBJZkV4aXN0cykgPT4ge1xuICB2YXIgYXJnID0gY29udGV4dC5jb25zdW1lQXJnKCkudG9rZW5zO1xuXG4gIGlmIChhcmcubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcbmV3Y29tbWFuZCdzIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBtYWNybyBuYW1lXCIpO1xuICB9XG5cbiAgdmFyIG5hbWUgPSBhcmdbMF0udGV4dDtcbiAgdmFyIGV4aXN0cyA9IGNvbnRleHQuaXNEZWZpbmVkKG5hbWUpO1xuXG4gIGlmIChleGlzdHMgJiYgIWV4aXN0c09LKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcbmV3Y29tbWFuZHtcIiArIG5hbWUgKyBcIn0gYXR0ZW1wdGluZyB0byByZWRlZmluZSBcIiArIChuYW1lICsgXCI7IHVzZSBcXFxccmVuZXdjb21tYW5kXCIpKTtcbiAgfVxuXG4gIGlmICghZXhpc3RzICYmICFub25leGlzdHNPSykge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiXFxcXHJlbmV3Y29tbWFuZHtcIiArIG5hbWUgKyBcIn0gd2hlbiBjb21tYW5kIFwiICsgbmFtZSArIFwiIFwiICsgXCJkb2VzIG5vdCB5ZXQgZXhpc3Q7IHVzZSBcXFxcbmV3Y29tbWFuZFwiKTtcbiAgfVxuXG4gIHZhciBudW1BcmdzID0gMDtcbiAgYXJnID0gY29udGV4dC5jb25zdW1lQXJnKCkudG9rZW5zO1xuXG4gIGlmIChhcmcubGVuZ3RoID09PSAxICYmIGFyZ1swXS50ZXh0ID09PSBcIltcIikge1xuICAgIHZhciBhcmdUZXh0ID0gJyc7XG4gICAgdmFyIHRva2VuID0gY29udGV4dC5leHBhbmROZXh0VG9rZW4oKTtcblxuICAgIHdoaWxlICh0b2tlbi50ZXh0ICE9PSBcIl1cIiAmJiB0b2tlbi50ZXh0ICE9PSBcIkVPRlwiKSB7XG4gICAgICAvLyBUT0RPOiBTaG91bGQgcHJvcGVybHkgZXhwYW5kIGFyZywgZS5nLiwgaWdub3JlIHt9c1xuICAgICAgYXJnVGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgdG9rZW4gPSBjb250ZXh0LmV4cGFuZE5leHRUb2tlbigpO1xuICAgIH1cblxuICAgIGlmICghYXJnVGV4dC5tYXRjaCgvXlxccypbMC05XStcXHMqJC8pKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50czogXCIgKyBhcmdUZXh0KTtcbiAgICB9XG5cbiAgICBudW1BcmdzID0gcGFyc2VJbnQoYXJnVGV4dCk7XG4gICAgYXJnID0gY29udGV4dC5jb25zdW1lQXJnKCkudG9rZW5zO1xuICB9XG5cbiAgaWYgKCEoZXhpc3RzICYmIHNraXBJZkV4aXN0cykpIHtcbiAgICAvLyBGaW5hbCBhcmcgaXMgdGhlIGV4cGFuc2lvbiBvZiB0aGUgbWFjcm9cbiAgICBjb250ZXh0Lm1hY3Jvcy5zZXQobmFtZSwge1xuICAgICAgdG9rZW5zOiBhcmcsXG4gICAgICBudW1BcmdzXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59O1xuXG5kZWZpbmVNYWNybyhcIlxcXFxuZXdjb21tYW5kXCIsIGNvbnRleHQgPT4gbmV3Y29tbWFuZChjb250ZXh0LCBmYWxzZSwgdHJ1ZSwgZmFsc2UpKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlbmV3Y29tbWFuZFwiLCBjb250ZXh0ID0+IG5ld2NvbW1hbmQoY29udGV4dCwgdHJ1ZSwgZmFsc2UsIGZhbHNlKSk7XG5kZWZpbmVNYWNybyhcIlxcXFxwcm92aWRlY29tbWFuZFwiLCBjb250ZXh0ID0+IG5ld2NvbW1hbmQoY29udGV4dCwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSkpOyAvLyB0ZXJtaW5hbCAoY29uc29sZSkgdG9vbHNcblxuZGVmaW5lTWFjcm8oXCJcXFxcbWVzc2FnZVwiLCBjb250ZXh0ID0+IHtcbiAgdmFyIGFyZyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMSlbMF07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cbiAgY29uc29sZS5sb2coYXJnLnJldmVyc2UoKS5tYXAodG9rZW4gPT4gdG9rZW4udGV4dCkuam9pbihcIlwiKSk7XG4gIHJldHVybiAnJztcbn0pO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXJybWVzc2FnZVwiLCBjb250ZXh0ID0+IHtcbiAgdmFyIGFyZyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMSlbMF07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cbiAgY29uc29sZS5lcnJvcihhcmcucmV2ZXJzZSgpLm1hcCh0b2tlbiA9PiB0b2tlbi50ZXh0KS5qb2luKFwiXCIpKTtcbiAgcmV0dXJuICcnO1xufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxzaG93XCIsIGNvbnRleHQgPT4ge1xuICB2YXIgdG9rID0gY29udGV4dC5wb3BUb2tlbigpO1xuICB2YXIgbmFtZSA9IHRvay50ZXh0OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXG4gIGNvbnNvbGUubG9nKHRvaywgY29udGV4dC5tYWNyb3MuZ2V0KG5hbWUpLCBmdW5jdGlvbnNbbmFtZV0sIHN5bWJvbHMubWF0aFtuYW1lXSwgc3ltYm9scy50ZXh0W25hbWVdKTtcbiAgcmV0dXJuICcnO1xufSk7IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEdyb3VwaW5nXG4vLyBcXGxldFxcYmdyb3VwPXsgXFxsZXRcXGVncm91cD19XG5cbmRlZmluZU1hY3JvKFwiXFxcXGJncm91cFwiLCBcIntcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlZ3JvdXBcIiwgXCJ9XCIpOyAvLyBTeW1ib2xzIGZyb20gbGF0ZXgubHR4OlxuLy8gXFxkZWZ+e1xcbm9icmVha3NwYWNle319XG4vLyBcXGRlZlxcbHF7YH1cbi8vIFxcZGVmXFxycXsnfVxuLy8gXFxkZWYgXFxhYSB7XFxyIGF9XG4vLyBcXGRlZiBcXEFBIHtcXHIgQX1cblxuZGVmaW5lTWFjcm8oXCJ+XCIsIFwiXFxcXG5vYnJlYWtzcGFjZVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxxXCIsIFwiYFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJxXCIsIFwiJ1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFhXCIsIFwiXFxcXHIgYVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEFBXCIsIFwiXFxcXHIgQVwiKTsgLy8gQ29weXJpZ2h0IChDKSBhbmQgcmVnaXN0ZXJlZCAoUikgc3ltYm9scy4gVXNlIHJhdyBzeW1ib2wgaW4gTWF0aE1MLlxuLy8gXFxEZWNsYXJlVGV4dENvbW1hbmREZWZhdWx0e1xcdGV4dGNvcHlyaWdodH17XFx0ZXh0Y2lyY2xlZHtjfX1cbi8vIFxcRGVjbGFyZVRleHRDb21tYW5kRGVmYXVsdHtcXHRleHRyZWdpc3RlcmVkfXtcXHRleHRjaXJjbGVkeyVcbi8vICAgICAgXFxjaGVja0BtYXRoZm9udHNcXGZvbnRzaXplXFxzZkBzaXplXFx6QFxcbWF0aEBmb250c2ZhbHNlXFxzZWxlY3Rmb250IFJ9fVxuLy8gXFxEZWNsYXJlUm9idXN0Q29tbWFuZHtcXGNvcHlyaWdodH17JVxuLy8gICAgXFxpZm1tb2Rle1xcbmZzc0B0ZXh0e1xcdGV4dGNvcHlyaWdodH19XFxlbHNlXFx0ZXh0Y29weXJpZ2h0XFxmaX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcdGV4dGNvcHlyaWdodFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcdGV4dGNpcmNsZWR7Y319e1xcXFxjaGFyYMKpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvcHlyaWdodFwiLCBcIlxcXFxUZXh0T3JNYXRoe1xcXFx0ZXh0Y29weXJpZ2h0fXtcXFxcdGV4dHtcXFxcdGV4dGNvcHlyaWdodH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGV4dHJlZ2lzdGVyZWRcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHRleHRjaXJjbGVke1xcXFxzY3JpcHRzaXplIFJ9fXtcXFxcY2hhcmDCrn1cIik7IC8vIENoYXJhY3RlcnMgb21pdHRlZCBmcm9tIFVuaWNvZGUgcmFuZ2UgMUQ0MDDigJMxRDdGRlxuXG5kZWZpbmVNYWNybyhcIlxcdTIxMkNcIiwgXCJcXFxcbWF0aHNjcntCfVwiKTsgLy8gc2NyaXB0XG5cbmRlZmluZU1hY3JvKFwiXFx1MjEzMFwiLCBcIlxcXFxtYXRoc2Nye0V9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMTMxXCIsIFwiXFxcXG1hdGhzY3J7Rn1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIxMEJcIiwgXCJcXFxcbWF0aHNjcntIfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjExMFwiLCBcIlxcXFxtYXRoc2Nye0l9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMTEyXCIsIFwiXFxcXG1hdGhzY3J7TH1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIxMzNcIiwgXCJcXFxcbWF0aHNjcntNfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjExQlwiLCBcIlxcXFxtYXRoc2Nye1J9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMTJEXCIsIFwiXFxcXG1hdGhmcmFre0N9XCIpOyAvLyBGcmFrdHVyXG5cbmRlZmluZU1hY3JvKFwiXFx1MjEwQ1wiLCBcIlxcXFxtYXRoZnJha3tIfVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjEyOFwiLCBcIlxcXFxtYXRoZnJha3tafVwiKTsgLy8gRGVmaW5lIFxcQmJiayB3aXRoIGEgbWFjcm8gdGhhdCB3b3JrcyBpbiBib3RoIEhUTUwgYW5kIE1hdGhNTC5cblxuZGVmaW5lTWFjcm8oXCJcXFxcQmJia1wiLCBcIlxcXFxCYmJ7a31cIik7IC8vIFVuaWNvZGUgbWlkZGxlIGRvdFxuLy8gVGhlIEthVGVYIGZvbnRzIGRvIG5vdCBjb250YWluIFUrMDBCNy4gSW5zdGVhZCwgXFxjZG90cCBkaXNwbGF5c1xuLy8gdGhlIGRvdCBhdCBVKzIyQzUgYW5kIGdpdmVzIGl0IHB1bmN0IHNwYWNpbmcuXG5cbmRlZmluZU1hY3JvKFwiXFx1MDBiN1wiLCBcIlxcXFxjZG90cFwiKTsgLy8gXFxsbGFwIGFuZCBcXHJsYXAgcmVuZGVyIHRoZWlyIGNvbnRlbnRzIGluIHRleHQgbW9kZVxuXG5kZWZpbmVNYWNybyhcIlxcXFxsbGFwXCIsIFwiXFxcXG1hdGhsbGFwe1xcXFx0ZXh0cm17IzF9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJsYXBcIiwgXCJcXFxcbWF0aHJsYXB7XFxcXHRleHRybXsjMX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY2xhcFwiLCBcIlxcXFxtYXRoY2xhcHtcXFxcdGV4dHJteyMxfX1cIik7IC8vIFxcbWF0aHN0cnV0IGZyb20gdGhlIFRlWGJvb2ssIHAgMzYwXG5cbmRlZmluZU1hY3JvKFwiXFxcXG1hdGhzdHJ1dFwiLCBcIlxcXFx2cGhhbnRvbXsofVwiKTsgLy8gXFx1bmRlcmJhciBmcm9tIFRlWGJvb2sgcCAzNTNcblxuZGVmaW5lTWFjcm8oXCJcXFxcdW5kZXJiYXJcIiwgXCJcXFxcdW5kZXJsaW5le1xcXFx0ZXh0eyMxfX1cIik7IC8vIFxcbm90IGlzIGRlZmluZWQgYnkgYmFzZS9mb250bWF0aC5sdHggdmlhXG4vLyBcXERlY2xhcmVNYXRoU3ltYm9se1xcbm90fXtcXG1hdGhyZWx9e3N5bWJvbHN9e1wiMzZ9XG4vLyBJdCdzIHRodXMgdHJlYXRlZCBsaWtlIGEgXFxtYXRocmVsLCBidXQgZGVmaW5lZCBieSBhIHN5bWJvbCB0aGF0IGhhcyB6ZXJvXG4vLyB3aWR0aCBidXQgZXh0ZW5kcyB0byB0aGUgcmlnaHQuICBXZSB1c2UgXFxybGFwIHRvIGdldCB0aGF0IHNwYWNpbmcuXG4vLyBGb3IgTWF0aE1MIHdlIHdyaXRlIFUrMDMzOCBoZXJlLiBidWlsZE1hdGhNTC5qcyB3aWxsIHRoZW4gZG8gdGhlIG92ZXJsYXkuXG5cbmRlZmluZU1hY3JvKFwiXFxcXG5vdFwiLCAnXFxcXGh0bWxAbWF0aG1se1xcXFxtYXRocmVse1xcXFxtYXRocmxhcFxcXFxAbm90fX17XFxcXGNoYXJcIjMzOH0nKTsgLy8gTmVnYXRlZCBzeW1ib2xzIGZyb20gYmFzZS9mb250bWF0aC5sdHg6XG4vLyBcXGRlZlxcbmVxe1xcbm90PX0gXFxsZXRcXG5lPVxcbmVxXG4vLyBcXERlY2xhcmVSb2J1c3RDb21tYW5kXG4vLyAgIFxcbm90aW57XFxtYXRocmVse1xcbUB0aFxcbWF0aHBhbGV0dGVcXGNAbmNlbFxcaW59fVxuLy8gXFxkZWZcXGNAbmNlbCMxIzJ7XFxtQHRoXFxvb2FsaWdueyRcXGhmaWwjMVxcbWtlcm4xbXUvXFxoZmlsJFxcY3JjciQjMSMyJH19XG5cbmRlZmluZU1hY3JvKFwiXFxcXG5lcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcbWF0aHJlbHtcXFxcbm90PX19e1xcXFxtYXRocmVse1xcXFxjaGFyYOKJoH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbmVcIiwgXCJcXFxcbmVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjYwXCIsIFwiXFxcXG5lcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5vdGluXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxtYXRocmVse3tcXFxcaW59XFxcXG1hdGhsbGFwey9cXFxcbXNraXAxbXV9fX1cIiArIFwie1xcXFxtYXRocmVse1xcXFxjaGFyYOKIiX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjA5XCIsIFwiXFxcXG5vdGluXCIpOyAvLyBVbmljb2RlIHN0YWNrZWQgcmVsYXRpb25zXG5cbmRlZmluZU1hY3JvKFwiXFx1MjI1OFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7PVxcXFxrZXJuey0xZW19XFxcXHJhaXNlYm94ezAuNGVtfXskXFxcXHNjcmlwdHNpemVcXFxcZnJvd24kfX1cIiArIFwifXtcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjU4fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNTlcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFx0aW55XFxcXHdlZGdlfXs9fX17XFxcXG1hdGhyZWx7XFxcXGNoYXJgXFx1MjI1OH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjVBXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxzdGFja3JlbHtcXFxcdGlueVxcXFx2ZWV9ez19fXtcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjVBfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNUJcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFxzY3JpcHRzaXplXFxcXHN0YXJ9ez19fVwiICsgXCJ7XFxcXG1hdGhyZWx7XFxcXGNoYXJgXFx1MjI1Qn19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMjVEXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxzdGFja3JlbHtcXFxcdGlueVxcXFxtYXRocm17ZGVmfX17PX19XCIgKyBcIntcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjVEfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNUVcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFx0aW55XFxcXG1hdGhybXttfX17PX19XCIgKyBcIntcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjVFfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyNUZcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXHN0YWNrcmVse1xcXFx0aW55P317PX19e1xcXFxtYXRocmVse1xcXFxjaGFyYFxcdTIyNUZ9fVwiKTsgLy8gTWlzYyBVbmljb2RlXG5cbmRlZmluZU1hY3JvKFwiXFx1MjdDMlwiLCBcIlxcXFxwZXJwXCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMDNDXCIsIFwiXFxcXG1hdGhjbG9zZXshXFxcXG1rZXJuLTAuOG11IX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyMENcIiwgXCJcXFxcbm90bmlcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIzMUNcIiwgXCJcXFxcdWxjb3JuZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIzMURcIiwgXCJcXFxcdXJjb3JuZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIzMUVcIiwgXCJcXFxcbGxjb3JuZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcdTIzMUZcIiwgXCJcXFxcbHJjb3JuZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcdTAwQTlcIiwgXCJcXFxcY29weXJpZ2h0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUwMEFFXCIsIFwiXFxcXHRleHRyZWdpc3RlcmVkXCIpO1xuZGVmaW5lTWFjcm8oXCJcXHVGRTBGXCIsIFwiXFxcXHRleHRyZWdpc3RlcmVkXCIpOyAvLyBUaGUgS2FUZVggZm9udHMgaGF2ZSBjb3JuZXJzIGF0IGNvZGVwb2ludHMgdGhhdCBkb24ndCBtYXRjaCBVbmljb2RlLlxuLy8gRm9yIE1hdGhNTCBwdXJwb3NlcywgdXNlIHRoZSBVbmljb2RlIGNvZGUgcG9pbnQuXG5cbmRlZmluZU1hY3JvKFwiXFxcXHVsY29ybmVyXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAdWxjb3JuZXJ9e1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjMxY319XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXJjb3JuZXJcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEB1cmNvcm5lcn17XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMzFkfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsbGNvcm5lclwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQGxsY29ybmVyfXtcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIzMWV9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxyY29ybmVyXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbHJjb3JuZXJ9e1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjMxZn19XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBMYVRlWF8yzrVcbi8vIFxcdmRvdHN7XFx2Ym94e1xcYmFzZWxpbmVza2lwNFxccEAgIFxcbGluZXNraXBsaW1pdFxcekBcbi8vIFxca2VybjZcXHBAXFxoYm94ey59XFxoYm94ey59XFxoYm94ey59fX1cbi8vIFdlJ2xsIGNhbGwgXFx2YXJ2ZG90cywgd2hpY2ggZ2V0cyBhIGdseXBoIGZyb20gc3ltYm9scy5qcy5cbi8vIFRoZSB6ZXJvLXdpZHRoIHJ1bGUgZ2V0cyB1cyBhbiBlcXVpdmFsZW50IHRvIHRoZSB2ZXJ0aWNhbCA2cHQga2Vybi5cblxuZGVmaW5lTWFjcm8oXCJcXFxcdmRvdHNcIiwgXCJ7XFxcXHZhcnZkb3RzXFxcXHJ1bGV7MHB0fXsxNXB0fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyZWVcIiwgXCJcXFxcdmRvdHNcIik7IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGFtc21hdGguc3R5XG4vLyBodHRwOi8vbWlycm9ycy5jb25jZXJ0cGFzcy5jb20vdGV4LWFyY2hpdmUvbWFjcm9zL2xhdGV4L3JlcXVpcmVkL2Ftc21hdGgvYW1zbWF0aC5wZGZcbi8vIEl0YWxpYyBHcmVlayBjYXBpdGFsIGxldHRlcnMuICBBTVMgZGVmaW5lcyB0aGVzZSB3aXRoIFxcRGVjbGFyZU1hdGhTeW1ib2wsXG4vLyBidXQgdGhleSBhcmUgZXF1aXZhbGVudCB0byBcXG1hdGhpdHtcXExldHRlcn0uXG5cbmRlZmluZU1hY3JvKFwiXFxcXHZhckdhbW1hXCIsIFwiXFxcXG1hdGhpdHtcXFxcR2FtbWF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyRGVsdGFcIiwgXCJcXFxcbWF0aGl0e1xcXFxEZWx0YX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJUaGV0YVwiLCBcIlxcXFxtYXRoaXR7XFxcXFRoZXRhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhckxhbWJkYVwiLCBcIlxcXFxtYXRoaXR7XFxcXExhbWJkYX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJYaVwiLCBcIlxcXFxtYXRoaXR7XFxcXFhpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhclBpXCIsIFwiXFxcXG1hdGhpdHtcXFxcUGl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyU2lnbWFcIiwgXCJcXFxcbWF0aGl0e1xcXFxTaWdtYX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJVcHNpbG9uXCIsIFwiXFxcXG1hdGhpdHtcXFxcVXBzaWxvbn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJQaGlcIiwgXCJcXFxcbWF0aGl0e1xcXFxQaGl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyUHNpXCIsIFwiXFxcXG1hdGhpdHtcXFxcUHNpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhck9tZWdhXCIsIFwiXFxcXG1hdGhpdHtcXFxcT21lZ2F9XCIpOyAvL1xcbmV3Y29tbWFuZHtcXHN1YnN0YWNrfVsxXXtcXHN1YmFycmF5e2N9IzFcXGVuZHN1YmFycmF5fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxzdWJzdGFja1wiLCBcIlxcXFxiZWdpbntzdWJhcnJheX17Y30jMVxcXFxlbmR7c3ViYXJyYXl9XCIpOyAvLyBcXHJlbmV3Y29tbWFuZHtcXGNvbG9ufXtcXG5vYnJlYWtcXG1za2lwMm11XFxtYXRocHVuY3R7fVxcbm9uc2NyaXB0XG4vLyBcXG1rZXJuLVxcdGhpbm11c2tpcHs6fVxcbXNraXA2bXVwbHVzMW11XFxyZWxheH1cblxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25cIiwgXCJcXFxcbm9icmVha1xcXFxtc2tpcDJtdVxcXFxtYXRocHVuY3R7fVwiICsgXCJcXFxcbWF0aGNob2ljZXtcXFxcbWtlcm4tM211fXtcXFxcbWtlcm4tM211fXt9e317On1cXFxcbXNraXA2bXVcXFxccmVsYXhcIik7IC8vIFxcbmV3Y29tbWFuZHtcXGJveGVkfVsxXXtcXGZib3h7XFxtQHRoJFxcZGlzcGxheXN0eWxlIzEkfX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcYm94ZWRcIiwgXCJcXFxcZmJveHskXFxcXGRpc3BsYXlzdHlsZXsjMX0kfVwiKTsgLy8gXFxkZWZcXGlmZntcXERPVFNCXFw7XFxMb25nbGVmdHJpZ2h0YXJyb3dcXDt9XG4vLyBcXGRlZlxcaW1wbGllc3tcXERPVFNCXFw7XFxMb25ncmlnaHRhcnJvd1xcO31cbi8vIFxcZGVmXFxpbXBsaWVkYnl7XFxET1RTQlxcO1xcTG9uZ2xlZnRhcnJvd1xcO31cblxuZGVmaW5lTWFjcm8oXCJcXFxcaWZmXCIsIFwiXFxcXERPVFNCXFxcXDtcXFxcTG9uZ2xlZnRyaWdodGFycm93XFxcXDtcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpbXBsaWVzXCIsIFwiXFxcXERPVFNCXFxcXDtcXFxcTG9uZ3JpZ2h0YXJyb3dcXFxcO1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGltcGxpZWRieVwiLCBcIlxcXFxET1RTQlxcXFw7XFxcXExvbmdsZWZ0YXJyb3dcXFxcO1wiKTsgLy8gXFxkZWZcXGRkZG90IzF7e1xcbWF0aG9weyMxfVxcbGltaXRzXntcXHZib3ggdG8tMS40XFxleEB7XFxrZXJuLVxcdHdAXFxleEBcbi8vICBcXGhib3h7XFxub3JtYWxmb250IC4uLn1cXHZzc319fX1cbi8vIFdlIHVzZSBcXG92ZXJzZXQgd2hpY2ggYXZvaWRzIHRoZSB2ZXJ0aWNhbCBzaGlmdCBvZiBcXG1hdGhvcC5cblxuZGVmaW5lTWFjcm8oXCJcXFxcZGRkb3RcIiwgXCJ7XFxcXG92ZXJzZXR7XFxcXHJhaXNlYm94ey0wLjFleH17XFxcXG5vcm1hbHNpemUgLi4ufX17IzF9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRkZGRvdFwiLCBcIntcXFxcb3ZlcnNldHtcXFxccmFpc2Vib3h7LTAuMWV4fXtcXFxcbm9ybWFsc2l6ZSAuLi4ufX17IzF9fVwiKTsgLy8gQU1TTWF0aCdzIGF1dG9tYXRpYyBcXGRvdHMsIGJhc2VkIG9uIFxcbWRvdHNAQCBtYWNyby5cblxudmFyIGRvdHNCeVRva2VuID0ge1xuICAnLCc6ICdcXFxcZG90c2MnLFxuICAnXFxcXG5vdCc6ICdcXFxcZG90c2InLFxuICAvLyBcXGtleWJpbkAgY2hlY2tzIGZvciB0aGUgZm9sbG93aW5nOlxuICAnKyc6ICdcXFxcZG90c2InLFxuICAnPSc6ICdcXFxcZG90c2InLFxuICAnPCc6ICdcXFxcZG90c2InLFxuICAnPic6ICdcXFxcZG90c2InLFxuICAnLSc6ICdcXFxcZG90c2InLFxuICAnKic6ICdcXFxcZG90c2InLFxuICAnOic6ICdcXFxcZG90c2InLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxET1RTQjpcbiAgJ1xcXFxET1RTQic6ICdcXFxcZG90c2InLFxuICAnXFxcXGNvcHJvZCc6ICdcXFxcZG90c2InLFxuICAnXFxcXGJpZ3ZlZSc6ICdcXFxcZG90c2InLFxuICAnXFxcXGJpZ3dlZGdlJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlndXBsdXMnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxiaWdjYXAnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxiaWdjdXAnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxwcm9kJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcc3VtJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlnb3RpbWVzJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlnb3BsdXMnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxiaWdvZG90JzogJ1xcXFxkb3RzYicsXG4gICdcXFxcYmlnc3FjdXAnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxBbmQnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxsb25ncmlnaHRhcnJvdyc6ICdcXFxcZG90c2InLFxuICAnXFxcXExvbmdyaWdodGFycm93JzogJ1xcXFxkb3RzYicsXG4gICdcXFxcbG9uZ2xlZnRhcnJvdyc6ICdcXFxcZG90c2InLFxuICAnXFxcXExvbmdsZWZ0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxsb25nbGVmdHJpZ2h0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxMb25nbGVmdHJpZ2h0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxtYXBzdG8nOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxsb25nbWFwc3RvJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcaG9va3JpZ2h0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFxkb3RlcSc6ICdcXFxcZG90c2InLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxtYXRoYmluOlxuICAnXFxcXG1hdGhiaW4nOiAnXFxcXGRvdHNiJyxcbiAgLy8gU3ltYm9scyB3aG9zZSBkZWZpbml0aW9uIHN0YXJ0cyB3aXRoIFxcbWF0aHJlbDpcbiAgJ1xcXFxtYXRocmVsJzogJ1xcXFxkb3RzYicsXG4gICdcXFxccmVsYmFyJzogJ1xcXFxkb3RzYicsXG4gICdcXFxcUmVsYmFyJzogJ1xcXFxkb3RzYicsXG4gICdcXFxceHJpZ2h0YXJyb3cnOiAnXFxcXGRvdHNiJyxcbiAgJ1xcXFx4bGVmdGFycm93JzogJ1xcXFxkb3RzYicsXG4gIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcXERPVFNJOlxuICAnXFxcXERPVFNJJzogJ1xcXFxkb3RzaScsXG4gICdcXFxcaW50JzogJ1xcXFxkb3RzaScsXG4gICdcXFxcb2ludCc6ICdcXFxcZG90c2knLFxuICAnXFxcXGlpbnQnOiAnXFxcXGRvdHNpJyxcbiAgJ1xcXFxpaWludCc6ICdcXFxcZG90c2knLFxuICAnXFxcXGlpaWludCc6ICdcXFxcZG90c2knLFxuICAnXFxcXGlkb3RzaW50JzogJ1xcXFxkb3RzaScsXG4gIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcXERPVFNYOlxuICAnXFxcXERPVFNYJzogJ1xcXFxkb3RzeCdcbn07XG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIC8vIFRPRE86IElmIHVzZWQgaW4gdGV4dCBtb2RlLCBzaG91bGQgZXhwYW5kIHRvIFxcdGV4dGVsbGlwc2lzLlxuICAvLyBIb3dldmVyLCBpbiBLYVRlWCwgXFx0ZXh0ZWxsaXBzaXMgYW5kIFxcbGRvdHMgYmVoYXZlIHRoZSBzYW1lXG4gIC8vIChpbiB0ZXh0IG1vZGUpLCBhbmQgaXQncyB1bmxpa2VseSB3ZSdkIHNlZSBhbnkgb2YgdGhlIG1hdGggY29tbWFuZHNcbiAgLy8gdGhhdCBhZmZlY3QgdGhlIGJlaGF2aW9yIG9mIFxcZG90cyB3aGVuIGluIHRleHQgbW9kZS4gIFNvIGZpbmUgZm9yIG5vd1xuICAvLyAodW50aWwgd2Ugc3VwcG9ydCBcXGlmbW1vZGUgLi4uIFxcZWxzZSAuLi4gXFxmaSkuXG4gIHZhciB0aGVkb3RzID0gJ1xcXFxkb3Rzbyc7XG4gIHZhciBuZXh0ID0gY29udGV4dC5leHBhbmRBZnRlckZ1dHVyZSgpLnRleHQ7XG5cbiAgaWYgKG5leHQgaW4gZG90c0J5VG9rZW4pIHtcbiAgICB0aGVkb3RzID0gZG90c0J5VG9rZW5bbmV4dF07XG4gIH0gZWxzZSBpZiAobmV4dC5zbGljZSgwLCA0KSA9PT0gJ1xcXFxub3QnKSB7XG4gICAgdGhlZG90cyA9ICdcXFxcZG90c2InO1xuICB9IGVsc2UgaWYgKG5leHQgaW4gc3ltYm9scy5tYXRoKSB7XG4gICAgaWYgKFsnYmluJywgJ3JlbCddLmluY2x1ZGVzKHN5bWJvbHMubWF0aFtuZXh0XS5ncm91cCkpIHtcbiAgICAgIHRoZWRvdHMgPSAnXFxcXGRvdHNiJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhlZG90cztcbn0pO1xudmFyIHNwYWNlQWZ0ZXJEb3RzID0ge1xuICAvLyBcXHJpZ2h0ZGVsaW1AIGNoZWNrcyBmb3IgdGhlIGZvbGxvd2luZzpcbiAgJyknOiB0cnVlLFxuICAnXSc6IHRydWUsXG4gICdcXFxccmJyYWNrJzogdHJ1ZSxcbiAgJ1xcXFx9JzogdHJ1ZSxcbiAgJ1xcXFxyYnJhY2UnOiB0cnVlLFxuICAnXFxcXHJhbmdsZSc6IHRydWUsXG4gICdcXFxccmNlaWwnOiB0cnVlLFxuICAnXFxcXHJmbG9vcic6IHRydWUsXG4gICdcXFxccmdyb3VwJzogdHJ1ZSxcbiAgJ1xcXFxybW91c3RhY2hlJzogdHJ1ZSxcbiAgJ1xcXFxyaWdodCc6IHRydWUsXG4gICdcXFxcYmlncic6IHRydWUsXG4gICdcXFxcYmlnZ3InOiB0cnVlLFxuICAnXFxcXEJpZ3InOiB0cnVlLFxuICAnXFxcXEJpZ2dyJzogdHJ1ZSxcbiAgLy8gXFxleHRyYUAgYWxzbyB0ZXN0cyBmb3IgdGhlIGZvbGxvd2luZzpcbiAgJyQnOiB0cnVlLFxuICAvLyBcXGV4dHJhcEAgY2hlY2tzIGZvciB0aGUgZm9sbG93aW5nOlxuICAnOyc6IHRydWUsXG4gICcuJzogdHJ1ZSxcbiAgJywnOiB0cnVlXG59O1xuZGVmaW5lTWFjcm8oXCJcXFxcZG90c29cIiwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIG5leHQgPSBjb250ZXh0LmZ1dHVyZSgpLnRleHQ7XG5cbiAgaWYgKG5leHQgaW4gc3BhY2VBZnRlckRvdHMpIHtcbiAgICByZXR1cm4gXCJcXFxcbGRvdHNcXFxcLFwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlxcXFxsZG90c1wiO1xuICB9XG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNjXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHZhciBuZXh0ID0gY29udGV4dC5mdXR1cmUoKS50ZXh0OyAvLyBcXGRvdHNjIHVzZXMgXFxleHRyYUAgYnV0IG5vdCBcXGV4dHJhcEAsIGluc3RlYWQgc3BlY2lhbGx5IGNoZWNraW5nIGZvclxuICAvLyAnOycgYW5kICcuJywgYnV0IGRvZXNuJ3QgY2hlY2sgZm9yICcsJy5cblxuICBpZiAobmV4dCBpbiBzcGFjZUFmdGVyRG90cyAmJiBuZXh0ICE9PSAnLCcpIHtcbiAgICByZXR1cm4gXCJcXFxcbGRvdHNcXFxcLFwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlxcXFxsZG90c1wiO1xuICB9XG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXGNkb3RzXCIsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHZhciBuZXh0ID0gY29udGV4dC5mdXR1cmUoKS50ZXh0O1xuXG4gIGlmIChuZXh0IGluIHNwYWNlQWZ0ZXJEb3RzKSB7XG4gICAgcmV0dXJuIFwiXFxcXEBjZG90c1xcXFwsXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXFxcXEBjZG90c1wiO1xuICB9XG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNiXCIsIFwiXFxcXGNkb3RzXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZG90c21cIiwgXCJcXFxcY2RvdHNcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzaVwiLCBcIlxcXFwhXFxcXGNkb3RzXCIpOyAvLyBhbXNtYXRoIGRvZXNuJ3QgYWN0dWFsbHkgZGVmaW5lIFxcZG90c3gsIGJ1dCBcXGRvdHMgZm9sbG93ZWQgYnkgYSBtYWNyb1xuLy8gc3RhcnRpbmcgd2l0aCBcXERPVFNYIGltcGxpZXMgXFxkb3RzbywgYW5kIHRoZW4gXFxleHRyYUAgZGV0ZWN0cyB0aGlzIGNhc2Vcbi8vIGFuZCBmb3JjZXMgdGhlIGFkZGVkIGBcXCxgLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzeFwiLCBcIlxcXFxsZG90c1xcXFwsXCIpOyAvLyBcXGxldFxcRE9UU0lcXHJlbGF4XG4vLyBcXGxldFxcRE9UU0JcXHJlbGF4XG4vLyBcXGxldFxcRE9UU1hcXHJlbGF4XG5cbmRlZmluZU1hY3JvKFwiXFxcXERPVFNJXCIsIFwiXFxcXHJlbGF4XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRE9UU0JcIiwgXCJcXFxccmVsYXhcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxET1RTWFwiLCBcIlxcXFxyZWxheFwiKTsgLy8gU3BhY2luZywgYmFzZWQgb24gYW1zbWF0aC5zdHkncyBvdmVycmlkZSBvZiBMYVRlWCBkZWZhdWx0c1xuLy8gXFxEZWNsYXJlUm9idXN0Q29tbWFuZHtcXHRtc3BhY2V9WzNdeyVcbi8vICAgXFxpZm1tb2RlXFxtc2tpcCMxIzJcXGVsc2VcXGtlcm4jMSMzXFxmaVxccmVsYXh9XG5cbmRlZmluZU1hY3JvKFwiXFxcXHRtc3BhY2VcIiwgXCJcXFxcVGV4dE9yTWF0aHtcXFxca2VybiMxIzN9e1xcXFxtc2tpcCMxIzJ9XFxcXHJlbGF4XCIpOyAvLyBcXHJlbmV3Y29tbWFuZHtcXCx9e1xcdG1zcGFjZStcXHRoaW5tdXNraXB7LjE2NjdlbX19XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXHRoaW5tdXNraXBcblxuZGVmaW5lTWFjcm8oXCJcXFxcLFwiLCBcIlxcXFx0bXNwYWNlK3szbXV9ey4xNjY3ZW19XCIpOyAvLyBcXGxldFxcdGhpbnNwYWNlXFwsXG5cbmRlZmluZU1hY3JvKFwiXFxcXHRoaW5zcGFjZVwiLCBcIlxcXFwsXCIpOyAvLyBcXGRlZlxcPntcXG1za2lwXFxtZWRtdXNraXB9XG4vLyBcXHJlbmV3Y29tbWFuZHtcXDp9e1xcdG1zcGFjZStcXG1lZG11c2tpcHsuMjIyMmVtfX1cbi8vIFRPRE86IFxcPiBhbmQgbWF0aCBtb2RlIG9mIFxcOiBzaG91bGQgdXNlIFxcbWVkbXVza2lwID0gNG11IHBsdXMgMm11IG1pbnVzIDRtdVxuXG5kZWZpbmVNYWNybyhcIlxcXFw+XCIsIFwiXFxcXG1za2lwezRtdX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFw6XCIsIFwiXFxcXHRtc3BhY2UrezRtdX17LjIyMjJlbX1cIik7IC8vIFxcbGV0XFxtZWRzcGFjZVxcOlxuXG5kZWZpbmVNYWNybyhcIlxcXFxtZWRzcGFjZVwiLCBcIlxcXFw6XCIpOyAvLyBcXHJlbmV3Y29tbWFuZHtcXDt9e1xcdG1zcGFjZStcXHRoaWNrbXVza2lwey4yNzc3ZW19fVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFx0aGlja211c2tpcCA9IDVtdSBwbHVzIDVtdVxuXG5kZWZpbmVNYWNybyhcIlxcXFw7XCIsIFwiXFxcXHRtc3BhY2UrezVtdX17LjI3NzdlbX1cIik7IC8vIFxcbGV0XFx0aGlja3NwYWNlXFw7XG5cbmRlZmluZU1hY3JvKFwiXFxcXHRoaWNrc3BhY2VcIiwgXCJcXFxcO1wiKTsgLy8gXFxyZW5ld2NvbW1hbmR7XFwhfXtcXHRtc3BhY2UtXFx0aGlubXVza2lwey4xNjY3ZW19fVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFx0aGlubXVza2lwXG5cbmRlZmluZU1hY3JvKFwiXFxcXCFcIiwgXCJcXFxcdG1zcGFjZS17M211fXsuMTY2N2VtfVwiKTsgLy8gXFxsZXRcXG5lZ3RoaW5zcGFjZVxcIVxuXG5kZWZpbmVNYWNybyhcIlxcXFxuZWd0aGluc3BhY2VcIiwgXCJcXFxcIVwiKTsgLy8gXFxuZXdjb21tYW5ke1xcbmVnbWVkc3BhY2V9e1xcdG1zcGFjZS1cXG1lZG11c2tpcHsuMjIyMmVtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcbWVkbXVza2lwXG5cbmRlZmluZU1hY3JvKFwiXFxcXG5lZ21lZHNwYWNlXCIsIFwiXFxcXHRtc3BhY2UtezRtdX17LjIyMjJlbX1cIik7IC8vIFxcbmV3Y29tbWFuZHtcXG5lZ3RoaWNrc3BhY2V9e1xcdG1zcGFjZS1cXHRoaWNrbXVza2lwey4yNzc3ZW19fVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFx0aGlja211c2tpcFxuXG5kZWZpbmVNYWNybyhcIlxcXFxuZWd0aGlja3NwYWNlXCIsIFwiXFxcXHRtc3BhY2UtezVtdX17LjI3N2VtfVwiKTsgLy8gXFxkZWZcXGVuc3BhY2V7XFxrZXJuLjVlbSB9XG5cbmRlZmluZU1hY3JvKFwiXFxcXGVuc3BhY2VcIiwgXCJcXFxca2Vybi41ZW0gXCIpOyAvLyBcXGRlZlxcZW5za2lwe1xcaHNraXAuNWVtXFxyZWxheH1cblxuZGVmaW5lTWFjcm8oXCJcXFxcZW5za2lwXCIsIFwiXFxcXGhza2lwLjVlbVxcXFxyZWxheFwiKTsgLy8gXFxkZWZcXHF1YWR7XFxoc2tpcDFlbVxccmVsYXh9XG5cbmRlZmluZU1hY3JvKFwiXFxcXHF1YWRcIiwgXCJcXFxcaHNraXAxZW1cXFxccmVsYXhcIik7IC8vIFxcZGVmXFxxcXVhZHtcXGhza2lwMmVtXFxyZWxheH1cblxuZGVmaW5lTWFjcm8oXCJcXFxccXF1YWRcIiwgXCJcXFxcaHNraXAyZW1cXFxccmVsYXhcIik7IC8vIFxcdGFnQGluQGRpc3BsYXkgZm9ybSBvZiBcXHRhZ1xuXG5kZWZpbmVNYWNybyhcIlxcXFx0YWdcIiwgXCJcXFxcQGlmc3RhclxcXFx0YWdAbGl0ZXJhbFxcXFx0YWdAcGFyZW5cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0YWdAcGFyZW5cIiwgXCJcXFxcdGFnQGxpdGVyYWx7KHsjMX0pfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRhZ0BsaXRlcmFsXCIsIGNvbnRleHQgPT4ge1xuICBpZiAoY29udGV4dC5tYWNyb3MuZ2V0KFwiXFxcXGRmQHRhZ1wiKSkge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiTXVsdGlwbGUgXFxcXHRhZ1wiKTtcbiAgfVxuXG4gIHJldHVybiBcIlxcXFxnZGVmXFxcXGRmQHRhZ3tcXFxcdGV4dHsjMX19XCI7XG59KTsgLy8gXFxyZW5ld2NvbW1hbmR7XFxibW9kfXtcXG5vbnNjcmlwdFxcbXNraXAtXFxtZWRtdXNraXBcXG1rZXJuNW11XFxtYXRoYmluXG4vLyAgIHtcXG9wZXJhdG9yQGZvbnQgbW9kfVxccGVuYWx0eTkwMFxuLy8gICBcXG1rZXJuNW11XFxub25zY3JpcHRcXG1za2lwLVxcbWVkbXVza2lwfVxuLy8gXFxuZXdjb21tYW5ke1xccG9kfVsxXXtcXGFsbG93YnJlYWtcbi8vICAgXFxpZkBkaXNwbGF5XFxta2VybjE4bXVcXGVsc2VcXG1rZXJuOG11XFxmaSgjMSl9XG4vLyBcXHJlbmV3Y29tbWFuZHtcXHBtb2R9WzFde1xccG9ke3tcXG9wZXJhdG9yQGZvbnQgbW9kfVxcbWtlcm42bXUjMX19XG4vLyBcXG5ld2NvbW1hbmR7XFxtb2R9WzFde1xcYWxsb3dicmVha1xcaWZAZGlzcGxheVxcbWtlcm4xOG11XG4vLyAgIFxcZWxzZVxcbWtlcm4xMm11XFxmaXtcXG9wZXJhdG9yQGZvbnQgbW9kfVxcLFxcLCMxfVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFxtZWRtdXNraXAgPSA0bXUgcGx1cyAybXUgbWludXMgNG11XG5cbmRlZmluZU1hY3JvKFwiXFxcXGJtb2RcIiwgXCJcXFxcbWF0aGNob2ljZXtcXFxcbXNraXAxbXV9e1xcXFxtc2tpcDFtdX17XFxcXG1za2lwNW11fXtcXFxcbXNraXA1bXV9XCIgKyBcIlxcXFxtYXRoYmlue1xcXFxybSBtb2R9XCIgKyBcIlxcXFxtYXRoY2hvaWNle1xcXFxtc2tpcDFtdX17XFxcXG1za2lwMW11fXtcXFxcbXNraXA1bXV9e1xcXFxtc2tpcDVtdX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwb2RcIiwgXCJcXFxcYWxsb3dicmVha1wiICsgXCJcXFxcbWF0aGNob2ljZXtcXFxcbWtlcm4xOG11fXtcXFxcbWtlcm44bXV9e1xcXFxta2VybjhtdX17XFxcXG1rZXJuOG11fSgjMSlcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwbW9kXCIsIFwiXFxcXHBvZHt7XFxcXHJtIG1vZH1cXFxcbWtlcm42bXUjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtb2RcIiwgXCJcXFxcYWxsb3dicmVha1wiICsgXCJcXFxcbWF0aGNob2ljZXtcXFxcbWtlcm4xOG11fXtcXFxcbWtlcm4xMm11fXtcXFxcbWtlcm4xMm11fXtcXFxcbWtlcm4xMm11fVwiICsgXCJ7XFxcXHJtIG1vZH1cXFxcLFxcXFwsIzFcIik7IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIExhVGVYIHNvdXJjZTJlXG4vLyBcXGV4cGFuZGFmdGVyXFxsZXRcXGV4cGFuZGFmdGVyXFxAbm9ybWFsY3Jcbi8vICAgICBcXGNzbmFtZVxcZXhwYW5kYWZ0ZXJcXEBnb2JibGVcXHN0cmluZ1xcXFwgXFxlbmRjc25hbWVcbi8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmRcXG5ld2xpbmV7XFxAbm9ybWFsY3JcXHJlbGF4fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxuZXdsaW5lXCIsIFwiXFxcXFxcXFxcXFxccmVsYXhcIik7IC8vIFxcZGVmXFxUZVh7VFxca2Vybi0uMTY2N2VtXFxsb3dlci41ZXhcXGhib3h7RX1cXGtlcm4tLjEyNWVtWFxcQH1cbi8vIFRPRE86IERvZXNuJ3Qgbm9ybWFsbHkgd29yayBpbiBtYXRoIG1vZGUgYmVjYXVzZSBcXEAgZmFpbHMuICBLYVRlWCBkb2Vzbid0XG4vLyBzdXBwb3J0IFxcQCB5ZXQsIHNvIHRoYXQncyBvbWl0dGVkLCBhbmQgd2UgYWRkIFxcdGV4dCBzbyB0aGF0IHRoZSByZXN1bHRcbi8vIGRvZXNuJ3QgbG9vayBmdW5ueSBpbiBtYXRoIG1vZGUuXG5cbmRlZmluZU1hY3JvKFwiXFxcXFRlWFwiLCBcIlxcXFx0ZXh0cm17XFxcXGh0bWxAbWF0aG1se1wiICsgXCJUXFxcXGtlcm4tLjE2NjdlbVxcXFxyYWlzZWJveHstLjVleH17RX1cXFxca2Vybi0uMTI1ZW1YXCIgKyBcIn17VGVYfX1cIik7IC8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmR7XFxMYVRlWH17TFxca2Vybi0uMzZlbSVcbi8vICAgICAgICAge1xcc2JveFxcekAgVCVcbi8vICAgICAgICAgIFxcdmJveCB0b1xcaHRcXHpAe1xcaGJveHtcXGNoZWNrQG1hdGhmb250c1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxmb250c2l6ZVxcc2ZAc2l6ZVxcekBcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbWF0aEBmb250c2ZhbHNlXFxzZWxlY3Rmb250XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBfSVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIFxcdnNzfSVcbi8vICAgICAgICAgfSVcbi8vICAgICAgICAgXFxrZXJuLS4xNWVtJVxuLy8gICAgICAgICBcXFRlWH1cbi8vIFRoaXMgY29kZSBhbGlnbnMgdGhlIHRvcCBvZiB0aGUgQSB3aXRoIHRoZSBUIChmcm9tIHRoZSBwZXJzcGVjdGl2ZSBvZiBUZVgnc1xuLy8gYm94ZXMsIHRob3VnaCB2aXN1YWxseSB0aGUgQSBhcHBlYXJzIHRvIGV4dGVuZCBhYm92ZSBzbGlnaHRseSkuXG4vLyBXZSBjb21wdXRlIHRoZSBjb3JyZXNwb25kaW5nIFxccmFpc2Vib3ggd2hlbiBBIGlzIHJlbmRlcmVkIGluIFxcbm9ybWFsc2l6ZVxuLy8gXFxzY3JpcHRzdHlsZSwgd2hpY2ggaGFzIGEgc2NhbGUgZmFjdG9yIG9mIDAuNyAoc2VlIE9wdGlvbnMuanMpLlxuXG52YXIgbGF0ZXhSYWlzZUEgPSBtYWtlRW0oZm9udE1ldHJpY3NEYXRhWydNYWluLVJlZ3VsYXInXVtcIlRcIi5jaGFyQ29kZUF0KDApXVsxXSAtIDAuNyAqIGZvbnRNZXRyaWNzRGF0YVsnTWFpbi1SZWd1bGFyJ11bXCJBXCIuY2hhckNvZGVBdCgwKV1bMV0pO1xuZGVmaW5lTWFjcm8oXCJcXFxcTGFUZVhcIiwgXCJcXFxcdGV4dHJte1xcXFxodG1sQG1hdGhtbHtcIiArIChcIkxcXFxca2Vybi0uMzZlbVxcXFxyYWlzZWJveHtcIiArIGxhdGV4UmFpc2VBICsgXCJ9e1xcXFxzY3JpcHRzdHlsZSBBfVwiKSArIFwiXFxcXGtlcm4tLjE1ZW1cXFxcVGVYfXtMYVRlWH19XCIpOyAvLyBOZXcgS2FUZVggbG9nbyBiYXNlZCBvbiB0d2Vha2luZyBMYVRlWCBsb2dvXG5cbmRlZmluZU1hY3JvKFwiXFxcXEthVGVYXCIsIFwiXFxcXHRleHRybXtcXFxcaHRtbEBtYXRobWx7XCIgKyAoXCJLXFxcXGtlcm4tLjE3ZW1cXFxccmFpc2Vib3h7XCIgKyBsYXRleFJhaXNlQSArIFwifXtcXFxcc2NyaXB0c3R5bGUgQX1cIikgKyBcIlxcXFxrZXJuLS4xNWVtXFxcXFRlWH17S2FUZVh9fVwiKTsgLy8gXFxEZWNsYXJlUm9idXN0Q29tbWFuZFxcaHNwYWNle1xcQGlmc3RhclxcQGhzcGFjZXJcXEBoc3BhY2V9XG4vLyBcXGRlZlxcQGhzcGFjZSMxe1xcaHNraXAgICMxXFxyZWxheH1cbi8vIFxcZGVmXFxAaHNwYWNlciMxe1xcdnJ1bGUgXFxAd2lkdGhcXHpAXFxub2JyZWFrXG4vLyAgICAgICAgICAgICAgICAgXFxoc2tpcCAjMVxcaHNraXAgXFx6QHNraXB9XG5cbmRlZmluZU1hY3JvKFwiXFxcXGhzcGFjZVwiLCBcIlxcXFxAaWZzdGFyXFxcXEBoc3BhY2VyXFxcXEBoc3BhY2VcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxAaHNwYWNlXCIsIFwiXFxcXGhza2lwICMxXFxcXHJlbGF4XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQGhzcGFjZXJcIiwgXCJcXFxccnVsZXswcHR9ezBwdH1cXFxcaHNraXAgIzFcXFxccmVsYXhcIik7IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIG1hdGh0b29scy5zdHlcbi8vXFxwcm92aWRlY29tbWFuZFxcb3JkaW5hcnljb2xvbns6fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxvcmRpbmFyeWNvbG9uXCIsIFwiOlwiKTsgLy9cXGRlZlxcdmNlbnRjb2xvbntcXG1hdGhyZWx7XFxtYXRob3BcXG9yZGluYXJ5Y29sb259fVxuLy9UT0RPKGVkZW1haW5lKTogTm90IHlldCBjZW50ZXJlZC4gRml4IHZpYSBcXHJhaXNlYm94IG9yICM3MjZcblxuZGVmaW5lTWFjcm8oXCJcXFxcdmNlbnRjb2xvblwiLCBcIlxcXFxtYXRocmVse1xcXFxtYXRob3BcXFxcb3JkaW5hcnljb2xvbn1cIik7IC8vIFxccHJvdmlkZWNvbW1hbmQqXFxkYmxjb2xvbntcXHZjZW50Y29sb25cXG1hdGhyZWx7XFxta2Vybi0uOW11fVxcdmNlbnRjb2xvbn1cblxuZGVmaW5lTWFjcm8oXCJcXFxcZGJsY29sb25cIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVse1xcXFx2Y2VudGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLS45bXV9XFxcXHZjZW50Y29sb259fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjM3fX1cIik7IC8vIFxccHJvdmlkZWNvbW1hbmQqXFxjb2xvbmVxcXtcXHZjZW50Y29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX09fVxuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7XFxcXHZjZW50Y29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9PX19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyNTR9fVwiKTsgLy8g4omUXG4vLyBcXHByb3ZpZGVjb21tYW5kKlxcQ29sb25lcXF7XFxkYmxjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fT19XG5cbmRlZmluZU1hY3JvKFwiXFxcXENvbG9uZXFxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcZGJsY29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9PX19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyMzdcXFxcY2hhclxcXCIzZH19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcY29sb25lcXtcXHZjZW50Y29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXG1hdGhyZWx7LX19XG5cbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uZXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVse1xcXFx2Y2VudGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFxtYXRocmVsey19fX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiM2FcXFxcY2hhclxcXCIyMjEyfX1cIik7IC8vIFxccHJvdmlkZWNvbW1hbmQqXFxDb2xvbmVxe1xcZGJsY29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXG1hdGhyZWx7LX19XG5cbmRlZmluZU1hY3JvKFwiXFxcXENvbG9uZXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVse1xcXFxkYmxjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcbWF0aHJlbHstfX19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyMzdcXFxcY2hhclxcXCIyMjEyfX1cIik7IC8vIFxccHJvdmlkZWNvbW1hbmQqXFxlcXFjb2xvbns9XFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFx2Y2VudGNvbG9ufVxuXG5kZWZpbmVNYWNybyhcIlxcXFxlcXFjb2xvblwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhyZWx7PVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcdmNlbnRjb2xvbn19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyNTV9fVwiKTsgLy8g4omVXG4vLyBcXHByb3ZpZGVjb21tYW5kKlxcRXFxY29sb257PVxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcZGJsY29sb259XG5cbmRlZmluZU1hY3JvKFwiXFxcXEVxcWNvbG9uXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHs9XFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFxkYmxjb2xvbn19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjNkXFxcXGNoYXJcXFwiMjIzN319XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcZXFjb2xvbntcXG1hdGhyZWx7LX1cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXHZjZW50Y29sb259XG5cbmRlZmluZU1hY3JvKFwiXFxcXGVxY29sb25cIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVse1xcXFxtYXRocmVsey19XFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFx2Y2VudGNvbG9ufX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjIzOX19XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcRXFjb2xvbntcXG1hdGhyZWx7LX1cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXGRibGNvbG9ufVxuXG5kZWZpbmVNYWNybyhcIlxcXFxFcWNvbG9uXCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcbWF0aHJlbHstfVxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcZGJsY29sb259fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIyMjEyXFxcXGNoYXJcXFwiMjIzN319XCIpOyAvLyBcXHByb3ZpZGVjb21tYW5kKlxcY29sb25hcHByb3h7XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxhcHByb3h9XG5cbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uYXBwcm94XCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcdmNlbnRjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcYXBwcm94fX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiM2FcXFxcY2hhclxcXCIyMjQ4fX1cIik7IC8vIFxccHJvdmlkZWNvbW1hbmQqXFxDb2xvbmFwcHJveHtcXGRibGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxhcHByb3h9XG5cbmRlZmluZU1hY3JvKFwiXFxcXENvbG9uYXBwcm94XCIsIFwiXFxcXGh0bWxAbWF0aG1se1wiICsgXCJcXFxcbWF0aHJlbHtcXFxcZGJsY29sb25cXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXGFwcHJveH19XCIgKyBcIntcXFxcbWF0aG9we1xcXFxjaGFyXFxcIjIyMzdcXFxcY2hhclxcXCIyMjQ4fX1cIik7IC8vIFxccHJvdmlkZWNvbW1hbmQqXFxjb2xvbnNpbXtcXHZjZW50Y29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXHNpbX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25zaW1cIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVse1xcXFx2Y2VudGNvbG9uXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFxzaW19fVwiICsgXCJ7XFxcXG1hdGhvcHtcXFxcY2hhclxcXCIzYVxcXFxjaGFyXFxcIjIyM2N9fVwiKTsgLy8gXFxwcm92aWRlY29tbWFuZCpcXENvbG9uc2lte1xcZGJsY29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXHNpbX1cblxuZGVmaW5lTWFjcm8oXCJcXFxcQ29sb25zaW1cIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRocmVse1xcXFxkYmxjb2xvblxcXFxtYXRocmVse1xcXFxta2Vybi0xLjJtdX1cXFxcc2ltfX1cIiArIFwie1xcXFxtYXRob3B7XFxcXGNoYXJcXFwiMjIzN1xcXFxjaGFyXFxcIjIyM2N9fVwiKTsgLy8gU29tZSBVbmljb2RlIGNoYXJhY3RlcnMgYXJlIGltcGxlbWVudGVkIHdpdGggbWFjcm9zIHRvIG1hdGh0b29scyBmdW5jdGlvbnMuXG5cbmRlZmluZU1hY3JvKFwiXFx1MjIzN1wiLCBcIlxcXFxkYmxjb2xvblwiKTsgLy8gOjpcblxuZGVmaW5lTWFjcm8oXCJcXHUyMjM5XCIsIFwiXFxcXGVxY29sb25cIik7IC8vIC06XG5cbmRlZmluZU1hY3JvKFwiXFx1MjI1NFwiLCBcIlxcXFxjb2xvbmVxcVwiKTsgLy8gOj1cblxuZGVmaW5lTWFjcm8oXCJcXHUyMjU1XCIsIFwiXFxcXGVxcWNvbG9uXCIpOyAvLyA9OlxuXG5kZWZpbmVNYWNybyhcIlxcdTJBNzRcIiwgXCJcXFxcQ29sb25lcXFcIik7IC8vIDo6PVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gY29sb25lcXVhbHMuc3R5XG4vLyBBbHRlcm5hdGUgbmFtZXMgZm9yIG1hdGh0b29scydzIG1hY3JvczpcblxuZGVmaW5lTWFjcm8oXCJcXFxccmF0aW9cIiwgXCJcXFxcdmNlbnRjb2xvblwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uY29sb25cIiwgXCJcXFxcZGJsY29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmVxdWFsc1wiLCBcIlxcXFxjb2xvbmVxcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uY29sb25lcXVhbHNcIiwgXCJcXFxcQ29sb25lcXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlcXVhbHNjb2xvblwiLCBcIlxcXFxlcXFjb2xvblwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGVxdWFsc2NvbG9uY29sb25cIiwgXCJcXFxcRXFxY29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbm1pbnVzXCIsIFwiXFxcXGNvbG9uZXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9ubWludXNcIiwgXCJcXFxcQ29sb25lcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1pbnVzY29sb25cIiwgXCJcXFxcZXFjb2xvblwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1pbnVzY29sb25jb2xvblwiLCBcIlxcXFxFcWNvbG9uXCIpOyAvLyBcXGNvbG9uYXBwcm94IG5hbWUgaXMgc2FtZSBpbiBtYXRodG9vbHMgYW5kIGNvbG9uZXF1YWxzLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9uYXBwcm94XCIsIFwiXFxcXENvbG9uYXBwcm94XCIpOyAvLyBcXGNvbG9uc2ltIG5hbWUgaXMgc2FtZSBpbiBtYXRodG9vbHMgYW5kIGNvbG9uZXF1YWxzLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9uc2ltXCIsIFwiXFxcXENvbG9uc2ltXCIpOyAvLyBBZGRpdGlvbmFsIG1hY3JvcywgaW1wbGVtZW50ZWQgYnkgYW5hbG9neSB3aXRoIG1hdGh0b29scyBkZWZpbml0aW9uczpcblxuZGVmaW5lTWFjcm8oXCJcXFxcc2ltY29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxcc2ltXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFx2Y2VudGNvbG9ufVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHNpbWNvbG9uY29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxcc2ltXFxcXG1hdGhyZWx7XFxcXG1rZXJuLTEuMm11fVxcXFxkYmxjb2xvbn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhcHByb3hjb2xvblwiLCBcIlxcXFxtYXRocmVse1xcXFxhcHByb3hcXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXHZjZW50Y29sb259XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYXBwcm94Y29sb25jb2xvblwiLCBcIlxcXFxtYXRocmVse1xcXFxhcHByb3hcXFxcbWF0aHJlbHtcXFxcbWtlcm4tMS4ybXV9XFxcXGRibGNvbG9ufVwiKTsgLy8gUHJlc2VudCBpbiBuZXd0eG1hdGgsIHB4Zm9udHMgYW5kIHR4Zm9udHNcblxuZGVmaW5lTWFjcm8oXCJcXFxcbm90bmlcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXG5vdFxcXFxuaX17XFxcXG1hdGhyZWx7XFxcXGNoYXJgXFx1MjIwQ319XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbGltc3VwXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7bGltXFxcXCxzdXB9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbGltaW5mXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7bGltXFxcXCxpbmZ9XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBGcm9tIGFtc29wbi5zdHlcblxuZGVmaW5lTWFjcm8oXCJcXFxcaW5qbGltXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7aW5qXFxcXCxsaW19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHJvamxpbVwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe3Byb2pcXFxcLGxpbX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJsaW1zdXBcIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntcXFxcb3ZlcmxpbmV7bGltfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJsaW1pbmZcIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntcXFxcdW5kZXJsaW5le2xpbX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyaW5qbGltXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7XFxcXHVuZGVycmlnaHRhcnJvd3tsaW19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcnByb2psaW1cIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntcXFxcdW5kZXJsZWZ0YXJyb3d7bGltfX1cIik7IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE1hdGhNTCBhbHRlcm5hdGVzIGZvciBLYVRlWCBnbHlwaHMgaW4gdGhlIFVuaWNvZGUgcHJpdmF0ZSBhcmVhXG5cbmRlZmluZU1hY3JvKFwiXFxcXGd2ZXJ0bmVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQGd2ZXJ0bmVxcX17XFx1MjI2OX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsdmVydG5lcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBsdmVydG5lcXF9e1xcdTIyNjh9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbmdlcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBuZ2VxcX17XFx1MjI3MX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxuZ2Vxc2xhbnRcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBuZ2Vxc2xhbnR9e1xcdTIyNzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbmxlcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBubGVxcX17XFx1MjI3MH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxubGVxc2xhbnRcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBubGVxc2xhbnR9e1xcdTIyNzB9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbnNob3J0bWlkXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAbnNob3J0bWlkfXviiKR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbnNob3J0cGFyYWxsZWxcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBuc2hvcnRwYXJhbGxlbH174oimfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5zdWJzZXRlcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBuc3Vic2V0ZXFxfXtcXHUyMjg4fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5zdXBzZXRlcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEBuc3Vwc2V0ZXFxfXtcXHUyMjg5fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcnN1YnNldG5lcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQHZhcnN1YnNldG5lcX174oqKfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcnN1YnNldG5lcXFcIiwgXCJcXFxcaHRtbEBtYXRobWx7XFxcXEB2YXJzdWJzZXRuZXFxfXviq4t9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyc3Vwc2V0bmVxXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAdmFyc3Vwc2V0bmVxfXviiot9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyc3Vwc2V0bmVxcVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQHZhcnN1cHNldG5lcXF9e+KrjH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpbWF0aFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcXFxcQGltYXRofXtcXHUwMTMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGptYXRoXCIsIFwiXFxcXGh0bWxAbWF0aG1se1xcXFxAam1hdGh9e1xcdTAyMzd9XCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBzdG1hcnlyZCBhbmQgc2VtYW50aWNcbi8vIFRoZSBzdG1hcnlyZCBhbmQgc2VtYW50aWMgcGFja2FnZXMgcmVuZGVyIHRoZSBuZXh0IGZvdXIgaXRlbXMgYnkgY2FsbGluZyBhXG4vLyBnbHlwaC4gVGhvc2UgZ2x5cGhzIGRvIG5vdCBleGlzdCBpbiB0aGUgS2FUZVggZm9udHMuIEhlbmNlIHRoZSBtYWNyb3MuXG5cbmRlZmluZU1hY3JvKFwiXFxcXGxsYnJhY2tldFwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhvcGVue1tcXFxcbWtlcm4tMy4ybXVbfX1cIiArIFwie1xcXFxtYXRob3BlbntcXFxcY2hhcmBcXHUyN2U2fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxycmJyYWNrZXRcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRoY2xvc2V7XVxcXFxta2Vybi0zLjJtdV19fVwiICsgXCJ7XFxcXG1hdGhjbG9zZXtcXFxcY2hhcmBcXHUyN2U3fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTI3ZTZcIiwgXCJcXFxcbGxicmFja2V0XCIpOyAvLyBibGFja2JvYXJkIGJvbGQgW1xuXG5kZWZpbmVNYWNybyhcIlxcdTI3ZTdcIiwgXCJcXFxccnJicmFja2V0XCIpOyAvLyBibGFja2JvYXJkIGJvbGQgXVxuXG5kZWZpbmVNYWNybyhcIlxcXFxsQnJhY2VcIiwgXCJcXFxcaHRtbEBtYXRobWx7XCIgKyBcIlxcXFxtYXRob3BlbntcXFxce1xcXFxta2Vybi0zLjJtdVt9fVwiICsgXCJ7XFxcXG1hdGhvcGVue1xcXFxjaGFyYFxcdTI5ODN9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJCcmFjZVwiLCBcIlxcXFxodG1sQG1hdGhtbHtcIiArIFwiXFxcXG1hdGhjbG9zZXtdXFxcXG1rZXJuLTMuMm11XFxcXH19fVwiICsgXCJ7XFxcXG1hdGhjbG9zZXtcXFxcY2hhcmBcXHUyOTg0fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTI5ODNcIiwgXCJcXFxcbEJyYWNlXCIpOyAvLyBibGFja2JvYXJkIGJvbGQge1xuXG5kZWZpbmVNYWNybyhcIlxcdTI5ODRcIiwgXCJcXFxcckJyYWNlXCIpOyAvLyBibGFja2JvYXJkIGJvbGQgfVxuLy8gVE9ETzogQ3JlYXRlIHZhcmlhYmxlIHNpemVkIHZlcnNpb25zIG9mIHRoZSBsYXN0IHR3byBpdGVtcy4gSSBiZWxpZXZlIHRoYXRcbi8vIHdpbGwgcmVxdWlyZSBuZXcgZm9udCBnbHlwaHMuXG4vLyBUaGUgc3RtYXJ5cmQgZnVuY3Rpb24gYFxcbWludXNvYCBwcm92aWRlcyBhIFwiUGxpbXNvbGxcIiBzeW1ib2wgdGhhdFxuLy8gc3VwZXJpbXBvc2VzIHRoZSBjaGFyYWN0ZXJzIFxcY2lyYyBhbmQgXFxtYXRobWludXMuIFVzZWQgaW4gY2hlbWlzdHJ5LlxuXG5kZWZpbmVNYWNybyhcIlxcXFxtaW51c29cIiwgXCJcXFxcbWF0aGJpbntcXFxcaHRtbEBtYXRobWx7XCIgKyBcIntcXFxcbWF0aHJsYXB7XFxcXG1hdGhjaG9pY2V7XFxcXGtlcm57MC4xNDVlbX19e1xcXFxrZXJuezAuMTQ1ZW19fVwiICsgXCJ7XFxcXGtlcm57MC4xMDE1ZW19fXtcXFxca2VybnswLjA3MjVlbX19XFxcXGNpcmN9ey19fX1cIiArIFwie1xcXFxjaGFyYOKmtX19XCIpO1xuZGVmaW5lTWFjcm8oXCLiprVcIiwgXCJcXFxcbWludXNvXCIpOyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyB0ZXh2Yy5zdHlcbi8vIFRoZSB0ZXh2YyBwYWNrYWdlIGNvbnRhaW5zIG1hY3JvcyBhdmFpbGFibGUgaW4gbWVkaWF3aWtpIHBhZ2VzLlxuLy8gV2Ugb21pdCB0aGUgZnVuY3Rpb25zIGRlcHJlY2F0ZWQgYXRcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlbHA6RGlzcGxheWluZ19hX2Zvcm11bGEjRGVwcmVjYXRlZF9zeW50YXhcbi8vIFdlIGFsc28gb21pdCB0ZXh2YydzIFxcTywgd2hpY2ggY29uZmxpY3RzIHdpdGggXFx0ZXh0e1xcT31cblxuZGVmaW5lTWFjcm8oXCJcXFxcZGFyclwiLCBcIlxcXFxkb3duYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkQXJyXCIsIFwiXFxcXERvd25hcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXERhcnJcIiwgXCJcXFxcRG93bmFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbGFuZ1wiLCBcIlxcXFxsYW5nbGVcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyYW5nXCIsIFwiXFxcXHJhbmdsZVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVhcnJcIiwgXCJcXFxcdXBhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVBcnJcIiwgXCJcXFxcVXBhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFVhcnJcIiwgXCJcXFxcVXBhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXE5cIiwgXCJcXFxcbWF0aGJie059XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcUlwiLCBcIlxcXFxtYXRoYmJ7Un1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxaXCIsIFwiXFxcXG1hdGhiYntafVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFsZWZcIiwgXCJcXFxcYWxlcGhcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhbGVmc3ltXCIsIFwiXFxcXGFsZXBoXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQWxwaGFcIiwgXCJcXFxcbWF0aHJte0F9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQmV0YVwiLCBcIlxcXFxtYXRocm17Qn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxidWxsXCIsIFwiXFxcXGJ1bGxldFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXENoaVwiLCBcIlxcXFxtYXRocm17WH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjbHVic1wiLCBcIlxcXFxjbHVic3VpdFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNudW1zXCIsIFwiXFxcXG1hdGhiYntDfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXENvbXBsZXhcIiwgXCJcXFxcbWF0aGJie0N9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRGFnZ2VyXCIsIFwiXFxcXGRkYWdnZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkaWFtb25kc1wiLCBcIlxcXFxkaWFtb25kc3VpdFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGVtcHR5XCIsIFwiXFxcXGVtcHR5c2V0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRXBzaWxvblwiLCBcIlxcXFxtYXRocm17RX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxFdGFcIiwgXCJcXFxcbWF0aHJte0h9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXhpc3RcIiwgXCJcXFxcZXhpc3RzXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaGFyclwiLCBcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGhBcnJcIiwgXCJcXFxcTGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxIYXJyXCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaGVhcnRzXCIsIFwiXFxcXGhlYXJ0c3VpdFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGltYWdlXCIsIFwiXFxcXEltXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaW5maW5cIiwgXCJcXFxcaW5mdHlcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxJb3RhXCIsIFwiXFxcXG1hdGhybXtJfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGlzaW5cIiwgXCJcXFxcaW5cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxLYXBwYVwiLCBcIlxcXFxtYXRocm17S31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsYXJyXCIsIFwiXFxcXGxlZnRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxBcnJcIiwgXCJcXFxcTGVmdGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcTGFyclwiLCBcIlxcXFxMZWZ0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxscmFyclwiLCBcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxyQXJyXCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcTHJhcnJcIiwgXCJcXFxcTGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxNdVwiLCBcIlxcXFxtYXRocm17TX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxuYXRudW1zXCIsIFwiXFxcXG1hdGhiYntOfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXE51XCIsIFwiXFxcXG1hdGhybXtOfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXE9taWNyb25cIiwgXCJcXFxcbWF0aHJte099XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccGx1c21uXCIsIFwiXFxcXHBtXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmFyclwiLCBcIlxcXFxyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcckFyclwiLCBcIlxcXFxSaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcUmFyclwiLCBcIlxcXFxSaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVhbFwiLCBcIlxcXFxSZVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlYWxzXCIsIFwiXFxcXG1hdGhiYntSfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJlYWxzXCIsIFwiXFxcXG1hdGhiYntSfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJob1wiLCBcIlxcXFxtYXRocm17UH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzZG90XCIsIFwiXFxcXGNkb3RcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzZWN0XCIsIFwiXFxcXFNcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzcGFkZXNcIiwgXCJcXFxcc3BhZGVzdWl0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc3ViXCIsIFwiXFxcXHN1YnNldFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHN1YmVcIiwgXCJcXFxcc3Vic2V0ZXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzdXBlXCIsIFwiXFxcXHN1cHNldGVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcVGF1XCIsIFwiXFxcXG1hdGhybXtUfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRoZXRhc3ltXCIsIFwiXFxcXHZhcnRoZXRhXCIpOyAvLyBUT0RPOiBkZWZpbmVNYWNybyhcIlxcXFx2YXJjb3BwYVwiLCBcIlxcXFxcXG1ib3h7XFxcXGNvcHBhfVwiKTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcd2VpZXJwXCIsIFwiXFxcXHdwXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcWmV0YVwiLCBcIlxcXFxtYXRocm17Wn1cIik7IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIHN0YXRtYXRoLnN0eVxuLy8gaHR0cHM6Ly9jdGFuLm1hdGguaWxsaW5vaXMuZWR1L21hY3Jvcy9sYXRleC9jb250cmliL3N0YXRtYXRoL3N0YXRtYXRoLnBkZlxuXG5kZWZpbmVNYWNybyhcIlxcXFxhcmdtaW5cIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKnthcmdcXFxcLG1pbn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhcmdtYXhcIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKnthcmdcXFxcLG1heH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwbGltXCIsIFwiXFxcXERPVFNCXFxcXG1hdGhvcHtcXFxcb3BlcmF0b3JuYW1le3BsaW19fVxcXFxsaW1pdHNcIik7IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGJyYWtldC5zdHlcbi8vIGh0dHA6Ly9jdGFuLm1hdGgud2FzaGluZ3Rvbi5lZHUvdGV4LWFyY2hpdmUvbWFjcm9zL2xhdGV4L2NvbnRyaWIvYnJha2V0L2JyYWtldC5wZGZcblxuZGVmaW5lTWFjcm8oXCJcXFxcYnJhXCIsIFwiXFxcXG1hdGhpbm5lcntcXFxcbGFuZ2xleyMxfXx9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxca2V0XCIsIFwiXFxcXG1hdGhpbm5lcnt8eyMxfVxcXFxyYW5nbGV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYnJha2V0XCIsIFwiXFxcXG1hdGhpbm5lcntcXFxcbGFuZ2xleyMxfVxcXFxyYW5nbGV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQnJhXCIsIFwiXFxcXGxlZnRcXFxcbGFuZ2xlIzFcXFxccmlnaHR8XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcS2V0XCIsIFwiXFxcXGxlZnR8IzFcXFxccmlnaHRcXFxccmFuZ2xlXCIpO1xuXG52YXIgYnJha2V0SGVscGVyID0gb25lID0+IGNvbnRleHQgPT4ge1xuICB2YXIgbGVmdCA9IGNvbnRleHQuY29uc3VtZUFyZygpLnRva2VucztcbiAgdmFyIG1pZGRsZSA9IGNvbnRleHQuY29uc3VtZUFyZygpLnRva2VucztcbiAgdmFyIG1pZGRsZURvdWJsZSA9IGNvbnRleHQuY29uc3VtZUFyZygpLnRva2VucztcbiAgdmFyIHJpZ2h0ID0gY29udGV4dC5jb25zdW1lQXJnKCkudG9rZW5zO1xuICB2YXIgb2xkTWlkZGxlID0gY29udGV4dC5tYWNyb3MuZ2V0KFwifFwiKTtcbiAgdmFyIG9sZE1pZGRsZURvdWJsZSA9IGNvbnRleHQubWFjcm9zLmdldChcIlxcXFx8XCIpO1xuICBjb250ZXh0Lm1hY3Jvcy5iZWdpbkdyb3VwKCk7XG5cbiAgdmFyIG1pZE1hY3JvID0gZG91YmxlID0+IGNvbnRleHQgPT4ge1xuICAgIGlmIChvbmUpIHtcbiAgICAgIC8vIE9ubHkgbW9kaWZ5IHRoZSBmaXJzdCBpbnN0YW5jZSBvZiB8IG9yIFxcfFxuICAgICAgY29udGV4dC5tYWNyb3Muc2V0KFwifFwiLCBvbGRNaWRkbGUpO1xuXG4gICAgICBpZiAobWlkZGxlRG91YmxlLmxlbmd0aCkge1xuICAgICAgICBjb250ZXh0Lm1hY3Jvcy5zZXQoXCJcXFxcfFwiLCBvbGRNaWRkbGVEb3VibGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkb3VibGVkID0gZG91YmxlO1xuXG4gICAgaWYgKCFkb3VibGUgJiYgbWlkZGxlRG91YmxlLmxlbmd0aCkge1xuICAgICAgLy8gTWltaWMgXFxAaWZuZXh0Y2hhclxuICAgICAgdmFyIG5leHRUb2tlbiA9IGNvbnRleHQuZnV0dXJlKCk7XG5cbiAgICAgIGlmIChuZXh0VG9rZW4udGV4dCA9PT0gXCJ8XCIpIHtcbiAgICAgICAgY29udGV4dC5wb3BUb2tlbigpO1xuICAgICAgICBkb3VibGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5zOiBkb3VibGVkID8gbWlkZGxlRG91YmxlIDogbWlkZGxlLFxuICAgICAgbnVtQXJnczogMFxuICAgIH07XG4gIH07XG5cbiAgY29udGV4dC5tYWNyb3Muc2V0KFwifFwiLCBtaWRNYWNybyhmYWxzZSkpO1xuXG4gIGlmIChtaWRkbGVEb3VibGUubGVuZ3RoKSB7XG4gICAgY29udGV4dC5tYWNyb3Muc2V0KFwiXFxcXHxcIiwgbWlkTWFjcm8odHJ1ZSkpO1xuICB9XG5cbiAgdmFyIGFyZyA9IGNvbnRleHQuY29uc3VtZUFyZygpLnRva2VucztcbiAgdmFyIGV4cGFuZGVkID0gY29udGV4dC5leHBhbmRUb2tlbnMoWy4uLnJpZ2h0LCAuLi5hcmcsIC4uLmxlZnQgLy8gcmV2ZXJzZWRcbiAgXSk7XG4gIGNvbnRleHQubWFjcm9zLmVuZEdyb3VwKCk7XG4gIHJldHVybiB7XG4gICAgdG9rZW5zOiBleHBhbmRlZC5yZXZlcnNlKCksXG4gICAgbnVtQXJnczogMFxuICB9O1xufTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcYnJhQGtldFwiLCBicmFrZXRIZWxwZXIoZmFsc2UpKTtcbmRlZmluZU1hY3JvKFwiXFxcXGJyYUBzZXRcIiwgYnJha2V0SGVscGVyKHRydWUpKTtcbmRlZmluZU1hY3JvKFwiXFxcXEJyYWtldFwiLCBcIlxcXFxicmFAa2V0e1xcXFxsZWZ0XFxcXGxhbmdsZX1cIiArIFwie1xcXFwsXFxcXG1pZGRsZVxcXFx2ZXJ0XFxcXCx9e1xcXFwsXFxcXG1pZGRsZVxcXFx2ZXJ0XFxcXCx9e1xcXFxyaWdodFxcXFxyYW5nbGV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcU2V0XCIsIFwiXFxcXGJyYUBzZXR7XFxcXGxlZnRcXFxce1xcXFw6fVwiICsgXCJ7XFxcXDtcXFxcbWlkZGxlXFxcXHZlcnRcXFxcO317XFxcXDtcXFxcbWlkZGxlXFxcXFZlcnRcXFxcO317XFxcXDpcXFxccmlnaHRcXFxcfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzZXRcIiwgXCJcXFxcYnJhQHNldHtcXFxce1xcXFwsfXtcXFxcbWlkfXt9e1xcXFwsXFxcXH19XCIpOyAvLyBoYXMgbm8gc3VwcG9ydCBmb3Igc3BlY2lhbCB8fCBvciBcXHxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGFjdHVhcmlhbGFuZ2xlLmR0eFxuXG5kZWZpbmVNYWNybyhcIlxcXFxhbmdsblwiLCBcIntcXFxcYW5nbCBufVwiKTsgLy8gQ3VzdG9tIEtoYW4gQWNhZGVteSBjb2xvcnMsIHNob3VsZCBiZSBtb3ZlZCB0byBhbiBvcHRpb25hbCBwYWNrYWdlXG5cbmRlZmluZU1hY3JvKFwiXFxcXGJsdWVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjNjQ5NWVkfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxvcmFuZ2VcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmZhNTAwfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwaW5rXCIsIFwiXFxcXHRleHRjb2xvcnsjI2ZmMDBhZn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVkXCIsIFwiXFxcXHRleHRjb2xvcnsjI2RmMDAzMH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JlZW5cIiwgXCJcXFxcdGV4dGNvbG9yeyMjMjhhZTdifXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5XCIsIFwiXFxcXHRleHRjb2xvcntncmF5fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwdXJwbGVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjOWQzOGJkfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxibHVlQVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNjY2ZhZmZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGJsdWVCXCIsIFwiXFxcXHRleHRjb2xvcnsjIzgwZjZmZn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYmx1ZUNcIiwgXCJcXFxcdGV4dGNvbG9yeyMjNjNkOWVhfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxibHVlRFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMxMWFjY2R9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGJsdWVFXCIsIFwiXFxcXHRleHRjb2xvcnsjIzBjN2Y5OX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGVhbEFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjOTRmZmY1fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0ZWFsQlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMyNmVkZDV9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRlYWxDXCIsIFwiXFxcXHRleHRjb2xvcnsjIzAxZDFjMX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGVhbERcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMDFhOTk1fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0ZWFsRVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMyMDgxNzB9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyZWVuQVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNiNmZmYjB9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyZWVuQlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM4YWYyODF9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyZWVuQ1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyM3NGNmNzB9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyZWVuRFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMxZmFiNTR9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyZWVuRVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyMwZDkyM2Z9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdvbGRBXCIsIFwiXFxcXHRleHRjb2xvcnsjI2ZmZDBhOX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ29sZEJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmZiYjcxfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxnb2xkQ1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmZjljMzl9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdvbGREXCIsIFwiXFxcXHRleHRjb2xvcnsjI2UwN2QxMH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ29sZEVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjYTc1YTA1fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWRBXCIsIFwiXFxcXHRleHRjb2xvcnsjI2ZjYTlhOX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVkQlwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmZjg0ODJ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlZENcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZjk2ODVkfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWREXCIsIFwiXFxcXHRleHRjb2xvcnsjI2U4NGQzOX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVkRVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNiYzI2MTJ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1hcm9vbkFcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZmZiZGUwfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtYXJvb25CXCIsIFwiXFxcXHRleHRjb2xvcnsjI2ZmOTJjNn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWFyb29uQ1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyNlZDVmYTZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1hcm9vbkRcIiwgXCJcXFxcdGV4dGNvbG9yeyMjY2EzMzdjfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtYXJvb25FXCIsIFwiXFxcXHRleHRjb2xvcnsjIzllMDM0ZX17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHVycGxlQVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNkZGQ3ZmZ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHB1cnBsZUJcIiwgXCJcXFxcdGV4dGNvbG9yeyMjYzZiOWZjfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwdXJwbGVDXCIsIFwiXFxcXHRleHRjb2xvcnsjI2FhODdmZn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHVycGxlRFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyM3ODU0YWJ9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHB1cnBsZUVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjNTQzYjc4fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtaW50QVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmNWY5ZTh9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1pbnRCXCIsIFwiXFxcXHRleHRjb2xvcnsjI2VkZjJkZn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWludENcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZTBlNWNjfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5QVwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNmNmY3Zjd9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlCXCIsIFwiXFxcXHRleHRjb2xvcnsjI2YwZjFmMn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheUNcIiwgXCJcXFxcdGV4dGNvbG9yeyMjZTNlNWU2fXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5RFwiLCBcIlxcXFx0ZXh0Y29sb3J7IyNkNmQ4ZGF9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlFXCIsIFwiXFxcXHRleHRjb2xvcnsjI2JhYmVjMn17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheUZcIiwgXCJcXFxcdGV4dGNvbG9yeyMjODg4ZDkzfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmF5R1wiLCBcIlxcXFx0ZXh0Y29sb3J7IyM2MjY1Njl9eyMxfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYXlIXCIsIFwiXFxcXHRleHRjb2xvcnsjIzNiM2U0MH17IzF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JheUlcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMjEyNDJjfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxrYUJsdWVcIiwgXCJcXFxcdGV4dGNvbG9yeyMjMzE0NDUzfXsjMX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxrYUdyZWVuXCIsIFwiXFxcXHRleHRjb2xvcnsjIzcxQjMwN317IzF9XCIpO1xuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUg4oCcZ3VsbGV04oCdIHdoZXJlIG1hY3JvcyBhcmUgZXhwYW5kZWRcbiAqIHVudGlsIG9ubHkgbm9uLW1hY3JvIHRva2VucyByZW1haW4uXG4gKi9cbi8vIExpc3Qgb2YgY29tbWFuZHMgdGhhdCBhY3QgbGlrZSBtYWNyb3MgYnV0IGFyZW4ndCBkZWZpbmVkIGFzIGEgbWFjcm8sXG4vLyBmdW5jdGlvbiwgb3Igc3ltYm9sLiAgVXNlZCBpbiBgaXNEZWZpbmVkYC5cbnZhciBpbXBsaWNpdENvbW1hbmRzID0ge1xuICBcIl5cIjogdHJ1ZSxcbiAgLy8gUGFyc2VyLmpzXG4gIFwiX1wiOiB0cnVlLFxuICAvLyBQYXJzZXIuanNcbiAgXCJcXFxcbGltaXRzXCI6IHRydWUsXG4gIC8vIFBhcnNlci5qc1xuICBcIlxcXFxub2xpbWl0c1wiOiB0cnVlIC8vIFBhcnNlci5qc1xuXG59O1xuY2xhc3MgTWFjcm9FeHBhbmRlciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0LCBzZXR0aW5ncywgbW9kZSkge1xuICAgIHRoaXMuc2V0dGluZ3MgPSB2b2lkIDA7XG4gICAgdGhpcy5leHBhbnNpb25Db3VudCA9IHZvaWQgMDtcbiAgICB0aGlzLmxleGVyID0gdm9pZCAwO1xuICAgIHRoaXMubWFjcm9zID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5tb2RlID0gdm9pZCAwO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmV4cGFuc2lvbkNvdW50ID0gMDtcbiAgICB0aGlzLmZlZWQoaW5wdXQpOyAvLyBNYWtlIG5ldyBnbG9iYWwgbmFtZXNwYWNlXG5cbiAgICB0aGlzLm1hY3JvcyA9IG5ldyBOYW1lc3BhY2UobWFjcm9zLCBzZXR0aW5ncy5tYWNyb3MpO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgdGhpcy5zdGFjayA9IFtdOyAvLyBjb250YWlucyB0b2tlbnMgaW4gUkVWRVJTRSBvcmRlclxuICB9XG4gIC8qKlxuICAgKiBGZWVkIGEgbmV3IGlucHV0IHN0cmluZyB0byB0aGUgc2FtZSBNYWNyb0V4cGFuZGVyXG4gICAqICh3aXRoIGV4aXN0aW5nIG1hY3JvcyBldGMuKS5cbiAgICovXG5cblxuICBmZWVkKGlucHV0KSB7XG4gICAgdGhpcy5sZXhlciA9IG5ldyBMZXhlcihpbnB1dCwgdGhpcy5zZXR0aW5ncyk7XG4gIH1cbiAgLyoqXG4gICAqIFN3aXRjaGVzIGJldHdlZW4gXCJ0ZXh0XCIgYW5kIFwibWF0aFwiIG1vZGVzLlxuICAgKi9cblxuXG4gIHN3aXRjaE1vZGUobmV3TW9kZSkge1xuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IGEgbmV3IGdyb3VwIG5lc3Rpbmcgd2l0aGluIGFsbCBuYW1lc3BhY2VzLlxuICAgKi9cblxuXG4gIGJlZ2luR3JvdXAoKSB7XG4gICAgdGhpcy5tYWNyb3MuYmVnaW5Hcm91cCgpO1xuICB9XG4gIC8qKlxuICAgKiBFbmQgY3VycmVudCBncm91cCBuZXN0aW5nIHdpdGhpbiBhbGwgbmFtZXNwYWNlcy5cbiAgICovXG5cblxuICBlbmRHcm91cCgpIHtcbiAgICB0aGlzLm1hY3Jvcy5lbmRHcm91cCgpO1xuICB9XG4gIC8qKlxuICAgKiBFbmRzIGFsbCBjdXJyZW50bHkgbmVzdGVkIGdyb3VwcyAoaWYgYW55KSwgcmVzdG9yaW5nIHZhbHVlcyBiZWZvcmUgdGhlXG4gICAqIGdyb3VwcyBiZWdhbi4gIFVzZWZ1bCBpbiBjYXNlIG9mIGFuIGVycm9yIGluIHRoZSBtaWRkbGUgb2YgcGFyc2luZy5cbiAgICovXG5cblxuICBlbmRHcm91cHMoKSB7XG4gICAgdGhpcy5tYWNyb3MuZW5kR3JvdXBzKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRvcG1vc3QgdG9rZW4gb24gdGhlIHN0YWNrLCB3aXRob3V0IGV4cGFuZGluZyBpdC5cbiAgICogU2ltaWxhciBpbiBiZWhhdmlvciB0byBUZVgncyBgXFxmdXR1cmVsZXRgLlxuICAgKi9cblxuXG4gIGZ1dHVyZSgpIHtcbiAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucHVzaFRva2VuKHRoaXMubGV4ZXIubGV4KCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhbmQgcmV0dXJuIHRoZSBuZXh0IHVuZXhwYW5kZWQgdG9rZW4uXG4gICAqL1xuXG5cbiAgcG9wVG9rZW4oKSB7XG4gICAgdGhpcy5mdXR1cmUoKTsgLy8gZW5zdXJlIG5vbi1lbXB0eSBzdGFja1xuXG4gICAgcmV0dXJuIHRoaXMuc3RhY2sucG9wKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIGdpdmVuIHRva2VuIHRvIHRoZSB0b2tlbiBzdGFjay4gIEluIHBhcnRpY3VsYXIsIHRoaXMgZ2V0IGJlIHVzZWRcbiAgICogdG8gcHV0IGJhY2sgYSB0b2tlbiByZXR1cm5lZCBmcm9tIG9uZSBvZiB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgICovXG5cblxuICBwdXNoVG9rZW4odG9rZW4pIHtcbiAgICB0aGlzLnN0YWNrLnB1c2godG9rZW4pO1xuICB9XG4gIC8qKlxuICAgKiBBcHBlbmQgYW4gYXJyYXkgb2YgdG9rZW5zIHRvIHRoZSB0b2tlbiBzdGFjay5cbiAgICovXG5cblxuICBwdXNoVG9rZW5zKHRva2Vucykge1xuICAgIHRoaXMuc3RhY2sucHVzaCguLi50b2tlbnMpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIGFuIG1hY3JvIGFyZ3VtZW50IHdpdGhvdXQgZXhwYW5kaW5nIHRva2VucyBhbmQgYXBwZW5kIHRoZSBhcnJheSBvZlxuICAgKiB0b2tlbnMgdG8gdGhlIHRva2VuIHN0YWNrLiBVc2VzIFRva2VuIGFzIGEgY29udGFpbmVyIGZvciB0aGUgcmVzdWx0LlxuICAgKi9cblxuXG4gIHNjYW5Bcmd1bWVudChpc09wdGlvbmFsKSB7XG4gICAgdmFyIHN0YXJ0O1xuICAgIHZhciBlbmQ7XG4gICAgdmFyIHRva2VucztcblxuICAgIGlmIChpc09wdGlvbmFsKSB7XG4gICAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTsgLy8gXFxAaWZuZXh0Y2hhciBnb2JibGVzIGFueSBzcGFjZSBmb2xsb3dpbmcgaXRcblxuICAgICAgaWYgKHRoaXMuZnV0dXJlKCkudGV4dCAhPT0gXCJbXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0ID0gdGhpcy5wb3BUb2tlbigpOyAvLyBkb24ndCBpbmNsdWRlIFsgaW4gdG9rZW5zXG5cbiAgICAgICh7XG4gICAgICAgIHRva2VucyxcbiAgICAgICAgZW5kXG4gICAgICB9ID0gdGhpcy5jb25zdW1lQXJnKFtcIl1cIl0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgKHtcbiAgICAgICAgdG9rZW5zLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kXG4gICAgICB9ID0gdGhpcy5jb25zdW1lQXJnKCkpO1xuICAgIH0gLy8gaW5kaWNhdGUgdGhlIGVuZCBvZiBhbiBhcmd1bWVudFxuXG5cbiAgICB0aGlzLnB1c2hUb2tlbihuZXcgVG9rZW4oXCJFT0ZcIiwgZW5kLmxvYykpO1xuICAgIHRoaXMucHVzaFRva2Vucyh0b2tlbnMpO1xuICAgIHJldHVybiBuZXcgVG9rZW4oXCJcIiwgU291cmNlTG9jYXRpb24ucmFuZ2Uoc3RhcnQsIGVuZCkpO1xuICB9XG4gIC8qKlxuICAgKiBDb25zdW1lIGFsbCBmb2xsb3dpbmcgc3BhY2UgdG9rZW5zLCB3aXRob3V0IGV4cGFuc2lvbi5cbiAgICovXG5cblxuICBjb25zdW1lU3BhY2VzKCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRoaXMuZnV0dXJlKCk7XG5cbiAgICAgIGlmICh0b2tlbi50ZXh0ID09PSBcIiBcIikge1xuICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb25zdW1lIGFuIGFyZ3VtZW50IGZyb20gdGhlIHRva2VuIHN0cmVhbSwgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGFycmF5XG4gICAqIG9mIHRva2VucyBhbmQgc3RhcnQvZW5kIHRva2VuLlxuICAgKi9cblxuXG4gIGNvbnN1bWVBcmcoZGVsaW1zKSB7XG4gICAgLy8gVGhlIGFyZ3VtZW50IGZvciBhIGRlbGltaXRlZCBwYXJhbWV0ZXIgaXMgdGhlIHNob3J0ZXN0IChwb3NzaWJseVxuICAgIC8vIGVtcHR5KSBzZXF1ZW5jZSBvZiB0b2tlbnMgd2l0aCBwcm9wZXJseSBuZXN0ZWQgey4uLn0gZ3JvdXBzIHRoYXQgaXNcbiAgICAvLyBmb2xsb3dlZCAuLi4gYnkgdGhpcyBwYXJ0aWN1bGFyIGxpc3Qgb2Ygbm9uLXBhcmFtZXRlciB0b2tlbnMuXG4gICAgLy8gVGhlIGFyZ3VtZW50IGZvciBhbiB1bmRlbGltaXRlZCBwYXJhbWV0ZXIgaXMgdGhlIG5leHQgbm9uYmxhbmtcbiAgICAvLyB0b2tlbiwgdW5sZXNzIHRoYXQgdG9rZW4gaXMg4oCYe+KAmSwgd2hlbiB0aGUgYXJndW1lbnQgd2lsbCBiZSB0aGVcbiAgICAvLyBlbnRpcmUgey4uLn0gZ3JvdXAgdGhhdCBmb2xsb3dzLlxuICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICB2YXIgaXNEZWxpbWl0ZWQgPSBkZWxpbXMgJiYgZGVsaW1zLmxlbmd0aCA+IDA7XG5cbiAgICBpZiAoIWlzRGVsaW1pdGVkKSB7XG4gICAgICAvLyBJZ25vcmUgc3BhY2VzIGJldHdlZW4gYXJndW1lbnRzLiAgQXMgdGhlIFRlWGJvb2sgc2F5czpcbiAgICAgIC8vIFwiQWZ0ZXIgeW91IGhhdmUgc2FpZCDigJhcXGRlZlxccm93IzEjMnsuLi594oCZLCB5b3UgYXJlIGFsbG93ZWQgdG9cbiAgICAgIC8vICBwdXQgc3BhY2VzIGJldHdlZW4gdGhlIGFyZ3VtZW50cyAoZS5nLiwg4oCYXFxyb3cgeCBu4oCZKSwgYmVjYXVzZVxuICAgICAgLy8gIFRlWCBkb2VzbuKAmXQgdXNlIHNpbmdsZSBzcGFjZXMgYXMgdW5kZWxpbWl0ZWQgYXJndW1lbnRzLlwiXG4gICAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSB0aGlzLmZ1dHVyZSgpO1xuICAgIHZhciB0b2s7XG4gICAgdmFyIGRlcHRoID0gMDtcbiAgICB2YXIgbWF0Y2ggPSAwO1xuXG4gICAgZG8ge1xuICAgICAgdG9rID0gdGhpcy5wb3BUb2tlbigpO1xuICAgICAgdG9rZW5zLnB1c2godG9rKTtcblxuICAgICAgaWYgKHRvay50ZXh0ID09PSBcIntcIikge1xuICAgICAgICArK2RlcHRoO1xuICAgICAgfSBlbHNlIGlmICh0b2sudGV4dCA9PT0gXCJ9XCIpIHtcbiAgICAgICAgLS1kZXB0aDtcblxuICAgICAgICBpZiAoZGVwdGggPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHRyYSB9XCIsIHRvayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodG9rLnRleHQgPT09IFwiRU9GXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCBpbiBhIG1hY3JvIGFyZ3VtZW50XCIgKyBcIiwgZXhwZWN0ZWQgJ1wiICsgKGRlbGltcyAmJiBpc0RlbGltaXRlZCA/IGRlbGltc1ttYXRjaF0gOiBcIn1cIikgKyBcIidcIiwgdG9rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlbGltcyAmJiBpc0RlbGltaXRlZCkge1xuICAgICAgICBpZiAoKGRlcHRoID09PSAwIHx8IGRlcHRoID09PSAxICYmIGRlbGltc1ttYXRjaF0gPT09IFwie1wiKSAmJiB0b2sudGV4dCA9PT0gZGVsaW1zW21hdGNoXSkge1xuICAgICAgICAgICsrbWF0Y2g7XG5cbiAgICAgICAgICBpZiAobWF0Y2ggPT09IGRlbGltcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGluY2x1ZGUgZGVsaW1zIGluIHRva2Vuc1xuICAgICAgICAgICAgdG9rZW5zLnNwbGljZSgtbWF0Y2gsIG1hdGNoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IHdoaWxlIChkZXB0aCAhPT0gMCB8fCBpc0RlbGltaXRlZCk7IC8vIElmIHRoZSBhcmd1bWVudCBmb3VuZCAuLi4gaGFzIHRoZSBmb3JtIOKAmHs8bmVzdGVkIHRva2Vucz594oCZLFxuICAgIC8vIC4uLiB0aGUgb3V0ZXJtb3N0IGJyYWNlcyBlbmNsb3NpbmcgdGhlIGFyZ3VtZW50IGFyZSByZW1vdmVkXG5cblxuICAgIGlmIChzdGFydC50ZXh0ID09PSBcIntcIiAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnRleHQgPT09IFwifVwiKSB7XG4gICAgICB0b2tlbnMucG9wKCk7XG4gICAgICB0b2tlbnMuc2hpZnQoKTtcbiAgICB9XG5cbiAgICB0b2tlbnMucmV2ZXJzZSgpOyAvLyB0byBmaXQgaW4gd2l0aCBzdGFjayBvcmRlclxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VucyxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kOiB0b2tcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDb25zdW1lIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIChkZWxpbWl0ZWQpIGFyZ3VtZW50cyBmcm9tIHRoZSB0b2tlblxuICAgKiBzdHJlYW0gYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAgICovXG5cblxuICBjb25zdW1lQXJncyhudW1BcmdzLCBkZWxpbWl0ZXJzKSB7XG4gICAgaWYgKGRlbGltaXRlcnMpIHtcbiAgICAgIGlmIChkZWxpbWl0ZXJzLmxlbmd0aCAhPT0gbnVtQXJncyArIDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJUaGUgbGVuZ3RoIG9mIGRlbGltaXRlcnMgZG9lc24ndCBtYXRjaCB0aGUgbnVtYmVyIG9mIGFyZ3MhXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVsaW1zID0gZGVsaW1pdGVyc1swXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRvayA9IHRoaXMucG9wVG9rZW4oKTtcblxuICAgICAgICBpZiAoZGVsaW1zW2ldICE9PSB0b2sudGV4dCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVXNlIG9mIHRoZSBtYWNybyBkb2Vzbid0IG1hdGNoIGl0cyBkZWZpbml0aW9uXCIsIHRvayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG51bUFyZ3M7IF9pKyspIHtcbiAgICAgIGFyZ3MucHVzaCh0aGlzLmNvbnN1bWVBcmcoZGVsaW1pdGVycyAmJiBkZWxpbWl0ZXJzW19pICsgMV0pLnRva2Vucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cbiAgLyoqXG4gICAqIEluY3JlbWVudCBgZXhwYW5zaW9uQ291bnRgIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LlxuICAgKiBUaHJvdyBhbiBlcnJvciBpZiBpdCBleGNlZWRzIGBtYXhFeHBhbmRgLlxuICAgKi9cblxuXG4gIGNvdW50RXhwYW5zaW9uKGFtb3VudCkge1xuICAgIHRoaXMuZXhwYW5zaW9uQ291bnQgKz0gYW1vdW50O1xuXG4gICAgaWYgKHRoaXMuZXhwYW5zaW9uQ291bnQgPiB0aGlzLnNldHRpbmdzLm1heEV4cGFuZCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJUb28gbWFueSBleHBhbnNpb25zOiBpbmZpbml0ZSBsb29wIG9yIFwiICsgXCJuZWVkIHRvIGluY3JlYXNlIG1heEV4cGFuZCBzZXR0aW5nXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRXhwYW5kIHRoZSBuZXh0IHRva2VuIG9ubHkgb25jZSBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogSWYgdGhlIHRva2VuIGlzIGV4cGFuZGVkLCB0aGUgcmVzdWx0aW5nIHRva2VucyB3aWxsIGJlIHB1c2hlZCBvbnRvXG4gICAqIHRoZSBzdGFjayBpbiByZXZlcnNlIG9yZGVyLCBhbmQgdGhlIG51bWJlciBvZiBzdWNoIHRva2VucyB3aWxsIGJlXG4gICAqIHJldHVybmVkLiAgVGhpcyBudW1iZXIgbWlnaHQgYmUgemVybyBvciBwb3NpdGl2ZS5cbiAgICpcbiAgICogSWYgbm90LCB0aGUgcmV0dXJuIHZhbHVlIGlzIGBmYWxzZWAsIGFuZCB0aGUgbmV4dCB0b2tlbiByZW1haW5zIGF0IHRoZVxuICAgKiB0b3Agb2YgdGhlIHN0YWNrLlxuICAgKlxuICAgKiBJbiBlaXRoZXIgY2FzZSwgdGhlIG5leHQgdG9rZW4gd2lsbCBiZSBvbiB0aGUgdG9wIG9mIHRoZSBzdGFjayxcbiAgICogb3IgdGhlIHN0YWNrIHdpbGwgYmUgZW1wdHkgKGluIGNhc2Ugb2YgZW1wdHkgZXhwYW5zaW9uXG4gICAqIGFuZCBubyBvdGhlciB0b2tlbnMpLlxuICAgKlxuICAgKiBVc2VkIHRvIGltcGxlbWVudCBgZXhwYW5kQWZ0ZXJGdXR1cmVgIGFuZCBgZXhwYW5kTmV4dFRva2VuYC5cbiAgICpcbiAgICogSWYgZXhwYW5kYWJsZU9ubHksIG9ubHkgZXhwYW5kYWJsZSB0b2tlbnMgYXJlIGV4cGFuZGVkIGFuZFxuICAgKiBhbiB1bmRlZmluZWQgY29udHJvbCBzZXF1ZW5jZSByZXN1bHRzIGluIGFuIGVycm9yLlxuICAgKi9cblxuXG4gIGV4cGFuZE9uY2UoZXhwYW5kYWJsZU9ubHkpIHtcbiAgICB2YXIgdG9wVG9rZW4gPSB0aGlzLnBvcFRva2VuKCk7XG4gICAgdmFyIG5hbWUgPSB0b3BUb2tlbi50ZXh0O1xuICAgIHZhciBleHBhbnNpb24gPSAhdG9wVG9rZW4ubm9leHBhbmQgPyB0aGlzLl9nZXRFeHBhbnNpb24obmFtZSkgOiBudWxsO1xuXG4gICAgaWYgKGV4cGFuc2lvbiA9PSBudWxsIHx8IGV4cGFuZGFibGVPbmx5ICYmIGV4cGFuc2lvbi51bmV4cGFuZGFibGUpIHtcbiAgICAgIGlmIChleHBhbmRhYmxlT25seSAmJiBleHBhbnNpb24gPT0gbnVsbCAmJiBuYW1lWzBdID09PSBcIlxcXFxcIiAmJiAhdGhpcy5pc0RlZmluZWQobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJVbmRlZmluZWQgY29udHJvbCBzZXF1ZW5jZTogXCIgKyBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wdXNoVG9rZW4odG9wVG9rZW4pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuY291bnRFeHBhbnNpb24oMSk7XG4gICAgdmFyIHRva2VucyA9IGV4cGFuc2lvbi50b2tlbnM7XG4gICAgdmFyIGFyZ3MgPSB0aGlzLmNvbnN1bWVBcmdzKGV4cGFuc2lvbi5udW1BcmdzLCBleHBhbnNpb24uZGVsaW1pdGVycyk7XG5cbiAgICBpZiAoZXhwYW5zaW9uLm51bUFyZ3MpIHtcbiAgICAgIC8vIHBhc3RlIGFyZ3VtZW50cyBpbiBwbGFjZSBvZiB0aGUgcGxhY2Vob2xkZXJzXG4gICAgICB0b2tlbnMgPSB0b2tlbnMuc2xpY2UoKTsgLy8gbWFrZSBhIHNoYWxsb3cgY29weVxuXG4gICAgICBmb3IgKHZhciBpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciB0b2sgPSB0b2tlbnNbaV07XG5cbiAgICAgICAgaWYgKHRvay50ZXh0ID09PSBcIiNcIikge1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkluY29tcGxldGUgcGxhY2Vob2xkZXIgYXQgZW5kIG9mIG1hY3JvIGJvZHlcIiwgdG9rKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2sgPSB0b2tlbnNbLS1pXTsgLy8gbmV4dCB0b2tlbiBvbiBzdGFja1xuXG4gICAgICAgICAgaWYgKHRvay50ZXh0ID09PSBcIiNcIikge1xuICAgICAgICAgICAgLy8gIyMg4oaSICNcbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSArIDEsIDEpOyAvLyBkcm9wIGZpcnN0ICNcbiAgICAgICAgICB9IGVsc2UgaWYgKC9eWzEtOV0kLy50ZXN0KHRvay50ZXh0KSkge1xuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgcGxhY2Vob2xkZXIgd2l0aCB0aGUgaW5kaWNhdGVkIGFyZ3VtZW50XG4gICAgICAgICAgICB0b2tlbnMuc3BsaWNlKGksIDIsIC4uLmFyZ3NbK3Rvay50ZXh0IC0gMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIk5vdCBhIHZhbGlkIGFyZ3VtZW50IG51bWJlclwiLCB0b2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gQ29uY2F0ZW5hdGUgZXhwYW5zaW9uIG9udG8gdG9wIG9mIHN0YWNrLlxuXG5cbiAgICB0aGlzLnB1c2hUb2tlbnModG9rZW5zKTtcbiAgICByZXR1cm4gdG9rZW5zLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgICogRXhwYW5kIHRoZSBuZXh0IHRva2VuIG9ubHkgb25jZSAoaWYgcG9zc2libGUpLCBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmdcbiAgICogdG9wIHRva2VuIG9uIHRoZSBzdGFjayAod2l0aG91dCByZW1vdmluZyBhbnl0aGluZyBmcm9tIHRoZSBzdGFjaykuXG4gICAqIFNpbWlsYXIgaW4gYmVoYXZpb3IgdG8gVGVYJ3MgYFxcZXhwYW5kYWZ0ZXJcXGZ1dHVyZWxldGAuXG4gICAqIEVxdWl2YWxlbnQgdG8gZXhwYW5kT25jZSgpIGZvbGxvd2VkIGJ5IGZ1dHVyZSgpLlxuICAgKi9cblxuXG4gIGV4cGFuZEFmdGVyRnV0dXJlKCkge1xuICAgIHRoaXMuZXhwYW5kT25jZSgpO1xuICAgIHJldHVybiB0aGlzLmZ1dHVyZSgpO1xuICB9XG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBleHBhbmQgZmlyc3QgdG9rZW4sIHRoZW4gcmV0dXJuIGZpcnN0IG5vbi1leHBhbmRhYmxlIHRva2VuLlxuICAgKi9cblxuXG4gIGV4cGFuZE5leHRUb2tlbigpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5leHBhbmRPbmNlKCkgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGZ1bGx5IGV4cGFuZGVkXG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMuc3RhY2sucG9wKCk7IC8vIHRoZSB0b2tlbiBhZnRlciBcXG5vZXhwYW5kIGlzIGludGVycHJldGVkIGFzIGlmIGl0cyBtZWFuaW5nXG4gICAgICAgIC8vIHdlcmUg4oCYXFxyZWxheOKAmVxuXG4gICAgICAgIGlmICh0b2tlbi50cmVhdEFzUmVsYXgpIHtcbiAgICAgICAgICB0b2tlbi50ZXh0ID0gXCJcXFxccmVsYXhcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cbiAgICB9IC8vIEZsb3cgdW5hYmxlIHRvIGZpZ3VyZSBvdXQgdGhhdCB0aGlzIHBhdGh3YXkgaXMgaW1wb3NzaWJsZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNDgwOFxuXG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnJlYWNoYWJsZVxuICB9XG4gIC8qKlxuICAgKiBGdWxseSBleHBhbmQgdGhlIGdpdmVuIG1hY3JvIG5hbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGxpc3Qgb2ZcbiAgICogdG9rZW5zLCBvciByZXR1cm4gYHVuZGVmaW5lZGAgaWYgbm8gc3VjaCBtYWNybyBpcyBkZWZpbmVkLlxuICAgKi9cblxuXG4gIGV4cGFuZE1hY3JvKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYWNyb3MuaGFzKG5hbWUpID8gdGhpcy5leHBhbmRUb2tlbnMoW25ldyBUb2tlbihuYW1lKV0pIDogdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBGdWxseSBleHBhbmQgdGhlIGdpdmVuIHRva2VuIHN0cmVhbSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgbGlzdCBvZlxuICAgKiB0b2tlbnMuICBOb3RlIHRoYXQgdGhlIGlucHV0IHRva2VucyBhcmUgaW4gcmV2ZXJzZSBvcmRlciwgYnV0IHRoZVxuICAgKiBvdXRwdXQgdG9rZW5zIGFyZSBpbiBmb3J3YXJkIG9yZGVyLlxuICAgKi9cblxuXG4gIGV4cGFuZFRva2Vucyh0b2tlbnMpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgdmFyIG9sZFN0YWNrTGVuZ3RoID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgdGhpcy5wdXNoVG9rZW5zKHRva2Vucyk7XG5cbiAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiBvbGRTdGFja0xlbmd0aCkge1xuICAgICAgLy8gRXhwYW5kIG9ubHkgZXhwYW5kYWJsZSB0b2tlbnNcbiAgICAgIGlmICh0aGlzLmV4cGFuZE9uY2UodHJ1ZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGZ1bGx5IGV4cGFuZGVkXG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMuc3RhY2sucG9wKCk7XG5cbiAgICAgICAgaWYgKHRva2VuLnRyZWF0QXNSZWxheCkge1xuICAgICAgICAgIC8vIHRoZSBleHBhbnNpb24gb2YgXFxub2V4cGFuZCBpcyB0aGUgdG9rZW4gaXRzZWxmXG4gICAgICAgICAgdG9rZW4ubm9leHBhbmQgPSBmYWxzZTtcbiAgICAgICAgICB0b2tlbi50cmVhdEFzUmVsYXggPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICB9IC8vIENvdW50IGFsbCBvZiB0aGVzZSB0b2tlbnMgYXMgYWRkaXRpb25hbCBleHBhbnNpb25zLCB0byBwcmV2ZW50XG4gICAgLy8gZXhwb25lbnRpYWwgYmxvd3VwIGZyb20gbGluZWFybHkgbWFueSBcXGVkZWYncy5cblxuXG4gICAgdGhpcy5jb3VudEV4cGFuc2lvbihvdXRwdXQubGVuZ3RoKTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIC8qKlxuICAgKiBGdWxseSBleHBhbmQgdGhlIGdpdmVuIG1hY3JvIG5hbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0IGFzIGEgc3RyaW5nLFxuICAgKiBvciByZXR1cm4gYHVuZGVmaW5lZGAgaWYgbm8gc3VjaCBtYWNybyBpcyBkZWZpbmVkLlxuICAgKi9cblxuXG4gIGV4cGFuZE1hY3JvQXNUZXh0KG5hbWUpIHtcbiAgICB2YXIgdG9rZW5zID0gdGhpcy5leHBhbmRNYWNybyhuYW1lKTtcblxuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIHJldHVybiB0b2tlbnMubWFwKHRva2VuID0+IHRva2VuLnRleHQpLmpvaW4oXCJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBleHBhbmRlZCBtYWNybyBhcyBhIHJldmVyc2VkIGFycmF5IG9mIHRva2VucyBhbmQgYSBtYWNyb1xuICAgKiBhcmd1bWVudCBjb3VudC4gIE9yIHJldHVybnMgYG51bGxgIGlmIG5vIHN1Y2ggbWFjcm8uXG4gICAqL1xuXG5cbiAgX2dldEV4cGFuc2lvbihuYW1lKSB7XG4gICAgdmFyIGRlZmluaXRpb24gPSB0aGlzLm1hY3Jvcy5nZXQobmFtZSk7XG5cbiAgICBpZiAoZGVmaW5pdGlvbiA9PSBudWxsKSB7XG4gICAgICAvLyBtYWlubHkgY2hlY2tpbmcgZm9yIHVuZGVmaW5lZCBoZXJlXG4gICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICB9IC8vIElmIGEgc2luZ2xlIGNoYXJhY3RlciBoYXMgYW4gYXNzb2NpYXRlZCBjYXRjb2RlIG90aGVyIHRoYW4gMTNcbiAgICAvLyAoYWN0aXZlIGNoYXJhY3RlciksIHRoZW4gZG9uJ3QgZXhwYW5kIGl0LlxuXG5cbiAgICBpZiAobmFtZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjYXRjb2RlID0gdGhpcy5sZXhlci5jYXRjb2Rlc1tuYW1lXTtcblxuICAgICAgaWYgKGNhdGNvZGUgIT0gbnVsbCAmJiBjYXRjb2RlICE9PSAxMykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGV4cGFuc2lvbiA9IHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBkZWZpbml0aW9uKHRoaXMpIDogZGVmaW5pdGlvbjtcblxuICAgIGlmICh0eXBlb2YgZXhwYW5zaW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YXIgbnVtQXJncyA9IDA7XG5cbiAgICAgIGlmIChleHBhbnNpb24uaW5kZXhPZihcIiNcIikgIT09IC0xKSB7XG4gICAgICAgIHZhciBzdHJpcHBlZCA9IGV4cGFuc2lvbi5yZXBsYWNlKC8jIy9nLCBcIlwiKTtcblxuICAgICAgICB3aGlsZSAoc3RyaXBwZWQuaW5kZXhPZihcIiNcIiArIChudW1BcmdzICsgMSkpICE9PSAtMSkge1xuICAgICAgICAgICsrbnVtQXJncztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYm9keUxleGVyID0gbmV3IExleGVyKGV4cGFuc2lvbiwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICB2YXIgdG9rZW5zID0gW107XG4gICAgICB2YXIgdG9rID0gYm9keUxleGVyLmxleCgpO1xuXG4gICAgICB3aGlsZSAodG9rLnRleHQgIT09IFwiRU9GXCIpIHtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rKTtcbiAgICAgICAgdG9rID0gYm9keUxleGVyLmxleCgpO1xuICAgICAgfVxuXG4gICAgICB0b2tlbnMucmV2ZXJzZSgpOyAvLyB0byBmaXQgaW4gd2l0aCBzdGFjayB1c2luZyBwdXNoIGFuZCBwb3BcblxuICAgICAgdmFyIGV4cGFuZGVkID0ge1xuICAgICAgICB0b2tlbnMsXG4gICAgICAgIG51bUFyZ3NcbiAgICAgIH07XG4gICAgICByZXR1cm4gZXhwYW5kZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cGFuc2lvbjtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBjb21tYW5kIGlzIGN1cnJlbnRseSBcImRlZmluZWRcIiAoaGFzIHNvbWVcbiAgICogZnVuY3Rpb25hbGl0eSksIG1lYW5pbmcgdGhhdCBpdCdzIGEgbWFjcm8gKGluIHRoZSBjdXJyZW50IGdyb3VwKSxcbiAgICogYSBmdW5jdGlvbiwgYSBzeW1ib2wsIG9yIG9uZSBvZiB0aGUgc3BlY2lhbCBjb21tYW5kcyBsaXN0ZWQgaW5cbiAgICogYGltcGxpY2l0Q29tbWFuZHNgLlxuICAgKi9cblxuXG4gIGlzRGVmaW5lZChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFjcm9zLmhhcyhuYW1lKSB8fCBmdW5jdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgc3ltYm9scy5tYXRoLmhhc093blByb3BlcnR5KG5hbWUpIHx8IHN5bWJvbHMudGV4dC5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBpbXBsaWNpdENvbW1hbmRzLmhhc093blByb3BlcnR5KG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBhIGNvbW1hbmQgaXMgZXhwYW5kYWJsZS5cbiAgICovXG5cblxuICBpc0V4cGFuZGFibGUobmFtZSkge1xuICAgIHZhciBtYWNybyA9IHRoaXMubWFjcm9zLmdldChuYW1lKTtcbiAgICByZXR1cm4gbWFjcm8gIT0gbnVsbCA/IHR5cGVvZiBtYWNybyA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWFjcm8gPT09IFwiZnVuY3Rpb25cIiB8fCAhbWFjcm8udW5leHBhbmRhYmxlIDogZnVuY3Rpb25zLmhhc093blByb3BlcnR5KG5hbWUpICYmICFmdW5jdGlvbnNbbmFtZV0ucHJpbWl0aXZlO1xuICB9XG5cbn1cblxuLy8gSGVscGVycyBmb3IgUGFyc2VyLmpzIGhhbmRsaW5nIG9mIFVuaWNvZGUgKHN1YnxzdXBlcilzY3JpcHQgY2hhcmFjdGVycy5cbnZhciB1bmljb2RlU3ViUmVnRXggPSAvXlvigorigovigozigo3igo7igoDigoHigoLigoPigoTigoXigobigofigojigonigpDigpHigpXhtaLisbzigpbigpfigpjigpnigpLigprhtaPigpvigpzhtaThtaXigpPhtabhtafhtajhtanhtapdLztcbnZhciB1U3Vic0FuZFN1cHMgPSBPYmplY3QuZnJlZXplKHtcbiAgJ+KCiic6ICcrJyxcbiAgJ+KCiyc6ICctJyxcbiAgJ+KCjCc6ICc9JyxcbiAgJ+KCjSc6ICcoJyxcbiAgJ+KCjic6ICcpJyxcbiAgJ+KCgCc6ICcwJyxcbiAgJ+KCgSc6ICcxJyxcbiAgJ+KCgic6ICcyJyxcbiAgJ+KCgyc6ICczJyxcbiAgJ+KChCc6ICc0JyxcbiAgJ+KChSc6ICc1JyxcbiAgJ+KChic6ICc2JyxcbiAgJ+KChyc6ICc3JyxcbiAgJ+KCiCc6ICc4JyxcbiAgJ+KCiSc6ICc5JyxcbiAgJ1xcdTIwOTAnOiAnYScsXG4gICdcXHUyMDkxJzogJ2UnLFxuICAnXFx1MjA5NSc6ICdoJyxcbiAgJ1xcdTFENjInOiAnaScsXG4gICdcXHUyQzdDJzogJ2onLFxuICAnXFx1MjA5Nic6ICdrJyxcbiAgJ1xcdTIwOTcnOiAnbCcsXG4gICdcXHUyMDk4JzogJ20nLFxuICAnXFx1MjA5OSc6ICduJyxcbiAgJ1xcdTIwOTInOiAnbycsXG4gICdcXHUyMDlBJzogJ3AnLFxuICAnXFx1MUQ2Myc6ICdyJyxcbiAgJ1xcdTIwOUInOiAncycsXG4gICdcXHUyMDlDJzogJ3QnLFxuICAnXFx1MUQ2NCc6ICd1JyxcbiAgJ1xcdTFENjUnOiAndicsXG4gICdcXHUyMDkzJzogJ3gnLFxuICAnXFx1MUQ2Nic6ICfOsicsXG4gICdcXHUxRDY3JzogJ86zJyxcbiAgJ1xcdTFENjgnOiAnz4EnLFxuICAnXFx1MUQ2OSc6ICdcXHUwM2Q1JyxcbiAgJ1xcdTFENkEnOiAnz4cnLFxuICAn4oG6JzogJysnLFxuICAn4oG7JzogJy0nLFxuICAn4oG8JzogJz0nLFxuICAn4oG9JzogJygnLFxuICAn4oG+JzogJyknLFxuICAn4oGwJzogJzAnLFxuICAnwrknOiAnMScsXG4gICfCsic6ICcyJyxcbiAgJ8KzJzogJzMnLFxuICAn4oG0JzogJzQnLFxuICAn4oG1JzogJzUnLFxuICAn4oG2JzogJzYnLFxuICAn4oG3JzogJzcnLFxuICAn4oG4JzogJzgnLFxuICAn4oG5JzogJzknLFxuICAnXFx1MUQyQyc6ICdBJyxcbiAgJ1xcdTFEMkUnOiAnQicsXG4gICdcXHUxRDMwJzogJ0QnLFxuICAnXFx1MUQzMSc6ICdFJyxcbiAgJ1xcdTFEMzMnOiAnRycsXG4gICdcXHUxRDM0JzogJ0gnLFxuICAnXFx1MUQzNSc6ICdJJyxcbiAgJ1xcdTFEMzYnOiAnSicsXG4gICdcXHUxRDM3JzogJ0snLFxuICAnXFx1MUQzOCc6ICdMJyxcbiAgJ1xcdTFEMzknOiAnTScsXG4gICdcXHUxRDNBJzogJ04nLFxuICAnXFx1MUQzQyc6ICdPJyxcbiAgJ1xcdTFEM0UnOiAnUCcsXG4gICdcXHUxRDNGJzogJ1InLFxuICAnXFx1MUQ0MCc6ICdUJyxcbiAgJ1xcdTFENDEnOiAnVScsXG4gICdcXHUyQzdEJzogJ1YnLFxuICAnXFx1MUQ0Mic6ICdXJyxcbiAgJ1xcdTFENDMnOiAnYScsXG4gICdcXHUxRDQ3JzogJ2InLFxuICAnXFx1MUQ5Qyc6ICdjJyxcbiAgJ1xcdTFENDgnOiAnZCcsXG4gICdcXHUxRDQ5JzogJ2UnLFxuICAnXFx1MURBMCc6ICdmJyxcbiAgJ1xcdTFENEQnOiAnZycsXG4gICdcXHUwMkIwJzogJ2gnLFxuICAnXFx1MjA3MSc6ICdpJyxcbiAgJ1xcdTAyQjInOiAnaicsXG4gICdcXHUxRDRGJzogJ2snLFxuICAnXFx1MDJFMSc6ICdsJyxcbiAgJ1xcdTFENTAnOiAnbScsXG4gICdcXHUyMDdGJzogJ24nLFxuICAnXFx1MUQ1Mic6ICdvJyxcbiAgJ1xcdTFENTYnOiAncCcsXG4gICdcXHUwMkIzJzogJ3InLFxuICAnXFx1MDJFMic6ICdzJyxcbiAgJ1xcdTFENTcnOiAndCcsXG4gICdcXHUxRDU4JzogJ3UnLFxuICAnXFx1MUQ1Qic6ICd2JyxcbiAgJ1xcdTAyQjcnOiAndycsXG4gICdcXHUwMkUzJzogJ3gnLFxuICAnXFx1MDJCOCc6ICd5JyxcbiAgJ1xcdTFEQkInOiAneicsXG4gICdcXHUxRDVEJzogJ86yJyxcbiAgJ1xcdTFENUUnOiAnzrMnLFxuICAnXFx1MUQ1Ric6ICfOtCcsXG4gICdcXHUxRDYwJzogJ1xcdTAzZDUnLFxuICAnXFx1MUQ2MSc6ICfPhycsXG4gICdcXHUxREJGJzogJ864J1xufSk7XG5cbi8qIGVzbGludCBuby1jb25zdGFudC1jb25kaXRpb246MCAqL1xuXG52YXIgdW5pY29kZUFjY2VudHMgPSB7XG4gIFwizIFcIjoge1xuICAgIFwidGV4dFwiOiBcIlxcXFwnXCIsXG4gICAgXCJtYXRoXCI6IFwiXFxcXGFjdXRlXCJcbiAgfSxcbiAgXCLMgFwiOiB7XG4gICAgXCJ0ZXh0XCI6IFwiXFxcXGBcIixcbiAgICBcIm1hdGhcIjogXCJcXFxcZ3JhdmVcIlxuICB9LFxuICBcIsyIXCI6IHtcbiAgICBcInRleHRcIjogXCJcXFxcXFxcIlwiLFxuICAgIFwibWF0aFwiOiBcIlxcXFxkZG90XCJcbiAgfSxcbiAgXCLMg1wiOiB7XG4gICAgXCJ0ZXh0XCI6IFwiXFxcXH5cIixcbiAgICBcIm1hdGhcIjogXCJcXFxcdGlsZGVcIlxuICB9LFxuICBcIsyEXCI6IHtcbiAgICBcInRleHRcIjogXCJcXFxcPVwiLFxuICAgIFwibWF0aFwiOiBcIlxcXFxiYXJcIlxuICB9LFxuICBcIsyGXCI6IHtcbiAgICBcInRleHRcIjogXCJcXFxcdVwiLFxuICAgIFwibWF0aFwiOiBcIlxcXFxicmV2ZVwiXG4gIH0sXG4gIFwizIxcIjoge1xuICAgIFwidGV4dFwiOiBcIlxcXFx2XCIsXG4gICAgXCJtYXRoXCI6IFwiXFxcXGNoZWNrXCJcbiAgfSxcbiAgXCLMglwiOiB7XG4gICAgXCJ0ZXh0XCI6IFwiXFxcXF5cIixcbiAgICBcIm1hdGhcIjogXCJcXFxcaGF0XCJcbiAgfSxcbiAgXCLMh1wiOiB7XG4gICAgXCJ0ZXh0XCI6IFwiXFxcXC5cIixcbiAgICBcIm1hdGhcIjogXCJcXFxcZG90XCJcbiAgfSxcbiAgXCLMilwiOiB7XG4gICAgXCJ0ZXh0XCI6IFwiXFxcXHJcIixcbiAgICBcIm1hdGhcIjogXCJcXFxcbWF0aHJpbmdcIlxuICB9LFxuICBcIsyLXCI6IHtcbiAgICBcInRleHRcIjogXCJcXFxcSFwiXG4gIH0sXG4gIFwizKdcIjoge1xuICAgIFwidGV4dFwiOiBcIlxcXFxjXCJcbiAgfVxufTtcbnZhciB1bmljb2RlU3ltYm9scyA9IHtcbiAgXCLDoVwiOiBcImHMgVwiLFxuICBcIsOgXCI6IFwiYcyAXCIsXG4gIFwiw6RcIjogXCJhzIhcIixcbiAgXCLHn1wiOiBcImHMiMyEXCIsXG4gIFwiw6NcIjogXCJhzINcIixcbiAgXCLEgVwiOiBcImHMhFwiLFxuICBcIsSDXCI6IFwiYcyGXCIsXG4gIFwi4bqvXCI6IFwiYcyGzIFcIixcbiAgXCLhurFcIjogXCJhzIbMgFwiLFxuICBcIuG6tVwiOiBcImHMhsyDXCIsXG4gIFwix45cIjogXCJhzIxcIixcbiAgXCLDolwiOiBcImHMglwiLFxuICBcIuG6pVwiOiBcImHMgsyBXCIsXG4gIFwi4bqnXCI6IFwiYcyCzIBcIixcbiAgXCLhuqtcIjogXCJhzILMg1wiLFxuICBcIsinXCI6IFwiYcyHXCIsXG4gIFwix6FcIjogXCJhzIfMhFwiLFxuICBcIsOlXCI6IFwiYcyKXCIsXG4gIFwix7tcIjogXCJhzIrMgVwiLFxuICBcIuG4g1wiOiBcImLMh1wiLFxuICBcIsSHXCI6IFwiY8yBXCIsXG4gIFwi4biJXCI6IFwiY8ynzIFcIixcbiAgXCLEjVwiOiBcImPMjFwiLFxuICBcIsSJXCI6IFwiY8yCXCIsXG4gIFwixItcIjogXCJjzIdcIixcbiAgXCLDp1wiOiBcImPMp1wiLFxuICBcIsSPXCI6IFwiZMyMXCIsXG4gIFwi4biLXCI6IFwiZMyHXCIsXG4gIFwi4biRXCI6IFwiZMynXCIsXG4gIFwiw6lcIjogXCJlzIFcIixcbiAgXCLDqFwiOiBcImXMgFwiLFxuICBcIsOrXCI6IFwiZcyIXCIsXG4gIFwi4bq9XCI6IFwiZcyDXCIsXG4gIFwixJNcIjogXCJlzIRcIixcbiAgXCLhuJdcIjogXCJlzITMgVwiLFxuICBcIuG4lVwiOiBcImXMhMyAXCIsXG4gIFwixJVcIjogXCJlzIZcIixcbiAgXCLhuJ1cIjogXCJlzKfMhlwiLFxuICBcIsSbXCI6IFwiZcyMXCIsXG4gIFwiw6pcIjogXCJlzIJcIixcbiAgXCLhur9cIjogXCJlzILMgVwiLFxuICBcIuG7gVwiOiBcImXMgsyAXCIsXG4gIFwi4buFXCI6IFwiZcyCzINcIixcbiAgXCLEl1wiOiBcImXMh1wiLFxuICBcIsipXCI6IFwiZcynXCIsXG4gIFwi4bifXCI6IFwiZsyHXCIsXG4gIFwix7VcIjogXCJnzIFcIixcbiAgXCLhuKFcIjogXCJnzIRcIixcbiAgXCLEn1wiOiBcImfMhlwiLFxuICBcIsenXCI6IFwiZ8yMXCIsXG4gIFwixJ1cIjogXCJnzIJcIixcbiAgXCLEoVwiOiBcImfMh1wiLFxuICBcIsSjXCI6IFwiZ8ynXCIsXG4gIFwi4binXCI6IFwiaMyIXCIsXG4gIFwiyJ9cIjogXCJozIxcIixcbiAgXCLEpVwiOiBcImjMglwiLFxuICBcIuG4o1wiOiBcImjMh1wiLFxuICBcIuG4qVwiOiBcImjMp1wiLFxuICBcIsOtXCI6IFwiacyBXCIsXG4gIFwiw6xcIjogXCJpzIBcIixcbiAgXCLDr1wiOiBcImnMiFwiLFxuICBcIuG4r1wiOiBcImnMiMyBXCIsXG4gIFwixKlcIjogXCJpzINcIixcbiAgXCLEq1wiOiBcImnMhFwiLFxuICBcIsStXCI6IFwiacyGXCIsXG4gIFwix5BcIjogXCJpzIxcIixcbiAgXCLDrlwiOiBcImnMglwiLFxuICBcIsewXCI6IFwiasyMXCIsXG4gIFwixLVcIjogXCJqzIJcIixcbiAgXCLhuLFcIjogXCJrzIFcIixcbiAgXCLHqVwiOiBcImvMjFwiLFxuICBcIsS3XCI6IFwia8ynXCIsXG4gIFwixLpcIjogXCJszIFcIixcbiAgXCLEvlwiOiBcImzMjFwiLFxuICBcIsS8XCI6IFwibMynXCIsXG4gIFwi4bi/XCI6IFwibcyBXCIsXG4gIFwi4bmBXCI6IFwibcyHXCIsXG4gIFwixYRcIjogXCJuzIFcIixcbiAgXCLHuVwiOiBcIm7MgFwiLFxuICBcIsOxXCI6IFwibsyDXCIsXG4gIFwixYhcIjogXCJuzIxcIixcbiAgXCLhuYVcIjogXCJuzIdcIixcbiAgXCLFhlwiOiBcIm7Mp1wiLFxuICBcIsOzXCI6IFwib8yBXCIsXG4gIFwiw7JcIjogXCJvzIBcIixcbiAgXCLDtlwiOiBcIm/MiFwiLFxuICBcIsirXCI6IFwib8yIzIRcIixcbiAgXCLDtVwiOiBcIm/Mg1wiLFxuICBcIuG5jVwiOiBcIm/Mg8yBXCIsXG4gIFwi4bmPXCI6IFwib8yDzIhcIixcbiAgXCLIrVwiOiBcIm/Mg8yEXCIsXG4gIFwixY1cIjogXCJvzIRcIixcbiAgXCLhuZNcIjogXCJvzITMgVwiLFxuICBcIuG5kVwiOiBcIm/MhMyAXCIsXG4gIFwixY9cIjogXCJvzIZcIixcbiAgXCLHklwiOiBcIm/MjFwiLFxuICBcIsO0XCI6IFwib8yCXCIsXG4gIFwi4buRXCI6IFwib8yCzIFcIixcbiAgXCLhu5NcIjogXCJvzILMgFwiLFxuICBcIuG7l1wiOiBcIm/MgsyDXCIsXG4gIFwiyK9cIjogXCJvzIdcIixcbiAgXCLIsVwiOiBcIm/Mh8yEXCIsXG4gIFwixZFcIjogXCJvzItcIixcbiAgXCLhuZVcIjogXCJwzIFcIixcbiAgXCLhuZdcIjogXCJwzIdcIixcbiAgXCLFlVwiOiBcInLMgVwiLFxuICBcIsWZXCI6IFwicsyMXCIsXG4gIFwi4bmZXCI6IFwicsyHXCIsXG4gIFwixZdcIjogXCJyzKdcIixcbiAgXCLFm1wiOiBcInPMgVwiLFxuICBcIuG5pVwiOiBcInPMgcyHXCIsXG4gIFwixaFcIjogXCJzzIxcIixcbiAgXCLhuadcIjogXCJzzIzMh1wiLFxuICBcIsWdXCI6IFwic8yCXCIsXG4gIFwi4bmhXCI6IFwic8yHXCIsXG4gIFwixZ9cIjogXCJzzKdcIixcbiAgXCLhupdcIjogXCJ0zIhcIixcbiAgXCLFpVwiOiBcInTMjFwiLFxuICBcIuG5q1wiOiBcInTMh1wiLFxuICBcIsWjXCI6IFwidMynXCIsXG4gIFwiw7pcIjogXCJ1zIFcIixcbiAgXCLDuVwiOiBcInXMgFwiLFxuICBcIsO8XCI6IFwidcyIXCIsXG4gIFwix5hcIjogXCJ1zIjMgVwiLFxuICBcIsecXCI6IFwidcyIzIBcIixcbiAgXCLHllwiOiBcInXMiMyEXCIsXG4gIFwix5pcIjogXCJ1zIjMjFwiLFxuICBcIsWpXCI6IFwidcyDXCIsXG4gIFwi4bm5XCI6IFwidcyDzIFcIixcbiAgXCLFq1wiOiBcInXMhFwiLFxuICBcIuG5u1wiOiBcInXMhMyIXCIsXG4gIFwixa1cIjogXCJ1zIZcIixcbiAgXCLHlFwiOiBcInXMjFwiLFxuICBcIsO7XCI6IFwidcyCXCIsXG4gIFwixa9cIjogXCJ1zIpcIixcbiAgXCLFsVwiOiBcInXMi1wiLFxuICBcIuG5vVwiOiBcInbMg1wiLFxuICBcIuG6g1wiOiBcInfMgVwiLFxuICBcIuG6gVwiOiBcInfMgFwiLFxuICBcIuG6hVwiOiBcInfMiFwiLFxuICBcIsW1XCI6IFwid8yCXCIsXG4gIFwi4bqHXCI6IFwid8yHXCIsXG4gIFwi4bqYXCI6IFwid8yKXCIsXG4gIFwi4bqNXCI6IFwieMyIXCIsXG4gIFwi4bqLXCI6IFwieMyHXCIsXG4gIFwiw71cIjogXCJ5zIFcIixcbiAgXCLhu7NcIjogXCJ5zIBcIixcbiAgXCLDv1wiOiBcInnMiFwiLFxuICBcIuG7uVwiOiBcInnMg1wiLFxuICBcIsizXCI6IFwiecyEXCIsXG4gIFwixbdcIjogXCJ5zIJcIixcbiAgXCLhuo9cIjogXCJ5zIdcIixcbiAgXCLhuplcIjogXCJ5zIpcIixcbiAgXCLFulwiOiBcInrMgVwiLFxuICBcIsW+XCI6IFwiesyMXCIsXG4gIFwi4bqRXCI6IFwiesyCXCIsXG4gIFwixbxcIjogXCJ6zIdcIixcbiAgXCLDgVwiOiBcIkHMgVwiLFxuICBcIsOAXCI6IFwiQcyAXCIsXG4gIFwiw4RcIjogXCJBzIhcIixcbiAgXCLHnlwiOiBcIkHMiMyEXCIsXG4gIFwiw4NcIjogXCJBzINcIixcbiAgXCLEgFwiOiBcIkHMhFwiLFxuICBcIsSCXCI6IFwiQcyGXCIsXG4gIFwi4bquXCI6IFwiQcyGzIFcIixcbiAgXCLhurBcIjogXCJBzIbMgFwiLFxuICBcIuG6tFwiOiBcIkHMhsyDXCIsXG4gIFwix41cIjogXCJBzIxcIixcbiAgXCLDglwiOiBcIkHMglwiLFxuICBcIuG6pFwiOiBcIkHMgsyBXCIsXG4gIFwi4bqmXCI6IFwiQcyCzIBcIixcbiAgXCLhuqpcIjogXCJBzILMg1wiLFxuICBcIsimXCI6IFwiQcyHXCIsXG4gIFwix6BcIjogXCJBzIfMhFwiLFxuICBcIsOFXCI6IFwiQcyKXCIsXG4gIFwix7pcIjogXCJBzIrMgVwiLFxuICBcIuG4glwiOiBcIkLMh1wiLFxuICBcIsSGXCI6IFwiQ8yBXCIsXG4gIFwi4biIXCI6IFwiQ8ynzIFcIixcbiAgXCLEjFwiOiBcIkPMjFwiLFxuICBcIsSIXCI6IFwiQ8yCXCIsXG4gIFwixIpcIjogXCJDzIdcIixcbiAgXCLDh1wiOiBcIkPMp1wiLFxuICBcIsSOXCI6IFwiRMyMXCIsXG4gIFwi4biKXCI6IFwiRMyHXCIsXG4gIFwi4biQXCI6IFwiRMynXCIsXG4gIFwiw4lcIjogXCJFzIFcIixcbiAgXCLDiFwiOiBcIkXMgFwiLFxuICBcIsOLXCI6IFwiRcyIXCIsXG4gIFwi4bq8XCI6IFwiRcyDXCIsXG4gIFwixJJcIjogXCJFzIRcIixcbiAgXCLhuJZcIjogXCJFzITMgVwiLFxuICBcIuG4lFwiOiBcIkXMhMyAXCIsXG4gIFwixJRcIjogXCJFzIZcIixcbiAgXCLhuJxcIjogXCJFzKfMhlwiLFxuICBcIsSaXCI6IFwiRcyMXCIsXG4gIFwiw4pcIjogXCJFzIJcIixcbiAgXCLhur5cIjogXCJFzILMgVwiLFxuICBcIuG7gFwiOiBcIkXMgsyAXCIsXG4gIFwi4buEXCI6IFwiRcyCzINcIixcbiAgXCLEllwiOiBcIkXMh1wiLFxuICBcIsioXCI6IFwiRcynXCIsXG4gIFwi4bieXCI6IFwiRsyHXCIsXG4gIFwix7RcIjogXCJHzIFcIixcbiAgXCLhuKBcIjogXCJHzIRcIixcbiAgXCLEnlwiOiBcIkfMhlwiLFxuICBcIsemXCI6IFwiR8yMXCIsXG4gIFwixJxcIjogXCJHzIJcIixcbiAgXCLEoFwiOiBcIkfMh1wiLFxuICBcIsSiXCI6IFwiR8ynXCIsXG4gIFwi4bimXCI6IFwiSMyIXCIsXG4gIFwiyJ5cIjogXCJIzIxcIixcbiAgXCLEpFwiOiBcIkjMglwiLFxuICBcIuG4olwiOiBcIkjMh1wiLFxuICBcIuG4qFwiOiBcIkjMp1wiLFxuICBcIsONXCI6IFwiScyBXCIsXG4gIFwiw4xcIjogXCJJzIBcIixcbiAgXCLDj1wiOiBcIknMiFwiLFxuICBcIuG4rlwiOiBcIknMiMyBXCIsXG4gIFwixKhcIjogXCJJzINcIixcbiAgXCLEqlwiOiBcIknMhFwiLFxuICBcIsSsXCI6IFwiScyGXCIsXG4gIFwix49cIjogXCJJzIxcIixcbiAgXCLDjlwiOiBcIknMglwiLFxuICBcIsSwXCI6IFwiScyHXCIsXG4gIFwixLRcIjogXCJKzIJcIixcbiAgXCLhuLBcIjogXCJLzIFcIixcbiAgXCLHqFwiOiBcIkvMjFwiLFxuICBcIsS2XCI6IFwiS8ynXCIsXG4gIFwixLlcIjogXCJMzIFcIixcbiAgXCLEvVwiOiBcIkzMjFwiLFxuICBcIsS7XCI6IFwiTMynXCIsXG4gIFwi4bi+XCI6IFwiTcyBXCIsXG4gIFwi4bmAXCI6IFwiTcyHXCIsXG4gIFwixYNcIjogXCJOzIFcIixcbiAgXCLHuFwiOiBcIk7MgFwiLFxuICBcIsORXCI6IFwiTsyDXCIsXG4gIFwixYdcIjogXCJOzIxcIixcbiAgXCLhuYRcIjogXCJOzIdcIixcbiAgXCLFhVwiOiBcIk7Mp1wiLFxuICBcIsOTXCI6IFwiT8yBXCIsXG4gIFwiw5JcIjogXCJPzIBcIixcbiAgXCLDllwiOiBcIk/MiFwiLFxuICBcIsiqXCI6IFwiT8yIzIRcIixcbiAgXCLDlVwiOiBcIk/Mg1wiLFxuICBcIuG5jFwiOiBcIk/Mg8yBXCIsXG4gIFwi4bmOXCI6IFwiT8yDzIhcIixcbiAgXCLIrFwiOiBcIk/Mg8yEXCIsXG4gIFwixYxcIjogXCJPzIRcIixcbiAgXCLhuZJcIjogXCJPzITMgVwiLFxuICBcIuG5kFwiOiBcIk/MhMyAXCIsXG4gIFwixY5cIjogXCJPzIZcIixcbiAgXCLHkVwiOiBcIk/MjFwiLFxuICBcIsOUXCI6IFwiT8yCXCIsXG4gIFwi4buQXCI6IFwiT8yCzIFcIixcbiAgXCLhu5JcIjogXCJPzILMgFwiLFxuICBcIuG7llwiOiBcIk/MgsyDXCIsXG4gIFwiyK5cIjogXCJPzIdcIixcbiAgXCLIsFwiOiBcIk/Mh8yEXCIsXG4gIFwixZBcIjogXCJPzItcIixcbiAgXCLhuZRcIjogXCJQzIFcIixcbiAgXCLhuZZcIjogXCJQzIdcIixcbiAgXCLFlFwiOiBcIlLMgVwiLFxuICBcIsWYXCI6IFwiUsyMXCIsXG4gIFwi4bmYXCI6IFwiUsyHXCIsXG4gIFwixZZcIjogXCJSzKdcIixcbiAgXCLFmlwiOiBcIlPMgVwiLFxuICBcIuG5pFwiOiBcIlPMgcyHXCIsXG4gIFwixaBcIjogXCJTzIxcIixcbiAgXCLhuaZcIjogXCJTzIzMh1wiLFxuICBcIsWcXCI6IFwiU8yCXCIsXG4gIFwi4bmgXCI6IFwiU8yHXCIsXG4gIFwixZ5cIjogXCJTzKdcIixcbiAgXCLFpFwiOiBcIlTMjFwiLFxuICBcIuG5qlwiOiBcIlTMh1wiLFxuICBcIsWiXCI6IFwiVMynXCIsXG4gIFwiw5pcIjogXCJVzIFcIixcbiAgXCLDmVwiOiBcIlXMgFwiLFxuICBcIsOcXCI6IFwiVcyIXCIsXG4gIFwix5dcIjogXCJVzIjMgVwiLFxuICBcIsebXCI6IFwiVcyIzIBcIixcbiAgXCLHlVwiOiBcIlXMiMyEXCIsXG4gIFwix5lcIjogXCJVzIjMjFwiLFxuICBcIsWoXCI6IFwiVcyDXCIsXG4gIFwi4bm4XCI6IFwiVcyDzIFcIixcbiAgXCLFqlwiOiBcIlXMhFwiLFxuICBcIuG5ulwiOiBcIlXMhMyIXCIsXG4gIFwixaxcIjogXCJVzIZcIixcbiAgXCLHk1wiOiBcIlXMjFwiLFxuICBcIsObXCI6IFwiVcyCXCIsXG4gIFwixa5cIjogXCJVzIpcIixcbiAgXCLFsFwiOiBcIlXMi1wiLFxuICBcIuG5vFwiOiBcIlbMg1wiLFxuICBcIuG6glwiOiBcIlfMgVwiLFxuICBcIuG6gFwiOiBcIlfMgFwiLFxuICBcIuG6hFwiOiBcIlfMiFwiLFxuICBcIsW0XCI6IFwiV8yCXCIsXG4gIFwi4bqGXCI6IFwiV8yHXCIsXG4gIFwi4bqMXCI6IFwiWMyIXCIsXG4gIFwi4bqKXCI6IFwiWMyHXCIsXG4gIFwiw51cIjogXCJZzIFcIixcbiAgXCLhu7JcIjogXCJZzIBcIixcbiAgXCLFuFwiOiBcIlnMiFwiLFxuICBcIuG7uFwiOiBcIlnMg1wiLFxuICBcIsiyXCI6IFwiWcyEXCIsXG4gIFwixbZcIjogXCJZzIJcIixcbiAgXCLhuo5cIjogXCJZzIdcIixcbiAgXCLFuVwiOiBcIlrMgVwiLFxuICBcIsW9XCI6IFwiWsyMXCIsXG4gIFwi4bqQXCI6IFwiWsyCXCIsXG4gIFwixbtcIjogXCJazIdcIixcbiAgXCLOrFwiOiBcIs6xzIFcIixcbiAgXCLhvbBcIjogXCLOscyAXCIsXG4gIFwi4b6xXCI6IFwizrHMhFwiLFxuICBcIuG+sFwiOiBcIs6xzIZcIixcbiAgXCLOrVwiOiBcIs61zIFcIixcbiAgXCLhvbJcIjogXCLOtcyAXCIsXG4gIFwizq5cIjogXCLOt8yBXCIsXG4gIFwi4b20XCI6IFwizrfMgFwiLFxuICBcIs6vXCI6IFwizrnMgVwiLFxuICBcIuG9tlwiOiBcIs65zIBcIixcbiAgXCLPilwiOiBcIs65zIhcIixcbiAgXCLOkFwiOiBcIs65zIjMgVwiLFxuICBcIuG/klwiOiBcIs65zIjMgFwiLFxuICBcIuG/kVwiOiBcIs65zIRcIixcbiAgXCLhv5BcIjogXCLOucyGXCIsXG4gIFwiz4xcIjogXCLOv8yBXCIsXG4gIFwi4b24XCI6IFwizr/MgFwiLFxuICBcIs+NXCI6IFwiz4XMgVwiLFxuICBcIuG9ulwiOiBcIs+FzIBcIixcbiAgXCLPi1wiOiBcIs+FzIhcIixcbiAgXCLOsFwiOiBcIs+FzIjMgVwiLFxuICBcIuG/olwiOiBcIs+FzIjMgFwiLFxuICBcIuG/oVwiOiBcIs+FzIRcIixcbiAgXCLhv6BcIjogXCLPhcyGXCIsXG4gIFwiz45cIjogXCLPicyBXCIsXG4gIFwi4b28XCI6IFwiz4nMgFwiLFxuICBcIs6OXCI6IFwizqXMgVwiLFxuICBcIuG/qlwiOiBcIs6lzIBcIixcbiAgXCLOq1wiOiBcIs6lzIhcIixcbiAgXCLhv6lcIjogXCLOpcyEXCIsXG4gIFwi4b+oXCI6IFwizqXMhlwiLFxuICBcIs6PXCI6IFwizqnMgVwiLFxuICBcIuG/ulwiOiBcIs6pzIBcIlxufTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIHBhcnNlciB1c2VkIHRvIHBhcnNlIG91dCBhIFRlWCBleHByZXNzaW9uIGZyb20gdGhlXG4gKiBpbnB1dC4gU2luY2UgVGVYIGlzbid0IGNvbnRleHQtZnJlZSwgc3RhbmRhcmQgcGFyc2VycyBkb24ndCB3b3JrIHBhcnRpY3VsYXJseVxuICogd2VsbC5cbiAqXG4gKiBUaGUgc3RyYXRlZ3kgb2YgdGhpcyBwYXJzZXIgaXMgYXMgc3VjaDpcbiAqXG4gKiBUaGUgbWFpbiBmdW5jdGlvbnMgKHRoZSBgLnBhcnNlLi4uYCBvbmVzKSB0YWtlIGEgcG9zaXRpb24gaW4gdGhlIGN1cnJlbnRcbiAqIHBhcnNlIHN0cmluZyB0byBwYXJzZSB0b2tlbnMgZnJvbS4gVGhlIGxleGVyIChmb3VuZCBpbiBMZXhlci5qcywgc3RvcmVkIGF0XG4gKiB0aGlzLmd1bGxldC5sZXhlcikgYWxzbyBzdXBwb3J0cyBwdWxsaW5nIG91dCB0b2tlbnMgYXQgYXJiaXRyYXJ5IHBsYWNlcy4gV2hlblxuICogaW5kaXZpZHVhbCB0b2tlbnMgYXJlIG5lZWRlZCBhdCBhIHBvc2l0aW9uLCB0aGUgbGV4ZXIgaXMgY2FsbGVkIHRvIHB1bGwgb3V0IGFcbiAqIHRva2VuLCB3aGljaCBpcyB0aGVuIHVzZWQuXG4gKlxuICogVGhlIHBhcnNlciBoYXMgYSBwcm9wZXJ0eSBjYWxsZWQgXCJtb2RlXCIgaW5kaWNhdGluZyB0aGUgbW9kZSB0aGF0XG4gKiB0aGUgcGFyc2VyIGlzIGN1cnJlbnRseSBpbi4gQ3VycmVudGx5IGl0IGhhcyB0byBiZSBvbmUgb2YgXCJtYXRoXCIgb3JcbiAqIFwidGV4dFwiLCB3aGljaCBkZW5vdGVzIHdoZXRoZXIgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgYSBtYXRoLXlcbiAqIG9uZSBvciBhIHRleHQteSBvbmUgKGUuZy4gaW5zaWRlIFxcdGV4dCkuIEN1cnJlbnRseSwgdGhpcyBzZXJ2ZXMgdG9cbiAqIGxpbWl0IHRoZSBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIHVzZWQgaW4gdGV4dCBtb2RlLlxuICpcbiAqIFRoZSBtYWluIGZ1bmN0aW9ucyB0aGVuIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIHVzZWZ1bCBkYXRhIHRoYXRcbiAqIHdhcyBwYXJzZWQgYXQgaXRzIGdpdmVuIHBvaW50LCBhbmQgYSBuZXcgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgcGFyc2VkXG4gKiBkYXRhLiBUaGUgbWFpbiBmdW5jdGlvbnMgY2FuIGNhbGwgZWFjaCBvdGhlciBhbmQgY29udGludWUgdGhlIHBhcnNpbmcgYnlcbiAqIHVzaW5nIHRoZSByZXR1cm5lZCBwb3NpdGlvbiBhcyBhIG5ldyBzdGFydGluZyBwb2ludC5cbiAqXG4gKiBUaGVyZSBhcmUgYWxzbyBleHRyYSBgLmhhbmRsZS4uLmAgZnVuY3Rpb25zLCB3aGljaCBwdWxsIG91dCBzb21lIHJldXNlZFxuICogZnVuY3Rpb25hbGl0eSBpbnRvIHNlbGYtY29udGFpbmVkIGZ1bmN0aW9ucy5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIHJldHVybiBQYXJzZU5vZGVzLlxuICovXG5jbGFzcyBQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihpbnB1dCwgc2V0dGluZ3MpIHtcbiAgICB0aGlzLm1vZGUgPSB2b2lkIDA7XG4gICAgdGhpcy5ndWxsZXQgPSB2b2lkIDA7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHZvaWQgMDtcbiAgICB0aGlzLmxlZnRyaWdodERlcHRoID0gdm9pZCAwO1xuICAgIHRoaXMubmV4dFRva2VuID0gdm9pZCAwO1xuICAgIC8vIFN0YXJ0IGluIG1hdGggbW9kZVxuICAgIHRoaXMubW9kZSA9IFwibWF0aFwiOyAvLyBDcmVhdGUgYSBuZXcgbWFjcm8gZXhwYW5kZXIgKGd1bGxldCkgYW5kIChpbmRpcmVjdGx5IHZpYSB0aGF0KSBhbHNvIGFcbiAgICAvLyBuZXcgbGV4ZXIgKG1vdXRoKSBmb3IgdGhpcyBwYXJzZXIgKHN0b21hY2gsIGluIHRoZSBsYW5ndWFnZSBvZiBUZVgpXG5cbiAgICB0aGlzLmd1bGxldCA9IG5ldyBNYWNyb0V4cGFuZGVyKGlucHV0LCBzZXR0aW5ncywgdGhpcy5tb2RlKTsgLy8gU3RvcmUgdGhlIHNldHRpbmdzIGZvciB1c2UgaW4gcGFyc2luZ1xuXG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzOyAvLyBDb3VudCBsZWZ0cmlnaHQgZGVwdGggKGZvciBcXG1pZGRsZSBlcnJvcnMpXG5cbiAgICB0aGlzLmxlZnRyaWdodERlcHRoID0gMDtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGEgcmVzdWx0IHRvIG1ha2Ugc3VyZSBpdCBoYXMgdGhlIHJpZ2h0IHR5cGUsIGFuZCB0aHJvd3MgYW5cbiAgICogYXBwcm9wcmlhdGUgZXJyb3Igb3RoZXJ3aXNlLlxuICAgKi9cblxuXG4gIGV4cGVjdCh0ZXh0LCBjb25zdW1lKSB7XG4gICAgaWYgKGNvbnN1bWUgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3VtZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmV0Y2goKS50ZXh0ICE9PSB0ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkV4cGVjdGVkICdcIiArIHRleHQgKyBcIicsIGdvdCAnXCIgKyB0aGlzLmZldGNoKCkudGV4dCArIFwiJ1wiLCB0aGlzLmZldGNoKCkpO1xuICAgIH1cblxuICAgIGlmIChjb25zdW1lKSB7XG4gICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERpc2NhcmRzIHRoZSBjdXJyZW50IGxvb2thaGVhZCB0b2tlbiwgY29uc2lkZXJpbmcgaXQgY29uc3VtZWQuXG4gICAqL1xuXG5cbiAgY29uc3VtZSgpIHtcbiAgICB0aGlzLm5leHRUb2tlbiA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCBsb29rYWhlYWQgdG9rZW4sIG9yIGlmIHRoZXJlIGlzbid0IG9uZSAoYXQgdGhlXG4gICAqIGJlZ2lubmluZywgb3IgaWYgdGhlIHByZXZpb3VzIGxvb2thaGVhZCB0b2tlbiB3YXMgY29uc3VtZSgpZCksXG4gICAqIGZldGNoIHRoZSBuZXh0IHRva2VuIGFzIHRoZSBuZXcgbG9va2FoZWFkIHRva2VuIGFuZCByZXR1cm4gaXQuXG4gICAqL1xuXG5cbiAgZmV0Y2goKSB7XG4gICAgaWYgKHRoaXMubmV4dFRva2VuID09IG51bGwpIHtcbiAgICAgIHRoaXMubmV4dFRva2VuID0gdGhpcy5ndWxsZXQuZXhwYW5kTmV4dFRva2VuKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubmV4dFRva2VuO1xuICB9XG4gIC8qKlxuICAgKiBTd2l0Y2hlcyBiZXR3ZWVuIFwidGV4dFwiIGFuZCBcIm1hdGhcIiBtb2Rlcy5cbiAgICovXG5cblxuICBzd2l0Y2hNb2RlKG5ld01vZGUpIHtcbiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICAgIHRoaXMuZ3VsbGV0LnN3aXRjaE1vZGUobmV3TW9kZSk7XG4gIH1cbiAgLyoqXG4gICAqIE1haW4gcGFyc2luZyBmdW5jdGlvbiwgd2hpY2ggcGFyc2VzIGFuIGVudGlyZSBpbnB1dC5cbiAgICovXG5cblxuICBwYXJzZSgpIHtcbiAgICBpZiAoIXRoaXMuc2V0dGluZ3MuZ2xvYmFsR3JvdXApIHtcbiAgICAgIC8vIENyZWF0ZSBhIGdyb3VwIG5hbWVzcGFjZSBmb3IgdGhlIG1hdGggZXhwcmVzc2lvbi5cbiAgICAgIC8vIChMYVRlWCBjcmVhdGVzIGEgbmV3IGdyb3VwIGZvciBldmVyeSAkLi4uJCwgJCQuLi4kJCwgXFxbLi4uXFxdLilcbiAgICAgIHRoaXMuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgICB9IC8vIFVzZSBvbGQgXFxjb2xvciBiZWhhdmlvciAoc2FtZSBhcyBMYVRlWCdzIFxcdGV4dGNvbG9yKSBpZiByZXF1ZXN0ZWQuXG4gICAgLy8gV2UgZG8gdGhpcyB3aXRoaW4gdGhlIGdyb3VwIGZvciB0aGUgbWF0aCBleHByZXNzaW9uLCBzbyBpdCBkb2Vzbid0XG4gICAgLy8gcG9sbHV0ZSBzZXR0aW5ncy5tYWNyb3MuXG5cblxuICAgIGlmICh0aGlzLnNldHRpbmdzLmNvbG9ySXNUZXh0Q29sb3IpIHtcbiAgICAgIHRoaXMuZ3VsbGV0Lm1hY3Jvcy5zZXQoXCJcXFxcY29sb3JcIiwgXCJcXFxcdGV4dGNvbG9yXCIpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgdG8gcGFyc2UgdGhlIGlucHV0XG4gICAgICB2YXIgcGFyc2UgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihmYWxzZSk7IC8vIElmIHdlIHN1Y2NlZWRlZCwgbWFrZSBzdXJlIHRoZXJlJ3MgYW4gRU9GIGF0IHRoZSBlbmRcblxuICAgICAgdGhpcy5leHBlY3QoXCJFT0ZcIik7IC8vIEVuZCB0aGUgZ3JvdXAgbmFtZXNwYWNlIGZvciB0aGUgZXhwcmVzc2lvblxuXG4gICAgICBpZiAoIXRoaXMuc2V0dGluZ3MuZ2xvYmFsR3JvdXApIHtcbiAgICAgICAgdGhpcy5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlOyAvLyBDbG9zZSBhbnkgbGVmdG92ZXIgZ3JvdXBzIGluIGNhc2Ugb2YgYSBwYXJzZSBlcnJvci5cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5ndWxsZXQuZW5kR3JvdXBzKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGdWxseSBwYXJzZSBhIHNlcGFyYXRlIHNlcXVlbmNlIG9mIHRva2VucyBhcyBhIHNlcGFyYXRlIGpvYi5cbiAgICogVG9rZW5zIHNob3VsZCBiZSBzcGVjaWZpZWQgaW4gcmV2ZXJzZSBvcmRlciwgYXMgaW4gYSBNYWNyb0RlZmluaXRpb24uXG4gICAqL1xuXG5cbiAgc3VicGFyc2UodG9rZW5zKSB7XG4gICAgLy8gU2F2ZSB0aGUgbmV4dCB0b2tlbiBmcm9tIHRoZSBjdXJyZW50IGpvYi5cbiAgICB2YXIgb2xkVG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICB0aGlzLmNvbnN1bWUoKTsgLy8gUnVuIHRoZSBuZXcgam9iLCB0ZXJtaW5hdGluZyBpdCB3aXRoIGFuIGV4Y2VzcyAnfSdcblxuICAgIHRoaXMuZ3VsbGV0LnB1c2hUb2tlbihuZXcgVG9rZW4oXCJ9XCIpKTtcbiAgICB0aGlzLmd1bGxldC5wdXNoVG9rZW5zKHRva2Vucyk7XG4gICAgdmFyIHBhcnNlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UpO1xuICAgIHRoaXMuZXhwZWN0KFwifVwiKTsgLy8gUmVzdG9yZSB0aGUgbmV4dCB0b2tlbiBmcm9tIHRoZSBjdXJyZW50IGpvYi5cblxuICAgIHRoaXMubmV4dFRva2VuID0gb2xkVG9rZW47XG4gICAgcmV0dXJuIHBhcnNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBcImV4cHJlc3Npb25cIiwgd2hpY2ggaXMgYSBsaXN0IG9mIGF0b21zLlxuICAgKlxuICAgKiBgYnJlYWtPbkluZml4YDogU2hvdWxkIHRoZSBwYXJzaW5nIHN0b3Agd2hlbiB3ZSBoaXQgaW5maXggbm9kZXM/IFRoaXNcbiAgICogICAgICAgICAgICAgICAgIGhhcHBlbnMgd2hlbiBmdW5jdGlvbnMgaGF2ZSBoaWdoZXIgcHJlY2VkZW5jZSBoYW4gaW5maXhcbiAgICogICAgICAgICAgICAgICAgIG5vZGVzIGluIGltcGxpY2l0IHBhcnNlcy5cbiAgICpcbiAgICogYGJyZWFrT25Ub2tlblRleHRgOiBUaGUgdGV4dCBvZiB0aGUgdG9rZW4gdGhhdCB0aGUgZXhwcmVzc2lvbiBzaG91bGQgZW5kXG4gICAqICAgICAgICAgICAgICAgICAgICAgd2l0aCwgb3IgYG51bGxgIGlmIHNvbWV0aGluZyBlbHNlIHNob3VsZCBlbmQgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5cbiAgICovXG4gIHBhcnNlRXhwcmVzc2lvbihicmVha09uSW5maXgsIGJyZWFrT25Ub2tlblRleHQpIHtcbiAgICB2YXIgYm9keSA9IFtdOyAvLyBLZWVwIGFkZGluZyBhdG9tcyB0byB0aGUgYm9keSB1bnRpbCB3ZSBjYW4ndCBwYXJzZSBhbnkgbW9yZSBhdG9tcyAoZWl0aGVyXG4gICAgLy8gd2UgcmVhY2hlZCB0aGUgZW5kLCBhIH0sIG9yIGEgXFxyaWdodClcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBJZ25vcmUgc3BhY2VzIGluIG1hdGggbW9kZVxuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJtYXRoXCIpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZXggPSB0aGlzLmZldGNoKCk7XG5cbiAgICAgIGlmIChQYXJzZXIuZW5kT2ZFeHByZXNzaW9uLmluZGV4T2YobGV4LnRleHQpICE9PSAtMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGJyZWFrT25Ub2tlblRleHQgJiYgbGV4LnRleHQgPT09IGJyZWFrT25Ub2tlblRleHQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChicmVha09uSW5maXggJiYgZnVuY3Rpb25zW2xleC50ZXh0XSAmJiBmdW5jdGlvbnNbbGV4LnRleHRdLmluZml4KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXRvbSA9IHRoaXMucGFyc2VBdG9tKGJyZWFrT25Ub2tlblRleHQpO1xuXG4gICAgICBpZiAoIWF0b20pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGF0b20udHlwZSA9PT0gXCJpbnRlcm5hbFwiKSB7XG4gICAgICAgIC8vIEludGVybmFsIG5vZGVzIGRvIG5vdCBhcHBlYXIgaW4gcGFyc2UgdHJlZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYm9keS5wdXNoKGF0b20pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgICB0aGlzLmZvcm1MaWdhdHVyZXMoYm9keSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlSW5maXhOb2Rlcyhib2R5KTtcbiAgfVxuICAvKipcbiAgICogUmV3cml0ZXMgaW5maXggb3BlcmF0b3JzIHN1Y2ggYXMgXFxvdmVyIHdpdGggY29ycmVzcG9uZGluZyBjb21tYW5kcyBzdWNoXG4gICAqIGFzIFxcZnJhYy5cbiAgICpcbiAgICogVGhlcmUgY2FuIG9ubHkgYmUgb25lIGluZml4IG9wZXJhdG9yIHBlciBncm91cC4gIElmIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZVxuICAgKiB0aGVuIHRoZSBleHByZXNzaW9uIGlzIGFtYmlndW91cy4gIFRoaXMgY2FuIGJlIHJlc29sdmVkIGJ5IGFkZGluZyB7fS5cbiAgICovXG5cblxuICBoYW5kbGVJbmZpeE5vZGVzKGJvZHkpIHtcbiAgICB2YXIgb3ZlckluZGV4ID0gLTE7XG4gICAgdmFyIGZ1bmNOYW1lO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYm9keVtpXS50eXBlID09PSBcImluZml4XCIpIHtcbiAgICAgICAgaWYgKG92ZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIm9ubHkgb25lIGluZml4IG9wZXJhdG9yIHBlciBncm91cFwiLCBib2R5W2ldLnRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG92ZXJJbmRleCA9IGk7XG4gICAgICAgIGZ1bmNOYW1lID0gYm9keVtpXS5yZXBsYWNlV2l0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3ZlckluZGV4ICE9PSAtMSAmJiBmdW5jTmFtZSkge1xuICAgICAgdmFyIG51bWVyTm9kZTtcbiAgICAgIHZhciBkZW5vbU5vZGU7XG4gICAgICB2YXIgbnVtZXJCb2R5ID0gYm9keS5zbGljZSgwLCBvdmVySW5kZXgpO1xuICAgICAgdmFyIGRlbm9tQm9keSA9IGJvZHkuc2xpY2Uob3ZlckluZGV4ICsgMSk7XG5cbiAgICAgIGlmIChudW1lckJvZHkubGVuZ3RoID09PSAxICYmIG51bWVyQm9keVswXS50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgbnVtZXJOb2RlID0gbnVtZXJCb2R5WzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbnVtZXJOb2RlID0ge1xuICAgICAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgYm9keTogbnVtZXJCb2R5XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChkZW5vbUJvZHkubGVuZ3RoID09PSAxICYmIGRlbm9tQm9keVswXS50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgZGVub21Ob2RlID0gZGVub21Cb2R5WzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVub21Ob2RlID0ge1xuICAgICAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgYm9keTogZGVub21Cb2R5XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlO1xuXG4gICAgICBpZiAoZnVuY05hbWUgPT09IFwiXFxcXFxcXFxhYm92ZWZyYWNcIikge1xuICAgICAgICBub2RlID0gdGhpcy5jYWxsRnVuY3Rpb24oZnVuY05hbWUsIFtudW1lck5vZGUsIGJvZHlbb3ZlckluZGV4XSwgZGVub21Ob2RlXSwgW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IHRoaXMuY2FsbEZ1bmN0aW9uKGZ1bmNOYW1lLCBbbnVtZXJOb2RlLCBkZW5vbU5vZGVdLCBbXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBib2R5O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlIGEgc3Vic2NyaXB0IG9yIHN1cGVyc2NyaXB0IHdpdGggbmljZSBlcnJvcnMuXG4gICAqL1xuXG5cbiAgaGFuZGxlU3VwU3Vic2NyaXB0KG5hbWUgLy8gRm9yIGVycm9yIHJlcG9ydGluZy5cbiAgKSB7XG4gICAgdmFyIHN5bWJvbFRva2VuID0gdGhpcy5mZXRjaCgpO1xuICAgIHZhciBzeW1ib2wgPSBzeW1ib2xUb2tlbi50ZXh0O1xuICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIHRoaXMuY29uc3VtZVNwYWNlcygpOyAvLyBpZ25vcmUgc3BhY2VzIGJlZm9yZSBzdXAvc3Vic2NyaXB0IGFyZ3VtZW50XG4gICAgLy8gU2tpcCBvdmVyIGFsbG93ZWQgaW50ZXJuYWwgbm9kZXMgc3VjaCBhcyBcXHJlbGF4XG5cbiAgICB2YXIgZ3JvdXA7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgX2dyb3VwO1xuXG4gICAgICBncm91cCA9IHRoaXMucGFyc2VHcm91cChuYW1lKTtcbiAgICB9IHdoaWxlICgoKF9ncm91cCA9IGdyb3VwKSA9PSBudWxsID8gdm9pZCAwIDogX2dyb3VwLnR5cGUpID09PSBcImludGVybmFsXCIpO1xuXG4gICAgaWYgKCFncm91cCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCBncm91cCBhZnRlciAnXCIgKyBzeW1ib2wgKyBcIidcIiwgc3ltYm9sVG9rZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBncm91cDtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHRleHR1YWwgaW5wdXQgb2YgYW4gdW5zdXBwb3J0ZWQgY29tbWFuZCBpbnRvIGEgdGV4dCBub2RlXG4gICAqIGNvbnRhaW5lZCB3aXRoaW4gYSBjb2xvciBub2RlIHdob3NlIGNvbG9yIGlzIGRldGVybWluZWQgYnkgZXJyb3JDb2xvclxuICAgKi9cblxuXG4gIGZvcm1hdFVuc3VwcG9ydGVkQ21kKHRleHQpIHtcbiAgICB2YXIgdGV4dG9yZEFycmF5ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRleHRvcmRBcnJheS5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICB0ZXh0OiB0ZXh0W2ldXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgdGV4dE5vZGUgPSB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIGJvZHk6IHRleHRvcmRBcnJheVxuICAgIH07XG4gICAgdmFyIGNvbG9yTm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIGNvbG9yOiB0aGlzLnNldHRpbmdzLmVycm9yQ29sb3IsXG4gICAgICBib2R5OiBbdGV4dE5vZGVdXG4gICAgfTtcbiAgICByZXR1cm4gY29sb3JOb2RlO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSBncm91cCB3aXRoIG9wdGlvbmFsIHN1cGVyL3N1YnNjcmlwdHMuXG4gICAqL1xuXG5cbiAgcGFyc2VBdG9tKGJyZWFrT25Ub2tlblRleHQpIHtcbiAgICAvLyBUaGUgYm9keSBvZiBhbiBhdG9tIGlzIGFuIGltcGxpY2l0IGdyb3VwLCBzbyB0aGF0IHRoaW5ncyBsaWtlXG4gICAgLy8gXFxsZWZ0KHhcXHJpZ2h0KV4yIHdvcmsgY29ycmVjdGx5LlxuICAgIHZhciBiYXNlID0gdGhpcy5wYXJzZUdyb3VwKFwiYXRvbVwiLCBicmVha09uVG9rZW5UZXh0KTsgLy8gSW50ZXJuYWwgbm9kZXMgKGUuZy4gXFxyZWxheCkgY2Fubm90IHN1cHBvcnQgc3VwZXIvc3Vic2NyaXB0cy5cbiAgICAvLyBJbnN0ZWFkIHdlIHdpbGwgcGljayB1cCBzdXBlci9zdWJzY3JpcHRzIHdpdGggYmxhbmsgYmFzZSBuZXh0IHJvdW5kLlxuXG4gICAgaWYgKChiYXNlID09IG51bGwgPyB2b2lkIDAgOiBiYXNlLnR5cGUpID09PSBcImludGVybmFsXCIpIHtcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH0gLy8gSW4gdGV4dCBtb2RlLCB3ZSBkb24ndCBoYXZlIHN1cGVyc2NyaXB0cyBvciBzdWJzY3JpcHRzXG5cblxuICAgIGlmICh0aGlzLm1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9IC8vIE5vdGUgdGhhdCBiYXNlIG1heSBiZSBlbXB0eSAoaS5lLiBudWxsKSBhdCB0aGlzIHBvaW50LlxuXG5cbiAgICB2YXIgc3VwZXJzY3JpcHQ7XG4gICAgdmFyIHN1YnNjcmlwdDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBHdWFyYW50ZWVkIGluIG1hdGggbW9kZSwgc28gZWF0IGFueSBzcGFjZXMgZmlyc3QuXG4gICAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTsgLy8gTGV4IHRoZSBmaXJzdCB0b2tlblxuXG4gICAgICB2YXIgbGV4ID0gdGhpcy5mZXRjaCgpO1xuXG4gICAgICBpZiAobGV4LnRleHQgPT09IFwiXFxcXGxpbWl0c1wiIHx8IGxleC50ZXh0ID09PSBcIlxcXFxub2xpbWl0c1wiKSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIGxpbWl0IGNvbnRyb2xcbiAgICAgICAgaWYgKGJhc2UgJiYgYmFzZS50eXBlID09PSBcIm9wXCIpIHtcbiAgICAgICAgICB2YXIgbGltaXRzID0gbGV4LnRleHQgPT09IFwiXFxcXGxpbWl0c1wiO1xuICAgICAgICAgIGJhc2UubGltaXRzID0gbGltaXRzO1xuICAgICAgICAgIGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChiYXNlICYmIGJhc2UudHlwZSA9PT0gXCJvcGVyYXRvcm5hbWVcIikge1xuICAgICAgICAgIGlmIChiYXNlLmFsd2F5c0hhbmRsZVN1cFN1Yikge1xuICAgICAgICAgICAgYmFzZS5saW1pdHMgPSBsZXgudGV4dCA9PT0gXCJcXFxcbGltaXRzXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiTGltaXQgY29udHJvbHMgbXVzdCBmb2xsb3cgYSBtYXRoIG9wZXJhdG9yXCIsIGxleCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgIH0gZWxzZSBpZiAobGV4LnRleHQgPT09IFwiXlwiKSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIHN1cGVyc2NyaXB0IHN0YXJ0XG4gICAgICAgIGlmIChzdXBlcnNjcmlwdCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRG91YmxlIHN1cGVyc2NyaXB0XCIsIGxleCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlcnNjcmlwdCA9IHRoaXMuaGFuZGxlU3VwU3Vic2NyaXB0KFwic3VwZXJzY3JpcHRcIik7XG4gICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSBcIl9cIikge1xuICAgICAgICAvLyBXZSBnb3QgYSBzdWJzY3JpcHQgc3RhcnRcbiAgICAgICAgaWYgKHN1YnNjcmlwdCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRG91YmxlIHN1YnNjcmlwdFwiLCBsZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3Vic2NyaXB0ID0gdGhpcy5oYW5kbGVTdXBTdWJzY3JpcHQoXCJzdWJzY3JpcHRcIik7XG4gICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSBcIidcIikge1xuICAgICAgICAvLyBXZSBnb3QgYSBwcmltZVxuICAgICAgICBpZiAoc3VwZXJzY3JpcHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkRvdWJsZSBzdXBlcnNjcmlwdFwiLCBsZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByaW1lID0ge1xuICAgICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICB0ZXh0OiBcIlxcXFxwcmltZVwiXG4gICAgICAgIH07IC8vIE1hbnkgcHJpbWVzIGNhbiBiZSBncm91cGVkIHRvZ2V0aGVyLCBzbyB3ZSBoYW5kbGUgdGhpcyBoZXJlXG5cbiAgICAgICAgdmFyIHByaW1lcyA9IFtwcmltZV07XG4gICAgICAgIHRoaXMuY29uc3VtZSgpOyAvLyBLZWVwIGxleGluZyB0b2tlbnMgdW50aWwgd2UgZ2V0IHNvbWV0aGluZyB0aGF0J3Mgbm90IGEgcHJpbWVcblxuICAgICAgICB3aGlsZSAodGhpcy5mZXRjaCgpLnRleHQgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgLy8gRm9yIGVhY2ggb25lLCBhZGQgYW5vdGhlciBwcmltZSB0byB0aGUgbGlzdFxuICAgICAgICAgIHByaW1lcy5wdXNoKHByaW1lKTtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfSAvLyBJZiB0aGVyZSdzIGEgc3VwZXJzY3JpcHQgZm9sbG93aW5nIHRoZSBwcmltZXMsIGNvbWJpbmUgdGhhdFxuICAgICAgICAvLyBzdXBlcnNjcmlwdCBpbiB3aXRoIHRoZSBwcmltZXMuXG5cblxuICAgICAgICBpZiAodGhpcy5mZXRjaCgpLnRleHQgPT09IFwiXlwiKSB7XG4gICAgICAgICAgcHJpbWVzLnB1c2godGhpcy5oYW5kbGVTdXBTdWJzY3JpcHQoXCJzdXBlcnNjcmlwdFwiKSk7XG4gICAgICAgIH0gLy8gUHV0IGV2ZXJ5dGhpbmcgaW50byBhbiBvcmRncm91cCBhcyB0aGUgc3VwZXJzY3JpcHRcblxuXG4gICAgICAgIHN1cGVyc2NyaXB0ID0ge1xuICAgICAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgYm9keTogcHJpbWVzXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHVTdWJzQW5kU3Vwc1tsZXgudGV4dF0pIHtcbiAgICAgICAgLy8gQSBVbmljb2RlIHN1YnNjcmlwdCBvciBzdXBlcnNjcmlwdCBjaGFyYWN0ZXIuXG4gICAgICAgIC8vIFdlIHRyZWF0IHRoZXNlIHNpbWlsYXJseSB0byB0aGUgdW5pY29kZS1tYXRoIHBhY2thZ2UuXG4gICAgICAgIC8vIFNvIHdlIHJlbmRlciBhIHN0cmluZyBvZiBVbmljb2RlIChzdWJ8c3VwZXIpc2NyaXB0cyB0aGVcbiAgICAgICAgLy8gc2FtZSBhcyBhIChzdWJ8c3VwZXIpc2NyaXB0IG9mIHJlZ3VsYXIgY2hhcmFjdGVycy5cbiAgICAgICAgdmFyIGlzU3ViID0gdW5pY29kZVN1YlJlZ0V4LnRlc3QobGV4LnRleHQpO1xuICAgICAgICB2YXIgc3Vic3VwVG9rZW5zID0gW107XG4gICAgICAgIHN1YnN1cFRva2Vucy5wdXNoKG5ldyBUb2tlbih1U3Vic0FuZFN1cHNbbGV4LnRleHRdKSk7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpOyAvLyBDb250aW51ZSBmZXRjaGluZyB0b2tlbnMgdG8gZmlsbCBvdXQgdGhlIHN0cmluZy5cblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMuZmV0Y2goKS50ZXh0O1xuXG4gICAgICAgICAgaWYgKCF1U3Vic0FuZFN1cHNbdG9rZW5dKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodW5pY29kZVN1YlJlZ0V4LnRlc3QodG9rZW4pICE9PSBpc1N1Yikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3Vic3VwVG9rZW5zLnVuc2hpZnQobmV3IFRva2VuKHVTdWJzQW5kU3Vwc1t0b2tlbl0pKTtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfSAvLyBOb3cgY3JlYXRlIGEgKHN1YnxzdXBlcilzY3JpcHQuXG5cblxuICAgICAgICB2YXIgYm9keSA9IHRoaXMuc3VicGFyc2Uoc3Vic3VwVG9rZW5zKTtcblxuICAgICAgICBpZiAoaXNTdWIpIHtcbiAgICAgICAgICBzdWJzY3JpcHQgPSB7XG4gICAgICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgICAgICBtb2RlOiBcIm1hdGhcIixcbiAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1cGVyc2NyaXB0ID0ge1xuICAgICAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICAgICAgbW9kZTogXCJtYXRoXCIsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgaXQgd2Fzbid0IF4sIF8sIG9yICcsIHN0b3AgcGFyc2luZyBzdXBlci9zdWJzY3JpcHRzXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gLy8gQmFzZSBtdXN0IGJlIHNldCBpZiBzdXBlcnNjcmlwdCBvciBzdWJzY3JpcHQgYXJlIHNldCBwZXIgbG9naWMgYWJvdmUsXG4gICAgLy8gYnV0IG5lZWQgdG8gY2hlY2sgaGVyZSBmb3IgdHlwZSBjaGVjayB0byBwYXNzLlxuXG5cbiAgICBpZiAoc3VwZXJzY3JpcHQgfHwgc3Vic2NyaXB0KSB7XG4gICAgICAvLyBJZiB3ZSBnb3QgZWl0aGVyIGEgc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0LCBjcmVhdGUgYSBzdXBzdWJcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3Vwc3ViXCIsXG4gICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgc3VwOiBzdXBlcnNjcmlwdCxcbiAgICAgICAgc3ViOiBzdWJzY3JpcHRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIG9yaWdpbmFsIGJvZHlcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGFuIGVudGlyZSBmdW5jdGlvbiwgaW5jbHVkaW5nIGl0cyBiYXNlIGFuZCBhbGwgb2YgaXRzIGFyZ3VtZW50cy5cbiAgICovXG5cblxuICBwYXJzZUZ1bmN0aW9uKGJyZWFrT25Ub2tlblRleHQsIG5hbWUgLy8gRm9yIGRldGVybWluaW5nIGl0cyBjb250ZXh0XG4gICkge1xuICAgIHZhciB0b2tlbiA9IHRoaXMuZmV0Y2goKTtcbiAgICB2YXIgZnVuYyA9IHRva2VuLnRleHQ7XG4gICAgdmFyIGZ1bmNEYXRhID0gZnVuY3Rpb25zW2Z1bmNdO1xuXG4gICAgaWYgKCFmdW5jRGF0YSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5jb25zdW1lKCk7IC8vIGNvbnN1bWUgY29tbWFuZCB0b2tlblxuXG4gICAgaWYgKG5hbWUgJiYgbmFtZSAhPT0gXCJhdG9tXCIgJiYgIWZ1bmNEYXRhLmFsbG93ZWRJbkFyZ3VtZW50KSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkdvdCBmdW5jdGlvbiAnXCIgKyBmdW5jICsgXCInIHdpdGggbm8gYXJndW1lbnRzXCIgKyAobmFtZSA/IFwiIGFzIFwiICsgbmFtZSA6IFwiXCIpLCB0b2tlbik7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT09IFwidGV4dFwiICYmICFmdW5jRGF0YS5hbGxvd2VkSW5UZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkNhbid0IHVzZSBmdW5jdGlvbiAnXCIgKyBmdW5jICsgXCInIGluIHRleHQgbW9kZVwiLCB0b2tlbik7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT09IFwibWF0aFwiICYmIGZ1bmNEYXRhLmFsbG93ZWRJbk1hdGggPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkNhbid0IHVzZSBmdW5jdGlvbiAnXCIgKyBmdW5jICsgXCInIGluIG1hdGggbW9kZVwiLCB0b2tlbik7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGFyZ3MsXG4gICAgICBvcHRBcmdzXG4gICAgfSA9IHRoaXMucGFyc2VBcmd1bWVudHMoZnVuYywgZnVuY0RhdGEpO1xuICAgIHJldHVybiB0aGlzLmNhbGxGdW5jdGlvbihmdW5jLCBhcmdzLCBvcHRBcmdzLCB0b2tlbiwgYnJlYWtPblRva2VuVGV4dCk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYSBmdW5jdGlvbiBoYW5kbGVyIHdpdGggYSBzdWl0YWJsZSBjb250ZXh0IGFuZCBhcmd1bWVudHMuXG4gICAqL1xuXG5cbiAgY2FsbEZ1bmN0aW9uKG5hbWUsIGFyZ3MsIG9wdEFyZ3MsIHRva2VuLCBicmVha09uVG9rZW5UZXh0KSB7XG4gICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICBmdW5jTmFtZTogbmFtZSxcbiAgICAgIHBhcnNlcjogdGhpcyxcbiAgICAgIHRva2VuLFxuICAgICAgYnJlYWtPblRva2VuVGV4dFxuICAgIH07XG4gICAgdmFyIGZ1bmMgPSBmdW5jdGlvbnNbbmFtZV07XG5cbiAgICBpZiAoZnVuYyAmJiBmdW5jLmhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBmdW5jLmhhbmRsZXIoY29udGV4dCwgYXJncywgb3B0QXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiTm8gZnVuY3Rpb24gaGFuZGxlciBmb3IgXCIgKyBuYW1lKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gb3IgZW52aXJvbm1lbnRcbiAgICovXG5cblxuICBwYXJzZUFyZ3VtZW50cyhmdW5jLCAvLyBTaG91bGQgbG9vayBsaWtlIFwiXFxuYW1lXCIgb3IgXCJcXGJlZ2lue25hbWV9XCIuXG4gIGZ1bmNEYXRhKSB7XG4gICAgdmFyIHRvdGFsQXJncyA9IGZ1bmNEYXRhLm51bUFyZ3MgKyBmdW5jRGF0YS5udW1PcHRpb25hbEFyZ3M7XG5cbiAgICBpZiAodG90YWxBcmdzID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgb3B0QXJnczogW11cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgb3B0QXJncyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbEFyZ3M7IGkrKykge1xuICAgICAgdmFyIGFyZ1R5cGUgPSBmdW5jRGF0YS5hcmdUeXBlcyAmJiBmdW5jRGF0YS5hcmdUeXBlc1tpXTtcbiAgICAgIHZhciBpc09wdGlvbmFsID0gaSA8IGZ1bmNEYXRhLm51bU9wdGlvbmFsQXJncztcblxuICAgICAgaWYgKGZ1bmNEYXRhLnByaW1pdGl2ZSAmJiBhcmdUeXBlID09IG51bGwgfHwgLy8gXFxzcXJ0IGV4cGFuZHMgaW50byBwcmltaXRpdmUgaWYgb3B0aW9uYWwgYXJndW1lbnQgZG9lc24ndCBleGlzdFxuICAgICAgZnVuY0RhdGEudHlwZSA9PT0gXCJzcXJ0XCIgJiYgaSA9PT0gMSAmJiBvcHRBcmdzWzBdID09IG51bGwpIHtcbiAgICAgICAgYXJnVHlwZSA9IFwicHJpbWl0aXZlXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlR3JvdXBPZlR5cGUoXCJhcmd1bWVudCB0byAnXCIgKyBmdW5jICsgXCInXCIsIGFyZ1R5cGUsIGlzT3B0aW9uYWwpO1xuXG4gICAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICBvcHRBcmdzLnB1c2goYXJnKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJnICE9IG51bGwpIHtcbiAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzaG91bGQgYmUgdW5yZWFjaGFibGVcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJOdWxsIGFyZ3VtZW50LCBwbGVhc2UgcmVwb3J0IHRoaXMgYXMgYSBidWdcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFyZ3MsXG4gICAgICBvcHRBcmdzXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgZ3JvdXAgd2hlbiB0aGUgbW9kZSBpcyBjaGFuZ2luZy5cbiAgICovXG5cblxuICBwYXJzZUdyb3VwT2ZUeXBlKG5hbWUsIHR5cGUsIG9wdGlvbmFsKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiY29sb3JcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb2xvckdyb3VwKG9wdGlvbmFsKTtcblxuICAgICAgY2FzZSBcInNpemVcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTaXplR3JvdXAob3B0aW9uYWwpO1xuXG4gICAgICBjYXNlIFwidXJsXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVXJsR3JvdXAob3B0aW9uYWwpO1xuXG4gICAgICBjYXNlIFwibWF0aFwiOlxuICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcmd1bWVudEdyb3VwKG9wdGlvbmFsLCB0eXBlKTtcblxuICAgICAgY2FzZSBcImhib3hcIjpcbiAgICAgICAge1xuICAgICAgICAgIC8vIGhib3ggYXJndW1lbnQgdHlwZSB3cmFwcyB0aGUgYXJndW1lbnQgaW4gdGhlIGVxdWl2YWxlbnQgb2ZcbiAgICAgICAgICAvLyBcXGhib3gsIHdoaWNoIGlzIGxpa2UgXFx0ZXh0IGJ1dCBzd2l0Y2hpbmcgdG8gXFx0ZXh0c3R5bGUgc2l6ZS5cbiAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLnBhcnNlQXJndW1lbnRHcm91cChvcHRpb25hbCwgXCJ0ZXh0XCIpO1xuICAgICAgICAgIHJldHVybiBncm91cCAhPSBudWxsID8ge1xuICAgICAgICAgICAgdHlwZTogXCJzdHlsaW5nXCIsXG4gICAgICAgICAgICBtb2RlOiBncm91cC5tb2RlLFxuICAgICAgICAgICAgYm9keTogW2dyb3VwXSxcbiAgICAgICAgICAgIHN0eWxlOiBcInRleHRcIiAvLyBzaW11bGF0ZSBcXHRleHRzdHlsZVxuXG4gICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInJhd1wiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5wYXJzZVN0cmluZ0dyb3VwKFwicmF3XCIsIG9wdGlvbmFsKTtcbiAgICAgICAgICByZXR1cm4gdG9rZW4gIT0gbnVsbCA/IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmF3XCIsXG4gICAgICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgICAgIHN0cmluZzogdG9rZW4udGV4dFxuICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJwcmltaXRpdmVcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJBIHByaW1pdGl2ZSBhcmd1bWVudCBjYW5ub3QgYmUgb3B0aW9uYWxcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9ncm91cDIgPSB0aGlzLnBhcnNlR3JvdXAobmFtZSk7XG5cbiAgICAgICAgICBpZiAoX2dyb3VwMiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkV4cGVjdGVkIGdyb3VwIGFzIFwiICsgbmFtZSwgdGhpcy5mZXRjaCgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gX2dyb3VwMjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwib3JpZ2luYWxcIjpcbiAgICAgIGNhc2UgbnVsbDpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFyZ3VtZW50R3JvdXAob3B0aW9uYWwpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVua25vd24gZ3JvdXAgdHlwZSBhcyBcIiArIG5hbWUsIHRoaXMuZmV0Y2goKSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEaXNjYXJkIGFueSBzcGFjZSB0b2tlbnMsIGZldGNoaW5nIHRoZSBuZXh0IG5vbi1zcGFjZSB0b2tlbi5cbiAgICovXG5cblxuICBjb25zdW1lU3BhY2VzKCkge1xuICAgIHdoaWxlICh0aGlzLmZldGNoKCkudGV4dCA9PT0gXCIgXCIpIHtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgZ3JvdXAsIGVzc2VudGlhbGx5IHJldHVybmluZyB0aGUgc3RyaW5nIGZvcm1lZCBieSB0aGVcbiAgICogYnJhY2UtZW5jbG9zZWQgdG9rZW5zIHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG5cblxuICBwYXJzZVN0cmluZ0dyb3VwKG1vZGVOYW1lLCAvLyBVc2VkIHRvIGRlc2NyaWJlIHRoZSBtb2RlIGluIGVycm9yIG1lc3NhZ2VzLlxuICBvcHRpb25hbCkge1xuICAgIHZhciBhcmdUb2tlbiA9IHRoaXMuZ3VsbGV0LnNjYW5Bcmd1bWVudChvcHRpb25hbCk7XG5cbiAgICBpZiAoYXJnVG9rZW4gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgdmFyIG5leHRUb2tlbjtcblxuICAgIHdoaWxlICgobmV4dFRva2VuID0gdGhpcy5mZXRjaCgpKS50ZXh0ICE9PSBcIkVPRlwiKSB7XG4gICAgICBzdHIgKz0gbmV4dFRva2VuLnRleHQ7XG4gICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnN1bWUoKTsgLy8gY29uc3VtZSB0aGUgZW5kIG9mIHRoZSBhcmd1bWVudFxuXG4gICAgYXJnVG9rZW4udGV4dCA9IHN0cjtcbiAgICByZXR1cm4gYXJnVG9rZW47XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHJlZ2V4LWRlbGltaXRlZCBncm91cDogdGhlIGxhcmdlc3Qgc2VxdWVuY2Ugb2YgdG9rZW5zXG4gICAqIHdob3NlIGNvbmNhdGVuYXRlZCBzdHJpbmdzIG1hdGNoIGByZWdleGAuIFJldHVybnMgdGhlIHN0cmluZ1xuICAgKiBmb3JtZWQgYnkgdGhlIHRva2VucyBwbHVzIHNvbWUgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuXG5cbiAgcGFyc2VSZWdleEdyb3VwKHJlZ2V4LCBtb2RlTmFtZSAvLyBVc2VkIHRvIGRlc2NyaWJlIHRoZSBtb2RlIGluIGVycm9yIG1lc3NhZ2VzLlxuICApIHtcbiAgICB2YXIgZmlyc3RUb2tlbiA9IHRoaXMuZmV0Y2goKTtcbiAgICB2YXIgbGFzdFRva2VuID0gZmlyc3RUb2tlbjtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgbmV4dFRva2VuO1xuXG4gICAgd2hpbGUgKChuZXh0VG9rZW4gPSB0aGlzLmZldGNoKCkpLnRleHQgIT09IFwiRU9GXCIgJiYgcmVnZXgudGVzdChzdHIgKyBuZXh0VG9rZW4udGV4dCkpIHtcbiAgICAgIGxhc3RUb2tlbiA9IG5leHRUb2tlbjtcbiAgICAgIHN0ciArPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cblxuICAgIGlmIChzdHIgPT09IFwiXCIpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBcIiArIG1vZGVOYW1lICsgXCI6ICdcIiArIGZpcnN0VG9rZW4udGV4dCArIFwiJ1wiLCBmaXJzdFRva2VuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmlyc3RUb2tlbi5yYW5nZShsYXN0VG9rZW4sIHN0cik7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIGNvbG9yIGRlc2NyaXB0aW9uLlxuICAgKi9cblxuXG4gIHBhcnNlQ29sb3JHcm91cChvcHRpb25hbCkge1xuICAgIHZhciByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoXCJjb2xvclwiLCBvcHRpb25hbCk7XG5cbiAgICBpZiAocmVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IC9eKCNbYS1mMC05XXszLDR9fCNbYS1mMC05XXs2fXwjW2EtZjAtOV17OH18W2EtZjAtOV17Nn18W2Etel0rKSQvaS5leGVjKHJlcy50ZXh0KTtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBjb2xvcjogJ1wiICsgcmVzLnRleHQgKyBcIidcIiwgcmVzKTtcbiAgICB9XG5cbiAgICB2YXIgY29sb3IgPSBtYXRjaFswXTtcblxuICAgIGlmICgvXlswLTlhLWZdezZ9JC9pLnRlc3QoY29sb3IpKSB7XG4gICAgICAvLyBXZSBhbGxvdyBhIDYtZGlnaXQgSFRNTCBjb2xvciBzcGVjIHdpdGhvdXQgYSBsZWFkaW5nIFwiI1wiLlxuICAgICAgLy8gVGhpcyBmb2xsb3dzIHRoZSB4Y29sb3IgcGFja2FnZSdzIEhUTUwgY29sb3IgbW9kZWwuXG4gICAgICAvLyBQcmVkZWZpbmVkIGNvbG9yIG5hbWVzIGFyZSBhbGwgbWlzc2VkIGJ5IHRoaXMgUmVnRXggcGF0dGVybi5cbiAgICAgIGNvbG9yID0gXCIjXCIgKyBjb2xvcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjb2xvci10b2tlblwiLFxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgY29sb3JcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYSBzaXplIHNwZWNpZmljYXRpb24sIGNvbnNpc3Rpbmcgb2YgbWFnbml0dWRlIGFuZCB1bml0LlxuICAgKi9cblxuXG4gIHBhcnNlU2l6ZUdyb3VwKG9wdGlvbmFsKSB7XG4gICAgdmFyIHJlcztcbiAgICB2YXIgaXNCbGFuayA9IGZhbHNlOyAvLyBkb24ndCBleHBhbmQgYmVmb3JlIHBhcnNlU3RyaW5nR3JvdXBcblxuICAgIHRoaXMuZ3VsbGV0LmNvbnN1bWVTcGFjZXMoKTtcblxuICAgIGlmICghb3B0aW9uYWwgJiYgdGhpcy5ndWxsZXQuZnV0dXJlKCkudGV4dCAhPT0gXCJ7XCIpIHtcbiAgICAgIHJlcyA9IHRoaXMucGFyc2VSZWdleEdyb3VwKC9eWy0rXT8gKig/OiR8XFxkK3xcXGQrXFwuXFxkKnxcXC5cXGQqKSAqW2Etel17MCwyfSAqJC8sIFwic2l6ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gdGhpcy5wYXJzZVN0cmluZ0dyb3VwKFwic2l6ZVwiLCBvcHRpb25hbCk7XG4gICAgfVxuXG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9uYWwgJiYgcmVzLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBCZWNhdXNlIHdlJ3ZlIHRlc3RlZCBmb3Igd2hhdCBpcyAhb3B0aW9uYWwsIHRoaXMgYmxvY2sgd29uJ3RcbiAgICAgIC8vIGFmZmVjdCBcXGtlcm4sIFxcaHNwYWNlLCBldGMuIEl0IHdpbGwgY2FwdHVyZSB0aGUgbWFuZGF0b3J5IGFyZ3VtZW50c1xuICAgICAgLy8gdG8gXFxnZW5mcmFjIGFuZCBcXGFib3ZlLlxuICAgICAgcmVzLnRleHQgPSBcIjBwdFwiOyAvLyBFbmFibGUgXFxhYm92ZXt9XG5cbiAgICAgIGlzQmxhbmsgPSB0cnVlOyAvLyBUaGlzIGlzIGhlcmUgc3BlY2lmaWNhbGx5IGZvciBcXGdlbmZyYWNcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2ggPSAvKFstK10/KSAqKFxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykgKihbYS16XXsyfSkvLmV4ZWMocmVzLnRleHQpO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIHNpemU6ICdcIiArIHJlcy50ZXh0ICsgXCInXCIsIHJlcyk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBudW1iZXI6ICsobWF0Y2hbMV0gKyBtYXRjaFsyXSksXG4gICAgICAvLyBzaWduICsgbWFnbml0dWRlLCBjYXN0IHRvIG51bWJlclxuICAgICAgdW5pdDogbWF0Y2hbM11cbiAgICB9O1xuXG4gICAgaWYgKCF2YWxpZFVuaXQoZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCB1bml0OiAnXCIgKyBkYXRhLnVuaXQgKyBcIidcIiwgcmVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzaXplXCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICB2YWx1ZTogZGF0YSxcbiAgICAgIGlzQmxhbmtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gVVJMLCBjaGVja2luZyBlc2NhcGVkIGxldHRlcnMgYW5kIGFsbG93ZWQgcHJvdG9jb2xzLFxuICAgKiBhbmQgc2V0dGluZyB0aGUgY2F0Y29kZSBvZiAlIGFzIGFuIGFjdGl2ZSBjaGFyYWN0ZXIgKGFzIGluIFxcaHlwZXJyZWYpLlxuICAgKi9cblxuXG4gIHBhcnNlVXJsR3JvdXAob3B0aW9uYWwpIHtcbiAgICB0aGlzLmd1bGxldC5sZXhlci5zZXRDYXRjb2RlKFwiJVwiLCAxMyk7IC8vIGFjdGl2ZSBjaGFyYWN0ZXJcblxuICAgIHRoaXMuZ3VsbGV0LmxleGVyLnNldENhdGNvZGUoXCJ+XCIsIDEyKTsgLy8gb3RoZXIgY2hhcmFjdGVyXG5cbiAgICB2YXIgcmVzID0gdGhpcy5wYXJzZVN0cmluZ0dyb3VwKFwidXJsXCIsIG9wdGlvbmFsKTtcbiAgICB0aGlzLmd1bGxldC5sZXhlci5zZXRDYXRjb2RlKFwiJVwiLCAxNCk7IC8vIGNvbW1lbnQgY2hhcmFjdGVyXG5cbiAgICB0aGlzLmd1bGxldC5sZXhlci5zZXRDYXRjb2RlKFwiflwiLCAxMyk7IC8vIGFjdGl2ZSBjaGFyYWN0ZXJcblxuICAgIGlmIChyZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBoeXBlcnJlZiBwYWNrYWdlIGFsbG93cyBiYWNrc2xhc2hlcyBhbG9uZSBpbiBocmVmLCBidXQgZG9lc24ndFxuICAgIC8vIGdlbmVyYXRlIHZhbGlkIGxpbmtzIGluIHN1Y2ggY2FzZXM7IHdlIGludGVycHJldCB0aGlzIGFzXG4gICAgLy8gXCJ1bmRlZmluZWRcIiBiZWhhdmlvdXIsIGFuZCBrZWVwIHRoZW0gYXMtaXMuIFNvbWUgYnJvd3NlciB3aWxsXG4gICAgLy8gcmVwbGFjZSBiYWNrc2xhc2hlcyB3aXRoIGZvcndhcmQgc2xhc2hlcy5cblxuXG4gICAgdmFyIHVybCA9IHJlcy50ZXh0LnJlcGxhY2UoL1xcXFwoWyMkJSZ+X157fV0pL2csICckMScpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInVybFwiLFxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgdXJsXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGFuIGFyZ3VtZW50IHdpdGggdGhlIG1vZGUgc3BlY2lmaWVkLlxuICAgKi9cblxuXG4gIHBhcnNlQXJndW1lbnRHcm91cChvcHRpb25hbCwgbW9kZSkge1xuICAgIHZhciBhcmdUb2tlbiA9IHRoaXMuZ3VsbGV0LnNjYW5Bcmd1bWVudChvcHRpb25hbCk7XG5cbiAgICBpZiAoYXJnVG9rZW4gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG91dGVyTW9kZSA9IHRoaXMubW9kZTtcblxuICAgIGlmIChtb2RlKSB7XG4gICAgICAvLyBTd2l0Y2ggdG8gc3BlY2lmaWVkIG1vZGVcbiAgICAgIHRoaXMuc3dpdGNoTW9kZShtb2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLmd1bGxldC5iZWdpbkdyb3VwKCk7XG4gICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgXCJFT0ZcIik7IC8vIFRPRE86IGZpbmQgYW4gYWx0ZXJuYXRpdmUgd2F5IHRvIGRlbm90ZSB0aGUgZW5kXG5cbiAgICB0aGlzLmV4cGVjdChcIkVPRlwiKTsgLy8gZXhwZWN0IHRoZSBlbmQgb2YgdGhlIGFyZ3VtZW50XG5cbiAgICB0aGlzLmd1bGxldC5lbmRHcm91cCgpO1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICBsb2M6IGFyZ1Rva2VuLmxvYyxcbiAgICAgIGJvZHk6IGV4cHJlc3Npb25cbiAgICB9O1xuXG4gICAgaWYgKG1vZGUpIHtcbiAgICAgIC8vIFN3aXRjaCBtb2RlIGJhY2tcbiAgICAgIHRoaXMuc3dpdGNoTW9kZShvdXRlck1vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBvcmRpbmFyeSBncm91cCwgd2hpY2ggaXMgZWl0aGVyIGEgc2luZ2xlIG51Y2xldXMgKGxpa2UgXCJ4XCIpXG4gICAqIG9yIGFuIGV4cHJlc3Npb24gaW4gYnJhY2VzIChsaWtlIFwie3greX1cIikgb3IgYW4gaW1wbGljaXQgZ3JvdXAsIGEgZ3JvdXBcbiAgICogdGhhdCBzdGFydHMgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCBlbmRzIHJpZ2h0IGJlZm9yZSBhIGhpZ2hlciBleHBsaWNpdFxuICAgKiBncm91cCBlbmRzLCBvciBhdCBFT0YuXG4gICAqL1xuXG5cbiAgcGFyc2VHcm91cChuYW1lLCAvLyBGb3IgZXJyb3IgcmVwb3J0aW5nLlxuICBicmVha09uVG9rZW5UZXh0KSB7XG4gICAgdmFyIGZpcnN0VG9rZW4gPSB0aGlzLmZldGNoKCk7XG4gICAgdmFyIHRleHQgPSBmaXJzdFRva2VuLnRleHQ7XG4gICAgdmFyIHJlc3VsdDsgLy8gVHJ5IHRvIHBhcnNlIGFuIG9wZW4gYnJhY2Ugb3IgXFxiZWdpbmdyb3VwXG5cbiAgICBpZiAodGV4dCA9PT0gXCJ7XCIgfHwgdGV4dCA9PT0gXCJcXFxcYmVnaW5ncm91cFwiKSB7XG4gICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgIHZhciBncm91cEVuZCA9IHRleHQgPT09IFwie1wiID8gXCJ9XCIgOiBcIlxcXFxlbmRncm91cFwiO1xuICAgICAgdGhpcy5ndWxsZXQuYmVnaW5Hcm91cCgpOyAvLyBJZiB3ZSBnZXQgYSBicmFjZSwgcGFyc2UgYW4gZXhwcmVzc2lvblxuXG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBncm91cEVuZCk7XG4gICAgICB2YXIgbGFzdFRva2VuID0gdGhpcy5mZXRjaCgpO1xuICAgICAgdGhpcy5leHBlY3QoZ3JvdXBFbmQpOyAvLyBDaGVjayB0aGF0IHdlIGdvdCBhIG1hdGNoaW5nIGNsb3NpbmcgYnJhY2VcblxuICAgICAgdGhpcy5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UoZmlyc3RUb2tlbiwgbGFzdFRva2VuKSxcbiAgICAgICAgYm9keTogZXhwcmVzc2lvbixcbiAgICAgICAgLy8gQSBncm91cCBmb3JtZWQgYnkgXFxiZWdpbmdyb3VwLi4uXFxlbmRncm91cCBpcyBhIHNlbWktc2ltcGxlIGdyb3VwXG4gICAgICAgIC8vIHdoaWNoIGRvZXNuJ3QgYWZmZWN0IHNwYWNpbmcgaW4gbWF0aCBtb2RlLCBpLmUuLCBpcyB0cmFuc3BhcmVudC5cbiAgICAgICAgLy8gaHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE5MzAvd2hlbi1zaG91bGQtb25lLVxuICAgICAgICAvLyB1c2UtYmVnaW5ncm91cC1pbnN0ZWFkLW9mLWJncm91cFxuICAgICAgICBzZW1pc2ltcGxlOiB0ZXh0ID09PSBcIlxcXFxiZWdpbmdyb3VwXCIgfHwgdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGVyZSBleGlzdHMgYSBmdW5jdGlvbiB3aXRoIHRoaXMgbmFtZSwgcGFyc2UgdGhlIGZ1bmN0aW9uLlxuICAgICAgLy8gT3RoZXJ3aXNlLCBqdXN0IHJldHVybiBhIG51Y2xldXNcbiAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VGdW5jdGlvbihicmVha09uVG9rZW5UZXh0LCBuYW1lKSB8fCB0aGlzLnBhcnNlU3ltYm9sKCk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCAmJiB0ZXh0WzBdID09PSBcIlxcXFxcIiAmJiAhaW1wbGljaXRDb21tYW5kcy5oYXNPd25Qcm9wZXJ0eSh0ZXh0KSkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy50aHJvd09uRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVuZGVmaW5lZCBjb250cm9sIHNlcXVlbmNlOiBcIiArIHRleHQsIGZpcnN0VG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gdGhpcy5mb3JtYXRVbnN1cHBvcnRlZENtZCh0ZXh0KTtcbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogRm9ybSBsaWdhdHVyZS1saWtlIGNvbWJpbmF0aW9ucyBvZiBjaGFyYWN0ZXJzIGZvciB0ZXh0IG1vZGUuXG4gICAqIFRoaXMgaW5jbHVkZXMgaW5wdXRzIGxpa2UgXCItLVwiLCBcIi0tLVwiLCBcImBgXCIgYW5kIFwiJydcIi5cbiAgICogVGhlIHJlc3VsdCB3aWxsIHNpbXBseSByZXBsYWNlIG11bHRpcGxlIHRleHRvcmQgbm9kZXMgd2l0aCBhIHNpbmdsZVxuICAgKiBjaGFyYWN0ZXIgaW4gZWFjaCB2YWx1ZSBieSBhIHNpbmdsZSB0ZXh0b3JkIG5vZGUgaGF2aW5nIG11bHRpcGxlXG4gICAqIGNoYXJhY3RlcnMgaW4gaXRzIHZhbHVlLiAgVGhlIHJlcHJlc2VudGF0aW9uIGlzIHN0aWxsIEFTQ0lJIHNvdXJjZS5cbiAgICogVGhlIGdyb3VwIHdpbGwgYmUgbW9kaWZpZWQgaW4gcGxhY2UuXG4gICAqL1xuXG5cbiAgZm9ybUxpZ2F0dXJlcyhncm91cCkge1xuICAgIHZhciBuID0gZ3JvdXAubGVuZ3RoIC0gMTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgYSA9IGdyb3VwW2ldOyAvLyAkRmxvd0ZpeE1lOiBOb3QgZXZlcnkgbm9kZSB0eXBlIGhhcyBhIGB0ZXh0YCBwcm9wZXJ0eS5cblxuICAgICAgdmFyIHYgPSBhLnRleHQ7XG5cbiAgICAgIGlmICh2ID09PSBcIi1cIiAmJiBncm91cFtpICsgMV0udGV4dCA9PT0gXCItXCIpIHtcbiAgICAgICAgaWYgKGkgKyAxIDwgbiAmJiBncm91cFtpICsgMl0udGV4dCA9PT0gXCItXCIpIHtcbiAgICAgICAgICBncm91cC5zcGxpY2UoaSwgMywge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UoYSwgZ3JvdXBbaSArIDJdKSxcbiAgICAgICAgICAgIHRleHQ6IFwiLS0tXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuIC09IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JvdXAuc3BsaWNlKGksIDIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICBsb2M6IFNvdXJjZUxvY2F0aW9uLnJhbmdlKGEsIGdyb3VwW2kgKyAxXSksXG4gICAgICAgICAgICB0ZXh0OiBcIi0tXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuIC09IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCh2ID09PSBcIidcIiB8fCB2ID09PSBcImBcIikgJiYgZ3JvdXBbaSArIDFdLnRleHQgPT09IHYpIHtcbiAgICAgICAgZ3JvdXAuc3BsaWNlKGksIDIsIHtcbiAgICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgICBsb2M6IFNvdXJjZUxvY2F0aW9uLnJhbmdlKGEsIGdyb3VwW2kgKyAxXSksXG4gICAgICAgICAgdGV4dDogdiArIHZcbiAgICAgICAgfSk7XG4gICAgICAgIG4gLT0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGEgc2luZ2xlIHN5bWJvbCBvdXQgb2YgdGhlIHN0cmluZy4gSGVyZSwgd2UgaGFuZGxlIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICogc3ltYm9scyBhbmQgc3BlY2lhbCBmdW5jdGlvbnMgbGlrZSBcXHZlcmIuXG4gICAqL1xuXG5cbiAgcGFyc2VTeW1ib2woKSB7XG4gICAgdmFyIG51Y2xldXMgPSB0aGlzLmZldGNoKCk7XG4gICAgdmFyIHRleHQgPSBudWNsZXVzLnRleHQ7XG5cbiAgICBpZiAoL15cXFxcdmVyYlteYS16QS1aXS8udGVzdCh0ZXh0KSkge1xuICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICB2YXIgYXJnID0gdGV4dC5zbGljZSg1KTtcbiAgICAgIHZhciBzdGFyID0gYXJnLmNoYXJBdCgwKSA9PT0gXCIqXCI7XG5cbiAgICAgIGlmIChzdGFyKSB7XG4gICAgICAgIGFyZyA9IGFyZy5zbGljZSgxKTtcbiAgICAgIH0gLy8gTGV4ZXIncyB0b2tlblJlZ2V4IGlzIGNvbnN0cnVjdGVkIHRvIGFsd2F5cyBoYXZlIG1hdGNoaW5nXG4gICAgICAvLyBmaXJzdC9sYXN0IGNoYXJhY3RlcnMuXG5cblxuICAgICAgaWYgKGFyZy5sZW5ndGggPCAyIHx8IGFyZy5jaGFyQXQoMCkgIT09IGFyZy5zbGljZSgtMSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcdmVyYiBhc3NlcnRpb24gZmFpbGVkIC0tXFxuICAgICAgICAgICAgICAgICAgICBwbGVhc2UgcmVwb3J0IHdoYXQgaW5wdXQgY2F1c2VkIHRoaXMgYnVnXCIpO1xuICAgICAgfVxuXG4gICAgICBhcmcgPSBhcmcuc2xpY2UoMSwgLTEpOyAvLyByZW1vdmUgZmlyc3QgYW5kIGxhc3QgY2hhclxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInZlcmJcIixcbiAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgIGJvZHk6IGFyZyxcbiAgICAgICAgc3RhclxuICAgICAgfTtcbiAgICB9IC8vIEF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGEgc3ltYm9sLCBwb3NzaWJseSB3aXRoIGFjY2VudHMuXG4gICAgLy8gRmlyc3QgZXhwYW5kIGFueSBhY2NlbnRlZCBiYXNlIHN5bWJvbCBhY2NvcmRpbmcgdG8gdW5pY29kZVN5bWJvbHMuXG5cblxuICAgIGlmICh1bmljb2RlU3ltYm9scy5oYXNPd25Qcm9wZXJ0eSh0ZXh0WzBdKSAmJiAhc3ltYm9sc1t0aGlzLm1vZGVdW3RleHRbMF1dKSB7XG4gICAgICAvLyBUaGlzIGJlaGF2aW9yIGlzIG5vdCBzdHJpY3QgKFhlVGVYLWNvbXBhdGlibGUpIGluIG1hdGggbW9kZS5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0cmljdCAmJiB0aGlzLm1vZGUgPT09IFwibWF0aFwiKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwidW5pY29kZVRleHRJbk1hdGhNb2RlXCIsIFwiQWNjZW50ZWQgVW5pY29kZSB0ZXh0IGNoYXJhY3RlciBcXFwiXCIgKyB0ZXh0WzBdICsgXCJcXFwiIHVzZWQgaW4gXCIgKyBcIm1hdGggbW9kZVwiLCBudWNsZXVzKTtcbiAgICAgIH1cblxuICAgICAgdGV4dCA9IHVuaWNvZGVTeW1ib2xzW3RleHRbMF1dICsgdGV4dC5zbGljZSgxKTtcbiAgICB9IC8vIFN0cmlwIG9mZiBhbnkgY29tYmluaW5nIGNoYXJhY3RlcnNcblxuXG4gICAgdmFyIG1hdGNoID0gY29tYmluaW5nRGlhY3JpdGljYWxNYXJrc0VuZFJlZ2V4LmV4ZWModGV4dCk7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBtYXRjaC5pbmRleCk7XG5cbiAgICAgIGlmICh0ZXh0ID09PSAnaScpIHtcbiAgICAgICAgdGV4dCA9ICdcXHUwMTMxJzsgLy8gZG90bGVzcyBpLCBpbiBtYXRoIGFuZCB0ZXh0IG1vZGVcbiAgICAgIH0gZWxzZSBpZiAodGV4dCA9PT0gJ2onKSB7XG4gICAgICAgIHRleHQgPSAnXFx1MDIzNyc7IC8vIGRvdGxlc3MgaiwgaW4gbWF0aCBhbmQgdGV4dCBtb2RlXG4gICAgICB9XG4gICAgfSAvLyBSZWNvZ25pemUgYmFzZSBzeW1ib2xcblxuXG4gICAgdmFyIHN5bWJvbDtcblxuICAgIGlmIChzeW1ib2xzW3RoaXMubW9kZV1bdGV4dF0pIHtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0cmljdCAmJiB0aGlzLm1vZGUgPT09ICdtYXRoJyAmJiBleHRyYUxhdGluLmluZGV4T2YodGV4dCkgPj0gMCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcInVuaWNvZGVUZXh0SW5NYXRoTW9kZVwiLCBcIkxhdGluLTEvVW5pY29kZSB0ZXh0IGNoYXJhY3RlciBcXFwiXCIgKyB0ZXh0WzBdICsgXCJcXFwiIHVzZWQgaW4gXCIgKyBcIm1hdGggbW9kZVwiLCBudWNsZXVzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGdyb3VwID0gc3ltYm9sc1t0aGlzLm1vZGVdW3RleHRdLmdyb3VwO1xuICAgICAgdmFyIGxvYyA9IFNvdXJjZUxvY2F0aW9uLnJhbmdlKG51Y2xldXMpO1xuICAgICAgdmFyIHM7XG5cbiAgICAgIGlmIChBVE9NUy5oYXNPd25Qcm9wZXJ0eShncm91cCkpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICB2YXIgZmFtaWx5ID0gZ3JvdXA7XG4gICAgICAgIHMgPSB7XG4gICAgICAgICAgdHlwZTogXCJhdG9tXCIsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGZhbWlseSxcbiAgICAgICAgICBsb2MsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICBzID0ge1xuICAgICAgICAgIHR5cGU6IGdyb3VwLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICBsb2MsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9O1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgc3ltYm9sID0gcztcbiAgICB9IGVsc2UgaWYgKHRleHQuY2hhckNvZGVBdCgwKSA+PSAweDgwKSB7XG4gICAgICAvLyBubyBzeW1ib2wgZm9yIGUuZy4gXlxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3RyaWN0KSB7XG4gICAgICAgIGlmICghc3VwcG9ydGVkQ29kZXBvaW50KHRleHQuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdChcInVua25vd25TeW1ib2xcIiwgXCJVbnJlY29nbml6ZWQgVW5pY29kZSBjaGFyYWN0ZXIgXFxcIlwiICsgdGV4dFswXSArIFwiXFxcIlwiICsgKFwiIChcIiArIHRleHQuY2hhckNvZGVBdCgwKSArIFwiKVwiKSwgbnVjbGV1cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBcIm1hdGhcIikge1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KFwidW5pY29kZVRleHRJbk1hdGhNb2RlXCIsIFwiVW5pY29kZSB0ZXh0IGNoYXJhY3RlciBcXFwiXCIgKyB0ZXh0WzBdICsgXCJcXFwiIHVzZWQgaW4gbWF0aCBtb2RlXCIsIG51Y2xldXMpO1xuICAgICAgICB9XG4gICAgICB9IC8vIEFsbCBub25tYXRoZW1hdGljYWwgVW5pY29kZSBjaGFyYWN0ZXJzIGFyZSByZW5kZXJlZCBhcyBpZiB0aGV5XG4gICAgICAvLyBhcmUgaW4gdGV4dCBtb2RlICh3cmFwcGVkIGluIFxcdGV4dCkgYmVjYXVzZSB0aGF0J3Mgd2hhdCBpdFxuICAgICAgLy8gdGFrZXMgdG8gcmVuZGVyIHRoZW0gaW4gTGFUZVguICBTZXR0aW5nIGBtb2RlOiB0aGlzLm1vZGVgIGlzXG4gICAgICAvLyBhbm90aGVyIG5hdHVyYWwgY2hvaWNlICh0aGUgdXNlciByZXF1ZXN0ZWQgbWF0aCBtb2RlKSwgYnV0XG4gICAgICAvLyB0aGlzIG1ha2VzIGl0IG1vcmUgZGlmZmljdWx0IGZvciBnZXRDaGFyYWN0ZXJNZXRyaWNzKCkgdG9cbiAgICAgIC8vIGRpc3Rpbmd1aXNoIFVuaWNvZGUgY2hhcmFjdGVycyB3aXRob3V0IG1ldHJpY3MgYW5kIHRob3NlIGZvclxuICAgICAgLy8gd2hpY2ggd2Ugd2FudCB0byBzaW11bGF0ZSB0aGUgbGV0dGVyIE0uXG5cblxuICAgICAgc3ltYm9sID0ge1xuICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UobnVjbGV1cyksXG4gICAgICAgIHRleHRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBFT0YsIF4sIF8sIHssIH0sIGV0Yy5cbiAgICB9XG5cbiAgICB0aGlzLmNvbnN1bWUoKTsgLy8gVHJhbnNmb3JtIGNvbWJpbmluZyBjaGFyYWN0ZXJzIGludG8gYWNjZW50c1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhY2NlbnQgPSBtYXRjaFswXVtpXTtcblxuICAgICAgICBpZiAoIXVuaWNvZGVBY2NlbnRzW2FjY2VudF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVua25vd24gYWNjZW50ICcgXCIgKyBhY2NlbnQgKyBcIidcIiwgbnVjbGV1cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29tbWFuZCA9IHVuaWNvZGVBY2NlbnRzW2FjY2VudF1bdGhpcy5tb2RlXSB8fCB1bmljb2RlQWNjZW50c1thY2NlbnRdLnRleHQ7XG5cbiAgICAgICAgaWYgKCFjb21tYW5kKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJBY2NlbnQgXCIgKyBhY2NlbnQgKyBcIiB1bnN1cHBvcnRlZCBpbiBcIiArIHRoaXMubW9kZSArIFwiIG1vZGVcIiwgbnVjbGV1cyk7XG4gICAgICAgIH1cblxuICAgICAgICBzeW1ib2wgPSB7XG4gICAgICAgICAgdHlwZTogXCJhY2NlbnRcIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShudWNsZXVzKSxcbiAgICAgICAgICBsYWJlbDogY29tbWFuZCxcbiAgICAgICAgICBpc1N0cmV0Y2h5OiBmYWxzZSxcbiAgICAgICAgICBpc1NoaWZ0eTogdHJ1ZSxcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgICAgYmFzZTogc3ltYm9sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSAvLyAkRmxvd0ZpeE1lXG5cblxuICAgIHJldHVybiBzeW1ib2w7XG4gIH1cblxufVxuUGFyc2VyLmVuZE9mRXhwcmVzc2lvbiA9IFtcIn1cIiwgXCJcXFxcZW5kZ3JvdXBcIiwgXCJcXFxcZW5kXCIsIFwiXFxcXHJpZ2h0XCIsIFwiJlwiXTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIHNpbmdsZSBmdW5jdGlvbiBmb3IgcGFyc2luZyBhbiBleHByZXNzaW9uIHVzaW5nIGEgUGFyc2VyXG4gKiBUT0RPKGVtaWx5KTogUmVtb3ZlIHRoaXNcbiAqL1xuXG4vKipcbiAqIFBhcnNlcyBhbiBleHByZXNzaW9uIHVzaW5nIGEgUGFyc2VyLCB0aGVuIHJldHVybnMgdGhlIHBhcnNlZCByZXN1bHQuXG4gKi9cbnZhciBwYXJzZVRyZWUgPSBmdW5jdGlvbiBwYXJzZVRyZWUodG9QYXJzZSwgc2V0dGluZ3MpIHtcbiAgaWYgKCEodHlwZW9mIHRvUGFyc2UgPT09ICdzdHJpbmcnIHx8IHRvUGFyc2UgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignS2FUZVggY2FuIG9ubHkgcGFyc2Ugc3RyaW5nIHR5cGVkIGV4cHJlc3Npb24nKTtcbiAgfVxuXG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKHRvUGFyc2UsIHNldHRpbmdzKTsgLy8gQmxhbmsgb3V0IGFueSBcXGRmQHRhZyB0byBhdm9pZCBzcHVyaW91cyBcIkR1cGxpY2F0ZSBcXHRhZ1wiIGVycm9yc1xuXG4gIGRlbGV0ZSBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5jdXJyZW50W1wiXFxcXGRmQHRhZ1wiXTtcbiAgdmFyIHRyZWUgPSBwYXJzZXIucGFyc2UoKTsgLy8gUHJldmVudCBhIGNvbG9yIGRlZmluaXRpb24gZnJvbSBwZXJzaXN0aW5nIGJldHdlZW4gY2FsbHMgdG8ga2F0ZXgucmVuZGVyKCkuXG5cbiAgZGVsZXRlIHBhcnNlci5ndWxsZXQubWFjcm9zLmN1cnJlbnRbXCJcXFxcY3VycmVudEBjb2xvclwiXTtcbiAgZGVsZXRlIHBhcnNlci5ndWxsZXQubWFjcm9zLmN1cnJlbnRbXCJcXFxcY29sb3JcIl07IC8vIElmIHRoZSBpbnB1dCB1c2VkIFxcdGFnLCBpdCB3aWxsIHNldCB0aGUgXFxkZkB0YWcgbWFjcm8gdG8gdGhlIHRhZy5cbiAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBzZXBhcmF0ZWx5IHBhcnNlIHRoZSB0YWcgYW5kIHdyYXAgdGhlIHRyZWUuXG5cbiAgaWYgKHBhcnNlci5ndWxsZXQubWFjcm9zLmdldChcIlxcXFxkZkB0YWdcIikpIHtcbiAgICBpZiAoIXNldHRpbmdzLmRpc3BsYXlNb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFx0YWcgd29ya3Mgb25seSBpbiBkaXNwbGF5IGVxdWF0aW9uc1wiKTtcbiAgICB9XG5cbiAgICB0cmVlID0gW3tcbiAgICAgIHR5cGU6IFwidGFnXCIsXG4gICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgIGJvZHk6IHRyZWUsXG4gICAgICB0YWc6IHBhcnNlci5zdWJwYXJzZShbbmV3IFRva2VuKFwiXFxcXGRmQHRhZ1wiKV0pXG4gICAgfV07XG4gIH1cblxuICByZXR1cm4gdHJlZTtcbn07XG5cbi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cblxuLyoqXG4gKiBQYXJzZSBhbmQgYnVpbGQgYW4gZXhwcmVzc2lvbiwgYW5kIHBsYWNlIHRoYXQgZXhwcmVzc2lvbiBpbiB0aGUgRE9NIG5vZGVcbiAqIGdpdmVuLlxuICovXG52YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGV4cHJlc3Npb24sIGJhc2VOb2RlLCBvcHRpb25zKSB7XG4gIGJhc2VOb2RlLnRleHRDb250ZW50ID0gXCJcIjtcbiAgdmFyIG5vZGUgPSByZW5kZXJUb0RvbVRyZWUoZXhwcmVzc2lvbiwgb3B0aW9ucykudG9Ob2RlKCk7XG4gIGJhc2VOb2RlLmFwcGVuZENoaWxkKG5vZGUpO1xufTsgLy8gS2FUZVgncyBzdHlsZXMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBxdWlya3MgbW9kZS4gUHJpbnQgb3V0IGFuIGVycm9yLCBhbmRcbi8vIGRpc2FibGUgcmVuZGVyaW5nLlxuXG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgaWYgKGRvY3VtZW50LmNvbXBhdE1vZGUgIT09IFwiQ1NTMUNvbXBhdFwiKSB7XG4gICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKFwiV2FybmluZzogS2FUZVggZG9lc24ndCB3b3JrIGluIHF1aXJrcyBtb2RlLiBNYWtlIHN1cmUgeW91ciBcIiArIFwid2Vic2l0ZSBoYXMgYSBzdWl0YWJsZSBkb2N0eXBlLlwiKTtcblxuICAgIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiS2FUZVggZG9lc24ndCB3b3JrIGluIHF1aXJrcyBtb2RlLlwiKTtcbiAgICB9O1xuICB9XG59XG4vKipcbiAqIFBhcnNlIGFuZCBidWlsZCBhbiBleHByZXNzaW9uLCBhbmQgcmV0dXJuIHRoZSBtYXJrdXAgZm9yIHRoYXQuXG4gKi9cblxuXG52YXIgcmVuZGVyVG9TdHJpbmcgPSBmdW5jdGlvbiByZW5kZXJUb1N0cmluZyhleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gIHZhciBtYXJrdXAgPSByZW5kZXJUb0RvbVRyZWUoZXhwcmVzc2lvbiwgb3B0aW9ucykudG9NYXJrdXAoKTtcbiAgcmV0dXJuIG1hcmt1cDtcbn07XG4vKipcbiAqIFBhcnNlIGFuIGV4cHJlc3Npb24gYW5kIHJldHVybiB0aGUgcGFyc2UgdHJlZS5cbiAqL1xuXG5cbnZhciBnZW5lcmF0ZVBhcnNlVHJlZSA9IGZ1bmN0aW9uIGdlbmVyYXRlUGFyc2VUcmVlKGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKG9wdGlvbnMpO1xuICByZXR1cm4gcGFyc2VUcmVlKGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbn07XG4vKipcbiAqIElmIHRoZSBnaXZlbiBlcnJvciBpcyBhIEthVGVYIFBhcnNlRXJyb3IgYW5kIG9wdGlvbnMudGhyb3dPbkVycm9yIGlzIGZhbHNlLFxuICogcmVuZGVycyB0aGUgaW52YWxpZCBMYVRlWCBhcyBhIHNwYW4gd2l0aCBob3ZlciB0aXRsZSBnaXZpbmcgdGhlIEthVGVYXG4gKiBlcnJvciBtZXNzYWdlLiAgT3RoZXJ3aXNlLCBzaW1wbHkgdGhyb3dzIHRoZSBlcnJvci5cbiAqL1xuXG5cbnZhciByZW5kZXJFcnJvciA9IGZ1bmN0aW9uIHJlbmRlckVycm9yKGVycm9yLCBleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnRocm93T25FcnJvciB8fCAhKGVycm9yIGluc3RhbmNlb2YgUGFyc2VFcnJvcikpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBub2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW1wia2F0ZXgtZXJyb3JcIl0sIFtuZXcgU3ltYm9sTm9kZShleHByZXNzaW9uKV0pO1xuICBub2RlLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIGVycm9yLnRvU3RyaW5nKCkpO1xuICBub2RlLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiY29sb3I6XCIgKyBvcHRpb25zLmVycm9yQ29sb3IpO1xuICByZXR1cm4gbm9kZTtcbn07XG4vKipcbiAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyB0aGUga2F0ZXggYnVpbGQgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciBhZHZhbmNlZFxuICogdXNlIGNhc2VzIChsaWtlIHJlbmRlcmluZyB0byBjdXN0b20gb3V0cHV0KS5cbiAqL1xuXG5cbnZhciByZW5kZXJUb0RvbVRyZWUgPSBmdW5jdGlvbiByZW5kZXJUb0RvbVRyZWUoZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3Mob3B0aW9ucyk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgdHJlZSA9IHBhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gICAgcmV0dXJuIGJ1aWxkVHJlZSh0cmVlLCBleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHJlbmRlckVycm9yKGVycm9yLCBleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gIH1cbn07XG4vKipcbiAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyB0aGUga2F0ZXggYnVpbGQgdHJlZSwgd2l0aCBqdXN0IEhUTUwgKG5vIE1hdGhNTCkuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGFkdmFuY2VkIHVzZSBjYXNlcyAobGlrZSByZW5kZXJpbmcgdG8gY3VzdG9tIG91dHB1dCkuXG4gKi9cblxuXG52YXIgcmVuZGVyVG9IVE1MVHJlZSA9IGZ1bmN0aW9uIHJlbmRlclRvSFRNTFRyZWUoZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3Mob3B0aW9ucyk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgdHJlZSA9IHBhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gICAgcmV0dXJuIGJ1aWxkSFRNTFRyZWUodHJlZSwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiByZW5kZXJFcnJvcihlcnJvciwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xuICB9XG59O1xuXG52YXIgdmVyc2lvbiA9IFwiMC4xNi4yN1wiO1xudmFyIF9fZG9tVHJlZSA9IHtcbiAgU3BhbixcbiAgQW5jaG9yLFxuICBTeW1ib2xOb2RlLFxuICBTdmdOb2RlLFxuICBQYXRoTm9kZSxcbiAgTGluZU5vZGVcbn07IC8vIEVTTSBleHBvcnRzXG5cbnZhciBrYXRleCA9IHtcbiAgLyoqXG4gICAqIEN1cnJlbnQgS2FUZVggdmVyc2lvblxuICAgKi9cbiAgdmVyc2lvbixcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZ2l2ZW4gTGFUZVggaW50byBhbiBIVE1MK01hdGhNTCBjb21iaW5hdGlvbiwgYW5kIGFkZHNcbiAgICogaXQgYXMgYSBjaGlsZCB0byB0aGUgc3BlY2lmaWVkIERPTSBub2RlLlxuICAgKi9cbiAgcmVuZGVyLFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIGFuIEhUTUwrTWF0aE1MIGNvbWJpbmF0aW9uIHN0cmluZyxcbiAgICogZm9yIHNlbmRpbmcgdG8gdGhlIGNsaWVudC5cbiAgICovXG4gIHJlbmRlclRvU3RyaW5nLFxuXG4gIC8qKlxuICAgKiBLYVRlWCBlcnJvciwgdXN1YWxseSBkdXJpbmcgcGFyc2luZy5cbiAgICovXG4gIFBhcnNlRXJyb3IsXG5cbiAgLyoqXG4gICAqIFRoZSBzY2hlbWEgb2YgU2V0dGluZ3NcbiAgICovXG4gIFNFVFRJTkdTX1NDSEVNQSxcblxuICAvKipcbiAgICogUGFyc2VzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIEthVGVYJ3MgaW50ZXJuYWwgcGFyc2UgdHJlZSBzdHJ1Y3R1cmUsXG4gICAqIHdpdGhvdXQgcmVuZGVyaW5nIHRvIEhUTUwgb3IgTWF0aE1MLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBub3QgY3VycmVudGx5IHJlY29tbWVuZGVkIGZvciBwdWJsaWMgdXNlLlxuICAgKiBUaGUgaW50ZXJuYWwgdHJlZSByZXByZXNlbnRhdGlvbiBpcyB1bnN0YWJsZSBhbmQgaXMgdmVyeSBsaWtlbHlcbiAgICogdG8gY2hhbmdlLiBVc2UgYXQgeW91ciBvd24gcmlzay5cbiAgICovXG4gIF9fcGFyc2U6IGdlbmVyYXRlUGFyc2VUcmVlLFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIGFuIEhUTUwrTWF0aE1MIGludGVybmFsIERPTSB0cmVlXG4gICAqIHJlcHJlc2VudGF0aW9uLCB3aXRob3V0IGZsYXR0ZW5pbmcgdGhhdCByZXByZXNlbnRhdGlvbiB0byBhIHN0cmluZy5cbiAgICpcbiAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IGN1cnJlbnRseSByZWNvbW1lbmRlZCBmb3IgcHVibGljIHVzZS5cbiAgICogVGhlIGludGVybmFsIHRyZWUgcmVwcmVzZW50YXRpb24gaXMgdW5zdGFibGUgYW5kIGlzIHZlcnkgbGlrZWx5XG4gICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAqL1xuICBfX3JlbmRlclRvRG9tVHJlZTogcmVuZGVyVG9Eb21UcmVlLFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIGFuIEhUTUwgaW50ZXJuYWwgRE9NIHRyZWUgcmVwcmVzZW50YXRpb24sXG4gICAqIHdpdGhvdXQgTWF0aE1MIGFuZCB3aXRob3V0IGZsYXR0ZW5pbmcgdGhhdCByZXByZXNlbnRhdGlvbiB0byBhIHN0cmluZy5cbiAgICpcbiAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IGN1cnJlbnRseSByZWNvbW1lbmRlZCBmb3IgcHVibGljIHVzZS5cbiAgICogVGhlIGludGVybmFsIHRyZWUgcmVwcmVzZW50YXRpb24gaXMgdW5zdGFibGUgYW5kIGlzIHZlcnkgbGlrZWx5XG4gICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAqL1xuICBfX3JlbmRlclRvSFRNTFRyZWU6IHJlbmRlclRvSFRNTFRyZWUsXG5cbiAgLyoqXG4gICAqIGV4dGVuZHMgaW50ZXJuYWwgZm9udCBtZXRyaWNzIG9iamVjdCB3aXRoIGEgbmV3IG9iamVjdFxuICAgKiBlYWNoIGtleSBpbiB0aGUgbmV3IG9iamVjdCByZXByZXNlbnRzIGEgZm9udCBuYW1lXG4gICovXG4gIF9fc2V0Rm9udE1ldHJpY3M6IHNldEZvbnRNZXRyaWNzLFxuXG4gIC8qKlxuICAgKiBhZGRzIGEgbmV3IHN5bWJvbCB0byBidWlsdGluIHN5bWJvbHMgdGFibGVcbiAgICovXG4gIF9fZGVmaW5lU3ltYm9sOiBkZWZpbmVTeW1ib2wsXG5cbiAgLyoqXG4gICAqIGFkZHMgYSBuZXcgZnVuY3Rpb24gdG8gYnVpbHRpbiBmdW5jdGlvbiBsaXN0LFxuICAgKiB3aGljaCBkaXJlY3RseSBwcm9kdWNlIHBhcnNlIHRyZWUgZWxlbWVudHNcbiAgICogYW5kIGhhdmUgdGhlaXIgb3duIGh0bWwvbWF0aG1sIGJ1aWxkZXJzXG4gICAqL1xuICBfX2RlZmluZUZ1bmN0aW9uOiBkZWZpbmVGdW5jdGlvbixcblxuICAvKipcbiAgICogYWRkcyBhIG5ldyBtYWNybyB0byBidWlsdGluIG1hY3JvIGxpc3RcbiAgICovXG4gIF9fZGVmaW5lTWFjcm86IGRlZmluZU1hY3JvLFxuXG4gIC8qKlxuICAgKiBFeHBvc2UgdGhlIGRvbSB0cmVlIG5vZGUgdHlwZXMsIHdoaWNoIGNhbiBiZSB1c2VmdWwgZm9yIHR5cGUgY2hlY2tpbmcgbm9kZXMuXG4gICAqXG4gICAqIE5PVEU6IFRoZXNlIG1ldGhvZHMgYXJlIG5vdCBjdXJyZW50bHkgcmVjb21tZW5kZWQgZm9yIHB1YmxpYyB1c2UuXG4gICAqIFRoZSBpbnRlcm5hbCB0cmVlIHJlcHJlc2VudGF0aW9uIGlzIHVuc3RhYmxlIGFuZCBpcyB2ZXJ5IGxpa2VseVxuICAgKiB0byBjaGFuZ2UuIFVzZSBhdCB5b3VyIG93biByaXNrLlxuICAgKi9cbiAgX19kb21UcmVlXG59O1xuXG5leHBvcnQgeyBQYXJzZUVycm9yLCBTRVRUSU5HU19TQ0hFTUEsIGRlZmluZUZ1bmN0aW9uIGFzIF9fZGVmaW5lRnVuY3Rpb24sIGRlZmluZU1hY3JvIGFzIF9fZGVmaW5lTWFjcm8sIGRlZmluZVN5bWJvbCBhcyBfX2RlZmluZVN5bWJvbCwgX19kb21UcmVlLCBnZW5lcmF0ZVBhcnNlVHJlZSBhcyBfX3BhcnNlLCByZW5kZXJUb0RvbVRyZWUgYXMgX19yZW5kZXJUb0RvbVRyZWUsIHJlbmRlclRvSFRNTFRyZWUgYXMgX19yZW5kZXJUb0hUTUxUcmVlLCBzZXRGb250TWV0cmljcyBhcyBfX3NldEZvbnRNZXRyaWNzLCBrYXRleCBhcyBkZWZhdWx0LCByZW5kZXIsIHJlbmRlclRvU3RyaW5nLCB2ZXJzaW9uIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/katex/dist/katex.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/longest-streak/index.js":
/*!**********************************************!*\
  !*** ./node_modules/longest-streak/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   longestStreak: () => (/* binding */ longestStreak)\n/* harmony export */ });\n/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nfunction longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb25nZXN0LXN0cmVhay9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbG9uZ2VzdC1zdHJlYWsvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHZXQgdGhlIGNvdW50IG9mIHRoZSBsb25nZXN0IHJlcGVhdGluZyBzdHJlYWsgb2YgYHN1YnN0cmluZ2AgaW4gYHZhbHVlYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqICAgQ29udGVudCB0byBzZWFyY2ggaW4uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3Vic3RyaW5nXG4gKiAgIFN1YnN0cmluZyB0byBsb29rIGZvciwgdHlwaWNhbGx5IG9uZSBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICogICBDb3VudCBvZiBtb3N0IGZyZXF1ZW50IGFkamFjZW50IGBzdWJzdHJpbmdgcyBpbiBgdmFsdWVgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9uZ2VzdFN0cmVhayh2YWx1ZSwgc3Vic3RyaW5nKSB7XG4gIGNvbnN0IHNvdXJjZSA9IFN0cmluZyh2YWx1ZSlcbiAgbGV0IGluZGV4ID0gc291cmNlLmluZGV4T2Yoc3Vic3RyaW5nKVxuICBsZXQgZXhwZWN0ZWQgPSBpbmRleFxuICBsZXQgY291bnQgPSAwXG4gIGxldCBtYXggPSAwXG5cbiAgaWYgKHR5cGVvZiBzdWJzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgc3Vic3RyaW5nJylcbiAgfVxuXG4gIHdoaWxlIChpbmRleCAhPT0gLTEpIHtcbiAgICBpZiAoaW5kZXggPT09IGV4cGVjdGVkKSB7XG4gICAgICBpZiAoKytjb3VudCA+IG1heCkge1xuICAgICAgICBtYXggPSBjb3VudFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDFcbiAgICB9XG5cbiAgICBleHBlY3RlZCA9IGluZGV4ICsgc3Vic3RyaW5nLmxlbmd0aFxuICAgIGluZGV4ID0gc291cmNlLmluZGV4T2Yoc3Vic3RyaW5nLCBleHBlY3RlZClcbiAgfVxuXG4gIHJldHVybiBtYXhcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/longest-streak/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/markdown-table/index.js":
/*!**********************************************!*\
  !*** ./node_modules/markdown-table/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   markdownTable: () => (/* binding */ markdownTable)\n/* harmony export */ });\n// To do: next major: remove.\n/**\n * @typedef {Options} MarkdownTableOptions\n *   Configuration.\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [alignDelimiters=true]\n *   Whether to align the delimiters (default: `true`);\n *   they are aligned by default:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   Pass `false` to make them staggered:\n *\n *   ```markdown\n *   | Alpha | B |\n *   | - | - |\n *   | C | Delta |\n *   ```\n * @property {ReadonlyArray<string | null | undefined> | string | null | undefined} [align]\n *   How to align columns (default: `''`);\n *   one style for all columns or styles for their respective columns;\n *   each style is either `'l'` (left), `'r'` (right), or `'c'` (center);\n *   other values are treated as `''`, which doesnt place the colon in the\n *   alignment row but does align left;\n *   *only the lowercased first character is used, so `Right` is fine.*\n * @property {boolean | null | undefined} [delimiterEnd=true]\n *   Whether to end each row with the delimiter (default: `true`).\n *\n *   >  **Note**: please dont use this: it could create fragile structures\n *   > that arent understandable to some markdown parsers.\n *\n *   When `true`, there are ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B\n *   | ----- | -----\n *   | C     | Delta\n *   ```\n * @property {boolean | null | undefined} [delimiterStart=true]\n *   Whether to begin each row with the delimiter (default: `true`).\n *\n *   >  **Note**: please dont use this: it could create fragile structures\n *   > that arent understandable to some markdown parsers.\n *\n *   When `true`, there are starting delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no starting delimiters:\n *\n *   ```markdown\n *   Alpha | B     |\n *   ----- | ----- |\n *   C     | Delta |\n *   ```\n * @property {boolean | null | undefined} [padding=true]\n *   Whether to add a space of padding between delimiters and cells\n *   (default: `true`).\n *\n *   When `true`, there is padding:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there is no padding:\n *\n *   ```markdown\n *   |Alpha|B    |\n *   |-----|-----|\n *   |C    |Delta|\n *   ```\n * @property {((value: string) => number) | null | undefined} [stringLength]\n *   Function to detect the length of table cell content (optional);\n *   this is used when aligning the delimiters (`|`) between table cells;\n *   full-width characters and emoji mess up delimiter alignment when viewing\n *   the markdown source;\n *   to fix this, you can pass this function,\n *   which receives the cell content and returns its visible size;\n *   note that what is and isnt visible depends on where the text is displayed.\n *\n *   Without such a function, the following:\n *\n *   ```js\n *   markdownTable([\n *     ['Alpha', 'Bravo'],\n *     ['', 'Charlie'],\n *     ['', 'Delta']\n *   ])\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo |\n *   | - | - |\n *   |  | Charlie |\n *   |  | Delta |\n *   ```\n *\n *   With [`string-width`](https://github.com/sindresorhus/string-width):\n *\n *   ```js\n *   import stringWidth from 'string-width'\n *\n *   markdownTable(\n *     [\n *       ['Alpha', 'Bravo'],\n *       ['', 'Charlie'],\n *       ['', 'Delta']\n *     ],\n *     {stringLength: stringWidth}\n *   )\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo   |\n *   | ----- | ------- |\n *   |   | Charlie |\n *   |     | Delta   |\n *   ```\n */\n\n/**\n * @param {string} value\n *   Cell value.\n * @returns {number}\n *   Cell size.\n */\nfunction defaultStringLength(value) {\n  return value.length\n}\n\n/**\n * Generate a markdown\n * ([GFM](https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables))\n * table.\n *\n * @param {ReadonlyArray<ReadonlyArray<string | null | undefined>>} table\n *   Table data (matrix of strings).\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Result.\n */\nfunction markdownTable(table, options) {\n  const settings = options || {}\n  // To do: next major: change to spread.\n  const align = (settings.align || []).concat()\n  const stringLength = settings.stringLength || defaultStringLength\n  /** @type {Array<number>} Character codes as symbols for alignment per column. */\n  const alignments = []\n  /** @type {Array<Array<string>>} Cells per row. */\n  const cellMatrix = []\n  /** @type {Array<Array<number>>} Sizes of each cell per row. */\n  const sizeMatrix = []\n  /** @type {Array<number>} */\n  const longestCellByColumn = []\n  let mostCellsPerRow = 0\n  let rowIndex = -1\n\n  // This is a superfluous loop if we dont align delimiters, but otherwise wed\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < table.length) {\n    /** @type {Array<string>} */\n    const row = []\n    /** @type {Array<number>} */\n    const sizes = []\n    let columnIndex = -1\n\n    if (table[rowIndex].length > mostCellsPerRow) {\n      mostCellsPerRow = table[rowIndex].length\n    }\n\n    while (++columnIndex < table[rowIndex].length) {\n      const cell = serialize(table[rowIndex][columnIndex])\n\n      if (settings.alignDelimiters !== false) {\n        const size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        if (\n          longestCellByColumn[columnIndex] === undefined ||\n          size > longestCellByColumn[columnIndex]\n        ) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  let columnIndex = -1\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    const code = toAlignment(align)\n\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  /** @type {Array<string>} */\n  const row = []\n  /** @type {Array<number>} */\n  const sizes = []\n\n  while (++columnIndex < mostCellsPerRow) {\n    const code = alignments[columnIndex]\n    let before = ''\n    let after = ''\n\n    if (code === 99 /* `c` */) {\n      before = ':'\n      after = ':'\n    } else if (code === 108 /* `l` */) {\n      before = ':'\n    } else if (code === 114 /* `r` */) {\n      after = ':'\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    let size =\n      settings.alignDelimiters === false\n        ? 1\n        : Math.max(\n            1,\n            longestCellByColumn[columnIndex] - before.length - after.length\n          )\n\n    const cell = before + '-'.repeat(size) + after\n\n    if (settings.alignDelimiters !== false) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (++rowIndex < cellMatrix.length) {\n    const row = cellMatrix[rowIndex]\n    const sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    /** @type {Array<string>} */\n    const line = []\n\n    while (++columnIndex < mostCellsPerRow) {\n      const cell = row[columnIndex] || ''\n      let before = ''\n      let after = ''\n\n      if (settings.alignDelimiters !== false) {\n        const size =\n          longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        const code = alignments[columnIndex]\n\n        if (code === 114 /* `r` */) {\n          before = ' '.repeat(size)\n        } else if (code === 99 /* `c` */) {\n          if (size % 2) {\n            before = ' '.repeat(size / 2 + 0.5)\n            after = ' '.repeat(size / 2 - 0.5)\n          } else {\n            before = ' '.repeat(size / 2)\n            after = before\n          }\n        } else {\n          after = ' '.repeat(size)\n        }\n      }\n\n      if (settings.delimiterStart !== false && !columnIndex) {\n        line.push('|')\n      }\n\n      if (\n        settings.padding !== false &&\n        // Dont add the opening space if were not aligning and the cell is\n        // empty: there will be a closing space.\n        !(settings.alignDelimiters === false && cell === '') &&\n        (settings.delimiterStart !== false || columnIndex)\n      ) {\n        line.push(' ')\n      }\n\n      if (settings.alignDelimiters !== false) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (settings.alignDelimiters !== false) {\n        line.push(after)\n      }\n\n      if (settings.padding !== false) {\n        line.push(' ')\n      }\n\n      if (\n        settings.delimiterEnd !== false ||\n        columnIndex !== mostCellsPerRow - 1\n      ) {\n        line.push('|')\n      }\n    }\n\n    lines.push(\n      settings.delimiterEnd === false\n        ? line.join('').replace(/ +$/, '')\n        : line.join('')\n    )\n  }\n\n  return lines.join('\\n')\n}\n\n/**\n * @param {string | null | undefined} [value]\n *   Value to serialize.\n * @returns {string}\n *   Result.\n */\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\n/**\n * @param {string | null | undefined} value\n *   Value.\n * @returns {number}\n *   Alignment.\n */\nfunction toAlignment(value) {\n  const code = typeof value === 'string' ? value.codePointAt(0) : 0\n\n  return code === 67 /* `C` */ || code === 99 /* `c` */\n    ? 99 /* `c` */\n    : code === 76 /* `L` */ || code === 108 /* `l` */\n      ? 108 /* `l` */\n      : code === 82 /* `R` */ || code === 114 /* `r` */\n        ? 114 /* `r` */\n        : 0\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi10YWJsZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzRUFBc0U7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdEQUFnRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlEQUF5RDtBQUNwRTtBQUNBLFdBQVcsc0NBQXNDO0FBQ2pEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQztBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBLGFBQWEsZUFBZTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGVBQWU7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21hcmtkb3duLXRhYmxlL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRvIGRvOiBuZXh0IG1ham9yOiByZW1vdmUuXG4vKipcbiAqIEB0eXBlZGVmIHtPcHRpb25zfSBNYXJrZG93blRhYmxlT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2FsaWduRGVsaW1pdGVycz10cnVlXVxuICogICBXaGV0aGVyIHRvIGFsaWduIHRoZSBkZWxpbWl0ZXJzIChkZWZhdWx0OiBgdHJ1ZWApO1xuICogICB0aGV5IGFyZSBhbGlnbmVkIGJ5IGRlZmF1bHQ6XG4gKlxuICogICBgYGBtYXJrZG93blxuICogICB8IEFscGhhIHwgQiAgICAgfFxuICogICB8IC0tLS0tIHwgLS0tLS0gfFxuICogICB8IEMgICAgIHwgRGVsdGEgfFxuICogICBgYGBcbiAqXG4gKiAgIFBhc3MgYGZhbHNlYCB0byBtYWtlIHRoZW0gc3RhZ2dlcmVkOlxuICpcbiAqICAgYGBgbWFya2Rvd25cbiAqICAgfCBBbHBoYSB8IEIgfFxuICogICB8IC0gfCAtIHxcbiAqICAgfCBDIHwgRGVsdGEgfFxuICogICBgYGBcbiAqIEBwcm9wZXJ0eSB7UmVhZG9ubHlBcnJheTxzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPiB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFthbGlnbl1cbiAqICAgSG93IHRvIGFsaWduIGNvbHVtbnMgKGRlZmF1bHQ6IGAnJ2ApO1xuICogICBvbmUgc3R5bGUgZm9yIGFsbCBjb2x1bW5zIG9yIHN0eWxlcyBmb3IgdGhlaXIgcmVzcGVjdGl2ZSBjb2x1bW5zO1xuICogICBlYWNoIHN0eWxlIGlzIGVpdGhlciBgJ2wnYCAobGVmdCksIGAncidgIChyaWdodCksIG9yIGAnYydgIChjZW50ZXIpO1xuICogICBvdGhlciB2YWx1ZXMgYXJlIHRyZWF0ZWQgYXMgYCcnYCwgd2hpY2ggZG9lc27igJl0IHBsYWNlIHRoZSBjb2xvbiBpbiB0aGVcbiAqICAgYWxpZ25tZW50IHJvdyBidXQgZG9lcyBhbGlnbiBsZWZ0O1xuICogICAqb25seSB0aGUgbG93ZXJjYXNlZCBmaXJzdCBjaGFyYWN0ZXIgaXMgdXNlZCwgc28gYFJpZ2h0YCBpcyBmaW5lLipcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtkZWxpbWl0ZXJFbmQ9dHJ1ZV1cbiAqICAgV2hldGhlciB0byBlbmQgZWFjaCByb3cgd2l0aCB0aGUgZGVsaW1pdGVyIChkZWZhdWx0OiBgdHJ1ZWApLlxuICpcbiAqICAgPiDwn5GJICoqTm90ZSoqOiBwbGVhc2UgZG9u4oCZdCB1c2UgdGhpczogaXQgY291bGQgY3JlYXRlIGZyYWdpbGUgc3RydWN0dXJlc1xuICogICA+IHRoYXQgYXJlbuKAmXQgdW5kZXJzdGFuZGFibGUgdG8gc29tZSBtYXJrZG93biBwYXJzZXJzLlxuICpcbiAqICAgV2hlbiBgdHJ1ZWAsIHRoZXJlIGFyZSBlbmRpbmcgZGVsaW1pdGVyczpcbiAqXG4gKiAgIGBgYG1hcmtkb3duXG4gKiAgIHwgQWxwaGEgfCBCICAgICB8XG4gKiAgIHwgLS0tLS0gfCAtLS0tLSB8XG4gKiAgIHwgQyAgICAgfCBEZWx0YSB8XG4gKiAgIGBgYFxuICpcbiAqICAgV2hlbiBgZmFsc2VgLCB0aGVyZSBhcmUgbm8gZW5kaW5nIGRlbGltaXRlcnM6XG4gKlxuICogICBgYGBtYXJrZG93blxuICogICB8IEFscGhhIHwgQlxuICogICB8IC0tLS0tIHwgLS0tLS1cbiAqICAgfCBDICAgICB8IERlbHRhXG4gKiAgIGBgYFxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2RlbGltaXRlclN0YXJ0PXRydWVdXG4gKiAgIFdoZXRoZXIgdG8gYmVnaW4gZWFjaCByb3cgd2l0aCB0aGUgZGVsaW1pdGVyIChkZWZhdWx0OiBgdHJ1ZWApLlxuICpcbiAqICAgPiDwn5GJICoqTm90ZSoqOiBwbGVhc2UgZG9u4oCZdCB1c2UgdGhpczogaXQgY291bGQgY3JlYXRlIGZyYWdpbGUgc3RydWN0dXJlc1xuICogICA+IHRoYXQgYXJlbuKAmXQgdW5kZXJzdGFuZGFibGUgdG8gc29tZSBtYXJrZG93biBwYXJzZXJzLlxuICpcbiAqICAgV2hlbiBgdHJ1ZWAsIHRoZXJlIGFyZSBzdGFydGluZyBkZWxpbWl0ZXJzOlxuICpcbiAqICAgYGBgbWFya2Rvd25cbiAqICAgfCBBbHBoYSB8IEIgICAgIHxcbiAqICAgfCAtLS0tLSB8IC0tLS0tIHxcbiAqICAgfCBDICAgICB8IERlbHRhIHxcbiAqICAgYGBgXG4gKlxuICogICBXaGVuIGBmYWxzZWAsIHRoZXJlIGFyZSBubyBzdGFydGluZyBkZWxpbWl0ZXJzOlxuICpcbiAqICAgYGBgbWFya2Rvd25cbiAqICAgQWxwaGEgfCBCICAgICB8XG4gKiAgIC0tLS0tIHwgLS0tLS0gfFxuICogICBDICAgICB8IERlbHRhIHxcbiAqICAgYGBgXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbcGFkZGluZz10cnVlXVxuICogICBXaGV0aGVyIHRvIGFkZCBhIHNwYWNlIG9mIHBhZGRpbmcgYmV0d2VlbiBkZWxpbWl0ZXJzIGFuZCBjZWxsc1xuICogICAoZGVmYXVsdDogYHRydWVgKS5cbiAqXG4gKiAgIFdoZW4gYHRydWVgLCB0aGVyZSBpcyBwYWRkaW5nOlxuICpcbiAqICAgYGBgbWFya2Rvd25cbiAqICAgfCBBbHBoYSB8IEIgICAgIHxcbiAqICAgfCAtLS0tLSB8IC0tLS0tIHxcbiAqICAgfCBDICAgICB8IERlbHRhIHxcbiAqICAgYGBgXG4gKlxuICogICBXaGVuIGBmYWxzZWAsIHRoZXJlIGlzIG5vIHBhZGRpbmc6XG4gKlxuICogICBgYGBtYXJrZG93blxuICogICB8QWxwaGF8QiAgICB8XG4gKiAgIHwtLS0tLXwtLS0tLXxcbiAqICAgfEMgICAgfERlbHRhfFxuICogICBgYGBcbiAqIEBwcm9wZXJ0eSB7KCh2YWx1ZTogc3RyaW5nKSA9PiBudW1iZXIpIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3N0cmluZ0xlbmd0aF1cbiAqICAgRnVuY3Rpb24gdG8gZGV0ZWN0IHRoZSBsZW5ndGggb2YgdGFibGUgY2VsbCBjb250ZW50IChvcHRpb25hbCk7XG4gKiAgIHRoaXMgaXMgdXNlZCB3aGVuIGFsaWduaW5nIHRoZSBkZWxpbWl0ZXJzIChgfGApIGJldHdlZW4gdGFibGUgY2VsbHM7XG4gKiAgIGZ1bGwtd2lkdGggY2hhcmFjdGVycyBhbmQgZW1vamkgbWVzcyB1cCBkZWxpbWl0ZXIgYWxpZ25tZW50IHdoZW4gdmlld2luZ1xuICogICB0aGUgbWFya2Rvd24gc291cmNlO1xuICogICB0byBmaXggdGhpcywgeW91IGNhbiBwYXNzIHRoaXMgZnVuY3Rpb24sXG4gKiAgIHdoaWNoIHJlY2VpdmVzIHRoZSBjZWxsIGNvbnRlbnQgYW5kIHJldHVybnMgaXRzIOKAnHZpc2libGXigJ0gc2l6ZTtcbiAqICAgbm90ZSB0aGF0IHdoYXQgaXMgYW5kIGlzbuKAmXQgdmlzaWJsZSBkZXBlbmRzIG9uIHdoZXJlIHRoZSB0ZXh0IGlzIGRpc3BsYXllZC5cbiAqXG4gKiAgIFdpdGhvdXQgc3VjaCBhIGZ1bmN0aW9uLCB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAgYGBganNcbiAqICAgbWFya2Rvd25UYWJsZShbXG4gKiAgICAgWydBbHBoYScsICdCcmF2byddLFxuICogICAgIFsn5Lit5paHJywgJ0NoYXJsaWUnXSxcbiAqICAgICBbJ/CfkanigI3inaTvuI/igI3wn5GpJywgJ0RlbHRhJ11cbiAqICAgXSlcbiAqICAgYGBgXG4gKlxuICogICBZaWVsZHM6XG4gKlxuICogICBgYGBtYXJrZG93blxuICogICB8IEFscGhhIHwgQnJhdm8gfFxuICogICB8IC0gfCAtIHxcbiAqICAgfCDkuK3mlocgfCBDaGFybGllIHxcbiAqICAgfCDwn5Gp4oCN4p2k77iP4oCN8J+RqSB8IERlbHRhIHxcbiAqICAgYGBgXG4gKlxuICogICBXaXRoIFtgc3RyaW5nLXdpZHRoYF0oaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9zdHJpbmctd2lkdGgpOlxuICpcbiAqICAgYGBganNcbiAqICAgaW1wb3J0IHN0cmluZ1dpZHRoIGZyb20gJ3N0cmluZy13aWR0aCdcbiAqXG4gKiAgIG1hcmtkb3duVGFibGUoXG4gKiAgICAgW1xuICogICAgICAgWydBbHBoYScsICdCcmF2byddLFxuICogICAgICAgWyfkuK3mlocnLCAnQ2hhcmxpZSddLFxuICogICAgICAgWyfwn5Gp4oCN4p2k77iP4oCN8J+RqScsICdEZWx0YSddXG4gKiAgICAgXSxcbiAqICAgICB7c3RyaW5nTGVuZ3RoOiBzdHJpbmdXaWR0aH1cbiAqICAgKVxuICogICBgYGBcbiAqXG4gKiAgIFlpZWxkczpcbiAqXG4gKiAgIGBgYG1hcmtkb3duXG4gKiAgIHwgQWxwaGEgfCBCcmF2byAgIHxcbiAqICAgfCAtLS0tLSB8IC0tLS0tLS0gfFxuICogICB8IOS4reaWhyAgfCBDaGFybGllIHxcbiAqICAgfCDwn5Gp4oCN4p2k77iP4oCN8J+RqSAgICB8IERlbHRhICAgfFxuICogICBgYGBcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogICBDZWxsIHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn1cbiAqICAgQ2VsbCBzaXplLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0U3RyaW5nTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5sZW5ndGhcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcmtkb3duXG4gKiAoW0dGTV0oaHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vZW4vZ2l0aHViL3dyaXRpbmctb24tZ2l0aHViL3dvcmtpbmctd2l0aC1hZHZhbmNlZC1mb3JtYXR0aW5nL29yZ2FuaXppbmctaW5mb3JtYXRpb24td2l0aC10YWJsZXMpKVxuICogdGFibGUuXG4gKlxuICogQHBhcmFtIHtSZWFkb25seUFycmF5PFJlYWRvbmx5QXJyYXk8c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZD4+fSB0YWJsZVxuICogICBUYWJsZSBkYXRhIChtYXRyaXggb2Ygc3RyaW5ncykuXG4gKiBAcGFyYW0ge1JlYWRvbmx5PE9wdGlvbnM+IHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiAgIFJlc3VsdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcmtkb3duVGFibGUodGFibGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBvcHRpb25zIHx8IHt9XG4gIC8vIFRvIGRvOiBuZXh0IG1ham9yOiBjaGFuZ2UgdG8gc3ByZWFkLlxuICBjb25zdCBhbGlnbiA9IChzZXR0aW5ncy5hbGlnbiB8fCBbXSkuY29uY2F0KClcbiAgY29uc3Qgc3RyaW5nTGVuZ3RoID0gc2V0dGluZ3Muc3RyaW5nTGVuZ3RoIHx8IGRlZmF1bHRTdHJpbmdMZW5ndGhcbiAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSBDaGFyYWN0ZXIgY29kZXMgYXMgc3ltYm9scyBmb3IgYWxpZ25tZW50IHBlciBjb2x1bW4uICovXG4gIGNvbnN0IGFsaWdubWVudHMgPSBbXVxuICAvKiogQHR5cGUge0FycmF5PEFycmF5PHN0cmluZz4+fSBDZWxscyBwZXIgcm93LiAqL1xuICBjb25zdCBjZWxsTWF0cml4ID0gW11cbiAgLyoqIEB0eXBlIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gU2l6ZXMgb2YgZWFjaCBjZWxsIHBlciByb3cuICovXG4gIGNvbnN0IHNpemVNYXRyaXggPSBbXVxuICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gIGNvbnN0IGxvbmdlc3RDZWxsQnlDb2x1bW4gPSBbXVxuICBsZXQgbW9zdENlbGxzUGVyUm93ID0gMFxuICBsZXQgcm93SW5kZXggPSAtMVxuXG4gIC8vIFRoaXMgaXMgYSBzdXBlcmZsdW91cyBsb29wIGlmIHdlIGRvbuKAmXQgYWxpZ24gZGVsaW1pdGVycywgYnV0IG90aGVyd2lzZSB3ZeKAmWRcbiAgLy8gZG8gc3VwZXJmbHVvdXMgd29yayB3aGVuIGFsaWduaW5nLCBzbyBvcHRpbWl6ZSBmb3IgYWxpZ25pbmcuXG4gIHdoaWxlICgrK3Jvd0luZGV4IDwgdGFibGUubGVuZ3RoKSB7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICAgIGNvbnN0IHJvdyA9IFtdXG4gICAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICAgIGNvbnN0IHNpemVzID0gW11cbiAgICBsZXQgY29sdW1uSW5kZXggPSAtMVxuXG4gICAgaWYgKHRhYmxlW3Jvd0luZGV4XS5sZW5ndGggPiBtb3N0Q2VsbHNQZXJSb3cpIHtcbiAgICAgIG1vc3RDZWxsc1BlclJvdyA9IHRhYmxlW3Jvd0luZGV4XS5sZW5ndGhcbiAgICB9XG5cbiAgICB3aGlsZSAoKytjb2x1bW5JbmRleCA8IHRhYmxlW3Jvd0luZGV4XS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNlbGwgPSBzZXJpYWxpemUodGFibGVbcm93SW5kZXhdW2NvbHVtbkluZGV4XSlcblxuICAgICAgaWYgKHNldHRpbmdzLmFsaWduRGVsaW1pdGVycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHN0cmluZ0xlbmd0aChjZWxsKVxuICAgICAgICBzaXplc1tjb2x1bW5JbmRleF0gPSBzaXplXG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGxvbmdlc3RDZWxsQnlDb2x1bW5bY29sdW1uSW5kZXhdID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICBzaXplID4gbG9uZ2VzdENlbGxCeUNvbHVtbltjb2x1bW5JbmRleF1cbiAgICAgICAgKSB7XG4gICAgICAgICAgbG9uZ2VzdENlbGxCeUNvbHVtbltjb2x1bW5JbmRleF0gPSBzaXplXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcm93LnB1c2goY2VsbClcbiAgICB9XG5cbiAgICBjZWxsTWF0cml4W3Jvd0luZGV4XSA9IHJvd1xuICAgIHNpemVNYXRyaXhbcm93SW5kZXhdID0gc2l6ZXNcbiAgfVxuXG4gIC8vIEZpZ3VyZSBvdXQgd2hpY2ggYWxpZ25tZW50cyB0byB1c2UuXG4gIGxldCBjb2x1bW5JbmRleCA9IC0xXG5cbiAgaWYgKHR5cGVvZiBhbGlnbiA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gYWxpZ24pIHtcbiAgICB3aGlsZSAoKytjb2x1bW5JbmRleCA8IG1vc3RDZWxsc1BlclJvdykge1xuICAgICAgYWxpZ25tZW50c1tjb2x1bW5JbmRleF0gPSB0b0FsaWdubWVudChhbGlnbltjb2x1bW5JbmRleF0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvZGUgPSB0b0FsaWdubWVudChhbGlnbilcblxuICAgIHdoaWxlICgrK2NvbHVtbkluZGV4IDwgbW9zdENlbGxzUGVyUm93KSB7XG4gICAgICBhbGlnbm1lbnRzW2NvbHVtbkluZGV4XSA9IGNvZGVcbiAgICB9XG4gIH1cblxuICAvLyBJbmplY3QgdGhlIGFsaWdubWVudCByb3cuXG4gIGNvbHVtbkluZGV4ID0gLTFcbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCByb3cgPSBbXVxuICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gIGNvbnN0IHNpemVzID0gW11cblxuICB3aGlsZSAoKytjb2x1bW5JbmRleCA8IG1vc3RDZWxsc1BlclJvdykge1xuICAgIGNvbnN0IGNvZGUgPSBhbGlnbm1lbnRzW2NvbHVtbkluZGV4XVxuICAgIGxldCBiZWZvcmUgPSAnJ1xuICAgIGxldCBhZnRlciA9ICcnXG5cbiAgICBpZiAoY29kZSA9PT0gOTkgLyogYGNgICovKSB7XG4gICAgICBiZWZvcmUgPSAnOidcbiAgICAgIGFmdGVyID0gJzonXG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAxMDggLyogYGxgICovKSB7XG4gICAgICBiZWZvcmUgPSAnOidcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDExNCAvKiBgcmAgKi8pIHtcbiAgICAgIGFmdGVyID0gJzonXG4gICAgfVxuXG4gICAgLy8gVGhlcmUgKm11c3QqIGJlIGF0IGxlYXN0IG9uZSBoeXBoZW4tbWludXMgaW4gZWFjaCBhbGlnbm1lbnQgY2VsbC5cbiAgICBsZXQgc2l6ZSA9XG4gICAgICBzZXR0aW5ncy5hbGlnbkRlbGltaXRlcnMgPT09IGZhbHNlXG4gICAgICAgID8gMVxuICAgICAgICA6IE1hdGgubWF4KFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIGxvbmdlc3RDZWxsQnlDb2x1bW5bY29sdW1uSW5kZXhdIC0gYmVmb3JlLmxlbmd0aCAtIGFmdGVyLmxlbmd0aFxuICAgICAgICAgIClcblxuICAgIGNvbnN0IGNlbGwgPSBiZWZvcmUgKyAnLScucmVwZWF0KHNpemUpICsgYWZ0ZXJcblxuICAgIGlmIChzZXR0aW5ncy5hbGlnbkRlbGltaXRlcnMgIT09IGZhbHNlKSB7XG4gICAgICBzaXplID0gYmVmb3JlLmxlbmd0aCArIHNpemUgKyBhZnRlci5sZW5ndGhcblxuICAgICAgaWYgKHNpemUgPiBsb25nZXN0Q2VsbEJ5Q29sdW1uW2NvbHVtbkluZGV4XSkge1xuICAgICAgICBsb25nZXN0Q2VsbEJ5Q29sdW1uW2NvbHVtbkluZGV4XSA9IHNpemVcbiAgICAgIH1cblxuICAgICAgc2l6ZXNbY29sdW1uSW5kZXhdID0gc2l6ZVxuICAgIH1cblxuICAgIHJvd1tjb2x1bW5JbmRleF0gPSBjZWxsXG4gIH1cblxuICAvLyBJbmplY3QgdGhlIGFsaWdubWVudCByb3cuXG4gIGNlbGxNYXRyaXguc3BsaWNlKDEsIDAsIHJvdylcbiAgc2l6ZU1hdHJpeC5zcGxpY2UoMSwgMCwgc2l6ZXMpXG5cbiAgcm93SW5kZXggPSAtMVxuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gIGNvbnN0IGxpbmVzID0gW11cblxuICB3aGlsZSAoKytyb3dJbmRleCA8IGNlbGxNYXRyaXgubGVuZ3RoKSB7XG4gICAgY29uc3Qgcm93ID0gY2VsbE1hdHJpeFtyb3dJbmRleF1cbiAgICBjb25zdCBzaXplcyA9IHNpemVNYXRyaXhbcm93SW5kZXhdXG4gICAgY29sdW1uSW5kZXggPSAtMVxuICAgIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgICBjb25zdCBsaW5lID0gW11cblxuICAgIHdoaWxlICgrK2NvbHVtbkluZGV4IDwgbW9zdENlbGxzUGVyUm93KSB7XG4gICAgICBjb25zdCBjZWxsID0gcm93W2NvbHVtbkluZGV4XSB8fCAnJ1xuICAgICAgbGV0IGJlZm9yZSA9ICcnXG4gICAgICBsZXQgYWZ0ZXIgPSAnJ1xuXG4gICAgICBpZiAoc2V0dGluZ3MuYWxpZ25EZWxpbWl0ZXJzICE9PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBzaXplID1cbiAgICAgICAgICBsb25nZXN0Q2VsbEJ5Q29sdW1uW2NvbHVtbkluZGV4XSAtIChzaXplc1tjb2x1bW5JbmRleF0gfHwgMClcbiAgICAgICAgY29uc3QgY29kZSA9IGFsaWdubWVudHNbY29sdW1uSW5kZXhdXG5cbiAgICAgICAgaWYgKGNvZGUgPT09IDExNCAvKiBgcmAgKi8pIHtcbiAgICAgICAgICBiZWZvcmUgPSAnICcucmVwZWF0KHNpemUpXG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gOTkgLyogYGNgICovKSB7XG4gICAgICAgICAgaWYgKHNpemUgJSAyKSB7XG4gICAgICAgICAgICBiZWZvcmUgPSAnICcucmVwZWF0KHNpemUgLyAyICsgMC41KVxuICAgICAgICAgICAgYWZ0ZXIgPSAnICcucmVwZWF0KHNpemUgLyAyIC0gMC41KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZWZvcmUgPSAnICcucmVwZWF0KHNpemUgLyAyKVxuICAgICAgICAgICAgYWZ0ZXIgPSBiZWZvcmVcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWZ0ZXIgPSAnICcucmVwZWF0KHNpemUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNldHRpbmdzLmRlbGltaXRlclN0YXJ0ICE9PSBmYWxzZSAmJiAhY29sdW1uSW5kZXgpIHtcbiAgICAgICAgbGluZS5wdXNoKCd8JylcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBzZXR0aW5ncy5wYWRkaW5nICE9PSBmYWxzZSAmJlxuICAgICAgICAvLyBEb27igJl0IGFkZCB0aGUgb3BlbmluZyBzcGFjZSBpZiB3ZeKAmXJlIG5vdCBhbGlnbmluZyBhbmQgdGhlIGNlbGwgaXNcbiAgICAgICAgLy8gZW1wdHk6IHRoZXJlIHdpbGwgYmUgYSBjbG9zaW5nIHNwYWNlLlxuICAgICAgICAhKHNldHRpbmdzLmFsaWduRGVsaW1pdGVycyA9PT0gZmFsc2UgJiYgY2VsbCA9PT0gJycpICYmXG4gICAgICAgIChzZXR0aW5ncy5kZWxpbWl0ZXJTdGFydCAhPT0gZmFsc2UgfHwgY29sdW1uSW5kZXgpXG4gICAgICApIHtcbiAgICAgICAgbGluZS5wdXNoKCcgJylcbiAgICAgIH1cblxuICAgICAgaWYgKHNldHRpbmdzLmFsaWduRGVsaW1pdGVycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgbGluZS5wdXNoKGJlZm9yZSlcbiAgICAgIH1cblxuICAgICAgbGluZS5wdXNoKGNlbGwpXG5cbiAgICAgIGlmIChzZXR0aW5ncy5hbGlnbkRlbGltaXRlcnMgIT09IGZhbHNlKSB7XG4gICAgICAgIGxpbmUucHVzaChhZnRlcilcbiAgICAgIH1cblxuICAgICAgaWYgKHNldHRpbmdzLnBhZGRpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIGxpbmUucHVzaCgnICcpXG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgc2V0dGluZ3MuZGVsaW1pdGVyRW5kICE9PSBmYWxzZSB8fFxuICAgICAgICBjb2x1bW5JbmRleCAhPT0gbW9zdENlbGxzUGVyUm93IC0gMVxuICAgICAgKSB7XG4gICAgICAgIGxpbmUucHVzaCgnfCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGluZXMucHVzaChcbiAgICAgIHNldHRpbmdzLmRlbGltaXRlckVuZCA9PT0gZmFsc2VcbiAgICAgICAgPyBsaW5lLmpvaW4oJycpLnJlcGxhY2UoLyArJC8sICcnKVxuICAgICAgICA6IGxpbmUuam9pbignJylcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGluZXMuam9pbignXFxuJylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFt2YWx1ZV1cbiAqICAgVmFsdWUgdG8gc2VyaWFsaXplLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqICAgUmVzdWx0LlxuICovXG5mdW5jdGlvbiBzZXJpYWxpemUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgPyAnJyA6IFN0cmluZyh2YWx1ZSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IHZhbHVlXG4gKiAgIFZhbHVlLlxuICogQHJldHVybnMge251bWJlcn1cbiAqICAgQWxpZ25tZW50LlxuICovXG5mdW5jdGlvbiB0b0FsaWdubWVudCh2YWx1ZSkge1xuICBjb25zdCBjb2RlID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlLmNvZGVQb2ludEF0KDApIDogMFxuXG4gIHJldHVybiBjb2RlID09PSA2NyAvKiBgQ2AgKi8gfHwgY29kZSA9PT0gOTkgLyogYGNgICovXG4gICAgPyA5OSAvKiBgY2AgKi9cbiAgICA6IGNvZGUgPT09IDc2IC8qIGBMYCAqLyB8fCBjb2RlID09PSAxMDggLyogYGxgICovXG4gICAgICA/IDEwOCAvKiBgbGAgKi9cbiAgICAgIDogY29kZSA9PT0gODIgLyogYFJgICovIHx8IGNvZGUgPT09IDExNCAvKiBgcmAgKi9cbiAgICAgICAgPyAxMTQgLyogYHJgICovXG4gICAgICAgIDogMFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/markdown-table/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-find-and-replace/lib/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/mdast-util-find-and-replace/lib/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findAndReplace: () => (/* binding */ findAndReplace)\n/* harmony export */ });\n/* harmony import */ var escape_string_regexp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! escape-string-regexp */ \"(app-pages-browser)/./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js\");\n/* harmony import */ var unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! unist-util-visit-parents */ \"(app-pages-browser)/./node_modules/unist-util-visit-parents/lib/index.js\");\n/* harmony import */ var unist_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unist-util-is */ \"(app-pages-browser)/./node_modules/unist-util-is/lib/index.js\");\n/**\n * @import {Nodes, Parents, PhrasingContent, Root, Text} from 'mdast'\n * @import {BuildVisitor, Test, VisitorResult} from 'unist-util-visit-parents'\n */\n\n/**\n * @typedef RegExpMatchObject\n *   Info on the match.\n * @property {number} index\n *   The index of the search at which the result was found.\n * @property {string} input\n *   A copy of the search string in the text node.\n * @property {[...Array<Parents>, Text]} stack\n *   All ancestors of the text node, where the last node is the text itself.\n *\n * @typedef {RegExp | string} Find\n *   Pattern to find.\n *\n *   Strings are escaped and then turned into global expressions.\n *\n * @typedef {Array<FindAndReplaceTuple>} FindAndReplaceList\n *   Several find and replaces, in array form.\n *\n * @typedef {[Find, Replace?]} FindAndReplaceTuple\n *   Find and replace in tuple form.\n *\n * @typedef {ReplaceFunction | string | null | undefined} Replace\n *   Thing to replace with.\n *\n * @callback ReplaceFunction\n *   Callback called when a search matches.\n * @param {...any} parameters\n *   The parameters are the result of corresponding search expression:\n *\n *   * `value` (`string`)  whole match\n *   * `...capture` (`Array<string>`)  matches from regex capture groups\n *   * `match` (`RegExpMatchObject`)  info on the match\n * @returns {Array<PhrasingContent> | PhrasingContent | string | false | null | undefined}\n *   Thing to replace with.\n *\n *   * when `null`, `undefined`, `''`, remove the match\n *   * or when `false`, do not replace at all\n *   * or when `string`, replace with a text node of that value\n *   * or when `Node` or `Array<Node>`, replace with those nodes\n *\n * @typedef {[RegExp, ReplaceFunction]} Pair\n *   Normalized find and replace.\n *\n * @typedef {Array<Pair>} Pairs\n *   All find and replaced.\n *\n * @typedef Options\n *   Configuration.\n * @property {Test | null | undefined} [ignore]\n *   Test for which nodes to ignore (optional).\n */\n\n\n\n\n\n/**\n * Find patterns in a tree and replace them.\n *\n * The algorithm searches the tree in *preorder* for complete values in `Text`\n * nodes.\n * Partial matches are not supported.\n *\n * @param {Nodes} tree\n *   Tree to change.\n * @param {FindAndReplaceList | FindAndReplaceTuple} list\n *   Patterns to find.\n * @param {Options | null | undefined} [options]\n *   Configuration (when `find` is not `Find`).\n * @returns {undefined}\n *   Nothing.\n */\nfunction findAndReplace(tree, list, options) {\n  const settings = options || {}\n  const ignored = (0,unist_util_is__WEBPACK_IMPORTED_MODULE_1__.convert)(settings.ignore || [])\n  const pairs = toPairs(list)\n  let pairIndex = -1\n\n  while (++pairIndex < pairs.length) {\n    (0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_2__.visitParents)(tree, 'text', visitor)\n  }\n\n  /** @type {BuildVisitor<Root, 'text'>} */\n  function visitor(node, parents) {\n    let index = -1\n    /** @type {Parents | undefined} */\n    let grandparent\n\n    while (++index < parents.length) {\n      const parent = parents[index]\n      /** @type {Array<Nodes> | undefined} */\n      const siblings = grandparent ? grandparent.children : undefined\n\n      if (\n        ignored(\n          parent,\n          siblings ? siblings.indexOf(parent) : undefined,\n          grandparent\n        )\n      ) {\n        return\n      }\n\n      grandparent = parent\n    }\n\n    if (grandparent) {\n      return handler(node, parents)\n    }\n  }\n\n  /**\n   * Handle a text node which is not in an ignored parent.\n   *\n   * @param {Text} node\n   *   Text node.\n   * @param {Array<Parents>} parents\n   *   Parents.\n   * @returns {VisitorResult}\n   *   Result.\n   */\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1]\n    const find = pairs[pairIndex][0]\n    const replace = pairs[pairIndex][1]\n    let start = 0\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children\n    const index = siblings.indexOf(node)\n    let change = false\n    /** @type {Array<PhrasingContent>} */\n    let nodes = []\n\n    find.lastIndex = 0\n\n    let match = find.exec(node.value)\n\n    while (match) {\n      const position = match.index\n      /** @type {RegExpMatchObject} */\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        stack: [...parents, node]\n      }\n      let value = replace(...match, matchObject)\n\n      if (typeof value === 'string') {\n        value = value.length > 0 ? {type: 'text', value} : undefined\n      }\n\n      // It wasnt a match after all.\n      if (value === false) {\n        // False acts as if there was no match.\n        // So we need to reset `lastIndex`, which currently being at the end of\n        // the current match, to the beginning.\n        find.lastIndex = position + 1\n      } else {\n        if (start !== position) {\n          nodes.push({\n            type: 'text',\n            value: node.value.slice(start, position)\n          })\n        }\n\n        if (Array.isArray(value)) {\n          nodes.push(...value)\n        } else if (value) {\n          nodes.push(value)\n        }\n\n        start = position + match[0].length\n        change = true\n      }\n\n      if (!find.global) {\n        break\n      }\n\n      match = find.exec(node.value)\n    }\n\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({type: 'text', value: node.value.slice(start)})\n      }\n\n      parent.children.splice(index, 1, ...nodes)\n    } else {\n      nodes = [node]\n    }\n\n    return index + nodes.length\n  }\n}\n\n/**\n * Turn a tuple or a list of tuples into pairs.\n *\n * @param {FindAndReplaceList | FindAndReplaceTuple} tupleOrList\n *   Schema.\n * @returns {Pairs}\n *   Clean pairs.\n */\nfunction toPairs(tupleOrList) {\n  /** @type {Pairs} */\n  const result = []\n\n  if (!Array.isArray(tupleOrList)) {\n    throw new TypeError('Expected find and replace tuple or list of tuples')\n  }\n\n  /** @type {FindAndReplaceList} */\n  // @ts-expect-error: correct.\n  const list =\n    !tupleOrList[0] || Array.isArray(tupleOrList[0])\n      ? tupleOrList\n      : [tupleOrList]\n\n  let index = -1\n\n  while (++index < list.length) {\n    const tuple = list[index]\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])])\n  }\n\n  return result\n}\n\n/**\n * Turn a find into an expression.\n *\n * @param {Find} find\n *   Find.\n * @returns {RegExp}\n *   Expression.\n */\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp((0,escape_string_regexp__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(find), 'g') : find\n}\n\n/**\n * Turn a replace into a function.\n *\n * @param {Replace} replace\n *   Replace.\n * @returns {ReplaceFunction}\n *   Function.\n */\nfunction toFunction(replace) {\n  return typeof replace === 'function'\n    ? replace\n    : function () {\n        return replace\n      }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWZpbmQtYW5kLXJlcGxhY2UvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBLFlBQVksNkNBQTZDO0FBQ3pELFlBQVksbUNBQW1DO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0EsYUFBYSw2Q0FBNkM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBOztBQUV5QztBQUNZO0FBQ2hCOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsMENBQTBDO0FBQ3JEO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQkFBa0Isc0RBQU87QUFDekI7QUFDQTs7QUFFQTtBQUNBLElBQUksc0VBQVk7QUFDaEI7O0FBRUEsYUFBYSw0QkFBNEI7QUFDekM7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBMEM7QUFDckQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnRUFBTTtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWZpbmQtYW5kLXJlcGxhY2UvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7Tm9kZXMsIFBhcmVudHMsIFBocmFzaW5nQ29udGVudCwgUm9vdCwgVGV4dH0gZnJvbSAnbWRhc3QnXG4gKiBAaW1wb3J0IHtCdWlsZFZpc2l0b3IsIFRlc3QsIFZpc2l0b3JSZXN1bHR9IGZyb20gJ3VuaXN0LXV0aWwtdmlzaXQtcGFyZW50cydcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIFJlZ0V4cE1hdGNoT2JqZWN0XG4gKiAgIEluZm8gb24gdGhlIG1hdGNoLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGluZGV4XG4gKiAgIFRoZSBpbmRleCBvZiB0aGUgc2VhcmNoIGF0IHdoaWNoIHRoZSByZXN1bHQgd2FzIGZvdW5kLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlucHV0XG4gKiAgIEEgY29weSBvZiB0aGUgc2VhcmNoIHN0cmluZyBpbiB0aGUgdGV4dCBub2RlLlxuICogQHByb3BlcnR5IHtbLi4uQXJyYXk8UGFyZW50cz4sIFRleHRdfSBzdGFja1xuICogICBBbGwgYW5jZXN0b3JzIG9mIHRoZSB0ZXh0IG5vZGUsIHdoZXJlIHRoZSBsYXN0IG5vZGUgaXMgdGhlIHRleHQgaXRzZWxmLlxuICpcbiAqIEB0eXBlZGVmIHtSZWdFeHAgfCBzdHJpbmd9IEZpbmRcbiAqICAgUGF0dGVybiB0byBmaW5kLlxuICpcbiAqICAgU3RyaW5ncyBhcmUgZXNjYXBlZCBhbmQgdGhlbiB0dXJuZWQgaW50byBnbG9iYWwgZXhwcmVzc2lvbnMuXG4gKlxuICogQHR5cGVkZWYge0FycmF5PEZpbmRBbmRSZXBsYWNlVHVwbGU+fSBGaW5kQW5kUmVwbGFjZUxpc3RcbiAqICAgU2V2ZXJhbCBmaW5kIGFuZCByZXBsYWNlcywgaW4gYXJyYXkgZm9ybS5cbiAqXG4gKiBAdHlwZWRlZiB7W0ZpbmQsIFJlcGxhY2U/XX0gRmluZEFuZFJlcGxhY2VUdXBsZVxuICogICBGaW5kIGFuZCByZXBsYWNlIGluIHR1cGxlIGZvcm0uXG4gKlxuICogQHR5cGVkZWYge1JlcGxhY2VGdW5jdGlvbiB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFJlcGxhY2VcbiAqICAgVGhpbmcgdG8gcmVwbGFjZSB3aXRoLlxuICpcbiAqIEBjYWxsYmFjayBSZXBsYWNlRnVuY3Rpb25cbiAqICAgQ2FsbGJhY2sgY2FsbGVkIHdoZW4gYSBzZWFyY2ggbWF0Y2hlcy5cbiAqIEBwYXJhbSB7Li4uYW55fSBwYXJhbWV0ZXJzXG4gKiAgIFRoZSBwYXJhbWV0ZXJzIGFyZSB0aGUgcmVzdWx0IG9mIGNvcnJlc3BvbmRpbmcgc2VhcmNoIGV4cHJlc3Npb246XG4gKlxuICogICAqIGB2YWx1ZWAgKGBzdHJpbmdgKSDigJQgd2hvbGUgbWF0Y2hcbiAqICAgKiBgLi4uY2FwdHVyZWAgKGBBcnJheTxzdHJpbmc+YCkg4oCUIG1hdGNoZXMgZnJvbSByZWdleCBjYXB0dXJlIGdyb3Vwc1xuICogICAqIGBtYXRjaGAgKGBSZWdFeHBNYXRjaE9iamVjdGApIOKAlCBpbmZvIG9uIHRoZSBtYXRjaFxuICogQHJldHVybnMge0FycmF5PFBocmFzaW5nQ29udGVudD4gfCBQaHJhc2luZ0NvbnRlbnQgfCBzdHJpbmcgfCBmYWxzZSB8IG51bGwgfCB1bmRlZmluZWR9XG4gKiAgIFRoaW5nIHRvIHJlcGxhY2Ugd2l0aC5cbiAqXG4gKiAgICogd2hlbiBgbnVsbGAsIGB1bmRlZmluZWRgLCBgJydgLCByZW1vdmUgdGhlIG1hdGNoXG4gKiAgICog4oCmb3Igd2hlbiBgZmFsc2VgLCBkbyBub3QgcmVwbGFjZSBhdCBhbGxcbiAqICAgKiDigKZvciB3aGVuIGBzdHJpbmdgLCByZXBsYWNlIHdpdGggYSB0ZXh0IG5vZGUgb2YgdGhhdCB2YWx1ZVxuICogICAqIOKApm9yIHdoZW4gYE5vZGVgIG9yIGBBcnJheTxOb2RlPmAsIHJlcGxhY2Ugd2l0aCB0aG9zZSBub2Rlc1xuICpcbiAqIEB0eXBlZGVmIHtbUmVnRXhwLCBSZXBsYWNlRnVuY3Rpb25dfSBQYWlyXG4gKiAgIE5vcm1hbGl6ZWQgZmluZCBhbmQgcmVwbGFjZS5cbiAqXG4gKiBAdHlwZWRlZiB7QXJyYXk8UGFpcj59IFBhaXJzXG4gKiAgIEFsbCBmaW5kIGFuZCByZXBsYWNlZC5cbiAqXG4gKiBAdHlwZWRlZiBPcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcHJvcGVydHkge1Rlc3QgfCBudWxsIHwgdW5kZWZpbmVkfSBbaWdub3JlXVxuICogICBUZXN0IGZvciB3aGljaCBub2RlcyB0byBpZ25vcmUgKG9wdGlvbmFsKS5cbiAqL1xuXG5pbXBvcnQgZXNjYXBlIGZyb20gJ2VzY2FwZS1zdHJpbmctcmVnZXhwJ1xuaW1wb3J0IHt2aXNpdFBhcmVudHN9IGZyb20gJ3VuaXN0LXV0aWwtdmlzaXQtcGFyZW50cydcbmltcG9ydCB7Y29udmVydH0gZnJvbSAndW5pc3QtdXRpbC1pcydcblxuLyoqXG4gKiBGaW5kIHBhdHRlcm5zIGluIGEgdHJlZSBhbmQgcmVwbGFjZSB0aGVtLlxuICpcbiAqIFRoZSBhbGdvcml0aG0gc2VhcmNoZXMgdGhlIHRyZWUgaW4gKnByZW9yZGVyKiBmb3IgY29tcGxldGUgdmFsdWVzIGluIGBUZXh0YFxuICogbm9kZXMuXG4gKiBQYXJ0aWFsIG1hdGNoZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogQHBhcmFtIHtOb2Rlc30gdHJlZVxuICogICBUcmVlIHRvIGNoYW5nZS5cbiAqIEBwYXJhbSB7RmluZEFuZFJlcGxhY2VMaXN0IHwgRmluZEFuZFJlcGxhY2VUdXBsZX0gbGlzdFxuICogICBQYXR0ZXJucyB0byBmaW5kLlxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gKHdoZW4gYGZpbmRgIGlzIG5vdCBgRmluZGApLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRBbmRSZXBsYWNlKHRyZWUsIGxpc3QsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBvcHRpb25zIHx8IHt9XG4gIGNvbnN0IGlnbm9yZWQgPSBjb252ZXJ0KHNldHRpbmdzLmlnbm9yZSB8fCBbXSlcbiAgY29uc3QgcGFpcnMgPSB0b1BhaXJzKGxpc3QpXG4gIGxldCBwYWlySW5kZXggPSAtMVxuXG4gIHdoaWxlICgrK3BhaXJJbmRleCA8IHBhaXJzLmxlbmd0aCkge1xuICAgIHZpc2l0UGFyZW50cyh0cmVlLCAndGV4dCcsIHZpc2l0b3IpXG4gIH1cblxuICAvKiogQHR5cGUge0J1aWxkVmlzaXRvcjxSb290LCAndGV4dCc+fSAqL1xuICBmdW5jdGlvbiB2aXNpdG9yKG5vZGUsIHBhcmVudHMpIHtcbiAgICBsZXQgaW5kZXggPSAtMVxuICAgIC8qKiBAdHlwZSB7UGFyZW50cyB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgZ3JhbmRwYXJlbnRcblxuICAgIHdoaWxlICgrK2luZGV4IDwgcGFyZW50cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHBhcmVudHNbaW5kZXhdXG4gICAgICAvKiogQHR5cGUge0FycmF5PE5vZGVzPiB8IHVuZGVmaW5lZH0gKi9cbiAgICAgIGNvbnN0IHNpYmxpbmdzID0gZ3JhbmRwYXJlbnQgPyBncmFuZHBhcmVudC5jaGlsZHJlbiA6IHVuZGVmaW5lZFxuXG4gICAgICBpZiAoXG4gICAgICAgIGlnbm9yZWQoXG4gICAgICAgICAgcGFyZW50LFxuICAgICAgICAgIHNpYmxpbmdzID8gc2libGluZ3MuaW5kZXhPZihwYXJlbnQpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGdyYW5kcGFyZW50XG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgZ3JhbmRwYXJlbnQgPSBwYXJlbnRcbiAgICB9XG5cbiAgICBpZiAoZ3JhbmRwYXJlbnQpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyKG5vZGUsIHBhcmVudHMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIHRleHQgbm9kZSB3aGljaCBpcyBub3QgaW4gYW4gaWdub3JlZCBwYXJlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGV4dH0gbm9kZVxuICAgKiAgIFRleHQgbm9kZS5cbiAgICogQHBhcmFtIHtBcnJheTxQYXJlbnRzPn0gcGFyZW50c1xuICAgKiAgIFBhcmVudHMuXG4gICAqIEByZXR1cm5zIHtWaXNpdG9yUmVzdWx0fVxuICAgKiAgIFJlc3VsdC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZXIobm9kZSwgcGFyZW50cykge1xuICAgIGNvbnN0IHBhcmVudCA9IHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXVxuICAgIGNvbnN0IGZpbmQgPSBwYWlyc1twYWlySW5kZXhdWzBdXG4gICAgY29uc3QgcmVwbGFjZSA9IHBhaXJzW3BhaXJJbmRleF1bMV1cbiAgICBsZXQgc3RhcnQgPSAwXG4gICAgLyoqIEB0eXBlIHtBcnJheTxOb2Rlcz59ICovXG4gICAgY29uc3Qgc2libGluZ3MgPSBwYXJlbnQuY2hpbGRyZW5cbiAgICBjb25zdCBpbmRleCA9IHNpYmxpbmdzLmluZGV4T2Yobm9kZSlcbiAgICBsZXQgY2hhbmdlID0gZmFsc2VcbiAgICAvKiogQHR5cGUge0FycmF5PFBocmFzaW5nQ29udGVudD59ICovXG4gICAgbGV0IG5vZGVzID0gW11cblxuICAgIGZpbmQubGFzdEluZGV4ID0gMFxuXG4gICAgbGV0IG1hdGNoID0gZmluZC5leGVjKG5vZGUudmFsdWUpXG5cbiAgICB3aGlsZSAobWF0Y2gpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gbWF0Y2guaW5kZXhcbiAgICAgIC8qKiBAdHlwZSB7UmVnRXhwTWF0Y2hPYmplY3R9ICovXG4gICAgICBjb25zdCBtYXRjaE9iamVjdCA9IHtcbiAgICAgICAgaW5kZXg6IG1hdGNoLmluZGV4LFxuICAgICAgICBpbnB1dDogbWF0Y2guaW5wdXQsXG4gICAgICAgIHN0YWNrOiBbLi4ucGFyZW50cywgbm9kZV1cbiAgICAgIH1cbiAgICAgIGxldCB2YWx1ZSA9IHJlcGxhY2UoLi4ubWF0Y2gsIG1hdGNoT2JqZWN0KVxuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLmxlbmd0aCA+IDAgPyB7dHlwZTogJ3RleHQnLCB2YWx1ZX0gOiB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgLy8gSXQgd2FzbuKAmXQgYSBtYXRjaCBhZnRlciBhbGwuXG4gICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIEZhbHNlIGFjdHMgYXMgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxuICAgICAgICAvLyBTbyB3ZSBuZWVkIHRvIHJlc2V0IGBsYXN0SW5kZXhgLCB3aGljaCBjdXJyZW50bHkgYmVpbmcgYXQgdGhlIGVuZCBvZlxuICAgICAgICAvLyB0aGUgY3VycmVudCBtYXRjaCwgdG8gdGhlIGJlZ2lubmluZy5cbiAgICAgICAgZmluZC5sYXN0SW5kZXggPSBwb3NpdGlvbiArIDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGFydCAhPT0gcG9zaXRpb24pIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHZhbHVlOiBub2RlLnZhbHVlLnNsaWNlKHN0YXJ0LCBwb3NpdGlvbilcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgbm9kZXMucHVzaCguLi52YWx1ZSlcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgIG5vZGVzLnB1c2godmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IHBvc2l0aW9uICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgIGNoYW5nZSA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKCFmaW5kLmdsb2JhbCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IGZpbmQuZXhlYyhub2RlLnZhbHVlKVxuICAgIH1cblxuICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgIGlmIChzdGFydCA8IG5vZGUudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIG5vZGVzLnB1c2goe3R5cGU6ICd0ZXh0JywgdmFsdWU6IG5vZGUudmFsdWUuc2xpY2Uoc3RhcnQpfSlcbiAgICAgIH1cblxuICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSwgLi4ubm9kZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVzID0gW25vZGVdXG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4ICsgbm9kZXMubGVuZ3RoXG4gIH1cbn1cblxuLyoqXG4gKiBUdXJuIGEgdHVwbGUgb3IgYSBsaXN0IG9mIHR1cGxlcyBpbnRvIHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7RmluZEFuZFJlcGxhY2VMaXN0IHwgRmluZEFuZFJlcGxhY2VUdXBsZX0gdHVwbGVPckxpc3RcbiAqICAgU2NoZW1hLlxuICogQHJldHVybnMge1BhaXJzfVxuICogICBDbGVhbiBwYWlycy5cbiAqL1xuZnVuY3Rpb24gdG9QYWlycyh0dXBsZU9yTGlzdCkge1xuICAvKiogQHR5cGUge1BhaXJzfSAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuXG4gIGlmICghQXJyYXkuaXNBcnJheSh0dXBsZU9yTGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBmaW5kIGFuZCByZXBsYWNlIHR1cGxlIG9yIGxpc3Qgb2YgdHVwbGVzJylcbiAgfVxuXG4gIC8qKiBAdHlwZSB7RmluZEFuZFJlcGxhY2VMaXN0fSAqL1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBjb3JyZWN0LlxuICBjb25zdCBsaXN0ID1cbiAgICAhdHVwbGVPckxpc3RbMF0gfHwgQXJyYXkuaXNBcnJheSh0dXBsZU9yTGlzdFswXSlcbiAgICAgID8gdHVwbGVPckxpc3RcbiAgICAgIDogW3R1cGxlT3JMaXN0XVxuXG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBsaXN0Lmxlbmd0aCkge1xuICAgIGNvbnN0IHR1cGxlID0gbGlzdFtpbmRleF1cbiAgICByZXN1bHQucHVzaChbdG9FeHByZXNzaW9uKHR1cGxlWzBdKSwgdG9GdW5jdGlvbih0dXBsZVsxXSldKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIFR1cm4gYSBmaW5kIGludG8gYW4gZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0ge0ZpbmR9IGZpbmRcbiAqICAgRmluZC5cbiAqIEByZXR1cm5zIHtSZWdFeHB9XG4gKiAgIEV4cHJlc3Npb24uXG4gKi9cbmZ1bmN0aW9uIHRvRXhwcmVzc2lvbihmaW5kKSB7XG4gIHJldHVybiB0eXBlb2YgZmluZCA9PT0gJ3N0cmluZycgPyBuZXcgUmVnRXhwKGVzY2FwZShmaW5kKSwgJ2cnKSA6IGZpbmRcbn1cblxuLyoqXG4gKiBUdXJuIGEgcmVwbGFjZSBpbnRvIGEgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtSZXBsYWNlfSByZXBsYWNlXG4gKiAgIFJlcGxhY2UuXG4gKiBAcmV0dXJucyB7UmVwbGFjZUZ1bmN0aW9ufVxuICogICBGdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9GdW5jdGlvbihyZXBsYWNlKSB7XG4gIHJldHVybiB0eXBlb2YgcmVwbGFjZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gcmVwbGFjZVxuICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVwbGFjZVxuICAgICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-find-and-replace/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ escapeStringRegexp)\n/* harmony export */ });\nfunction escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when its always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWZpbmQtYW5kLXJlcGxhY2Uvbm9kZV9tb2R1bGVzL2VzY2FwZS1zdHJpbmctcmVnZXhwL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1maW5kLWFuZC1yZXBsYWNlL25vZGVfbW9kdWxlcy9lc2NhcGUtc3RyaW5nLXJlZ2V4cC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlc2NhcGVTdHJpbmdSZWdleHAoc3RyaW5nKSB7XG5cdGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG5cdH1cblxuXHQvLyBFc2NhcGUgY2hhcmFjdGVycyB3aXRoIHNwZWNpYWwgbWVhbmluZyBlaXRoZXIgaW5zaWRlIG9yIG91dHNpZGUgY2hhcmFjdGVyIHNldHMuXG5cdC8vIFVzZSBhIHNpbXBsZSBiYWNrc2xhc2ggZXNjYXBlIHdoZW4gaXTigJlzIGFsd2F5cyB2YWxpZCwgYW5kIGEgYFxceG5uYCBlc2NhcGUgd2hlbiB0aGUgc2ltcGxlciBmb3JtIHdvdWxkIGJlIGRpc2FsbG93ZWQgYnkgVW5pY29kZSBwYXR0ZXJuc+KAmSBzdHJpY3RlciBncmFtbWFyLlxuXHRyZXR1cm4gc3RyaW5nXG5cdFx0LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nLCAnXFxcXCQmJylcblx0XHQucmVwbGFjZSgvLS9nLCAnXFxcXHgyZCcpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-gfm-autolink-literal/lib/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mdast-util-gfm-autolink-literal/lib/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmAutolinkLiteralFromMarkdown: () => (/* binding */ gfmAutolinkLiteralFromMarkdown),\n/* harmony export */   gfmAutolinkLiteralToMarkdown: () => (/* binding */ gfmAutolinkLiteralToMarkdown)\n/* harmony export */ });\n/* harmony import */ var ccount__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ccount */ \"(app-pages-browser)/./node_modules/ccount/index.js\");\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devlop */ \"(app-pages-browser)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-character */ \"(app-pages-browser)/./node_modules/micromark-util-character/dev/index.js\");\n/* harmony import */ var mdast_util_find_and_replace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mdast-util-find-and-replace */ \"(app-pages-browser)/./node_modules/mdast-util-find-and-replace/lib/index.js\");\n/**\n * @import {RegExpMatchObject, ReplaceFunction} from 'mdast-util-find-and-replace'\n * @import {CompileContext, Extension as FromMarkdownExtension, Handle as FromMarkdownHandle, Transform as FromMarkdownTransform} from 'mdast-util-from-markdown'\n * @import {ConstructName, Options as ToMarkdownExtension} from 'mdast-util-to-markdown'\n * @import {Link, PhrasingContent} from 'mdast'\n */\n\n\n\n\n\n\n/** @type {ConstructName} */\nconst inConstruct = 'phrasing'\n/** @type {Array<ConstructName>} */\nconst notInConstruct = ['autolink', 'link', 'image', 'label']\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM autolink\n * literals in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n */\nfunction gfmAutolinkLiteralFromMarkdown() {\n  return {\n    transforms: [transformGfmAutolinkLiterals],\n    enter: {\n      literalAutolink: enterLiteralAutolink,\n      literalAutolinkEmail: enterLiteralAutolinkValue,\n      literalAutolinkHttp: enterLiteralAutolinkValue,\n      literalAutolinkWww: enterLiteralAutolinkValue\n    },\n    exit: {\n      literalAutolink: exitLiteralAutolink,\n      literalAutolinkEmail: exitLiteralAutolinkEmail,\n      literalAutolinkHttp: exitLiteralAutolinkHttp,\n      literalAutolinkWww: exitLiteralAutolinkWww\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM autolink\n * literals in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM autolink literals.\n */\nfunction gfmAutolinkLiteralToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: '@',\n        before: '[+\\\\-.\\\\w]',\n        after: '[\\\\-.\\\\w]',\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: '.',\n        before: '[Ww]',\n        after: '[\\\\-.\\\\w]',\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: ':',\n        before: '[ps]',\n        after: '\\\\/',\n        inConstruct,\n        notInConstruct\n      }\n    ]\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolink(token) {\n  this.enter({type: 'link', title: null, url: '', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLiteralAutolinkValue(token) {\n  this.config.enter.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkHttp(token) {\n  this.config.exit.autolinkProtocol.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkWww(token) {\n  this.config.exit.data.call(this, token)\n  const node = this.stack[this.stack.length - 1]\n  ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'link')\n  node.url = 'http://' + this.sliceSerialize(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolinkEmail(token) {\n  this.config.exit.autolinkEmail.call(this, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitLiteralAutolink(token) {\n  this.exit(token)\n}\n\n/** @type {FromMarkdownTransform} */\nfunction transformGfmAutolinkLiterals(tree) {\n  (0,mdast_util_find_and_replace__WEBPACK_IMPORTED_MODULE_1__.findAndReplace)(\n    tree,\n    [\n      [/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/gi, findUrl],\n      [/(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)/gu, findEmail]\n    ],\n    {ignore: ['link', 'linkReference']}\n  )\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} protocol\n * @param {string} domain\n * @param {string} path\n * @param {RegExpMatchObject} match\n * @returns {Array<PhrasingContent> | Link | false}\n */\n// eslint-disable-next-line max-params\nfunction findUrl(_, protocol, domain, path, match) {\n  let prefix = ''\n\n  // Not an expected previous character.\n  if (!previous(match)) {\n    return false\n  }\n\n  // Treat `www` as part of the domain.\n  if (/^w/i.test(protocol)) {\n    domain = protocol + domain\n    protocol = ''\n    prefix = 'http://'\n  }\n\n  if (!isCorrectDomain(domain)) {\n    return false\n  }\n\n  const parts = splitUrl(domain + path)\n\n  if (!parts[0]) return false\n\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    title: null,\n    url: prefix + protocol + parts[0],\n    children: [{type: 'text', value: protocol + parts[0]}]\n  }\n\n  if (parts[1]) {\n    return [result, {type: 'text', value: parts[1]}]\n  }\n\n  return result\n}\n\n/**\n * @type {ReplaceFunction}\n * @param {string} _\n * @param {string} atext\n * @param {string} label\n * @param {RegExpMatchObject} match\n * @returns {Link | false}\n */\nfunction findEmail(_, atext, label, match) {\n  if (\n    // Not an expected previous character.\n    !previous(match, true) ||\n    // Label ends in not allowed character.\n    /[-\\d_]$/.test(label)\n  ) {\n    return false\n  }\n\n  return {\n    type: 'link',\n    title: null,\n    url: 'mailto:' + atext + '@' + label,\n    children: [{type: 'text', value: atext + '@' + label}]\n  }\n}\n\n/**\n * @param {string} domain\n * @returns {boolean}\n */\nfunction isCorrectDomain(domain) {\n  const parts = domain.split('.')\n\n  if (\n    parts.length < 2 ||\n    (parts[parts.length - 1] &&\n      (/_/.test(parts[parts.length - 1]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 1]))) ||\n    (parts[parts.length - 2] &&\n      (/_/.test(parts[parts.length - 2]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 2])))\n  ) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {string} url\n * @returns {[string, string | undefined]}\n */\nfunction splitUrl(url) {\n  const trailExec = /[!\"&'),.:;<>?\\]}]+$/.exec(url)\n\n  if (!trailExec) {\n    return [url, undefined]\n  }\n\n  url = url.slice(0, trailExec.index)\n\n  let trail = trailExec[0]\n  let closingParenIndex = trail.indexOf(')')\n  const openingParens = (0,ccount__WEBPACK_IMPORTED_MODULE_2__.ccount)(url, '(')\n  let closingParens = (0,ccount__WEBPACK_IMPORTED_MODULE_2__.ccount)(url, ')')\n\n  while (closingParenIndex !== -1 && openingParens > closingParens) {\n    url += trail.slice(0, closingParenIndex + 1)\n    trail = trail.slice(closingParenIndex + 1)\n    closingParenIndex = trail.indexOf(')')\n    closingParens++\n  }\n\n  return [url, trail]\n}\n\n/**\n * @param {RegExpMatchObject} match\n * @param {boolean | null | undefined} [email=false]\n * @returns {boolean}\n */\nfunction previous(match, email) {\n  const code = match.input.charCodeAt(match.index - 1)\n\n  return (\n    (match.index === 0 ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.unicodeWhitespace)(code) ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_3__.unicodePunctuation)(code)) &&\n    // If its an email, the previous character should not be a slash.\n    (!email || code !== 47)\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWdmbS1hdXRvbGluay1saXRlcmFsL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hELFlBQVksc0hBQXNIO0FBQ2xJLFlBQVksK0NBQStDO0FBQzNELFlBQVksdUJBQXVCO0FBQ25DOztBQUU2QjtBQUNNO0FBQzJDO0FBQ3BCOztBQUUxRCxXQUFXLGVBQWU7QUFDMUI7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYyxpREFBaUQ7QUFDL0Q7O0FBRUE7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDJDQUFNO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0EsRUFBRSwyRUFBYztBQUNoQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsRUFBRSxJQUFJLEVBQUU7QUFDNUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUF5QztBQUN6RDs7QUFFQTtBQUNBLHFCQUFxQiw4QkFBOEI7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1CQUFtQjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUNBQXlDO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTs7QUFFckM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsOENBQU07QUFDOUIsc0JBQXNCLDhDQUFNOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsNEJBQTRCO0FBQ3ZDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sMkVBQWlCO0FBQ3ZCLE1BQU0sNEVBQWtCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWdmbS1hdXRvbGluay1saXRlcmFsL2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge1JlZ0V4cE1hdGNoT2JqZWN0LCBSZXBsYWNlRnVuY3Rpb259IGZyb20gJ21kYXN0LXV0aWwtZmluZC1hbmQtcmVwbGFjZSdcbiAqIEBpbXBvcnQge0NvbXBpbGVDb250ZXh0LCBFeHRlbnNpb24gYXMgRnJvbU1hcmtkb3duRXh0ZW5zaW9uLCBIYW5kbGUgYXMgRnJvbU1hcmtkb3duSGFuZGxlLCBUcmFuc2Zvcm0gYXMgRnJvbU1hcmtkb3duVHJhbnNmb3JtfSBmcm9tICdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24nXG4gKiBAaW1wb3J0IHtDb25zdHJ1Y3ROYW1lLCBPcHRpb25zIGFzIFRvTWFya2Rvd25FeHRlbnNpb259IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nXG4gKiBAaW1wb3J0IHtMaW5rLCBQaHJhc2luZ0NvbnRlbnR9IGZyb20gJ21kYXN0J1xuICovXG5cbmltcG9ydCB7Y2NvdW50fSBmcm9tICdjY291bnQnXG5pbXBvcnQge29rIGFzIGFzc2VydH0gZnJvbSAnZGV2bG9wJ1xuaW1wb3J0IHt1bmljb2RlUHVuY3R1YXRpb24sIHVuaWNvZGVXaGl0ZXNwYWNlfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5pbXBvcnQge2ZpbmRBbmRSZXBsYWNlfSBmcm9tICdtZGFzdC11dGlsLWZpbmQtYW5kLXJlcGxhY2UnXG5cbi8qKiBAdHlwZSB7Q29uc3RydWN0TmFtZX0gKi9cbmNvbnN0IGluQ29uc3RydWN0ID0gJ3BocmFzaW5nJ1xuLyoqIEB0eXBlIHtBcnJheTxDb25zdHJ1Y3ROYW1lPn0gKi9cbmNvbnN0IG5vdEluQ29uc3RydWN0ID0gWydhdXRvbGluaycsICdsaW5rJywgJ2ltYWdlJywgJ2xhYmVsJ11cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duYCB0byBlbmFibGUgR0ZNIGF1dG9saW5rXG4gKiBsaXRlcmFscyBpbiBtYXJrZG93bi5cbiAqXG4gKiBAcmV0dXJucyB7RnJvbU1hcmtkb3duRXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLXRvLW1hcmtkb3duYCB0byBlbmFibGUgR0ZNIGF1dG9saW5rIGxpdGVyYWxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtQXV0b2xpbmtMaXRlcmFsRnJvbU1hcmtkb3duKCkge1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybXM6IFt0cmFuc2Zvcm1HZm1BdXRvbGlua0xpdGVyYWxzXSxcbiAgICBlbnRlcjoge1xuICAgICAgbGl0ZXJhbEF1dG9saW5rOiBlbnRlckxpdGVyYWxBdXRvbGluayxcbiAgICAgIGxpdGVyYWxBdXRvbGlua0VtYWlsOiBlbnRlckxpdGVyYWxBdXRvbGlua1ZhbHVlLFxuICAgICAgbGl0ZXJhbEF1dG9saW5rSHR0cDogZW50ZXJMaXRlcmFsQXV0b2xpbmtWYWx1ZSxcbiAgICAgIGxpdGVyYWxBdXRvbGlua1d3dzogZW50ZXJMaXRlcmFsQXV0b2xpbmtWYWx1ZVxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgbGl0ZXJhbEF1dG9saW5rOiBleGl0TGl0ZXJhbEF1dG9saW5rLFxuICAgICAgbGl0ZXJhbEF1dG9saW5rRW1haWw6IGV4aXRMaXRlcmFsQXV0b2xpbmtFbWFpbCxcbiAgICAgIGxpdGVyYWxBdXRvbGlua0h0dHA6IGV4aXRMaXRlcmFsQXV0b2xpbmtIdHRwLFxuICAgICAgbGl0ZXJhbEF1dG9saW5rV3d3OiBleGl0TGl0ZXJhbEF1dG9saW5rV3d3XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBmb3IgYG1kYXN0LXV0aWwtdG8tbWFya2Rvd25gIHRvIGVuYWJsZSBHRk0gYXV0b2xpbmtcbiAqIGxpdGVyYWxzIGluIG1hcmtkb3duLlxuICpcbiAqIEByZXR1cm5zIHtUb01hcmtkb3duRXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLXRvLW1hcmtkb3duYCB0byBlbmFibGUgR0ZNIGF1dG9saW5rIGxpdGVyYWxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtQXV0b2xpbmtMaXRlcmFsVG9NYXJrZG93bigpIHtcbiAgcmV0dXJuIHtcbiAgICB1bnNhZmU6IFtcbiAgICAgIHtcbiAgICAgICAgY2hhcmFjdGVyOiAnQCcsXG4gICAgICAgIGJlZm9yZTogJ1srXFxcXC0uXFxcXHddJyxcbiAgICAgICAgYWZ0ZXI6ICdbXFxcXC0uXFxcXHddJyxcbiAgICAgICAgaW5Db25zdHJ1Y3QsXG4gICAgICAgIG5vdEluQ29uc3RydWN0XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjaGFyYWN0ZXI6ICcuJyxcbiAgICAgICAgYmVmb3JlOiAnW1d3XScsXG4gICAgICAgIGFmdGVyOiAnW1xcXFwtLlxcXFx3XScsXG4gICAgICAgIGluQ29uc3RydWN0LFxuICAgICAgICBub3RJbkNvbnN0cnVjdFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2hhcmFjdGVyOiAnOicsXG4gICAgICAgIGJlZm9yZTogJ1twc10nLFxuICAgICAgICBhZnRlcjogJ1xcXFwvJyxcbiAgICAgICAgaW5Db25zdHJ1Y3QsXG4gICAgICAgIG5vdEluQ29uc3RydWN0XG4gICAgICB9XG4gICAgXVxuICB9XG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZW50ZXJMaXRlcmFsQXV0b2xpbmsodG9rZW4pIHtcbiAgdGhpcy5lbnRlcih7dHlwZTogJ2xpbmsnLCB0aXRsZTogbnVsbCwgdXJsOiAnJywgY2hpbGRyZW46IFtdfSwgdG9rZW4pXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZW50ZXJMaXRlcmFsQXV0b2xpbmtWYWx1ZSh0b2tlbikge1xuICB0aGlzLmNvbmZpZy5lbnRlci5hdXRvbGlua1Byb3RvY29sLmNhbGwodGhpcywgdG9rZW4pXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZXhpdExpdGVyYWxBdXRvbGlua0h0dHAodG9rZW4pIHtcbiAgdGhpcy5jb25maWcuZXhpdC5hdXRvbGlua1Byb3RvY29sLmNhbGwodGhpcywgdG9rZW4pXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZXhpdExpdGVyYWxBdXRvbGlua1d3dyh0b2tlbikge1xuICB0aGlzLmNvbmZpZy5leGl0LmRhdGEuY2FsbCh0aGlzLCB0b2tlbilcbiAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICBhc3NlcnQobm9kZS50eXBlID09PSAnbGluaycpXG4gIG5vZGUudXJsID0gJ2h0dHA6Ly8nICsgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbilcbn1cblxuLyoqXG4gKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICovXG5mdW5jdGlvbiBleGl0TGl0ZXJhbEF1dG9saW5rRW1haWwodG9rZW4pIHtcbiAgdGhpcy5jb25maWcuZXhpdC5hdXRvbGlua0VtYWlsLmNhbGwodGhpcywgdG9rZW4pXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZXhpdExpdGVyYWxBdXRvbGluayh0b2tlbikge1xuICB0aGlzLmV4aXQodG9rZW4pXG59XG5cbi8qKiBAdHlwZSB7RnJvbU1hcmtkb3duVHJhbnNmb3JtfSAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtR2ZtQXV0b2xpbmtMaXRlcmFscyh0cmVlKSB7XG4gIGZpbmRBbmRSZXBsYWNlKFxuICAgIHRyZWUsXG4gICAgW1xuICAgICAgWy8oaHR0cHM/OlxcL1xcL3x3d3coPz1cXC4pKShbLS5cXHddKykoW14gXFx0XFxyXFxuXSopL2dpLCBmaW5kVXJsXSxcbiAgICAgIFsvKD88PV58XFxzfFxccHtQfXxcXHB7U30pKFstLlxcdytdKylAKFstXFx3XSsoPzpcXC5bLVxcd10rKSspL2d1LCBmaW5kRW1haWxdXG4gICAgXSxcbiAgICB7aWdub3JlOiBbJ2xpbmsnLCAnbGlua1JlZmVyZW5jZSddfVxuICApXG59XG5cbi8qKlxuICogQHR5cGUge1JlcGxhY2VGdW5jdGlvbn1cbiAqIEBwYXJhbSB7c3RyaW5nfSBfXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvdG9jb2xcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21haW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge1JlZ0V4cE1hdGNoT2JqZWN0fSBtYXRjaFxuICogQHJldHVybnMge0FycmF5PFBocmFzaW5nQ29udGVudD4gfCBMaW5rIHwgZmFsc2V9XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG5mdW5jdGlvbiBmaW5kVXJsKF8sIHByb3RvY29sLCBkb21haW4sIHBhdGgsIG1hdGNoKSB7XG4gIGxldCBwcmVmaXggPSAnJ1xuXG4gIC8vIE5vdCBhbiBleHBlY3RlZCBwcmV2aW91cyBjaGFyYWN0ZXIuXG4gIGlmICghcHJldmlvdXMobWF0Y2gpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBUcmVhdCBgd3d3YCBhcyBwYXJ0IG9mIHRoZSBkb21haW4uXG4gIGlmICgvXncvaS50ZXN0KHByb3RvY29sKSkge1xuICAgIGRvbWFpbiA9IHByb3RvY29sICsgZG9tYWluXG4gICAgcHJvdG9jb2wgPSAnJ1xuICAgIHByZWZpeCA9ICdodHRwOi8vJ1xuICB9XG5cbiAgaWYgKCFpc0NvcnJlY3REb21haW4oZG9tYWluKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgcGFydHMgPSBzcGxpdFVybChkb21haW4gKyBwYXRoKVxuXG4gIGlmICghcGFydHNbMF0pIHJldHVybiBmYWxzZVxuXG4gIC8qKiBAdHlwZSB7TGlua30gKi9cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHR5cGU6ICdsaW5rJyxcbiAgICB0aXRsZTogbnVsbCxcbiAgICB1cmw6IHByZWZpeCArIHByb3RvY29sICsgcGFydHNbMF0sXG4gICAgY2hpbGRyZW46IFt7dHlwZTogJ3RleHQnLCB2YWx1ZTogcHJvdG9jb2wgKyBwYXJ0c1swXX1dXG4gIH1cblxuICBpZiAocGFydHNbMV0pIHtcbiAgICByZXR1cm4gW3Jlc3VsdCwge3R5cGU6ICd0ZXh0JywgdmFsdWU6IHBhcnRzWzFdfV1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBAdHlwZSB7UmVwbGFjZUZ1bmN0aW9ufVxuICogQHBhcmFtIHtzdHJpbmd9IF9cbiAqIEBwYXJhbSB7c3RyaW5nfSBhdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG4gKiBAcGFyYW0ge1JlZ0V4cE1hdGNoT2JqZWN0fSBtYXRjaFxuICogQHJldHVybnMge0xpbmsgfCBmYWxzZX1cbiAqL1xuZnVuY3Rpb24gZmluZEVtYWlsKF8sIGF0ZXh0LCBsYWJlbCwgbWF0Y2gpIHtcbiAgaWYgKFxuICAgIC8vIE5vdCBhbiBleHBlY3RlZCBwcmV2aW91cyBjaGFyYWN0ZXIuXG4gICAgIXByZXZpb3VzKG1hdGNoLCB0cnVlKSB8fFxuICAgIC8vIExhYmVsIGVuZHMgaW4gbm90IGFsbG93ZWQgY2hhcmFjdGVyLlxuICAgIC9bLVxcZF9dJC8udGVzdChsYWJlbClcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdsaW5rJyxcbiAgICB0aXRsZTogbnVsbCxcbiAgICB1cmw6ICdtYWlsdG86JyArIGF0ZXh0ICsgJ0AnICsgbGFiZWwsXG4gICAgY2hpbGRyZW46IFt7dHlwZTogJ3RleHQnLCB2YWx1ZTogYXRleHQgKyAnQCcgKyBsYWJlbH1dXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZG9tYWluXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDb3JyZWN0RG9tYWluKGRvbWFpbikge1xuICBjb25zdCBwYXJ0cyA9IGRvbWFpbi5zcGxpdCgnLicpXG5cbiAgaWYgKFxuICAgIHBhcnRzLmxlbmd0aCA8IDIgfHxcbiAgICAocGFydHNbcGFydHMubGVuZ3RoIC0gMV0gJiZcbiAgICAgICgvXy8udGVzdChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSkgfHxcbiAgICAgICAgIS9bYS16QS1aXFxkXS8udGVzdChwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSkpKSB8fFxuICAgIChwYXJ0c1twYXJ0cy5sZW5ndGggLSAyXSAmJlxuICAgICAgKC9fLy50ZXN0KHBhcnRzW3BhcnRzLmxlbmd0aCAtIDJdKSB8fFxuICAgICAgICAhL1thLXpBLVpcXGRdLy50ZXN0KHBhcnRzW3BhcnRzLmxlbmd0aCAtIDJdKSkpXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcmV0dXJucyB7W3N0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkXX1cbiAqL1xuZnVuY3Rpb24gc3BsaXRVcmwodXJsKSB7XG4gIGNvbnN0IHRyYWlsRXhlYyA9IC9bIVwiJicpLC46Ozw+P1xcXX1dKyQvLmV4ZWModXJsKVxuXG4gIGlmICghdHJhaWxFeGVjKSB7XG4gICAgcmV0dXJuIFt1cmwsIHVuZGVmaW5lZF1cbiAgfVxuXG4gIHVybCA9IHVybC5zbGljZSgwLCB0cmFpbEV4ZWMuaW5kZXgpXG5cbiAgbGV0IHRyYWlsID0gdHJhaWxFeGVjWzBdXG4gIGxldCBjbG9zaW5nUGFyZW5JbmRleCA9IHRyYWlsLmluZGV4T2YoJyknKVxuICBjb25zdCBvcGVuaW5nUGFyZW5zID0gY2NvdW50KHVybCwgJygnKVxuICBsZXQgY2xvc2luZ1BhcmVucyA9IGNjb3VudCh1cmwsICcpJylcblxuICB3aGlsZSAoY2xvc2luZ1BhcmVuSW5kZXggIT09IC0xICYmIG9wZW5pbmdQYXJlbnMgPiBjbG9zaW5nUGFyZW5zKSB7XG4gICAgdXJsICs9IHRyYWlsLnNsaWNlKDAsIGNsb3NpbmdQYXJlbkluZGV4ICsgMSlcbiAgICB0cmFpbCA9IHRyYWlsLnNsaWNlKGNsb3NpbmdQYXJlbkluZGV4ICsgMSlcbiAgICBjbG9zaW5nUGFyZW5JbmRleCA9IHRyYWlsLmluZGV4T2YoJyknKVxuICAgIGNsb3NpbmdQYXJlbnMrK1xuICB9XG5cbiAgcmV0dXJuIFt1cmwsIHRyYWlsXVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwTWF0Y2hPYmplY3R9IG1hdGNoXG4gKiBAcGFyYW0ge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbZW1haWw9ZmFsc2VdXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gcHJldmlvdXMobWF0Y2gsIGVtYWlsKSB7XG4gIGNvbnN0IGNvZGUgPSBtYXRjaC5pbnB1dC5jaGFyQ29kZUF0KG1hdGNoLmluZGV4IC0gMSlcblxuICByZXR1cm4gKFxuICAgIChtYXRjaC5pbmRleCA9PT0gMCB8fFxuICAgICAgdW5pY29kZVdoaXRlc3BhY2UoY29kZSkgfHxcbiAgICAgIHVuaWNvZGVQdW5jdHVhdGlvbihjb2RlKSkgJiZcbiAgICAvLyBJZiBpdOKAmXMgYW4gZW1haWwsIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgc2hvdWxkIG5vdCBiZSBhIHNsYXNoLlxuICAgICghZW1haWwgfHwgY29kZSAhPT0gNDcpXG4gIClcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-gfm-autolink-literal/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-gfm-footnote/lib/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/mdast-util-gfm-footnote/lib/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmFootnoteFromMarkdown: () => (/* binding */ gfmFootnoteFromMarkdown),\n/* harmony export */   gfmFootnoteToMarkdown: () => (/* binding */ gfmFootnoteToMarkdown)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devlop */ \"(app-pages-browser)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-normalize-identifier */ \"(app-pages-browser)/./node_modules/micromark-util-normalize-identifier/dev/index.js\");\n/**\n * @import {\n *   CompileContext,\n *   Extension as FromMarkdownExtension,\n *   Handle as FromMarkdownHandle\n * } from 'mdast-util-from-markdown'\n * @import {ToMarkdownOptions} from 'mdast-util-gfm-footnote'\n * @import {\n *   Handle as ToMarkdownHandle,\n *   Map,\n *   Options as ToMarkdownExtension\n * } from 'mdast-util-to-markdown'\n * @import {FootnoteDefinition, FootnoteReference} from 'mdast'\n */\n\n\n\n\nfootnoteReference.peek = footnoteReferencePeek\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCallString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteCall(token) {\n  this.enter({type: 'footnoteReference', identifier: '', label: ''}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinitionLabelString() {\n  this.buffer()\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterFootnoteDefinition(token) {\n  this.enter(\n    {type: 'footnoteDefinition', identifier: '', label: '', children: []},\n    token\n  )\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCallString(token) {\n  const label = this.resume()\n  const node = this.stack[this.stack.length - 1]\n  ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'footnoteReference')\n  node.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_1__.normalizeIdentifier)(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n  node.label = label\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteCall(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinitionLabelString(token) {\n  const label = this.resume()\n  const node = this.stack[this.stack.length - 1]\n  ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'footnoteDefinition')\n  node.identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_1__.normalizeIdentifier)(\n    this.sliceSerialize(token)\n  ).toLowerCase()\n  node.label = label\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitFootnoteDefinition(token) {\n  this.exit(token)\n}\n\n/** @type {ToMarkdownHandle} */\nfunction footnoteReferencePeek() {\n  return '['\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {FootnoteReference} node\n */\nfunction footnoteReference(node, _, state, info) {\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[^')\n  const exit = state.enter('footnoteReference')\n  const subexit = state.enter('reference')\n  value += tracker.move(\n    state.safe(state.associationId(node), {after: ']', before: value})\n  )\n  subexit()\n  exit()\n  value += tracker.move(']')\n  return value\n}\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nfunction gfmFootnoteFromMarkdown() {\n  return {\n    enter: {\n      gfmFootnoteCallString: enterFootnoteCallString,\n      gfmFootnoteCall: enterFootnoteCall,\n      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,\n      gfmFootnoteDefinition: enterFootnoteDefinition\n    },\n    exit: {\n      gfmFootnoteCallString: exitFootnoteCallString,\n      gfmFootnoteCall: exitFootnoteCall,\n      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,\n      gfmFootnoteDefinition: exitFootnoteDefinition\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM footnotes\n * in markdown.\n *\n * @param {ToMarkdownOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nfunction gfmFootnoteToMarkdown(options) {\n  // To do: next major: change default.\n  let firstLineBlank = false\n\n  if (options && options.firstLineBlank) {\n    firstLineBlank = true\n  }\n\n  return {\n    handlers: {footnoteDefinition, footnoteReference},\n    // This is on by default already.\n    unsafe: [{character: '[', inConstruct: ['label', 'phrasing', 'reference']}]\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {FootnoteDefinition} node\n   */\n  function footnoteDefinition(node, _, state, info) {\n    const tracker = state.createTracker(info)\n    let value = tracker.move('[^')\n    const exit = state.enter('footnoteDefinition')\n    const subexit = state.enter('label')\n    value += tracker.move(\n      state.safe(state.associationId(node), {before: value, after: ']'})\n    )\n    subexit()\n\n    value += tracker.move(']:')\n\n    if (node.children && node.children.length > 0) {\n      tracker.shift(4)\n\n      value += tracker.move(\n        (firstLineBlank ? '\\n' : ' ') +\n          state.indentLines(\n            state.containerFlow(node, tracker.current()),\n            firstLineBlank ? mapAll : mapExceptFirst\n          )\n      )\n    }\n\n    exit()\n\n    return value\n  }\n}\n\n/** @type {Map} */\nfunction mapExceptFirst(line, index, blank) {\n  return index === 0 ? line : mapAll(line, index, blank)\n}\n\n/** @type {Map} */\nfunction mapAll(line, index, blank) {\n  return (blank ? '' : '    ') + line\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWdmbS1mb290bm90ZS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSx1Q0FBdUM7QUFDbkQ7O0FBRW1DO0FBQ29DOztBQUV2RTs7QUFFQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjLHFEQUFxRDtBQUNuRTs7QUFFQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUssb0VBQW9FO0FBQ3pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDJDQUFNO0FBQ1Isb0JBQW9CLHdGQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyQ0FBTTtBQUNSLG9CQUFvQix3RkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQ0FBc0M7QUFDakQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHNDQUFzQztBQUNyRDtBQUNBLGNBQWMsZ0VBQWdFO0FBQzlFOztBQUVBO0FBQ0EsWUFBWTtBQUNaLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBCQUEwQjtBQUN2RTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWdmbS1mb290bm90ZS9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtcbiAqICAgQ29tcGlsZUNvbnRleHQsXG4gKiAgIEV4dGVuc2lvbiBhcyBGcm9tTWFya2Rvd25FeHRlbnNpb24sXG4gKiAgIEhhbmRsZSBhcyBGcm9tTWFya2Rvd25IYW5kbGVcbiAqIH0gZnJvbSAnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJ1xuICogQGltcG9ydCB7VG9NYXJrZG93bk9wdGlvbnN9IGZyb20gJ21kYXN0LXV0aWwtZ2ZtLWZvb3Rub3RlJ1xuICogQGltcG9ydCB7XG4gKiAgIEhhbmRsZSBhcyBUb01hcmtkb3duSGFuZGxlLFxuICogICBNYXAsXG4gKiAgIE9wdGlvbnMgYXMgVG9NYXJrZG93bkV4dGVuc2lvblxuICogfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duJ1xuICogQGltcG9ydCB7Rm9vdG5vdGVEZWZpbml0aW9uLCBGb290bm90ZVJlZmVyZW5jZX0gZnJvbSAnbWRhc3QnXG4gKi9cblxuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ2RldmxvcCdcbmltcG9ydCB7bm9ybWFsaXplSWRlbnRpZmllcn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtbm9ybWFsaXplLWlkZW50aWZpZXInXG5cbmZvb3Rub3RlUmVmZXJlbmNlLnBlZWsgPSBmb290bm90ZVJlZmVyZW5jZVBlZWtcblxuLyoqXG4gKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICovXG5mdW5jdGlvbiBlbnRlckZvb3Rub3RlQ2FsbFN0cmluZygpIHtcbiAgdGhpcy5idWZmZXIoKVxufVxuXG4vKipcbiAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gKi9cbmZ1bmN0aW9uIGVudGVyRm9vdG5vdGVDYWxsKHRva2VuKSB7XG4gIHRoaXMuZW50ZXIoe3R5cGU6ICdmb290bm90ZVJlZmVyZW5jZScsIGlkZW50aWZpZXI6ICcnLCBsYWJlbDogJyd9LCB0b2tlbilcbn1cblxuLyoqXG4gKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICovXG5mdW5jdGlvbiBlbnRlckZvb3Rub3RlRGVmaW5pdGlvbkxhYmVsU3RyaW5nKCkge1xuICB0aGlzLmJ1ZmZlcigpXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZW50ZXJGb290bm90ZURlZmluaXRpb24odG9rZW4pIHtcbiAgdGhpcy5lbnRlcihcbiAgICB7dHlwZTogJ2Zvb3Rub3RlRGVmaW5pdGlvbicsIGlkZW50aWZpZXI6ICcnLCBsYWJlbDogJycsIGNoaWxkcmVuOiBbXX0sXG4gICAgdG9rZW5cbiAgKVxufVxuXG4vKipcbiAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gKi9cbmZ1bmN0aW9uIGV4aXRGb290bm90ZUNhbGxTdHJpbmcodG9rZW4pIHtcbiAgY29uc3QgbGFiZWwgPSB0aGlzLnJlc3VtZSgpXG4gIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2Zvb3Rub3RlUmVmZXJlbmNlJylcbiAgbm9kZS5pZGVudGlmaWVyID0gbm9ybWFsaXplSWRlbnRpZmllcihcbiAgICB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICApLnRvTG93ZXJDYXNlKClcbiAgbm9kZS5sYWJlbCA9IGxhYmVsXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZXhpdEZvb3Rub3RlQ2FsbCh0b2tlbikge1xuICB0aGlzLmV4aXQodG9rZW4pXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZXhpdEZvb3Rub3RlRGVmaW5pdGlvbkxhYmVsU3RyaW5nKHRva2VuKSB7XG4gIGNvbnN0IGxhYmVsID0gdGhpcy5yZXN1bWUoKVxuICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gIGFzc2VydChub2RlLnR5cGUgPT09ICdmb290bm90ZURlZmluaXRpb24nKVxuICBub2RlLmlkZW50aWZpZXIgPSBub3JtYWxpemVJZGVudGlmaWVyKFxuICAgIHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG4gICkudG9Mb3dlckNhc2UoKVxuICBub2RlLmxhYmVsID0gbGFiZWxcbn1cblxuLyoqXG4gKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICovXG5mdW5jdGlvbiBleGl0Rm9vdG5vdGVEZWZpbml0aW9uKHRva2VuKSB7XG4gIHRoaXMuZXhpdCh0b2tlbilcbn1cblxuLyoqIEB0eXBlIHtUb01hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gZm9vdG5vdGVSZWZlcmVuY2VQZWVrKCkge1xuICByZXR1cm4gJ1snXG59XG5cbi8qKlxuICogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9XG4gKiBAcGFyYW0ge0Zvb3Rub3RlUmVmZXJlbmNlfSBub2RlXG4gKi9cbmZ1bmN0aW9uIGZvb3Rub3RlUmVmZXJlbmNlKG5vZGUsIF8sIHN0YXRlLCBpbmZvKSB7XG4gIGNvbnN0IHRyYWNrZXIgPSBzdGF0ZS5jcmVhdGVUcmFja2VyKGluZm8pXG4gIGxldCB2YWx1ZSA9IHRyYWNrZXIubW92ZSgnW14nKVxuICBjb25zdCBleGl0ID0gc3RhdGUuZW50ZXIoJ2Zvb3Rub3RlUmVmZXJlbmNlJylcbiAgY29uc3Qgc3ViZXhpdCA9IHN0YXRlLmVudGVyKCdyZWZlcmVuY2UnKVxuICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoXG4gICAgc3RhdGUuc2FmZShzdGF0ZS5hc3NvY2lhdGlvbklkKG5vZGUpLCB7YWZ0ZXI6ICddJywgYmVmb3JlOiB2YWx1ZX0pXG4gIClcbiAgc3ViZXhpdCgpXG4gIGV4aXQoKVxuICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJ10nKVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duYCB0byBlbmFibGUgR0ZNIGZvb3Rub3Rlc1xuICogaW4gbWFya2Rvd24uXG4gKlxuICogQHJldHVybnMge0Zyb21NYXJrZG93bkV4dGVuc2lvbn1cbiAqICAgRXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbUZvb3Rub3RlRnJvbU1hcmtkb3duKCkge1xuICByZXR1cm4ge1xuICAgIGVudGVyOiB7XG4gICAgICBnZm1Gb290bm90ZUNhbGxTdHJpbmc6IGVudGVyRm9vdG5vdGVDYWxsU3RyaW5nLFxuICAgICAgZ2ZtRm9vdG5vdGVDYWxsOiBlbnRlckZvb3Rub3RlQ2FsbCxcbiAgICAgIGdmbUZvb3Rub3RlRGVmaW5pdGlvbkxhYmVsU3RyaW5nOiBlbnRlckZvb3Rub3RlRGVmaW5pdGlvbkxhYmVsU3RyaW5nLFxuICAgICAgZ2ZtRm9vdG5vdGVEZWZpbml0aW9uOiBlbnRlckZvb3Rub3RlRGVmaW5pdGlvblxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgZ2ZtRm9vdG5vdGVDYWxsU3RyaW5nOiBleGl0Rm9vdG5vdGVDYWxsU3RyaW5nLFxuICAgICAgZ2ZtRm9vdG5vdGVDYWxsOiBleGl0Rm9vdG5vdGVDYWxsLFxuICAgICAgZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTGFiZWxTdHJpbmc6IGV4aXRGb290bm90ZURlZmluaXRpb25MYWJlbFN0cmluZyxcbiAgICAgIGdmbUZvb3Rub3RlRGVmaW5pdGlvbjogZXhpdEZvb3Rub3RlRGVmaW5pdGlvblxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBleHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLXRvLW1hcmtkb3duYCB0byBlbmFibGUgR0ZNIGZvb3Rub3Rlc1xuICogaW4gbWFya2Rvd24uXG4gKlxuICogQHBhcmFtIHtUb01hcmtkb3duT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zXVxuICogICBDb25maWd1cmF0aW9uIChvcHRpb25hbCkuXG4gKiBAcmV0dXJucyB7VG9NYXJrZG93bkV4dGVuc2lvbn1cbiAqICAgRXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC10by1tYXJrZG93bmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZm1Gb290bm90ZVRvTWFya2Rvd24ob3B0aW9ucykge1xuICAvLyBUbyBkbzogbmV4dCBtYWpvcjogY2hhbmdlIGRlZmF1bHQuXG4gIGxldCBmaXJzdExpbmVCbGFuayA9IGZhbHNlXG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5maXJzdExpbmVCbGFuaykge1xuICAgIGZpcnN0TGluZUJsYW5rID0gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoYW5kbGVyczoge2Zvb3Rub3RlRGVmaW5pdGlvbiwgZm9vdG5vdGVSZWZlcmVuY2V9LFxuICAgIC8vIFRoaXMgaXMgb24gYnkgZGVmYXVsdCBhbHJlYWR5LlxuICAgIHVuc2FmZTogW3tjaGFyYWN0ZXI6ICdbJywgaW5Db25zdHJ1Y3Q6IFsnbGFiZWwnLCAncGhyYXNpbmcnLCAncmVmZXJlbmNlJ119XVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtUb01hcmtkb3duSGFuZGxlfVxuICAgKiBAcGFyYW0ge0Zvb3Rub3RlRGVmaW5pdGlvbn0gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gZm9vdG5vdGVEZWZpbml0aW9uKG5vZGUsIF8sIHN0YXRlLCBpbmZvKSB7XG4gICAgY29uc3QgdHJhY2tlciA9IHN0YXRlLmNyZWF0ZVRyYWNrZXIoaW5mbylcbiAgICBsZXQgdmFsdWUgPSB0cmFja2VyLm1vdmUoJ1teJylcbiAgICBjb25zdCBleGl0ID0gc3RhdGUuZW50ZXIoJ2Zvb3Rub3RlRGVmaW5pdGlvbicpXG4gICAgY29uc3Qgc3ViZXhpdCA9IHN0YXRlLmVudGVyKCdsYWJlbCcpXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKFxuICAgICAgc3RhdGUuc2FmZShzdGF0ZS5hc3NvY2lhdGlvbklkKG5vZGUpLCB7YmVmb3JlOiB2YWx1ZSwgYWZ0ZXI6ICddJ30pXG4gICAgKVxuICAgIHN1YmV4aXQoKVxuXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKCddOicpXG5cbiAgICBpZiAobm9kZS5jaGlsZHJlbiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIHRyYWNrZXIuc2hpZnQoNClcblxuICAgICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKFxuICAgICAgICAoZmlyc3RMaW5lQmxhbmsgPyAnXFxuJyA6ICcgJykgK1xuICAgICAgICAgIHN0YXRlLmluZGVudExpbmVzKFxuICAgICAgICAgICAgc3RhdGUuY29udGFpbmVyRmxvdyhub2RlLCB0cmFja2VyLmN1cnJlbnQoKSksXG4gICAgICAgICAgICBmaXJzdExpbmVCbGFuayA/IG1hcEFsbCA6IG1hcEV4Y2VwdEZpcnN0XG4gICAgICAgICAgKVxuICAgICAgKVxuICAgIH1cblxuICAgIGV4aXQoKVxuXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbn1cblxuLyoqIEB0eXBlIHtNYXB9ICovXG5mdW5jdGlvbiBtYXBFeGNlcHRGaXJzdChsaW5lLCBpbmRleCwgYmxhbmspIHtcbiAgcmV0dXJuIGluZGV4ID09PSAwID8gbGluZSA6IG1hcEFsbChsaW5lLCBpbmRleCwgYmxhbmspXG59XG5cbi8qKiBAdHlwZSB7TWFwfSAqL1xuZnVuY3Rpb24gbWFwQWxsKGxpbmUsIGluZGV4LCBibGFuaykge1xuICByZXR1cm4gKGJsYW5rID8gJycgOiAnICAgICcpICsgbGluZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-gfm-footnote/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-gfm-strikethrough/lib/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/mdast-util-gfm-strikethrough/lib/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmStrikethroughFromMarkdown: () => (/* binding */ gfmStrikethroughFromMarkdown),\n/* harmony export */   gfmStrikethroughToMarkdown: () => (/* binding */ gfmStrikethroughToMarkdown)\n/* harmony export */ });\n/**\n * @typedef {import('mdast').Delete} Delete\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain strikethrough.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>\n *\n * @type {Array<ConstructName>}\n */\nconst constructsWithoutStrikethrough = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\nhandleDelete.peek = peekDelete\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM\n * strikethrough in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM strikethrough.\n */\nfunction gfmStrikethroughFromMarkdown() {\n  return {\n    canContainEols: ['delete'],\n    enter: {strikethrough: enterStrikethrough},\n    exit: {strikethrough: exitStrikethrough}\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM\n * strikethrough in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM strikethrough.\n */\nfunction gfmStrikethroughToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: '~',\n        inConstruct: 'phrasing',\n        notInConstruct: constructsWithoutStrikethrough\n      }\n    ],\n    handlers: {delete: handleDelete}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, state, info) {\n  const tracker = state.createTracker(info)\n  const exit = state.enter('strikethrough')\n  let value = tracker.move('~~')\n  value += state.containerPhrasing(node, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  })\n  value += tracker.move('~~')\n  exit()\n  return value\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWdmbS1zdHJpa2V0aHJvdWdoL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQSxhQUFhLG1EQUFtRDtBQUNoRSxhQUFhLDhDQUE4QztBQUMzRCxhQUFhLDJDQUEyQztBQUN4RDtBQUNBLGFBQWEsZ0RBQWdEO0FBQzdELGFBQWEseUNBQXlDO0FBQ3RELGFBQWEsMENBQTBDO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxZQUFZLGtDQUFrQztBQUM5QyxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQzs7QUFFQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1YsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtZ2ZtLXN0cmlrZXRocm91Z2gvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5EZWxldGV9IERlbGV0ZVxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkNvbXBpbGVDb250ZXh0fSBDb21waWxlQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuRXh0ZW5zaW9ufSBGcm9tTWFya2Rvd25FeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkhhbmRsZX0gRnJvbU1hcmtkb3duSGFuZGxlXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLkNvbnN0cnVjdE5hbWV9IENvbnN0cnVjdE5hbWVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nKS5IYW5kbGV9IFRvTWFya2Rvd25IYW5kbGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nKS5PcHRpb25zfSBUb01hcmtkb3duRXh0ZW5zaW9uXG4gKi9cblxuLyoqXG4gKiBMaXN0IG9mIGNvbnN0cnVjdHMgdGhhdCBvY2N1ciBpbiBwaHJhc2luZyAocGFyYWdyYXBocywgaGVhZGluZ3MpLCBidXQgY2Fubm90XG4gKiBjb250YWluIHN0cmlrZXRocm91Z2guXG4gKiBTbyB0aGV5IHNvcnQgb2YgY2FuY2VsIGVhY2ggb3RoZXIgb3V0LlxuICogTm90ZTogY291bGQgdXNlIGEgYmV0dGVyIG5hbWUuXG4gKlxuICogTm90ZToga2VlcCBpbiBzeW5jIHdpdGg6IDxodHRwczovL2dpdGh1Yi5jb20vc3ludGF4LXRyZWUvbWRhc3QtdXRpbC10by1tYXJrZG93bi9ibG9iLzhjZThkYmYvbGliL3Vuc2FmZS5qcyNMMTQ+XG4gKlxuICogQHR5cGUge0FycmF5PENvbnN0cnVjdE5hbWU+fVxuICovXG5jb25zdCBjb25zdHJ1Y3RzV2l0aG91dFN0cmlrZXRocm91Z2ggPSBbXG4gICdhdXRvbGluaycsXG4gICdkZXN0aW5hdGlvbkxpdGVyYWwnLFxuICAnZGVzdGluYXRpb25SYXcnLFxuICAncmVmZXJlbmNlJyxcbiAgJ3RpdGxlUXVvdGUnLFxuICAndGl0bGVBcG9zdHJvcGhlJ1xuXVxuXG5oYW5kbGVEZWxldGUucGVlayA9IHBlZWtEZWxldGVcblxuLyoqXG4gKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duYCB0byBlbmFibGUgR0ZNXG4gKiBzdHJpa2V0aHJvdWdoIGluIG1hcmtkb3duLlxuICpcbiAqIEByZXR1cm5zIHtGcm9tTWFya2Rvd25FeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1kYXN0LXV0aWwtZnJvbS1tYXJrZG93bmAgdG8gZW5hYmxlIEdGTSBzdHJpa2V0aHJvdWdoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtU3RyaWtldGhyb3VnaEZyb21NYXJrZG93bigpIHtcbiAgcmV0dXJuIHtcbiAgICBjYW5Db250YWluRW9sczogWydkZWxldGUnXSxcbiAgICBlbnRlcjoge3N0cmlrZXRocm91Z2g6IGVudGVyU3RyaWtldGhyb3VnaH0sXG4gICAgZXhpdDoge3N0cmlrZXRocm91Z2g6IGV4aXRTdHJpa2V0aHJvdWdofVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBmb3IgYG1kYXN0LXV0aWwtdG8tbWFya2Rvd25gIHRvIGVuYWJsZSBHRk1cbiAqIHN0cmlrZXRocm91Z2ggaW4gbWFya2Rvd24uXG4gKlxuICogQHJldHVybnMge1RvTWFya2Rvd25FeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1kYXN0LXV0aWwtdG8tbWFya2Rvd25gIHRvIGVuYWJsZSBHRk0gc3RyaWtldGhyb3VnaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbVN0cmlrZXRocm91Z2hUb01hcmtkb3duKCkge1xuICByZXR1cm4ge1xuICAgIHVuc2FmZTogW1xuICAgICAge1xuICAgICAgICBjaGFyYWN0ZXI6ICd+JyxcbiAgICAgICAgaW5Db25zdHJ1Y3Q6ICdwaHJhc2luZycsXG4gICAgICAgIG5vdEluQ29uc3RydWN0OiBjb25zdHJ1Y3RzV2l0aG91dFN0cmlrZXRocm91Z2hcbiAgICAgIH1cbiAgICBdLFxuICAgIGhhbmRsZXJzOiB7ZGVsZXRlOiBoYW5kbGVEZWxldGV9XG4gIH1cbn1cblxuLyoqXG4gKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICovXG5mdW5jdGlvbiBlbnRlclN0cmlrZXRocm91Z2godG9rZW4pIHtcbiAgdGhpcy5lbnRlcih7dHlwZTogJ2RlbGV0ZScsIGNoaWxkcmVuOiBbXX0sIHRva2VuKVxufVxuXG4vKipcbiAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gKi9cbmZ1bmN0aW9uIGV4aXRTdHJpa2V0aHJvdWdoKHRva2VuKSB7XG4gIHRoaXMuZXhpdCh0b2tlbilcbn1cblxuLyoqXG4gKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAqIEBwYXJhbSB7RGVsZXRlfSBub2RlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZURlbGV0ZShub2RlLCBfLCBzdGF0ZSwgaW5mbykge1xuICBjb25zdCB0cmFja2VyID0gc3RhdGUuY3JlYXRlVHJhY2tlcihpbmZvKVxuICBjb25zdCBleGl0ID0gc3RhdGUuZW50ZXIoJ3N0cmlrZXRocm91Z2gnKVxuICBsZXQgdmFsdWUgPSB0cmFja2VyLm1vdmUoJ35+JylcbiAgdmFsdWUgKz0gc3RhdGUuY29udGFpbmVyUGhyYXNpbmcobm9kZSwge1xuICAgIC4uLnRyYWNrZXIuY3VycmVudCgpLFxuICAgIGJlZm9yZTogdmFsdWUsXG4gICAgYWZ0ZXI6ICd+J1xuICB9KVxuICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJ35+JylcbiAgZXhpdCgpXG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKiogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9ICovXG5mdW5jdGlvbiBwZWVrRGVsZXRlKCkge1xuICByZXR1cm4gJ34nXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-gfm-strikethrough/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-gfm-table/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/mdast-util-gfm-table/lib/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTableFromMarkdown: () => (/* binding */ gfmTableFromMarkdown),\n/* harmony export */   gfmTableToMarkdown: () => (/* binding */ gfmTableToMarkdown)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devlop */ \"(app-pages-browser)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var markdown_table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! markdown-table */ \"(app-pages-browser)/./node_modules/markdown-table/index.js\");\n/* harmony import */ var mdast_util_to_markdown__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mdast-util-to-markdown */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/index.js\");\n/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Table} Table\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('mdast').TableRow} TableRow\n *\n * @typedef {import('markdown-table').Options} MarkdownTableOptions\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').State} State\n * @typedef {import('mdast-util-to-markdown').Info} Info\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [tableCellPadding=true]\n *   Whether to add a space of padding between delimiters and cells (default:\n *   `true`).\n * @property {boolean | null | undefined} [tablePipeAlign=true]\n *   Whether to align the delimiters (default: `true`).\n * @property {MarkdownTableOptions['stringLength'] | null | undefined} [stringLength]\n *   Function to detect the length of table cell content, used when aligning\n *   the delimiters between cells (optional).\n */\n\n\n\n\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM tables in\n * markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM tables.\n */\nfunction gfmTableFromMarkdown() {\n  return {\n    enter: {\n      table: enterTable,\n      tableData: enterCell,\n      tableHeader: enterCell,\n      tableRow: enterRow\n    },\n    exit: {\n      codeText: exitCodeText,\n      table: exitTable,\n      tableData: exit,\n      tableHeader: exit,\n      tableRow: exit\n    }\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterTable(token) {\n  const align = token._align\n  ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(align, 'expected `_align` on table')\n  this.enter(\n    {\n      type: 'table',\n      align: align.map(function (d) {\n        return d === 'none' ? null : d\n      }),\n      children: []\n    },\n    token\n  )\n  this.data.inTable = true\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitTable(token) {\n  this.exit(token)\n  this.data.inTable = undefined\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterRow(token) {\n  this.enter({type: 'tableRow', children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exit(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterCell(token) {\n  this.enter({type: 'tableCell', children: []}, token)\n}\n\n// Overwrite the default code text data handler to unescape escaped pipes when\n// they are in tables.\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCodeText(token) {\n  let value = this.resume()\n\n  if (this.data.inTable) {\n    value = value.replace(/\\\\([\\\\|])/g, replace)\n  }\n\n  const node = this.stack[this.stack.length - 1]\n  ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'inlineCode')\n  node.value = value\n  this.exit(token)\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes dont (but cant escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM tables in\n * markdown.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM tables.\n */\nfunction gfmTableToMarkdown(options) {\n  const settings = options || {}\n  const padding = settings.tableCellPadding\n  const alignDelimiters = settings.tablePipeAlign\n  const stringLength = settings.stringLength\n  const around = padding ? ' ' : '|'\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'tableCell'},\n      {character: '\\n', inConstruct: 'tableCell'},\n      // A pipe, when followed by a tab or space (padding), or a dash or colon\n      // (unpadded delimiter row), could result in a table.\n      {atBreak: true, character: '|', after: '[\\t :-]'},\n      // A pipe in a cell must be encoded.\n      {character: '|', inConstruct: 'tableCell'},\n      // A colon must be followed by a dash, in which case it could start a\n      // delimiter row.\n      {atBreak: true, character: ':', after: '-'},\n      // A delimiter row can also start with a dash, when followed by more\n      // dashes, a colon, or a pipe.\n      // This is a stricter version than the built in check for lists, thematic\n      // breaks, and setex heading underlines though:\n      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n      {atBreak: true, character: '-', after: '[:|-]'}\n    ],\n    handlers: {\n      inlineCode: inlineCodeWithTable,\n      table: handleTable,\n      tableCell: handleTableCell,\n      tableRow: handleTableRow\n    }\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Table} node\n   */\n  function handleTable(node, _, state, info) {\n    return serializeData(handleTableAsData(node, state, info), node.align)\n  }\n\n  /**\n   * This function isnt really used normally, because we handle rows at the\n   * table level.\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\n   *\n   * @type {ToMarkdownHandle}\n   * @param {TableRow} node\n   */\n  function handleTableRow(node, _, state, info) {\n    const row = handleTableRowAsData(node, state, info)\n    const value = serializeData([row])\n    // `markdown-table` will always add an align row\n    return value.slice(0, value.indexOf('\\n'))\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {TableCell} node\n   */\n  function handleTableCell(node, _, state, info) {\n    const exit = state.enter('tableCell')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...info,\n      before: around,\n      after: around\n    })\n    subexit()\n    exit()\n    return value\n  }\n\n  /**\n   * @param {Array<Array<string>>} matrix\n   * @param {Array<string | null | undefined> | null | undefined} [align]\n   */\n  function serializeData(matrix, align) {\n    return (0,markdown_table__WEBPACK_IMPORTED_MODULE_1__.markdownTable)(matrix, {\n      align,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      alignDelimiters,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      padding,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      stringLength\n    })\n  }\n\n  /**\n   * @param {Table} node\n   * @param {State} state\n   * @param {Info} info\n   */\n  function handleTableAsData(node, state, info) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<Array<string>>} */\n    const result = []\n    const subexit = state.enter('table')\n\n    while (++index < children.length) {\n      result[index] = handleTableRowAsData(children[index], state, info)\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @param {TableRow} node\n   * @param {State} state\n   * @param {Info} info\n   */\n  function handleTableRowAsData(node, state, info) {\n    const children = node.children\n    let index = -1\n    /** @type {Array<string>} */\n    const result = []\n    const subexit = state.enter('tableRow')\n\n    while (++index < children.length) {\n      // Note: the positional info as used here is incorrect.\n      // Making it correct would be impossible due to aligning cells?\n      // And it would need copy/pasting `markdown-table` into this project.\n      result[index] = handleTableCell(children[index], node, state, info)\n    }\n\n    subexit()\n\n    return result\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineCode} node\n   */\n  function inlineCodeWithTable(node, parent, state) {\n    let value = mdast_util_to_markdown__WEBPACK_IMPORTED_MODULE_2__.handle.inlineCode(node, parent, state)\n\n    if (state.stack.includes('tableCell')) {\n      value = value.replace(/\\|/g, '\\\\$&')\n    }\n\n    return value\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWdmbS10YWJsZS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsdUJBQXVCO0FBQ3BDLGFBQWEsMkJBQTJCO0FBQ3hDLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0M7QUFDQSxhQUFhLG1EQUFtRDtBQUNoRSxhQUFhLDhDQUE4QztBQUMzRCxhQUFhLDJDQUEyQztBQUN4RDtBQUNBLGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEseUNBQXlDO0FBQ3RELGFBQWEsd0NBQXdDO0FBQ3JELGFBQWEsdUNBQXVDO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBLGNBQWMseURBQXlEO0FBQ3ZFO0FBQ0E7QUFDQTs7QUFFbUM7QUFDUztBQUNVOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxFQUFFLDJDQUFNO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWMsK0JBQStCO0FBQzdDOztBQUVBO0FBQ0EsVUFBVTtBQUNWLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWMsZ0NBQWdDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUUsMkNBQU07QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTywwQ0FBMEM7QUFDakQsT0FBTywwQ0FBMEM7QUFDakQ7QUFDQTtBQUNBLE9BQU8sZ0RBQWdEO0FBQ3ZEO0FBQ0EsT0FBTyx5Q0FBeUM7QUFDaEQ7QUFDQTtBQUNBLE9BQU8sMENBQTBDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1osYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHFEQUFxRDtBQUNsRTtBQUNBO0FBQ0EsV0FBVyw2REFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1osYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQWU7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtZ2ZtLXRhYmxlL2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuSW5saW5lQ29kZX0gSW5saW5lQ29kZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5UYWJsZX0gVGFibGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuVGFibGVDZWxsfSBUYWJsZUNlbGxcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuVGFibGVSb3d9IFRhYmxlUm93XG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWFya2Rvd24tdGFibGUnKS5PcHRpb25zfSBNYXJrZG93blRhYmxlT3B0aW9uc1xuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkNvbXBpbGVDb250ZXh0fSBDb21waWxlQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuRXh0ZW5zaW9ufSBGcm9tTWFya2Rvd25FeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkhhbmRsZX0gRnJvbU1hcmtkb3duSGFuZGxlXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLk9wdGlvbnN9IFRvTWFya2Rvd25FeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nKS5IYW5kbGV9IFRvTWFya2Rvd25IYW5kbGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nKS5TdGF0ZX0gU3RhdGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nKS5JbmZvfSBJbmZvXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBPcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbdGFibGVDZWxsUGFkZGluZz10cnVlXVxuICogICBXaGV0aGVyIHRvIGFkZCBhIHNwYWNlIG9mIHBhZGRpbmcgYmV0d2VlbiBkZWxpbWl0ZXJzIGFuZCBjZWxscyAoZGVmYXVsdDpcbiAqICAgYHRydWVgKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFt0YWJsZVBpcGVBbGlnbj10cnVlXVxuICogICBXaGV0aGVyIHRvIGFsaWduIHRoZSBkZWxpbWl0ZXJzIChkZWZhdWx0OiBgdHJ1ZWApLlxuICogQHByb3BlcnR5IHtNYXJrZG93blRhYmxlT3B0aW9uc1snc3RyaW5nTGVuZ3RoJ10gfCBudWxsIHwgdW5kZWZpbmVkfSBbc3RyaW5nTGVuZ3RoXVxuICogICBGdW5jdGlvbiB0byBkZXRlY3QgdGhlIGxlbmd0aCBvZiB0YWJsZSBjZWxsIGNvbnRlbnQsIHVzZWQgd2hlbiBhbGlnbmluZ1xuICogICB0aGUgZGVsaW1pdGVycyBiZXR3ZWVuIGNlbGxzIChvcHRpb25hbCkuXG4gKi9cblxuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ2RldmxvcCdcbmltcG9ydCB7bWFya2Rvd25UYWJsZX0gZnJvbSAnbWFya2Rvd24tdGFibGUnXG5pbXBvcnQge2RlZmF1bHRIYW5kbGVyc30gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bidcblxuLyoqXG4gKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duYCB0byBlbmFibGUgR0ZNIHRhYmxlcyBpblxuICogbWFya2Rvd24uXG4gKlxuICogQHJldHVybnMge0Zyb21NYXJrZG93bkV4dGVuc2lvbn1cbiAqICAgRXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duYCB0byBlbmFibGUgR0ZNIHRhYmxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbVRhYmxlRnJvbU1hcmtkb3duKCkge1xuICByZXR1cm4ge1xuICAgIGVudGVyOiB7XG4gICAgICB0YWJsZTogZW50ZXJUYWJsZSxcbiAgICAgIHRhYmxlRGF0YTogZW50ZXJDZWxsLFxuICAgICAgdGFibGVIZWFkZXI6IGVudGVyQ2VsbCxcbiAgICAgIHRhYmxlUm93OiBlbnRlclJvd1xuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgY29kZVRleHQ6IGV4aXRDb2RlVGV4dCxcbiAgICAgIHRhYmxlOiBleGl0VGFibGUsXG4gICAgICB0YWJsZURhdGE6IGV4aXQsXG4gICAgICB0YWJsZUhlYWRlcjogZXhpdCxcbiAgICAgIHRhYmxlUm93OiBleGl0XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZW50ZXJUYWJsZSh0b2tlbikge1xuICBjb25zdCBhbGlnbiA9IHRva2VuLl9hbGlnblxuICBhc3NlcnQoYWxpZ24sICdleHBlY3RlZCBgX2FsaWduYCBvbiB0YWJsZScpXG4gIHRoaXMuZW50ZXIoXG4gICAge1xuICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgIGFsaWduOiBhbGlnbi5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQgPT09ICdub25lJyA/IG51bGwgOiBkXG4gICAgICB9KSxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH0sXG4gICAgdG9rZW5cbiAgKVxuICB0aGlzLmRhdGEuaW5UYWJsZSA9IHRydWVcbn1cblxuLyoqXG4gKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICovXG5mdW5jdGlvbiBleGl0VGFibGUodG9rZW4pIHtcbiAgdGhpcy5leGl0KHRva2VuKVxuICB0aGlzLmRhdGEuaW5UYWJsZSA9IHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gKi9cbmZ1bmN0aW9uIGVudGVyUm93KHRva2VuKSB7XG4gIHRoaXMuZW50ZXIoe3R5cGU6ICd0YWJsZVJvdycsIGNoaWxkcmVuOiBbXX0sIHRva2VuKVxufVxuXG4vKipcbiAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gKi9cbmZ1bmN0aW9uIGV4aXQodG9rZW4pIHtcbiAgdGhpcy5leGl0KHRva2VuKVxufVxuXG4vKipcbiAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gKi9cbmZ1bmN0aW9uIGVudGVyQ2VsbCh0b2tlbikge1xuICB0aGlzLmVudGVyKHt0eXBlOiAndGFibGVDZWxsJywgY2hpbGRyZW46IFtdfSwgdG9rZW4pXG59XG5cbi8vIE92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBjb2RlIHRleHQgZGF0YSBoYW5kbGVyIHRvIHVuZXNjYXBlIGVzY2FwZWQgcGlwZXMgd2hlblxuLy8gdGhleSBhcmUgaW4gdGFibGVzLlxuLyoqXG4gKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICovXG5mdW5jdGlvbiBleGl0Q29kZVRleHQodG9rZW4pIHtcbiAgbGV0IHZhbHVlID0gdGhpcy5yZXN1bWUoKVxuXG4gIGlmICh0aGlzLmRhdGEuaW5UYWJsZSkge1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXChbXFxcXHxdKS9nLCByZXBsYWNlKVxuICB9XG5cbiAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICBhc3NlcnQobm9kZS50eXBlID09PSAnaW5saW5lQ29kZScpXG4gIG5vZGUudmFsdWUgPSB2YWx1ZVxuICB0aGlzLmV4aXQodG9rZW4pXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9ICQwXG4gKiBAcGFyYW0ge3N0cmluZ30gJDFcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2UoJDAsICQxKSB7XG4gIC8vIFBpcGVzIHdvcmssIGJhY2tzbGFzaGVzIGRvbuKAmXQgKGJ1dCBjYW7igJl0IGVzY2FwZSBwaXBlcykuXG4gIHJldHVybiAkMSA9PT0gJ3wnID8gJDEgOiAkMFxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBleHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLXRvLW1hcmtkb3duYCB0byBlbmFibGUgR0ZNIHRhYmxlcyBpblxuICogbWFya2Rvd24uXG4gKlxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcmV0dXJucyB7VG9NYXJrZG93bkV4dGVuc2lvbn1cbiAqICAgRXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC10by1tYXJrZG93bmAgdG8gZW5hYmxlIEdGTSB0YWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZm1UYWJsZVRvTWFya2Rvd24ob3B0aW9ucykge1xuICBjb25zdCBzZXR0aW5ncyA9IG9wdGlvbnMgfHwge31cbiAgY29uc3QgcGFkZGluZyA9IHNldHRpbmdzLnRhYmxlQ2VsbFBhZGRpbmdcbiAgY29uc3QgYWxpZ25EZWxpbWl0ZXJzID0gc2V0dGluZ3MudGFibGVQaXBlQWxpZ25cbiAgY29uc3Qgc3RyaW5nTGVuZ3RoID0gc2V0dGluZ3Muc3RyaW5nTGVuZ3RoXG4gIGNvbnN0IGFyb3VuZCA9IHBhZGRpbmcgPyAnICcgOiAnfCdcblxuICByZXR1cm4ge1xuICAgIHVuc2FmZTogW1xuICAgICAge2NoYXJhY3RlcjogJ1xccicsIGluQ29uc3RydWN0OiAndGFibGVDZWxsJ30sXG4gICAgICB7Y2hhcmFjdGVyOiAnXFxuJywgaW5Db25zdHJ1Y3Q6ICd0YWJsZUNlbGwnfSxcbiAgICAgIC8vIEEgcGlwZSwgd2hlbiBmb2xsb3dlZCBieSBhIHRhYiBvciBzcGFjZSAocGFkZGluZyksIG9yIGEgZGFzaCBvciBjb2xvblxuICAgICAgLy8gKHVucGFkZGVkIGRlbGltaXRlciByb3cpLCBjb3VsZCByZXN1bHQgaW4gYSB0YWJsZS5cbiAgICAgIHthdEJyZWFrOiB0cnVlLCBjaGFyYWN0ZXI6ICd8JywgYWZ0ZXI6ICdbXFx0IDotXSd9LFxuICAgICAgLy8gQSBwaXBlIGluIGEgY2VsbCBtdXN0IGJlIGVuY29kZWQuXG4gICAgICB7Y2hhcmFjdGVyOiAnfCcsIGluQ29uc3RydWN0OiAndGFibGVDZWxsJ30sXG4gICAgICAvLyBBIGNvbG9uIG11c3QgYmUgZm9sbG93ZWQgYnkgYSBkYXNoLCBpbiB3aGljaCBjYXNlIGl0IGNvdWxkIHN0YXJ0IGFcbiAgICAgIC8vIGRlbGltaXRlciByb3cuXG4gICAgICB7YXRCcmVhazogdHJ1ZSwgY2hhcmFjdGVyOiAnOicsIGFmdGVyOiAnLSd9LFxuICAgICAgLy8gQSBkZWxpbWl0ZXIgcm93IGNhbiBhbHNvIHN0YXJ0IHdpdGggYSBkYXNoLCB3aGVuIGZvbGxvd2VkIGJ5IG1vcmVcbiAgICAgIC8vIGRhc2hlcywgYSBjb2xvbiwgb3IgYSBwaXBlLlxuICAgICAgLy8gVGhpcyBpcyBhIHN0cmljdGVyIHZlcnNpb24gdGhhbiB0aGUgYnVpbHQgaW4gY2hlY2sgZm9yIGxpc3RzLCB0aGVtYXRpY1xuICAgICAgLy8gYnJlYWtzLCBhbmQgc2V0ZXggaGVhZGluZyB1bmRlcmxpbmVzIHRob3VnaDpcbiAgICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vc3ludGF4LXRyZWUvbWRhc3QtdXRpbC10by1tYXJrZG93bi9ibG9iLzUxYTIwMzgvbGliL3Vuc2FmZS5qcyNMNTc+XG4gICAgICB7YXRCcmVhazogdHJ1ZSwgY2hhcmFjdGVyOiAnLScsIGFmdGVyOiAnWzp8LV0nfVxuICAgIF0sXG4gICAgaGFuZGxlcnM6IHtcbiAgICAgIGlubGluZUNvZGU6IGlubGluZUNvZGVXaXRoVGFibGUsXG4gICAgICB0YWJsZTogaGFuZGxlVGFibGUsXG4gICAgICB0YWJsZUNlbGw6IGhhbmRsZVRhYmxlQ2VsbCxcbiAgICAgIHRhYmxlUm93OiBoYW5kbGVUYWJsZVJvd1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAgICogQHBhcmFtIHtUYWJsZX0gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlVGFibGUobm9kZSwgXywgc3RhdGUsIGluZm8pIHtcbiAgICByZXR1cm4gc2VyaWFsaXplRGF0YShoYW5kbGVUYWJsZUFzRGF0YShub2RlLCBzdGF0ZSwgaW5mbyksIG5vZGUuYWxpZ24pXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpc27igJl0IHJlYWxseSB1c2VkIG5vcm1hbGx5LCBiZWNhdXNlIHdlIGhhbmRsZSByb3dzIGF0IHRoZVxuICAgKiB0YWJsZSBsZXZlbC5cbiAgICogQnV0LCBpZiBzb21lb25lIHBhc3NlcyBpbiBhIHRhYmxlIHJvdywgdGhpcyBlbnN1cmVzIHdlIG1ha2Ugc29tZXdoYXQgc2Vuc2UuXG4gICAqXG4gICAqIEB0eXBlIHtUb01hcmtkb3duSGFuZGxlfVxuICAgKiBAcGFyYW0ge1RhYmxlUm93fSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVUYWJsZVJvdyhub2RlLCBfLCBzdGF0ZSwgaW5mbykge1xuICAgIGNvbnN0IHJvdyA9IGhhbmRsZVRhYmxlUm93QXNEYXRhKG5vZGUsIHN0YXRlLCBpbmZvKVxuICAgIGNvbnN0IHZhbHVlID0gc2VyaWFsaXplRGF0YShbcm93XSlcbiAgICAvLyBgbWFya2Rvd24tdGFibGVgIHdpbGwgYWx3YXlzIGFkZCBhbiBhbGlnbiByb3dcbiAgICByZXR1cm4gdmFsdWUuc2xpY2UoMCwgdmFsdWUuaW5kZXhPZignXFxuJykpXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9XG4gICAqIEBwYXJhbSB7VGFibGVDZWxsfSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVUYWJsZUNlbGwobm9kZSwgXywgc3RhdGUsIGluZm8pIHtcbiAgICBjb25zdCBleGl0ID0gc3RhdGUuZW50ZXIoJ3RhYmxlQ2VsbCcpXG4gICAgY29uc3Qgc3ViZXhpdCA9IHN0YXRlLmVudGVyKCdwaHJhc2luZycpXG4gICAgY29uc3QgdmFsdWUgPSBzdGF0ZS5jb250YWluZXJQaHJhc2luZyhub2RlLCB7XG4gICAgICAuLi5pbmZvLFxuICAgICAgYmVmb3JlOiBhcm91bmQsXG4gICAgICBhZnRlcjogYXJvdW5kXG4gICAgfSlcbiAgICBzdWJleGl0KClcbiAgICBleGl0KClcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PEFycmF5PHN0cmluZz4+fSBtYXRyaXhcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPiB8IG51bGwgfCB1bmRlZmluZWR9IFthbGlnbl1cbiAgICovXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZURhdGEobWF0cml4LCBhbGlnbikge1xuICAgIHJldHVybiBtYXJrZG93blRhYmxlKG1hdHJpeCwge1xuICAgICAgYWxpZ24sXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBgbWFya2Rvd24tdGFibGVgIHR5cGVzIHNob3VsZCBzdXBwb3J0IGBudWxsYC5cbiAgICAgIGFsaWduRGVsaW1pdGVycyxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBtYXJrZG93bi10YWJsZWAgdHlwZXMgc2hvdWxkIHN1cHBvcnQgYG51bGxgLlxuICAgICAgcGFkZGluZyxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBtYXJrZG93bi10YWJsZWAgdHlwZXMgc2hvdWxkIHN1cHBvcnQgYG51bGxgLlxuICAgICAgc3RyaW5nTGVuZ3RoXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RhYmxlfSBub2RlXG4gICAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gICAqIEBwYXJhbSB7SW5mb30gaW5mb1xuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlVGFibGVBc0RhdGEobm9kZSwgc3RhdGUsIGluZm8pIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW5cbiAgICBsZXQgaW5kZXggPSAtMVxuICAgIC8qKiBAdHlwZSB7QXJyYXk8QXJyYXk8c3RyaW5nPj59ICovXG4gICAgY29uc3QgcmVzdWx0ID0gW11cbiAgICBjb25zdCBzdWJleGl0ID0gc3RhdGUuZW50ZXIoJ3RhYmxlJylcblxuICAgIHdoaWxlICgrK2luZGV4IDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaGFuZGxlVGFibGVSb3dBc0RhdGEoY2hpbGRyZW5baW5kZXhdLCBzdGF0ZSwgaW5mbylcbiAgICB9XG5cbiAgICBzdWJleGl0KClcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RhYmxlUm93fSBub2RlXG4gICAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gICAqIEBwYXJhbSB7SW5mb30gaW5mb1xuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlVGFibGVSb3dBc0RhdGEobm9kZSwgc3RhdGUsIGluZm8pIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW5cbiAgICBsZXQgaW5kZXggPSAtMVxuICAgIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgICBjb25zdCByZXN1bHQgPSBbXVxuICAgIGNvbnN0IHN1YmV4aXQgPSBzdGF0ZS5lbnRlcigndGFibGVSb3cnKVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIE5vdGU6IHRoZSBwb3NpdGlvbmFsIGluZm8gYXMgdXNlZCBoZXJlIGlzIGluY29ycmVjdC5cbiAgICAgIC8vIE1ha2luZyBpdCBjb3JyZWN0IHdvdWxkIGJlIGltcG9zc2libGUgZHVlIHRvIGFsaWduaW5nIGNlbGxzP1xuICAgICAgLy8gQW5kIGl0IHdvdWxkIG5lZWQgY29weS9wYXN0aW5nIGBtYXJrZG93bi10YWJsZWAgaW50byB0aGlzIHByb2plY3QuXG4gICAgICByZXN1bHRbaW5kZXhdID0gaGFuZGxlVGFibGVDZWxsKGNoaWxkcmVuW2luZGV4XSwgbm9kZSwgc3RhdGUsIGluZm8pXG4gICAgfVxuXG4gICAgc3ViZXhpdCgpXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9XG4gICAqIEBwYXJhbSB7SW5saW5lQ29kZX0gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gaW5saW5lQ29kZVdpdGhUYWJsZShub2RlLCBwYXJlbnQsIHN0YXRlKSB7XG4gICAgbGV0IHZhbHVlID0gZGVmYXVsdEhhbmRsZXJzLmlubGluZUNvZGUobm9kZSwgcGFyZW50LCBzdGF0ZSlcblxuICAgIGlmIChzdGF0ZS5zdGFjay5pbmNsdWRlcygndGFibGVDZWxsJykpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFx8L2csICdcXFxcJCYnKVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-gfm-table/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-gfm-task-list-item/lib/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mdast-util-gfm-task-list-item/lib/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTaskListItemFromMarkdown: () => (/* binding */ gfmTaskListItemFromMarkdown),\n/* harmony export */   gfmTaskListItemToMarkdown: () => (/* binding */ gfmTaskListItemToMarkdown)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devlop */ \"(app-pages-browser)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var mdast_util_to_markdown__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mdast-util-to-markdown */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/index.js\");\n/**\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\n\n\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM task\n * list items in markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM task list items.\n */\nfunction gfmTaskListItemFromMarkdown() {\n  return {\n    exit: {\n      taskListCheckValueChecked: exitCheck,\n      taskListCheckValueUnchecked: exitCheck,\n      paragraph: exitParagraphWithTaskListItem\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM task list\n * items in markdown.\n *\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM task list items.\n */\nfunction gfmTaskListItemToMarkdown() {\n  return {\n    unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],\n    handlers: {listItem: listItemWithTaskListItem}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitCheck(token) {\n  // Were always in a paragraph, in a list item.\n  const node = this.stack[this.stack.length - 2]\n  ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'listItem')\n  node.checked = token.type === 'taskListCheckValueChecked'\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = this.stack[this.stack.length - 2]\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean'\n  ) {\n    const node = this.stack[this.stack.length - 1]\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'paragraph')\n    const head = node.children[0]\n\n    if (head && head.type === 'text') {\n      const siblings = parent.children\n      let index = -1\n      /** @type {Paragraph | undefined} */\n      let firstParaghraph\n\n      while (++index < siblings.length) {\n        const sibling = siblings[index]\n        if (sibling.type === 'paragraph') {\n          firstParaghraph = sibling\n          break\n        }\n      }\n\n      if (firstParaghraph === node) {\n        // Must start with a space or a tab.\n        head.value = head.value.slice(1)\n\n        if (head.value.length === 0) {\n          node.children.shift()\n        } else if (\n          node.position &&\n          head.position &&\n          typeof head.position.start.offset === 'number'\n        ) {\n          head.position.start.column++\n          head.position.start.offset++\n          node.position.start = Object.assign({}, head.position.start)\n        }\n      }\n    }\n  }\n\n  this.exit(token)\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {ListItem} node\n */\nfunction listItemWithTaskListItem(node, parent, state, info) {\n  const head = node.children[0]\n  const checkable =\n    typeof node.checked === 'boolean' && head && head.type === 'paragraph'\n  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] '\n  const tracker = state.createTracker(info)\n\n  if (checkable) {\n    tracker.move(checkbox)\n  }\n\n  let value = mdast_util_to_markdown__WEBPACK_IMPORTED_MODULE_1__.handle.listItem(node, parent, state, {\n    ...info,\n    ...tracker.current()\n  })\n\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  /**\n   * @param {string} $0\n   * @returns {string}\n   */\n  function check($0) {\n    return $0 + checkbox\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWdmbS10YXNrLWxpc3QtaXRlbS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkMsYUFBYSwyQkFBMkI7QUFDeEMsYUFBYSxtREFBbUQ7QUFDaEUsYUFBYSw4Q0FBOEM7QUFDM0QsYUFBYSwyQ0FBMkM7QUFDeEQsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSx5Q0FBeUM7QUFDdEQ7O0FBRW1DO0FBQ21COztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0EsY0FBYyw4Q0FBOEM7QUFDNUQsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyQ0FBTTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDJDQUFNO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsMERBQWU7QUFDN0I7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxxREFBcUQsSUFBSTtBQUN6RDs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1nZm0tdGFzay1saXN0LWl0ZW0vbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5MaXN0SXRlbX0gTGlzdEl0ZW1cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0JykuUGFyYWdyYXBofSBQYXJhZ3JhcGhcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkNvbXBpbGVDb250ZXh0fSBDb21waWxlQ29udGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuRXh0ZW5zaW9ufSBGcm9tTWFya2Rvd25FeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkhhbmRsZX0gRnJvbU1hcmtkb3duSGFuZGxlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLXRvLW1hcmtkb3duJykuT3B0aW9uc30gVG9NYXJrZG93bkV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLkhhbmRsZX0gVG9NYXJrZG93bkhhbmRsZVxuICovXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5pbXBvcnQge2RlZmF1bHRIYW5kbGVyc30gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bidcblxuLyoqXG4gKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duYCB0byBlbmFibGUgR0ZNIHRhc2tcbiAqIGxpc3QgaXRlbXMgaW4gbWFya2Rvd24uXG4gKlxuICogQHJldHVybnMge0Zyb21NYXJrZG93bkV4dGVuc2lvbn1cbiAqICAgRXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duYCB0byBlbmFibGUgR0ZNIHRhc2sgbGlzdCBpdGVtcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbVRhc2tMaXN0SXRlbUZyb21NYXJrZG93bigpIHtcbiAgcmV0dXJuIHtcbiAgICBleGl0OiB7XG4gICAgICB0YXNrTGlzdENoZWNrVmFsdWVDaGVja2VkOiBleGl0Q2hlY2ssXG4gICAgICB0YXNrTGlzdENoZWNrVmFsdWVVbmNoZWNrZWQ6IGV4aXRDaGVjayxcbiAgICAgIHBhcmFncmFwaDogZXhpdFBhcmFncmFwaFdpdGhUYXNrTGlzdEl0ZW1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC10by1tYXJrZG93bmAgdG8gZW5hYmxlIEdGTSB0YXNrIGxpc3RcbiAqIGl0ZW1zIGluIG1hcmtkb3duLlxuICpcbiAqIEByZXR1cm5zIHtUb01hcmtkb3duRXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLXRvLW1hcmtkb3duYCB0byBlbmFibGUgR0ZNIHRhc2sgbGlzdCBpdGVtcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbVRhc2tMaXN0SXRlbVRvTWFya2Rvd24oKSB7XG4gIHJldHVybiB7XG4gICAgdW5zYWZlOiBbe2F0QnJlYWs6IHRydWUsIGNoYXJhY3RlcjogJy0nLCBhZnRlcjogJ1s6fC1dJ31dLFxuICAgIGhhbmRsZXJzOiB7bGlzdEl0ZW06IGxpc3RJdGVtV2l0aFRhc2tMaXN0SXRlbX1cbiAgfVxufVxuXG4vKipcbiAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gKi9cbmZ1bmN0aW9uIGV4aXRDaGVjayh0b2tlbikge1xuICAvLyBXZeKAmXJlIGFsd2F5cyBpbiBhIHBhcmFncmFwaCwgaW4gYSBsaXN0IGl0ZW0uXG4gIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl1cbiAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2xpc3RJdGVtJylcbiAgbm9kZS5jaGVja2VkID0gdG9rZW4udHlwZSA9PT0gJ3Rhc2tMaXN0Q2hlY2tWYWx1ZUNoZWNrZWQnXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZXhpdFBhcmFncmFwaFdpdGhUYXNrTGlzdEl0ZW0odG9rZW4pIHtcbiAgY29uc3QgcGFyZW50ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdXG5cbiAgaWYgKFxuICAgIHBhcmVudCAmJlxuICAgIHBhcmVudC50eXBlID09PSAnbGlzdEl0ZW0nICYmXG4gICAgdHlwZW9mIHBhcmVudC5jaGVja2VkID09PSAnYm9vbGVhbidcbiAgKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdwYXJhZ3JhcGgnKVxuICAgIGNvbnN0IGhlYWQgPSBub2RlLmNoaWxkcmVuWzBdXG5cbiAgICBpZiAoaGVhZCAmJiBoZWFkLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgY29uc3Qgc2libGluZ3MgPSBwYXJlbnQuY2hpbGRyZW5cbiAgICAgIGxldCBpbmRleCA9IC0xXG4gICAgICAvKiogQHR5cGUge1BhcmFncmFwaCB8IHVuZGVmaW5lZH0gKi9cbiAgICAgIGxldCBmaXJzdFBhcmFnaHJhcGhcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBzaWJsaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgc2libGluZyA9IHNpYmxpbmdzW2luZGV4XVxuICAgICAgICBpZiAoc2libGluZy50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgIGZpcnN0UGFyYWdocmFwaCA9IHNpYmxpbmdcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdFBhcmFnaHJhcGggPT09IG5vZGUpIHtcbiAgICAgICAgLy8gTXVzdCBzdGFydCB3aXRoIGEgc3BhY2Ugb3IgYSB0YWIuXG4gICAgICAgIGhlYWQudmFsdWUgPSBoZWFkLnZhbHVlLnNsaWNlKDEpXG5cbiAgICAgICAgaWYgKGhlYWQudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi5zaGlmdCgpXG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgbm9kZS5wb3NpdGlvbiAmJlxuICAgICAgICAgIGhlYWQucG9zaXRpb24gJiZcbiAgICAgICAgICB0eXBlb2YgaGVhZC5wb3NpdGlvbi5zdGFydC5vZmZzZXQgPT09ICdudW1iZXInXG4gICAgICAgICkge1xuICAgICAgICAgIGhlYWQucG9zaXRpb24uc3RhcnQuY29sdW1uKytcbiAgICAgICAgICBoZWFkLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCsrXG4gICAgICAgICAgbm9kZS5wb3NpdGlvbi5zdGFydCA9IE9iamVjdC5hc3NpZ24oe30sIGhlYWQucG9zaXRpb24uc3RhcnQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmV4aXQodG9rZW4pXG59XG5cbi8qKlxuICogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9XG4gKiBAcGFyYW0ge0xpc3RJdGVtfSBub2RlXG4gKi9cbmZ1bmN0aW9uIGxpc3RJdGVtV2l0aFRhc2tMaXN0SXRlbShub2RlLCBwYXJlbnQsIHN0YXRlLCBpbmZvKSB7XG4gIGNvbnN0IGhlYWQgPSBub2RlLmNoaWxkcmVuWzBdXG4gIGNvbnN0IGNoZWNrYWJsZSA9XG4gICAgdHlwZW9mIG5vZGUuY2hlY2tlZCA9PT0gJ2Jvb2xlYW4nICYmIGhlYWQgJiYgaGVhZC50eXBlID09PSAncGFyYWdyYXBoJ1xuICBjb25zdCBjaGVja2JveCA9ICdbJyArIChub2RlLmNoZWNrZWQgPyAneCcgOiAnICcpICsgJ10gJ1xuICBjb25zdCB0cmFja2VyID0gc3RhdGUuY3JlYXRlVHJhY2tlcihpbmZvKVxuXG4gIGlmIChjaGVja2FibGUpIHtcbiAgICB0cmFja2VyLm1vdmUoY2hlY2tib3gpXG4gIH1cblxuICBsZXQgdmFsdWUgPSBkZWZhdWx0SGFuZGxlcnMubGlzdEl0ZW0obm9kZSwgcGFyZW50LCBzdGF0ZSwge1xuICAgIC4uLmluZm8sXG4gICAgLi4udHJhY2tlci5jdXJyZW50KClcbiAgfSlcblxuICBpZiAoY2hlY2thYmxlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eKD86WyorLV18XFxkK1xcLikoW1xcclxcbl18IHsxLDN9KS8sIGNoZWNrKVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAkMFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gY2hlY2soJDApIHtcbiAgICByZXR1cm4gJDAgKyBjaGVja2JveFxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-gfm-task-list-item/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-gfm/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mdast-util-gfm/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmFromMarkdown: () => (/* binding */ gfmFromMarkdown),\n/* harmony export */   gfmToMarkdown: () => (/* binding */ gfmToMarkdown)\n/* harmony export */ });\n/* harmony import */ var mdast_util_gfm_autolink_literal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mdast-util-gfm-autolink-literal */ \"(app-pages-browser)/./node_modules/mdast-util-gfm-autolink-literal/lib/index.js\");\n/* harmony import */ var mdast_util_gfm_footnote__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mdast-util-gfm-footnote */ \"(app-pages-browser)/./node_modules/mdast-util-gfm-footnote/lib/index.js\");\n/* harmony import */ var mdast_util_gfm_strikethrough__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mdast-util-gfm-strikethrough */ \"(app-pages-browser)/./node_modules/mdast-util-gfm-strikethrough/lib/index.js\");\n/* harmony import */ var mdast_util_gfm_table__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mdast-util-gfm-table */ \"(app-pages-browser)/./node_modules/mdast-util-gfm-table/lib/index.js\");\n/* harmony import */ var mdast_util_gfm_task_list_item__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! mdast-util-gfm-task-list-item */ \"(app-pages-browser)/./node_modules/mdast-util-gfm-task-list-item/lib/index.js\");\n/**\n * @import {Extension as FromMarkdownExtension} from 'mdast-util-from-markdown'\n * @import {Options} from 'mdast-util-gfm'\n * @import {Options as ToMarkdownExtension} from 'mdast-util-to-markdown'\n */\n\n\n\n\n\n\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @returns {Array<FromMarkdownExtension>}\n *   Extension for `mdast-util-from-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nfunction gfmFromMarkdown() {\n  return [\n    (0,mdast_util_gfm_autolink_literal__WEBPACK_IMPORTED_MODULE_0__.gfmAutolinkLiteralFromMarkdown)(),\n    (0,mdast_util_gfm_footnote__WEBPACK_IMPORTED_MODULE_1__.gfmFootnoteFromMarkdown)(),\n    (0,mdast_util_gfm_strikethrough__WEBPACK_IMPORTED_MODULE_2__.gfmStrikethroughFromMarkdown)(),\n    (0,mdast_util_gfm_table__WEBPACK_IMPORTED_MODULE_3__.gfmTableFromMarkdown)(),\n    (0,mdast_util_gfm_task_list_item__WEBPACK_IMPORTED_MODULE_4__.gfmTaskListItemFromMarkdown)()\n  ]\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM (autolink\n * literals, footnotes, strikethrough, tables, tasklists).\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM (autolink literals,\n *   footnotes, strikethrough, tables, tasklists).\n */\nfunction gfmToMarkdown(options) {\n  return {\n    extensions: [\n      (0,mdast_util_gfm_autolink_literal__WEBPACK_IMPORTED_MODULE_0__.gfmAutolinkLiteralToMarkdown)(),\n      (0,mdast_util_gfm_footnote__WEBPACK_IMPORTED_MODULE_1__.gfmFootnoteToMarkdown)(options),\n      (0,mdast_util_gfm_strikethrough__WEBPACK_IMPORTED_MODULE_2__.gfmStrikethroughToMarkdown)(),\n      (0,mdast_util_gfm_table__WEBPACK_IMPORTED_MODULE_3__.gfmTableToMarkdown)(options),\n      (0,mdast_util_gfm_task_list_item__WEBPACK_IMPORTED_MODULE_4__.gfmTaskListItemToMarkdown)()\n    ]\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWdmbS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQsWUFBWSxTQUFTO0FBQ3JCLFlBQVksZ0NBQWdDO0FBQzVDOztBQUt3QztBQUlSO0FBSUs7QUFDd0M7QUFJdkM7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxJQUFJLCtGQUE4QjtBQUNsQyxJQUFJLGdGQUF1QjtBQUMzQixJQUFJLDBGQUE0QjtBQUNoQyxJQUFJLDBFQUFvQjtBQUN4QixJQUFJLDBGQUEyQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsTUFBTSw2RkFBNEI7QUFDbEMsTUFBTSw4RUFBcUI7QUFDM0IsTUFBTSx3RkFBMEI7QUFDaEMsTUFBTSx3RUFBa0I7QUFDeEIsTUFBTSx3RkFBeUI7QUFDL0I7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWdmbS9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtFeHRlbnNpb24gYXMgRnJvbU1hcmtkb3duRXh0ZW5zaW9ufSBmcm9tICdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24nXG4gKiBAaW1wb3J0IHtPcHRpb25zfSBmcm9tICdtZGFzdC11dGlsLWdmbSdcbiAqIEBpbXBvcnQge09wdGlvbnMgYXMgVG9NYXJrZG93bkV4dGVuc2lvbn0gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bidcbiAqL1xuXG5pbXBvcnQge1xuICBnZm1BdXRvbGlua0xpdGVyYWxGcm9tTWFya2Rvd24sXG4gIGdmbUF1dG9saW5rTGl0ZXJhbFRvTWFya2Rvd25cbn0gZnJvbSAnbWRhc3QtdXRpbC1nZm0tYXV0b2xpbmstbGl0ZXJhbCdcbmltcG9ydCB7XG4gIGdmbUZvb3Rub3RlRnJvbU1hcmtkb3duLFxuICBnZm1Gb290bm90ZVRvTWFya2Rvd25cbn0gZnJvbSAnbWRhc3QtdXRpbC1nZm0tZm9vdG5vdGUnXG5pbXBvcnQge1xuICBnZm1TdHJpa2V0aHJvdWdoRnJvbU1hcmtkb3duLFxuICBnZm1TdHJpa2V0aHJvdWdoVG9NYXJrZG93blxufSBmcm9tICdtZGFzdC11dGlsLWdmbS1zdHJpa2V0aHJvdWdoJ1xuaW1wb3J0IHtnZm1UYWJsZUZyb21NYXJrZG93biwgZ2ZtVGFibGVUb01hcmtkb3dufSBmcm9tICdtZGFzdC11dGlsLWdmbS10YWJsZSdcbmltcG9ydCB7XG4gIGdmbVRhc2tMaXN0SXRlbUZyb21NYXJrZG93bixcbiAgZ2ZtVGFza0xpc3RJdGVtVG9NYXJrZG93blxufSBmcm9tICdtZGFzdC11dGlsLWdmbS10YXNrLWxpc3QtaXRlbSdcblxuLyoqXG4gKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duYCB0byBlbmFibGUgR0ZNIChhdXRvbGlua1xuICogbGl0ZXJhbHMsIGZvb3Rub3Rlcywgc3RyaWtldGhyb3VnaCwgdGFibGVzLCB0YXNrbGlzdHMpLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheTxGcm9tTWFya2Rvd25FeHRlbnNpb24+fVxuICogICBFeHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLWZyb20tbWFya2Rvd25gIHRvIGVuYWJsZSBHRk0gKGF1dG9saW5rIGxpdGVyYWxzLFxuICogICBmb290bm90ZXMsIHN0cmlrZXRocm91Z2gsIHRhYmxlcywgdGFza2xpc3RzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbUZyb21NYXJrZG93bigpIHtcbiAgcmV0dXJuIFtcbiAgICBnZm1BdXRvbGlua0xpdGVyYWxGcm9tTWFya2Rvd24oKSxcbiAgICBnZm1Gb290bm90ZUZyb21NYXJrZG93bigpLFxuICAgIGdmbVN0cmlrZXRocm91Z2hGcm9tTWFya2Rvd24oKSxcbiAgICBnZm1UYWJsZUZyb21NYXJrZG93bigpLFxuICAgIGdmbVRhc2tMaXN0SXRlbUZyb21NYXJrZG93bigpXG4gIF1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC10by1tYXJrZG93bmAgdG8gZW5hYmxlIEdGTSAoYXV0b2xpbmtcbiAqIGxpdGVyYWxzLCBmb290bm90ZXMsIHN0cmlrZXRocm91Z2gsIHRhYmxlcywgdGFza2xpc3RzKS5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAqICAgQ29uZmlndXJhdGlvbiAob3B0aW9uYWwpLlxuICogQHJldHVybnMge1RvTWFya2Rvd25FeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1kYXN0LXV0aWwtdG8tbWFya2Rvd25gIHRvIGVuYWJsZSBHRk0gKGF1dG9saW5rIGxpdGVyYWxzLFxuICogICBmb290bm90ZXMsIHN0cmlrZXRocm91Z2gsIHRhYmxlcywgdGFza2xpc3RzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbVRvTWFya2Rvd24ob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGV4dGVuc2lvbnM6IFtcbiAgICAgIGdmbUF1dG9saW5rTGl0ZXJhbFRvTWFya2Rvd24oKSxcbiAgICAgIGdmbUZvb3Rub3RlVG9NYXJrZG93bihvcHRpb25zKSxcbiAgICAgIGdmbVN0cmlrZXRocm91Z2hUb01hcmtkb3duKCksXG4gICAgICBnZm1UYWJsZVRvTWFya2Rvd24ob3B0aW9ucyksXG4gICAgICBnZm1UYXNrTGlzdEl0ZW1Ub01hcmtkb3duKClcbiAgICBdXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-gfm/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-math/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mdast-util-math/lib/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mathFromMarkdown: () => (/* binding */ mathFromMarkdown),\n/* harmony export */   mathToMarkdown: () => (/* binding */ mathToMarkdown)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devlop */ \"(app-pages-browser)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var longest_streak__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! longest-streak */ \"(app-pages-browser)/./node_modules/longest-streak/index.js\");\n/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('../index.js').InlineMath} InlineMath\n * @typedef {import('../index.js').Math} Math\n *\n * @typedef ToOptions\n *   Configuration.\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (default: `true`).\n *\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with normal dollars in text.\n *   If you turn this off, you can still use two or more dollars for text math.\n */\n\n\n\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nfunction mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlow(token) {\n    /** @type {HastElement} */\n    const code = {\n      type: 'element',\n      tagName: 'code',\n      properties: {className: ['language-math', 'math-display']},\n      children: []\n    }\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {hName: 'pre', hChildren: [code]}\n      },\n      token\n    )\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'math')\n    node.meta = data\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.data.mathFlowInside) return\n    this.buffer()\n    this.data.mathFlowInside = true\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = this.stack[this.stack.length - 1]\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'math')\n    this.exit(token)\n    node.value = data\n    // @ts-expect-error: we defined it in `enterMathFlow`.\n    const code = /** @type {HastElement} */ (node.data.hChildren[0])\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(code.type === 'element')\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(code.tagName === 'code')\n    code.children.push({type: 'text', value: data})\n    this.data.mathFlowInside = undefined\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'code',\n          hProperties: {className: ['language-math', 'math-inline']},\n          hChildren: []\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = this.stack[this.stack.length - 1]\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === 'inlineMath')\n    this.exit(token)\n    node.value = data\n    const children = /** @type {Array<HastElementContent>} */ (\n      // @ts-expect-error: we defined it in `enterMathFlow`.\n      node.data.hChildren\n    )\n    children.push({type: 'text', value: data})\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {ToOptions | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nfunction mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\n      {\n        character: '$',\n        after: single ? undefined : '\\\\$',\n        inConstruct: 'phrasing'\n      },\n      {character: '$', inConstruct: 'mathFlowMeta'},\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  // Note: fixing this code? Please also fix the similar code for code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\n  function math(node, _, state, info) {\n    const raw = node.value || ''\n    const tracker = state.createTracker(info)\n    const sequence = '$'.repeat(Math.max((0,longest_streak__WEBPACK_IMPORTED_MODULE_1__.longestStreak)(raw, '$') + 1, 2))\n    const exit = state.enter('mathFlow')\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = state.enter('mathFlowMeta')\n      value += tracker.move(\n        state.safe(node.meta, {\n          after: '\\n',\n          before: value,\n          encode: ['$'],\n          ...tracker.current()\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  // Note: fixing this code? Please also fix the similar code for inline code:\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\n  function inlineMath(node, _, state) {\n    let value = node.value || ''\n    let size = 1\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    const sequence = '$'.repeat(size)\n\n    // If this is not just spaces or eols (tabs dont count), and either the\n    // first and last character are a space or eol, or the first or last\n    // character are dollar signs, then pad with spaces.\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) &&\n      // Starts with space and ends with space.\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\n        // Starts or ends with dollar.\n        /^\\$|\\$$/.test(value))\n    ) {\n      value = ' ' + value + ' '\n    }\n\n    let index = -1\n\n    // We have a potential problem: certain characters after eols could result in\n    // blocks being seen.\n    // For example, if someone injected the string `'\\n# b'`, then that would\n    // result in an ATX heading.\n    // We cant escape characters in `inlineMath`, but because eols are\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\n    // them out.\n    while (++index < state.unsafe.length) {\n      const pattern = state.unsafe[index]\n\n      // Only look for `atBreak`s.\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\n      // CR.\n      if (!pattern.atBreak) continue\n\n      const expression = state.compilePattern(pattern)\n      /** @type {RegExpExecArray | null} */\n      let match\n\n      while ((match = expression.exec(value))) {\n        let position = match.index\n\n        // Support CRLF (patterns only look for one of the characters).\n        if (\n          value.codePointAt(position) === 10 /* `\\n` */ &&\n          value.codePointAt(position - 1) === 13 /* `\\r` */\n        ) {\n          position--\n        }\n\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n      }\n    }\n\n    return sequence + value + sequence\n  }\n\n  /**\n   * @returns {string}\n   */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLW1hdGgvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsK0JBQStCO0FBQzVDLGFBQWEsbURBQW1EO0FBQ2hFLGFBQWEsOENBQThDO0FBQzNELGFBQWEsMkNBQTJDO0FBQ3hELGFBQWEseUNBQXlDO0FBQ3RELGFBQWEsMENBQTBDO0FBQ3ZELGFBQWEsa0NBQWtDO0FBQy9DLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUM7QUFDUzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2Q0FBNkM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwyQ0FBTTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMkNBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QyxJQUFJLDJDQUFNO0FBQ1YsSUFBSSwyQ0FBTTtBQUNWLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0Q0FBNEM7QUFDcEU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDJDQUFNO0FBQ1Y7QUFDQTtBQUNBLGdDQUFnQywyQkFBMkI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3Qzs7QUFFQTtBQUNBLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQThCO0FBQ3pDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLDZDQUE2QztBQUNwRCxPQUFPLDZDQUE2QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxPQUFPLDRDQUE0QztBQUNuRCxPQUFPO0FBQ1A7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQSxZQUFZO0FBQ1osYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw2REFBYTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtbWF0aC9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuRWxlbWVudH0gSGFzdEVsZW1lbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5FbGVtZW50Q29udGVudH0gSGFzdEVsZW1lbnRDb250ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24nKS5Db21waWxlQ29udGV4dH0gQ29tcGlsZUNvbnRleHRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtZnJvbS1tYXJrZG93bicpLkV4dGVuc2lvbn0gRnJvbU1hcmtkb3duRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24nKS5IYW5kbGV9IEZyb21NYXJrZG93bkhhbmRsZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLkhhbmRsZX0gVG9NYXJrZG93bkhhbmRsZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLk9wdGlvbnN9IFRvTWFya2Rvd25FeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL2luZGV4LmpzJykuSW5saW5lTWF0aH0gSW5saW5lTWF0aFxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vaW5kZXguanMnKS5NYXRofSBNYXRoXG4gKlxuICogQHR5cGVkZWYgVG9PcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbc2luZ2xlRG9sbGFyVGV4dE1hdGg9dHJ1ZV1cbiAqICAgV2hldGhlciB0byBzdXBwb3J0IG1hdGggKHRleHQpIHdpdGggYSBzaW5nbGUgZG9sbGFyIChkZWZhdWx0OiBgdHJ1ZWApLlxuICpcbiAqICAgU2luZ2xlIGRvbGxhcnMgd29yayBpbiBQYW5kb2MgYW5kIG1hbnkgb3RoZXIgcGxhY2VzLCBidXQgb2Z0ZW4gaW50ZXJmZXJlXG4gKiAgIHdpdGgg4oCcbm9ybWFs4oCdIGRvbGxhcnMgaW4gdGV4dC5cbiAqICAgSWYgeW91IHR1cm4gdGhpcyBvZmYsIHlvdSBjYW4gc3RpbGwgdXNlIHR3byBvciBtb3JlIGRvbGxhcnMgZm9yIHRleHQgbWF0aC5cbiAqL1xuXG5pbXBvcnQge29rIGFzIGFzc2VydH0gZnJvbSAnZGV2bG9wJ1xuaW1wb3J0IHtsb25nZXN0U3RyZWFrfSBmcm9tICdsb25nZXN0LXN0cmVhaydcblxuLyoqXG4gKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duYC5cbiAqXG4gKiBAcmV0dXJucyB7RnJvbU1hcmtkb3duRXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLWZyb20tbWFya2Rvd25gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0aEZyb21NYXJrZG93bigpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlcjoge1xuICAgICAgbWF0aEZsb3c6IGVudGVyTWF0aEZsb3csXG4gICAgICBtYXRoRmxvd0ZlbmNlTWV0YTogZW50ZXJNYXRoRmxvd01ldGEsXG4gICAgICBtYXRoVGV4dDogZW50ZXJNYXRoVGV4dFxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgbWF0aEZsb3c6IGV4aXRNYXRoRmxvdyxcbiAgICAgIG1hdGhGbG93RmVuY2U6IGV4aXRNYXRoRmxvd0ZlbmNlLFxuICAgICAgbWF0aEZsb3dGZW5jZU1ldGE6IGV4aXRNYXRoRmxvd01ldGEsXG4gICAgICBtYXRoRmxvd1ZhbHVlOiBleGl0TWF0aERhdGEsXG4gICAgICBtYXRoVGV4dDogZXhpdE1hdGhUZXh0LFxuICAgICAgbWF0aFRleHREYXRhOiBleGl0TWF0aERhdGFcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZW50ZXJNYXRoRmxvdyh0b2tlbikge1xuICAgIC8qKiBAdHlwZSB7SGFzdEVsZW1lbnR9ICovXG4gICAgY29uc3QgY29kZSA9IHtcbiAgICAgIHR5cGU6ICdlbGVtZW50JyxcbiAgICAgIHRhZ05hbWU6ICdjb2RlJyxcbiAgICAgIHByb3BlcnRpZXM6IHtjbGFzc05hbWU6IFsnbGFuZ3VhZ2UtbWF0aCcsICdtYXRoLWRpc3BsYXknXX0sXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9XG4gICAgdGhpcy5lbnRlcihcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ21hdGgnLFxuICAgICAgICBtZXRhOiBudWxsLFxuICAgICAgICB2YWx1ZTogJycsXG4gICAgICAgIGRhdGE6IHtoTmFtZTogJ3ByZScsIGhDaGlsZHJlbjogW2NvZGVdfVxuICAgICAgfSxcbiAgICAgIHRva2VuXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGVudGVyTWF0aEZsb3dNZXRhKCkge1xuICAgIHRoaXMuYnVmZmVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gICAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gICAqL1xuICBmdW5jdGlvbiBleGl0TWF0aEZsb3dNZXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc3VtZSgpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdtYXRoJylcbiAgICBub2RlLm1ldGEgPSBkYXRhXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1hdGhGbG93RmVuY2UoKSB7XG4gICAgLy8gRXhpdCBpZiB0aGlzIGlzIHRoZSBjbG9zaW5nIGZlbmNlLlxuICAgIGlmICh0aGlzLmRhdGEubWF0aEZsb3dJbnNpZGUpIHJldHVyblxuICAgIHRoaXMuYnVmZmVyKClcbiAgICB0aGlzLmRhdGEubWF0aEZsb3dJbnNpZGUgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1hdGhGbG93KHRva2VuKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKCkucmVwbGFjZSgvXihcXHI/XFxufFxccil8KFxccj9cXG58XFxyKSQvZywgJycpXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICAgIGFzc2VydChub2RlLnR5cGUgPT09ICdtYXRoJylcbiAgICB0aGlzLmV4aXQodG9rZW4pXG4gICAgbm9kZS52YWx1ZSA9IGRhdGFcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZSBkZWZpbmVkIGl0IGluIGBlbnRlck1hdGhGbG93YC5cbiAgICBjb25zdCBjb2RlID0gLyoqIEB0eXBlIHtIYXN0RWxlbWVudH0gKi8gKG5vZGUuZGF0YS5oQ2hpbGRyZW5bMF0pXG4gICAgYXNzZXJ0KGNvZGUudHlwZSA9PT0gJ2VsZW1lbnQnKVxuICAgIGFzc2VydChjb2RlLnRhZ05hbWUgPT09ICdjb2RlJylcbiAgICBjb2RlLmNoaWxkcmVuLnB1c2goe3R5cGU6ICd0ZXh0JywgdmFsdWU6IGRhdGF9KVxuICAgIHRoaXMuZGF0YS5tYXRoRmxvd0luc2lkZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAgICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIGVudGVyTWF0aFRleHQodG9rZW4pIHtcbiAgICB0aGlzLmVudGVyKFxuICAgICAge1xuICAgICAgICB0eXBlOiAnaW5saW5lTWF0aCcsXG4gICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGhOYW1lOiAnY29kZScsXG4gICAgICAgICAgaFByb3BlcnRpZXM6IHtjbGFzc05hbWU6IFsnbGFuZ3VhZ2UtbWF0aCcsICdtYXRoLWlubGluZSddfSxcbiAgICAgICAgICBoQ2hpbGRyZW46IFtdXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2tlblxuICAgIClcbiAgICB0aGlzLmJ1ZmZlcigpXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1hdGhUZXh0KHRva2VuKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzdW1lKClcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gICAgYXNzZXJ0KG5vZGUudHlwZSA9PT0gJ2lubGluZU1hdGgnKVxuICAgIHRoaXMuZXhpdCh0b2tlbilcbiAgICBub2RlLnZhbHVlID0gZGF0YVxuICAgIGNvbnN0IGNoaWxkcmVuID0gLyoqIEB0eXBlIHtBcnJheTxIYXN0RWxlbWVudENvbnRlbnQ+fSAqLyAoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZSBkZWZpbmVkIGl0IGluIGBlbnRlck1hdGhGbG93YC5cbiAgICAgIG5vZGUuZGF0YS5oQ2hpbGRyZW5cbiAgICApXG4gICAgY2hpbGRyZW4ucHVzaCh7dHlwZTogJ3RleHQnLCB2YWx1ZTogZGF0YX0pXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICAgKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICAgKi9cbiAgZnVuY3Rpb24gZXhpdE1hdGhEYXRhKHRva2VuKSB7XG4gICAgdGhpcy5jb25maWcuZW50ZXIuZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICAgIHRoaXMuY29uZmlnLmV4aXQuZGF0YS5jYWxsKHRoaXMsIHRva2VuKVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBmb3IgYG1kYXN0LXV0aWwtdG8tbWFya2Rvd25gLlxuICpcbiAqIEBwYXJhbSB7VG9PcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHtUb01hcmtkb3duRXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLXRvLW1hcmtkb3duYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGhUb01hcmtkb3duKG9wdGlvbnMpIHtcbiAgbGV0IHNpbmdsZSA9IChvcHRpb25zIHx8IHt9KS5zaW5nbGVEb2xsYXJUZXh0TWF0aFxuXG4gIGlmIChzaW5nbGUgPT09IG51bGwgfHwgc2luZ2xlID09PSB1bmRlZmluZWQpIHtcbiAgICBzaW5nbGUgPSB0cnVlXG4gIH1cblxuICBpbmxpbmVNYXRoLnBlZWsgPSBpbmxpbmVNYXRoUGVla1xuXG4gIHJldHVybiB7XG4gICAgdW5zYWZlOiBbXG4gICAgICB7Y2hhcmFjdGVyOiAnXFxyJywgaW5Db25zdHJ1Y3Q6ICdtYXRoRmxvd01ldGEnfSxcbiAgICAgIHtjaGFyYWN0ZXI6ICdcXG4nLCBpbkNvbnN0cnVjdDogJ21hdGhGbG93TWV0YSd9LFxuICAgICAge1xuICAgICAgICBjaGFyYWN0ZXI6ICckJyxcbiAgICAgICAgYWZ0ZXI6IHNpbmdsZSA/IHVuZGVmaW5lZCA6ICdcXFxcJCcsXG4gICAgICAgIGluQ29uc3RydWN0OiAncGhyYXNpbmcnXG4gICAgICB9LFxuICAgICAge2NoYXJhY3RlcjogJyQnLCBpbkNvbnN0cnVjdDogJ21hdGhGbG93TWV0YSd9LFxuICAgICAge2F0QnJlYWs6IHRydWUsIGNoYXJhY3RlcjogJyQnLCBhZnRlcjogJ1xcXFwkJ31cbiAgICBdLFxuICAgIGhhbmRsZXJzOiB7bWF0aCwgaW5saW5lTWF0aH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAgICogQHBhcmFtIHtNYXRofSBub2RlXG4gICAqL1xuICAvLyBOb3RlOiBmaXhpbmcgdGhpcyBjb2RlPyBQbGVhc2UgYWxzbyBmaXggdGhlIHNpbWlsYXIgY29kZSBmb3IgY29kZTpcbiAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9zeW50YXgtdHJlZS9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2Jsb2IvbWFpbi9saWIvaGFuZGxlL2NvZGUuanM+XG4gIGZ1bmN0aW9uIG1hdGgobm9kZSwgXywgc3RhdGUsIGluZm8pIHtcbiAgICBjb25zdCByYXcgPSBub2RlLnZhbHVlIHx8ICcnXG4gICAgY29uc3QgdHJhY2tlciA9IHN0YXRlLmNyZWF0ZVRyYWNrZXIoaW5mbylcbiAgICBjb25zdCBzZXF1ZW5jZSA9ICckJy5yZXBlYXQoTWF0aC5tYXgobG9uZ2VzdFN0cmVhayhyYXcsICckJykgKyAxLCAyKSlcbiAgICBjb25zdCBleGl0ID0gc3RhdGUuZW50ZXIoJ21hdGhGbG93JylcbiAgICBsZXQgdmFsdWUgPSB0cmFja2VyLm1vdmUoc2VxdWVuY2UpXG5cbiAgICBpZiAobm9kZS5tZXRhKSB7XG4gICAgICBjb25zdCBzdWJleGl0ID0gc3RhdGUuZW50ZXIoJ21hdGhGbG93TWV0YScpXG4gICAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoXG4gICAgICAgIHN0YXRlLnNhZmUobm9kZS5tZXRhLCB7XG4gICAgICAgICAgYWZ0ZXI6ICdcXG4nLFxuICAgICAgICAgIGJlZm9yZTogdmFsdWUsXG4gICAgICAgICAgZW5jb2RlOiBbJyQnXSxcbiAgICAgICAgICAuLi50cmFja2VyLmN1cnJlbnQoKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICAgc3ViZXhpdCgpXG4gICAgfVxuXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKCdcXG4nKVxuXG4gICAgaWYgKHJhdykge1xuICAgICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKHJhdyArICdcXG4nKVxuICAgIH1cblxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShzZXF1ZW5jZSlcbiAgICBleGl0KClcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAgICogQHBhcmFtIHtJbmxpbmVNYXRofSBub2RlXG4gICAqL1xuICAvLyBOb3RlOiBmaXhpbmcgdGhpcyBjb2RlPyBQbGVhc2UgYWxzbyBmaXggdGhlIHNpbWlsYXIgY29kZSBmb3IgaW5saW5lIGNvZGU6XG4gIC8vIDxodHRwczovL2dpdGh1Yi5jb20vc3ludGF4LXRyZWUvbWRhc3QtdXRpbC10by1tYXJrZG93bi9ibG9iL21haW4vbGliL2hhbmRsZS9pbmxpbmUtY29kZS5qcz5cbiAgZnVuY3Rpb24gaW5saW5lTWF0aChub2RlLCBfLCBzdGF0ZSkge1xuICAgIGxldCB2YWx1ZSA9IG5vZGUudmFsdWUgfHwgJydcbiAgICBsZXQgc2l6ZSA9IDFcblxuICAgIGlmICghc2luZ2xlKSBzaXplKytcblxuICAgIC8vIElmIHRoZXJlIGlzIGEgc2luZ2xlIGRvbGxhciBzaWduIG9uIGl0cyBvd24gaW4gdGhlIG1hdGgsIHVzZSBhIGZlbmNlIG9mXG4gICAgLy8gdHdvLlxuICAgIC8vIElmIHRoZXJlIGFyZSB0d28gaW4gYSByb3csIHVzZSBvbmUuXG4gICAgd2hpbGUgKFxuICAgICAgbmV3IFJlZ0V4cCgnKF58W14kXSknICsgJ1xcXFwkJy5yZXBlYXQoc2l6ZSkgKyAnKFteJF18JCknKS50ZXN0KHZhbHVlKVxuICAgICkge1xuICAgICAgc2l6ZSsrXG4gICAgfVxuXG4gICAgY29uc3Qgc2VxdWVuY2UgPSAnJCcucmVwZWF0KHNpemUpXG5cbiAgICAvLyBJZiB0aGlzIGlzIG5vdCBqdXN0IHNwYWNlcyBvciBlb2xzICh0YWJzIGRvbuKAmXQgY291bnQpLCBhbmQgZWl0aGVyIHRoZVxuICAgIC8vIGZpcnN0IGFuZCBsYXN0IGNoYXJhY3RlciBhcmUgYSBzcGFjZSBvciBlb2wsIG9yIHRoZSBmaXJzdCBvciBsYXN0XG4gICAgLy8gY2hhcmFjdGVyIGFyZSBkb2xsYXIgc2lnbnMsIHRoZW4gcGFkIHdpdGggc3BhY2VzLlxuICAgIGlmIChcbiAgICAgIC8vIENvbnRhaW5zIG5vbi1zcGFjZS5cbiAgICAgIC9bXiBcXHJcXG5dLy50ZXN0KHZhbHVlKSAmJlxuICAgICAgLy8gU3RhcnRzIHdpdGggc3BhY2UgYW5kIGVuZHMgd2l0aCBzcGFjZS5cbiAgICAgICgoL15bIFxcclxcbl0vLnRlc3QodmFsdWUpICYmIC9bIFxcclxcbl0kLy50ZXN0KHZhbHVlKSkgfHxcbiAgICAgICAgLy8gU3RhcnRzIG9yIGVuZHMgd2l0aCBkb2xsYXIuXG4gICAgICAgIC9eXFwkfFxcJCQvLnRlc3QodmFsdWUpKVxuICAgICkge1xuICAgICAgdmFsdWUgPSAnICcgKyB2YWx1ZSArICcgJ1xuICAgIH1cblxuICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICAvLyBXZSBoYXZlIGEgcG90ZW50aWFsIHByb2JsZW06IGNlcnRhaW4gY2hhcmFjdGVycyBhZnRlciBlb2xzIGNvdWxkIHJlc3VsdCBpblxuICAgIC8vIGJsb2NrcyBiZWluZyBzZWVuLlxuICAgIC8vIEZvciBleGFtcGxlLCBpZiBzb21lb25lIGluamVjdGVkIHRoZSBzdHJpbmcgYCdcXG4jIGInYCwgdGhlbiB0aGF0IHdvdWxkXG4gICAgLy8gcmVzdWx0IGluIGFuIEFUWCBoZWFkaW5nLlxuICAgIC8vIFdlIGNhbuKAmXQgZXNjYXBlIGNoYXJhY3RlcnMgaW4gYGlubGluZU1hdGhgLCBidXQgYmVjYXVzZSBlb2xzIGFyZVxuICAgIC8vIHRyYW5zZm9ybWVkIHRvIHNwYWNlcyB3aGVuIGdvaW5nIGZyb20gbWFya2Rvd24gdG8gSFRNTCBhbnl3YXksIHdlIGNhbiBzd2FwXG4gICAgLy8gdGhlbSBvdXQuXG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGF0ZS51bnNhZmUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gc3RhdGUudW5zYWZlW2luZGV4XVxuXG4gICAgICAvLyBPbmx5IGxvb2sgZm9yIGBhdEJyZWFrYHMuXG4gICAgICAvLyBCdHc6IG5vdGUgdGhhdCBgYXRCcmVha2AgcGF0dGVybnMgd2lsbCBhbHdheXMgc3RhcnQgdGhlIHJlZ2V4IGF0IExGIG9yXG4gICAgICAvLyBDUi5cbiAgICAgIGlmICghcGF0dGVybi5hdEJyZWFrKSBjb250aW51ZVxuXG4gICAgICBjb25zdCBleHByZXNzaW9uID0gc3RhdGUuY29tcGlsZVBhdHRlcm4ocGF0dGVybilcbiAgICAgIC8qKiBAdHlwZSB7UmVnRXhwRXhlY0FycmF5IHwgbnVsbH0gKi9cbiAgICAgIGxldCBtYXRjaFxuXG4gICAgICB3aGlsZSAoKG1hdGNoID0gZXhwcmVzc2lvbi5leGVjKHZhbHVlKSkpIHtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gbWF0Y2guaW5kZXhcblxuICAgICAgICAvLyBTdXBwb3J0IENSTEYgKHBhdHRlcm5zIG9ubHkgbG9vayBmb3Igb25lIG9mIHRoZSBjaGFyYWN0ZXJzKS5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHZhbHVlLmNvZGVQb2ludEF0KHBvc2l0aW9uKSA9PT0gMTAgLyogYFxcbmAgKi8gJiZcbiAgICAgICAgICB2YWx1ZS5jb2RlUG9pbnRBdChwb3NpdGlvbiAtIDEpID09PSAxMyAvKiBgXFxyYCAqL1xuICAgICAgICApIHtcbiAgICAgICAgICBwb3NpdGlvbi0tXG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIHBvc2l0aW9uKSArICcgJyArIHZhbHVlLnNsaWNlKG1hdGNoLmluZGV4ICsgMSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VxdWVuY2UgKyB2YWx1ZSArIHNlcXVlbmNlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIGlubGluZU1hdGhQZWVrKCkge1xuICAgIHJldHVybiAnJCdcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-math/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-phrasing/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/mdast-util-phrasing/lib/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   phrasing: () => (/* binding */ phrasing)\n/* harmony export */ });\n/* harmony import */ var unist_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-is */ \"(app-pages-browser)/./node_modules/unist-util-is/lib/index.js\");\n/**\n * @typedef {import('mdast').Html} Html\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n */\n\n\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * >  **Note**: Excludes `html`, which can be both phrasing or flow.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\n\nconst phrasing =\n  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */\n  (\n    (0,unist_util_is__WEBPACK_IMPORTED_MODULE_0__.convert)([\n      'break',\n      'delete',\n      'emphasis',\n      // To do: next major: removed since footnotes were added to GFM.\n      'footnote',\n      'footnoteReference',\n      'image',\n      'imageReference',\n      'inlineCode',\n      // Enabled by `mdast-util-math`:\n      'inlineMath',\n      'link',\n      'linkReference',\n      // Enabled by `mdast-util-mdx`:\n      'mdxJsxTextElement',\n      // Enabled by `mdast-util-mdx`:\n      'mdxTextExpression',\n      'strong',\n      'text',\n      // Enabled by `mdast-util-directive`:\n      'textDirective'\n    ])\n  )\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXBocmFzaW5nL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxpQ0FBaUM7QUFDOUM7O0FBRXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLGFBQWEsNERBQTREO0FBQ3pFO0FBQ0EsSUFBSSxzREFBTztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtcGhyYXNpbmcvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5IdG1sfSBIdG1sXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlBocmFzaW5nQ29udGVudH0gUGhyYXNpbmdDb250ZW50XG4gKi9cblxuaW1wb3J0IHtjb252ZXJ0fSBmcm9tICd1bmlzdC11dGlsLWlzJ1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyAqcGhyYXNpbmcgY29udGVudCouXG4gKlxuICogPiDwn5GJICoqTm90ZSoqOiBFeGNsdWRlcyBgaHRtbGAsIHdoaWNoIGNhbiBiZSBib3RoIHBocmFzaW5nIG9yIGZsb3cuXG4gKlxuICogQHBhcmFtIG5vZGVcbiAqICAgVGhpbmcgdG8gY2hlY2ssIHR5cGljYWxseSBgTm9kZWAuXG4gKiBAcmV0dXJuc1xuICogICBXaGV0aGVyIGB2YWx1ZWAgaXMgcGhyYXNpbmcgY29udGVudC5cbiAqL1xuXG5leHBvcnQgY29uc3QgcGhyYXNpbmcgPVxuICAvKiogQHR5cGUgeyhub2RlPzogdW5rbm93bikgPT4gbm9kZSBpcyBFeGNsdWRlPFBocmFzaW5nQ29udGVudCwgSHRtbD59ICovXG4gIChcbiAgICBjb252ZXJ0KFtcbiAgICAgICdicmVhaycsXG4gICAgICAnZGVsZXRlJyxcbiAgICAgICdlbXBoYXNpcycsXG4gICAgICAvLyBUbyBkbzogbmV4dCBtYWpvcjogcmVtb3ZlZCBzaW5jZSBmb290bm90ZXMgd2VyZSBhZGRlZCB0byBHRk0uXG4gICAgICAnZm9vdG5vdGUnLFxuICAgICAgJ2Zvb3Rub3RlUmVmZXJlbmNlJyxcbiAgICAgICdpbWFnZScsXG4gICAgICAnaW1hZ2VSZWZlcmVuY2UnLFxuICAgICAgJ2lubGluZUNvZGUnLFxuICAgICAgLy8gRW5hYmxlZCBieSBgbWRhc3QtdXRpbC1tYXRoYDpcbiAgICAgICdpbmxpbmVNYXRoJyxcbiAgICAgICdsaW5rJyxcbiAgICAgICdsaW5rUmVmZXJlbmNlJyxcbiAgICAgIC8vIEVuYWJsZWQgYnkgYG1kYXN0LXV0aWwtbWR4YDpcbiAgICAgICdtZHhKc3hUZXh0RWxlbWVudCcsXG4gICAgICAvLyBFbmFibGVkIGJ5IGBtZGFzdC11dGlsLW1keGA6XG4gICAgICAnbWR4VGV4dEV4cHJlc3Npb24nLFxuICAgICAgJ3N0cm9uZycsXG4gICAgICAndGV4dCcsXG4gICAgICAvLyBFbmFibGVkIGJ5IGBtZGFzdC11dGlsLWRpcmVjdGl2ZWA6XG4gICAgICAndGV4dERpcmVjdGl2ZSdcbiAgICBdKVxuICApXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-phrasing/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/blockquote.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/blockquote.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockquote: () => (/* binding */ blockquote)\n/* harmony export */ });\n/**\n * @import {Blockquote, Parents} from 'mdast'\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {Blockquote} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nfunction blockquote(node, _, state, info) {\n  const exit = state.enter('blockquote')\n  const tracker = state.createTracker(info)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvYmxvY2txdW90ZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLGtCQUFrQjtBQUM5Qjs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvYmxvY2txdW90ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge0Jsb2NrcXVvdGUsIFBhcmVudHN9IGZyb20gJ21kYXN0J1xuICogQGltcG9ydCB7SW5mbywgTWFwLCBTdGF0ZX0gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bidcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QmxvY2txdW90ZX0gbm9kZVxuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBfXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtJbmZvfSBpbmZvXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmxvY2txdW90ZShub2RlLCBfLCBzdGF0ZSwgaW5mbykge1xuICBjb25zdCBleGl0ID0gc3RhdGUuZW50ZXIoJ2Jsb2NrcXVvdGUnKVxuICBjb25zdCB0cmFja2VyID0gc3RhdGUuY3JlYXRlVHJhY2tlcihpbmZvKVxuICB0cmFja2VyLm1vdmUoJz4gJylcbiAgdHJhY2tlci5zaGlmdCgyKVxuICBjb25zdCB2YWx1ZSA9IHN0YXRlLmluZGVudExpbmVzKFxuICAgIHN0YXRlLmNvbnRhaW5lckZsb3cobm9kZSwgdHJhY2tlci5jdXJyZW50KCkpLFxuICAgIG1hcFxuICApXG4gIGV4aXQoKVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqIEB0eXBlIHtNYXB9ICovXG5mdW5jdGlvbiBtYXAobGluZSwgXywgYmxhbmspIHtcbiAgcmV0dXJuICc+JyArIChibGFuayA/ICcnIDogJyAnKSArIGxpbmVcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/blockquote.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/break.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/break.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hardBreak: () => (/* binding */ hardBreak)\n/* harmony export */ });\n/* harmony import */ var _util_pattern_in_scope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/pattern-in-scope.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js\");\n/**\n * @import {Break, Parents} from 'mdast'\n * @import {Info, State} from 'mdast-util-to-markdown'\n */\n\n\n\n/**\n * @param {Break} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nfunction hardBreak(_, _1, state, info) {\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    // If we cant put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      state.unsafe[index].character === '\\n' &&\n      (0,_util_pattern_in_scope_js__WEBPACK_IMPORTED_MODULE_0__.patternInScope)(state.stack, state.unsafe[index])\n    ) {\n      return /[ \\t]/.test(info.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvYnJlYWsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksYUFBYTtBQUN6Qjs7QUFFMEQ7O0FBRTFEO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsYUFBYTtBQUNiO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx5RUFBYztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvYnJlYWsuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtCcmVhaywgUGFyZW50c30gZnJvbSAnbWRhc3QnXG4gKiBAaW1wb3J0IHtJbmZvLCBTdGF0ZX0gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bidcbiAqL1xuXG5pbXBvcnQge3BhdHRlcm5JblNjb3BlfSBmcm9tICcuLi91dGlsL3BhdHRlcm4taW4tc2NvcGUuanMnXG5cbi8qKlxuICogQHBhcmFtIHtCcmVha30gX1xuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBfMVxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7SW5mb30gaW5mb1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhcmRCcmVhayhfLCBfMSwgc3RhdGUsIGluZm8pIHtcbiAgbGV0IGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IHN0YXRlLnVuc2FmZS5sZW5ndGgpIHtcbiAgICAvLyBJZiB3ZSBjYW7igJl0IHB1dCBlb2xzIGluIHRoaXMgY29uc3RydWN0IChzZXRleHQgaGVhZGluZ3MsIHRhYmxlcyksIHVzZSBhXG4gICAgLy8gc3BhY2UgaW5zdGVhZC5cbiAgICBpZiAoXG4gICAgICBzdGF0ZS51bnNhZmVbaW5kZXhdLmNoYXJhY3RlciA9PT0gJ1xcbicgJiZcbiAgICAgIHBhdHRlcm5JblNjb3BlKHN0YXRlLnN0YWNrLCBzdGF0ZS51bnNhZmVbaW5kZXhdKVxuICAgICkge1xuICAgICAgcmV0dXJuIC9bIFxcdF0vLnRlc3QoaW5mby5iZWZvcmUpID8gJycgOiAnICdcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJ1xcXFxcXG4nXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/break.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/code.js":
/*!****************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/code.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   code: () => (/* binding */ code)\n/* harmony export */ });\n/* harmony import */ var longest_streak__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! longest-streak */ \"(app-pages-browser)/./node_modules/longest-streak/index.js\");\n/* harmony import */ var _util_format_code_as_indented_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/format-code-as-indented.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js\");\n/* harmony import */ var _util_check_fence_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/check-fence.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-fence.js\");\n/**\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n * @import {Code, Parents} from 'mdast'\n */\n\n\n\n\n\n/**\n * @param {Code} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nfunction code(node, _, state, info) {\n  const marker = (0,_util_check_fence_js__WEBPACK_IMPORTED_MODULE_0__.checkFence)(state)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if ((0,_util_format_code_as_indented_js__WEBPACK_IMPORTED_MODULE_1__.formatCodeAsIndented)(node, state)) {\n    const exit = state.enter('codeIndented')\n    const value = state.indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = state.createTracker(info)\n  const sequence = marker.repeat(Math.max((0,longest_streak__WEBPACK_IMPORTED_MODULE_2__.longestStreak)(raw, marker) + 1, 3))\n  const exit = state.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`)\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\n    value += tracker.move(' ')\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvY29kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QixZQUFZLGVBQWU7QUFDM0I7O0FBRTRDO0FBQzJCO0FBQ3RCOztBQUVqRDtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLGFBQWE7QUFDYjtBQUNPO0FBQ1AsaUJBQWlCLGdFQUFVO0FBQzNCO0FBQ0E7O0FBRUEsTUFBTSxzRkFBb0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyw2REFBYTtBQUN2RDtBQUNBOztBQUVBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvaGFuZGxlL2NvZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtJbmZvLCBNYXAsIFN0YXRlfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duJ1xuICogQGltcG9ydCB7Q29kZSwgUGFyZW50c30gZnJvbSAnbWRhc3QnXG4gKi9cblxuaW1wb3J0IHtsb25nZXN0U3RyZWFrfSBmcm9tICdsb25nZXN0LXN0cmVhaydcbmltcG9ydCB7Zm9ybWF0Q29kZUFzSW5kZW50ZWR9IGZyb20gJy4uL3V0aWwvZm9ybWF0LWNvZGUtYXMtaW5kZW50ZWQuanMnXG5pbXBvcnQge2NoZWNrRmVuY2V9IGZyb20gJy4uL3V0aWwvY2hlY2stZmVuY2UuanMnXG5cbi8qKlxuICogQHBhcmFtIHtDb2RlfSBub2RlXG4gKiBAcGFyYW0ge1BhcmVudHMgfCB1bmRlZmluZWR9IF9cbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge0luZm99IGluZm9cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2RlKG5vZGUsIF8sIHN0YXRlLCBpbmZvKSB7XG4gIGNvbnN0IG1hcmtlciA9IGNoZWNrRmVuY2Uoc3RhdGUpXG4gIGNvbnN0IHJhdyA9IG5vZGUudmFsdWUgfHwgJydcbiAgY29uc3Qgc3VmZml4ID0gbWFya2VyID09PSAnYCcgPyAnR3JhdmVBY2NlbnQnIDogJ1RpbGRlJ1xuXG4gIGlmIChmb3JtYXRDb2RlQXNJbmRlbnRlZChub2RlLCBzdGF0ZSkpIHtcbiAgICBjb25zdCBleGl0ID0gc3RhdGUuZW50ZXIoJ2NvZGVJbmRlbnRlZCcpXG4gICAgY29uc3QgdmFsdWUgPSBzdGF0ZS5pbmRlbnRMaW5lcyhyYXcsIG1hcClcbiAgICBleGl0KClcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGNvbnN0IHRyYWNrZXIgPSBzdGF0ZS5jcmVhdGVUcmFja2VyKGluZm8pXG4gIGNvbnN0IHNlcXVlbmNlID0gbWFya2VyLnJlcGVhdChNYXRoLm1heChsb25nZXN0U3RyZWFrKHJhdywgbWFya2VyKSArIDEsIDMpKVxuICBjb25zdCBleGl0ID0gc3RhdGUuZW50ZXIoJ2NvZGVGZW5jZWQnKVxuICBsZXQgdmFsdWUgPSB0cmFja2VyLm1vdmUoc2VxdWVuY2UpXG5cbiAgaWYgKG5vZGUubGFuZykge1xuICAgIGNvbnN0IHN1YmV4aXQgPSBzdGF0ZS5lbnRlcihgY29kZUZlbmNlZExhbmcke3N1ZmZpeH1gKVxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShcbiAgICAgIHN0YXRlLnNhZmUobm9kZS5sYW5nLCB7XG4gICAgICAgIGJlZm9yZTogdmFsdWUsXG4gICAgICAgIGFmdGVyOiAnICcsXG4gICAgICAgIGVuY29kZTogWydgJ10sXG4gICAgICAgIC4uLnRyYWNrZXIuY3VycmVudCgpXG4gICAgICB9KVxuICAgIClcbiAgICBzdWJleGl0KClcbiAgfVxuXG4gIGlmIChub2RlLmxhbmcgJiYgbm9kZS5tZXRhKSB7XG4gICAgY29uc3Qgc3ViZXhpdCA9IHN0YXRlLmVudGVyKGBjb2RlRmVuY2VkTWV0YSR7c3VmZml4fWApXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKCcgJylcbiAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoXG4gICAgICBzdGF0ZS5zYWZlKG5vZGUubWV0YSwge1xuICAgICAgICBiZWZvcmU6IHZhbHVlLFxuICAgICAgICBhZnRlcjogJ1xcbicsXG4gICAgICAgIGVuY29kZTogWydgJ10sXG4gICAgICAgIC4uLnRyYWNrZXIuY3VycmVudCgpXG4gICAgICB9KVxuICAgIClcbiAgICBzdWJleGl0KClcbiAgfVxuXG4gIHZhbHVlICs9IHRyYWNrZXIubW92ZSgnXFxuJylcblxuICBpZiAocmF3KSB7XG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKHJhdyArICdcXG4nKVxuICB9XG5cbiAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKHNlcXVlbmNlKVxuICBleGl0KClcbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKiBAdHlwZSB7TWFwfSAqL1xuZnVuY3Rpb24gbWFwKGxpbmUsIF8sIGJsYW5rKSB7XG4gIHJldHVybiAoYmxhbmsgPyAnJyA6ICcgICAgJykgKyBsaW5lXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/code.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/definition.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/definition.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   definition: () => (/* binding */ definition)\n/* harmony export */ });\n/* harmony import */ var _util_check_quote_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/check-quote.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-quote.js\");\n/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Definition, Parents} from 'mdast'\n */\n\n\n\n/**\n * @param {Definition} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nfunction definition(node, _, state, info) {\n  const quote = (0,_util_check_quote_js__WEBPACK_IMPORTED_MODULE_0__.checkQuote)(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('definition')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If theres no url, or\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvZGVmaW5pdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVkscUJBQXFCO0FBQ2pDOztBQUVpRDs7QUFFakQ7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixhQUFhO0FBQ2I7QUFDTztBQUNQLGdCQUFnQixnRUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnREFBZ0Q7QUFDNUU7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL2hhbmRsZS9kZWZpbml0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7SW5mbywgU3RhdGV9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nXG4gKiBAaW1wb3J0IHtEZWZpbml0aW9uLCBQYXJlbnRzfSBmcm9tICdtZGFzdCdcbiAqL1xuXG5pbXBvcnQge2NoZWNrUXVvdGV9IGZyb20gJy4uL3V0aWwvY2hlY2stcXVvdGUuanMnXG5cbi8qKlxuICogQHBhcmFtIHtEZWZpbml0aW9ufSBub2RlXG4gKiBAcGFyYW0ge1BhcmVudHMgfCB1bmRlZmluZWR9IF9cbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge0luZm99IGluZm9cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbml0aW9uKG5vZGUsIF8sIHN0YXRlLCBpbmZvKSB7XG4gIGNvbnN0IHF1b3RlID0gY2hlY2tRdW90ZShzdGF0ZSlcbiAgY29uc3Qgc3VmZml4ID0gcXVvdGUgPT09ICdcIicgPyAnUXVvdGUnIDogJ0Fwb3N0cm9waGUnXG4gIGNvbnN0IGV4aXQgPSBzdGF0ZS5lbnRlcignZGVmaW5pdGlvbicpXG4gIGxldCBzdWJleGl0ID0gc3RhdGUuZW50ZXIoJ2xhYmVsJylcbiAgY29uc3QgdHJhY2tlciA9IHN0YXRlLmNyZWF0ZVRyYWNrZXIoaW5mbylcbiAgbGV0IHZhbHVlID0gdHJhY2tlci5tb3ZlKCdbJylcbiAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKFxuICAgIHN0YXRlLnNhZmUoc3RhdGUuYXNzb2NpYXRpb25JZChub2RlKSwge1xuICAgICAgYmVmb3JlOiB2YWx1ZSxcbiAgICAgIGFmdGVyOiAnXScsXG4gICAgICAuLi50cmFja2VyLmN1cnJlbnQoKVxuICAgIH0pXG4gIClcbiAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKCddOiAnKVxuXG4gIHN1YmV4aXQoKVxuXG4gIGlmIChcbiAgICAvLyBJZiB0aGVyZeKAmXMgbm8gdXJsLCBvcuKAplxuICAgICFub2RlLnVybCB8fFxuICAgIC8vIElmIHRoZXJlIGFyZSBjb250cm9sIGNoYXJhY3RlcnMgb3Igd2hpdGVzcGFjZS5cbiAgICAvW1xcMC0gXFx1MDA3Rl0vLnRlc3Qobm9kZS51cmwpXG4gICkge1xuICAgIHN1YmV4aXQgPSBzdGF0ZS5lbnRlcignZGVzdGluYXRpb25MaXRlcmFsJylcbiAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJzwnKVxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShcbiAgICAgIHN0YXRlLnNhZmUobm9kZS51cmwsIHtiZWZvcmU6IHZhbHVlLCBhZnRlcjogJz4nLCAuLi50cmFja2VyLmN1cnJlbnQoKX0pXG4gICAgKVxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZSgnPicpXG4gIH0gZWxzZSB7XG4gICAgLy8gTm8gd2hpdGVzcGFjZSwgcmF3IGlzIHByZXR0aWVyLlxuICAgIHN1YmV4aXQgPSBzdGF0ZS5lbnRlcignZGVzdGluYXRpb25SYXcnKVxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShcbiAgICAgIHN0YXRlLnNhZmUobm9kZS51cmwsIHtcbiAgICAgICAgYmVmb3JlOiB2YWx1ZSxcbiAgICAgICAgYWZ0ZXI6IG5vZGUudGl0bGUgPyAnICcgOiAnXFxuJyxcbiAgICAgICAgLi4udHJhY2tlci5jdXJyZW50KClcbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgc3ViZXhpdCgpXG5cbiAgaWYgKG5vZGUudGl0bGUpIHtcbiAgICBzdWJleGl0ID0gc3RhdGUuZW50ZXIoYHRpdGxlJHtzdWZmaXh9YClcbiAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJyAnICsgcXVvdGUpXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKFxuICAgICAgc3RhdGUuc2FmZShub2RlLnRpdGxlLCB7XG4gICAgICAgIGJlZm9yZTogdmFsdWUsXG4gICAgICAgIGFmdGVyOiBxdW90ZSxcbiAgICAgICAgLi4udHJhY2tlci5jdXJyZW50KClcbiAgICAgIH0pXG4gICAgKVxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShxdW90ZSlcbiAgICBzdWJleGl0KClcbiAgfVxuXG4gIGV4aXQoKVxuXG4gIHJldHVybiB2YWx1ZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/definition.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/emphasis.js":
/*!********************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/emphasis.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   emphasis: () => (/* binding */ emphasis)\n/* harmony export */ });\n/* harmony import */ var _util_check_emphasis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/check-emphasis.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js\");\n/* harmony import */ var _util_encode_character_reference_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/encode-character-reference.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js\");\n/* harmony import */ var _util_encode_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/encode-info.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/encode-info.js\");\n/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Emphasis, Parents} from 'mdast'\n */\n\n\n\n\n\nemphasis.peek = emphasisPeek\n\n/**\n * @param {Emphasis} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nfunction emphasis(node, _, state, info) {\n  const marker = (0,_util_check_emphasis_js__WEBPACK_IMPORTED_MODULE_0__.checkEmphasis)(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  const before = tracker.move(marker)\n\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  )\n  const betweenHead = between.charCodeAt(0)\n  const open = (0,_util_encode_info_js__WEBPACK_IMPORTED_MODULE_1__.encodeInfo)(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  )\n\n  if (open.inside) {\n    between = (0,_util_encode_character_reference_js__WEBPACK_IMPORTED_MODULE_2__.encodeCharacterReference)(betweenHead) + between.slice(1)\n  }\n\n  const betweenTail = between.charCodeAt(between.length - 1)\n  const close = (0,_util_encode_info_js__WEBPACK_IMPORTED_MODULE_1__.encodeInfo)(info.after.charCodeAt(0), betweenTail, marker)\n\n  if (close.inside) {\n    between = between.slice(0, -1) + (0,_util_encode_character_reference_js__WEBPACK_IMPORTED_MODULE_2__.encodeCharacterReference)(betweenTail)\n  }\n\n  const after = tracker.move(marker)\n\n  exit()\n\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  }\n  return before + between + after\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvZW1waGFzaXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVksbUJBQW1CO0FBQy9COztBQUV1RDtBQUN1QjtBQUM3Qjs7QUFFakQ7O0FBRUE7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixhQUFhO0FBQ2I7QUFDTztBQUNQLGlCQUFpQixzRUFBYTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSxnRUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsNkZBQXdCO0FBQ3RDOztBQUVBO0FBQ0EsZ0JBQWdCLGdFQUFVOztBQUUxQjtBQUNBLHFDQUFxQyw2RkFBd0I7QUFDN0Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL2hhbmRsZS9lbXBoYXNpcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge0luZm8sIFN0YXRlfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duJ1xuICogQGltcG9ydCB7RW1waGFzaXMsIFBhcmVudHN9IGZyb20gJ21kYXN0J1xuICovXG5cbmltcG9ydCB7Y2hlY2tFbXBoYXNpc30gZnJvbSAnLi4vdXRpbC9jaGVjay1lbXBoYXNpcy5qcydcbmltcG9ydCB7ZW5jb2RlQ2hhcmFjdGVyUmVmZXJlbmNlfSBmcm9tICcuLi91dGlsL2VuY29kZS1jaGFyYWN0ZXItcmVmZXJlbmNlLmpzJ1xuaW1wb3J0IHtlbmNvZGVJbmZvfSBmcm9tICcuLi91dGlsL2VuY29kZS1pbmZvLmpzJ1xuXG5lbXBoYXNpcy5wZWVrID0gZW1waGFzaXNQZWVrXG5cbi8qKlxuICogQHBhcmFtIHtFbXBoYXNpc30gbm9kZVxuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBfXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtJbmZvfSBpbmZvXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW1waGFzaXMobm9kZSwgXywgc3RhdGUsIGluZm8pIHtcbiAgY29uc3QgbWFya2VyID0gY2hlY2tFbXBoYXNpcyhzdGF0ZSlcbiAgY29uc3QgZXhpdCA9IHN0YXRlLmVudGVyKCdlbXBoYXNpcycpXG4gIGNvbnN0IHRyYWNrZXIgPSBzdGF0ZS5jcmVhdGVUcmFja2VyKGluZm8pXG4gIGNvbnN0IGJlZm9yZSA9IHRyYWNrZXIubW92ZShtYXJrZXIpXG5cbiAgbGV0IGJldHdlZW4gPSB0cmFja2VyLm1vdmUoXG4gICAgc3RhdGUuY29udGFpbmVyUGhyYXNpbmcobm9kZSwge1xuICAgICAgYWZ0ZXI6IG1hcmtlcixcbiAgICAgIGJlZm9yZSxcbiAgICAgIC4uLnRyYWNrZXIuY3VycmVudCgpXG4gICAgfSlcbiAgKVxuICBjb25zdCBiZXR3ZWVuSGVhZCA9IGJldHdlZW4uY2hhckNvZGVBdCgwKVxuICBjb25zdCBvcGVuID0gZW5jb2RlSW5mbyhcbiAgICBpbmZvLmJlZm9yZS5jaGFyQ29kZUF0KGluZm8uYmVmb3JlLmxlbmd0aCAtIDEpLFxuICAgIGJldHdlZW5IZWFkLFxuICAgIG1hcmtlclxuICApXG5cbiAgaWYgKG9wZW4uaW5zaWRlKSB7XG4gICAgYmV0d2VlbiA9IGVuY29kZUNoYXJhY3RlclJlZmVyZW5jZShiZXR3ZWVuSGVhZCkgKyBiZXR3ZWVuLnNsaWNlKDEpXG4gIH1cblxuICBjb25zdCBiZXR3ZWVuVGFpbCA9IGJldHdlZW4uY2hhckNvZGVBdChiZXR3ZWVuLmxlbmd0aCAtIDEpXG4gIGNvbnN0IGNsb3NlID0gZW5jb2RlSW5mbyhpbmZvLmFmdGVyLmNoYXJDb2RlQXQoMCksIGJldHdlZW5UYWlsLCBtYXJrZXIpXG5cbiAgaWYgKGNsb3NlLmluc2lkZSkge1xuICAgIGJldHdlZW4gPSBiZXR3ZWVuLnNsaWNlKDAsIC0xKSArIGVuY29kZUNoYXJhY3RlclJlZmVyZW5jZShiZXR3ZWVuVGFpbClcbiAgfVxuXG4gIGNvbnN0IGFmdGVyID0gdHJhY2tlci5tb3ZlKG1hcmtlcilcblxuICBleGl0KClcblxuICBzdGF0ZS5hdHRlbnRpb25FbmNvZGVTdXJyb3VuZGluZ0luZm8gPSB7XG4gICAgYWZ0ZXI6IGNsb3NlLm91dHNpZGUsXG4gICAgYmVmb3JlOiBvcGVuLm91dHNpZGVcbiAgfVxuICByZXR1cm4gYmVmb3JlICsgYmV0d2VlbiArIGFmdGVyXG59XG5cbi8qKlxuICogQHBhcmFtIHtFbXBoYXNpc30gX1xuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBfMVxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVtcGhhc2lzUGVlayhfLCBfMSwgc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLm9wdGlvbnMuZW1waGFzaXMgfHwgJyonXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/emphasis.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/heading.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/heading.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   heading: () => (/* binding */ heading)\n/* harmony export */ });\n/* harmony import */ var _util_encode_character_reference_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/encode-character-reference.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js\");\n/* harmony import */ var _util_format_heading_as_setext_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/format-heading-as-setext.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js\");\n/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Heading, Parents} from 'mdast'\n */\n\n\n\n\n/**\n * @param {Heading} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nfunction heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = state.createTracker(info)\n\n  if ((0,_util_format_heading_as_setext_js__WEBPACK_IMPORTED_MODULE_0__.formatHeadingAsSetext)(node, state)) {\n    const exit = state.enter('headingSetext')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = state.enter('headingAtx')\n  const subexit = state.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = state.containerPhrasing(node, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value = (0,_util_encode_character_reference_js__WEBPACK_IMPORTED_MODULE_1__.encodeCharacterReference)(value.charCodeAt(0)) + value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (state.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvaGVhZGluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLGtCQUFrQjtBQUM5Qjs7QUFFOEU7QUFDTDs7QUFFekU7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7O0FBRUEsTUFBTSx3RkFBcUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsWUFBWSw2RkFBd0I7QUFDcEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvaGFuZGxlL2hlYWRpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtJbmZvLCBTdGF0ZX0gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bidcbiAqIEBpbXBvcnQge0hlYWRpbmcsIFBhcmVudHN9IGZyb20gJ21kYXN0J1xuICovXG5cbmltcG9ydCB7ZW5jb2RlQ2hhcmFjdGVyUmVmZXJlbmNlfSBmcm9tICcuLi91dGlsL2VuY29kZS1jaGFyYWN0ZXItcmVmZXJlbmNlLmpzJ1xuaW1wb3J0IHtmb3JtYXRIZWFkaW5nQXNTZXRleHR9IGZyb20gJy4uL3V0aWwvZm9ybWF0LWhlYWRpbmctYXMtc2V0ZXh0LmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7SGVhZGluZ30gbm9kZVxuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBfXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtJbmZvfSBpbmZvXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGVhZGluZyhub2RlLCBfLCBzdGF0ZSwgaW5mbykge1xuICBjb25zdCByYW5rID0gTWF0aC5tYXgoTWF0aC5taW4oNiwgbm9kZS5kZXB0aCB8fCAxKSwgMSlcbiAgY29uc3QgdHJhY2tlciA9IHN0YXRlLmNyZWF0ZVRyYWNrZXIoaW5mbylcblxuICBpZiAoZm9ybWF0SGVhZGluZ0FzU2V0ZXh0KG5vZGUsIHN0YXRlKSkge1xuICAgIGNvbnN0IGV4aXQgPSBzdGF0ZS5lbnRlcignaGVhZGluZ1NldGV4dCcpXG4gICAgY29uc3Qgc3ViZXhpdCA9IHN0YXRlLmVudGVyKCdwaHJhc2luZycpXG4gICAgY29uc3QgdmFsdWUgPSBzdGF0ZS5jb250YWluZXJQaHJhc2luZyhub2RlLCB7XG4gICAgICAuLi50cmFja2VyLmN1cnJlbnQoKSxcbiAgICAgIGJlZm9yZTogJ1xcbicsXG4gICAgICBhZnRlcjogJ1xcbidcbiAgICB9KVxuICAgIHN1YmV4aXQoKVxuICAgIGV4aXQoKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHZhbHVlICtcbiAgICAgICdcXG4nICtcbiAgICAgIChyYW5rID09PSAxID8gJz0nIDogJy0nKS5yZXBlYXQoXG4gICAgICAgIC8vIFRoZSB3aG9sZSBzaXpl4oCmXG4gICAgICAgIHZhbHVlLmxlbmd0aCAtXG4gICAgICAgICAgLy8gTWludXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIGxhc3QgRU9MIChvclxuICAgICAgICAgIC8vIDAgaWYgdGhlcmUgaXMgbm9uZSnigKZcbiAgICAgICAgICAoTWF0aC5tYXgodmFsdWUubGFzdEluZGV4T2YoJ1xccicpLCB2YWx1ZS5sYXN0SW5kZXhPZignXFxuJykpICsgMSlcbiAgICAgIClcbiAgICApXG4gIH1cblxuICBjb25zdCBzZXF1ZW5jZSA9ICcjJy5yZXBlYXQocmFuaylcbiAgY29uc3QgZXhpdCA9IHN0YXRlLmVudGVyKCdoZWFkaW5nQXR4JylcbiAgY29uc3Qgc3ViZXhpdCA9IHN0YXRlLmVudGVyKCdwaHJhc2luZycpXG5cbiAgLy8gTm90ZTogZm9yIHByb3BlciB0cmFja2luZywgd2Ugc2hvdWxkIHJlc2V0IHRoZSBvdXRwdXQgcG9zaXRpb25zIHdoZW4gdGhlcmVcbiAgLy8gaXMgbm8gY29udGVudCByZXR1cm5lZCwgYmVjYXVzZSB0aGVuIHRoZSBzcGFjZSBpcyBub3Qgb3V0cHV0LlxuICAvLyBQcmFjdGljYWxseSwgaW4gdGhhdCBjYXNlLCB0aGVyZSBpcyBubyBjb250ZW50LCBzbyBpdCBkb2VzbuKAmXQgbWF0dGVyIHRoYXRcbiAgLy8gd2XigJl2ZSB0cmFja2VkIG9uZSB0b28gbWFueSBjaGFyYWN0ZXJzLlxuICB0cmFja2VyLm1vdmUoc2VxdWVuY2UgKyAnICcpXG5cbiAgbGV0IHZhbHVlID0gc3RhdGUuY29udGFpbmVyUGhyYXNpbmcobm9kZSwge1xuICAgIGJlZm9yZTogJyMgJyxcbiAgICBhZnRlcjogJ1xcbicsXG4gICAgLi4udHJhY2tlci5jdXJyZW50KClcbiAgfSlcblxuICBpZiAoL15bXFx0IF0vLnRlc3QodmFsdWUpKSB7XG4gICAgLy8gVG8gZG86IHdoYXQgZWZmZWN0IGhhcyB0aGUgY2hhcmFjdGVyIHJlZmVyZW5jZSBvbiB0cmFja2luZz9cbiAgICB2YWx1ZSA9IGVuY29kZUNoYXJhY3RlclJlZmVyZW5jZSh2YWx1ZS5jaGFyQ29kZUF0KDApKSArIHZhbHVlLnNsaWNlKDEpXG4gIH1cblxuICB2YWx1ZSA9IHZhbHVlID8gc2VxdWVuY2UgKyAnICcgKyB2YWx1ZSA6IHNlcXVlbmNlXG5cbiAgaWYgKHN0YXRlLm9wdGlvbnMuY2xvc2VBdHgpIHtcbiAgICB2YWx1ZSArPSAnICcgKyBzZXF1ZW5jZVxuICB9XG5cbiAgc3ViZXhpdCgpXG4gIGV4aXQoKVxuXG4gIHJldHVybiB2YWx1ZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/heading.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/html.js":
/*!****************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/html.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   html: () => (/* binding */ html)\n/* harmony export */ });\n/**\n * @import {Html} from 'mdast'\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {Html} node\n * @returns {string}\n */\nfunction html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvaHRtbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSxZQUFZLE1BQU07QUFDbEI7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvaHRtbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge0h0bWx9IGZyb20gJ21kYXN0J1xuICovXG5cbmh0bWwucGVlayA9IGh0bWxQZWVrXG5cbi8qKlxuICogQHBhcmFtIHtIdG1sfSBub2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHRtbChub2RlKSB7XG4gIHJldHVybiBub2RlLnZhbHVlIHx8ICcnXG59XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHRtbFBlZWsoKSB7XG4gIHJldHVybiAnPCdcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/html.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/image-reference.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/image-reference.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   imageReference: () => (/* binding */ imageReference)\n/* harmony export */ });\n/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {ImageReference, Parents} from 'mdast'\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nfunction imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvaW1hZ2UtcmVmZXJlbmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLHlCQUF5QjtBQUNyQzs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL2hhbmRsZS9pbWFnZS1yZWZlcmVuY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtJbmZvLCBTdGF0ZX0gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bidcbiAqIEBpbXBvcnQge0ltYWdlUmVmZXJlbmNlLCBQYXJlbnRzfSBmcm9tICdtZGFzdCdcbiAqL1xuXG5pbWFnZVJlZmVyZW5jZS5wZWVrID0gaW1hZ2VSZWZlcmVuY2VQZWVrXG5cbi8qKlxuICogQHBhcmFtIHtJbWFnZVJlZmVyZW5jZX0gbm9kZVxuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBfXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtJbmZvfSBpbmZvXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW1hZ2VSZWZlcmVuY2Uobm9kZSwgXywgc3RhdGUsIGluZm8pIHtcbiAgY29uc3QgdHlwZSA9IG5vZGUucmVmZXJlbmNlVHlwZVxuICBjb25zdCBleGl0ID0gc3RhdGUuZW50ZXIoJ2ltYWdlUmVmZXJlbmNlJylcbiAgbGV0IHN1YmV4aXQgPSBzdGF0ZS5lbnRlcignbGFiZWwnKVxuICBjb25zdCB0cmFja2VyID0gc3RhdGUuY3JlYXRlVHJhY2tlcihpbmZvKVxuICBsZXQgdmFsdWUgPSB0cmFja2VyLm1vdmUoJyFbJylcbiAgY29uc3QgYWx0ID0gc3RhdGUuc2FmZShub2RlLmFsdCwge1xuICAgIGJlZm9yZTogdmFsdWUsXG4gICAgYWZ0ZXI6ICddJyxcbiAgICAuLi50cmFja2VyLmN1cnJlbnQoKVxuICB9KVxuICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoYWx0ICsgJ11bJylcblxuICBzdWJleGl0KClcbiAgLy8gSGlkZSB0aGUgZmFjdCB0aGF0IHdl4oCZcmUgaW4gcGhyYXNpbmcsIGJlY2F1c2UgZXNjYXBlcyBkb27igJl0IHdvcmsuXG4gIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2tcbiAgc3RhdGUuc3RhY2sgPSBbXVxuICBzdWJleGl0ID0gc3RhdGUuZW50ZXIoJ3JlZmVyZW5jZScpXG4gIC8vIE5vdGU6IGZvciBwcm9wZXIgdHJhY2tpbmcsIHdlIHNob3VsZCByZXNldCB0aGUgb3V0cHV0IHBvc2l0aW9ucyB3aGVuIHdlIGVuZFxuICAvLyB1cCBtYWtpbmcgYSBgc2hvcnRjdXRgIHJlZmVyZW5jZSwgYmVjYXVzZSB0aGVuIHRoZXJlIGlzIG5vIGJyYWNlIG91dHB1dC5cbiAgLy8gUHJhY3RpY2FsbHksIGluIHRoYXQgY2FzZSwgdGhlcmUgaXMgbm8gY29udGVudCwgc28gaXQgZG9lc27igJl0IG1hdHRlciB0aGF0XG4gIC8vIHdl4oCZdmUgdHJhY2tlZCBvbmUgdG9vIG1hbnkgY2hhcmFjdGVycy5cbiAgY29uc3QgcmVmZXJlbmNlID0gc3RhdGUuc2FmZShzdGF0ZS5hc3NvY2lhdGlvbklkKG5vZGUpLCB7XG4gICAgYmVmb3JlOiB2YWx1ZSxcbiAgICBhZnRlcjogJ10nLFxuICAgIC4uLnRyYWNrZXIuY3VycmVudCgpXG4gIH0pXG4gIHN1YmV4aXQoKVxuICBzdGF0ZS5zdGFjayA9IHN0YWNrXG4gIGV4aXQoKVxuXG4gIGlmICh0eXBlID09PSAnZnVsbCcgfHwgIWFsdCB8fCBhbHQgIT09IHJlZmVyZW5jZSkge1xuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShyZWZlcmVuY2UgKyAnXScpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3Nob3J0Y3V0Jykge1xuICAgIC8vIFJlbW92ZSB0aGUgdW53YW50ZWQgYFtgLlxuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgLTEpXG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKCddJylcbiAgfVxuXG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGltYWdlUmVmZXJlbmNlUGVlaygpIHtcbiAgcmV0dXJuICchJ1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/image-reference.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/image.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/image.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   image: () => (/* binding */ image)\n/* harmony export */ });\n/* harmony import */ var _util_check_quote_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/check-quote.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-quote.js\");\n/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Image, Parents} from 'mdast'\n */\n\n\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nfunction image(node, _, state, info) {\n  const quote = (0,_util_check_quote_js__WEBPACK_IMPORTED_MODULE_0__.checkQuote)(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvaW1hZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLGdCQUFnQjtBQUM1Qjs7QUFFaUQ7O0FBRWpEOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsYUFBYTtBQUNiO0FBQ087QUFDUCxnQkFBZ0IsZ0VBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdEQUFnRDtBQUMxRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnREFBZ0Q7QUFDNUU7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvaGFuZGxlL2ltYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7SW5mbywgU3RhdGV9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nXG4gKiBAaW1wb3J0IHtJbWFnZSwgUGFyZW50c30gZnJvbSAnbWRhc3QnXG4gKi9cblxuaW1wb3J0IHtjaGVja1F1b3RlfSBmcm9tICcuLi91dGlsL2NoZWNrLXF1b3RlLmpzJ1xuXG5pbWFnZS5wZWVrID0gaW1hZ2VQZWVrXG5cbi8qKlxuICogQHBhcmFtIHtJbWFnZX0gbm9kZVxuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBfXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtJbmZvfSBpbmZvXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW1hZ2Uobm9kZSwgXywgc3RhdGUsIGluZm8pIHtcbiAgY29uc3QgcXVvdGUgPSBjaGVja1F1b3RlKHN0YXRlKVxuICBjb25zdCBzdWZmaXggPSBxdW90ZSA9PT0gJ1wiJyA/ICdRdW90ZScgOiAnQXBvc3Ryb3BoZSdcbiAgY29uc3QgZXhpdCA9IHN0YXRlLmVudGVyKCdpbWFnZScpXG4gIGxldCBzdWJleGl0ID0gc3RhdGUuZW50ZXIoJ2xhYmVsJylcbiAgY29uc3QgdHJhY2tlciA9IHN0YXRlLmNyZWF0ZVRyYWNrZXIoaW5mbylcbiAgbGV0IHZhbHVlID0gdHJhY2tlci5tb3ZlKCchWycpXG4gIHZhbHVlICs9IHRyYWNrZXIubW92ZShcbiAgICBzdGF0ZS5zYWZlKG5vZGUuYWx0LCB7YmVmb3JlOiB2YWx1ZSwgYWZ0ZXI6ICddJywgLi4udHJhY2tlci5jdXJyZW50KCl9KVxuICApXG4gIHZhbHVlICs9IHRyYWNrZXIubW92ZSgnXSgnKVxuXG4gIHN1YmV4aXQoKVxuXG4gIGlmIChcbiAgICAvLyBJZiB0aGVyZeKAmXMgbm8gdXJsIGJ1dCB0aGVyZSBpcyBhIHRpdGxl4oCmXG4gICAgKCFub2RlLnVybCAmJiBub2RlLnRpdGxlKSB8fFxuICAgIC8vIElmIHRoZXJlIGFyZSBjb250cm9sIGNoYXJhY3RlcnMgb3Igd2hpdGVzcGFjZS5cbiAgICAvW1xcMC0gXFx1MDA3Rl0vLnRlc3Qobm9kZS51cmwpXG4gICkge1xuICAgIHN1YmV4aXQgPSBzdGF0ZS5lbnRlcignZGVzdGluYXRpb25MaXRlcmFsJylcbiAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJzwnKVxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShcbiAgICAgIHN0YXRlLnNhZmUobm9kZS51cmwsIHtiZWZvcmU6IHZhbHVlLCBhZnRlcjogJz4nLCAuLi50cmFja2VyLmN1cnJlbnQoKX0pXG4gICAgKVxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZSgnPicpXG4gIH0gZWxzZSB7XG4gICAgLy8gTm8gd2hpdGVzcGFjZSwgcmF3IGlzIHByZXR0aWVyLlxuICAgIHN1YmV4aXQgPSBzdGF0ZS5lbnRlcignZGVzdGluYXRpb25SYXcnKVxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShcbiAgICAgIHN0YXRlLnNhZmUobm9kZS51cmwsIHtcbiAgICAgICAgYmVmb3JlOiB2YWx1ZSxcbiAgICAgICAgYWZ0ZXI6IG5vZGUudGl0bGUgPyAnICcgOiAnKScsXG4gICAgICAgIC4uLnRyYWNrZXIuY3VycmVudCgpXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIHN1YmV4aXQoKVxuXG4gIGlmIChub2RlLnRpdGxlKSB7XG4gICAgc3ViZXhpdCA9IHN0YXRlLmVudGVyKGB0aXRsZSR7c3VmZml4fWApXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKCcgJyArIHF1b3RlKVxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShcbiAgICAgIHN0YXRlLnNhZmUobm9kZS50aXRsZSwge1xuICAgICAgICBiZWZvcmU6IHZhbHVlLFxuICAgICAgICBhZnRlcjogcXVvdGUsXG4gICAgICAgIC4uLnRyYWNrZXIuY3VycmVudCgpXG4gICAgICB9KVxuICAgIClcbiAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUocXVvdGUpXG4gICAgc3ViZXhpdCgpXG4gIH1cblxuICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJyknKVxuICBleGl0KClcblxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBpbWFnZVBlZWsoKSB7XG4gIHJldHVybiAnISdcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/image.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handle: () => (/* binding */ handle)\n/* harmony export */ });\n/* harmony import */ var _blockquote_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blockquote.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/blockquote.js\");\n/* harmony import */ var _break_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./break.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/break.js\");\n/* harmony import */ var _code_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./code.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/code.js\");\n/* harmony import */ var _definition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./definition.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/definition.js\");\n/* harmony import */ var _emphasis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./emphasis.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/emphasis.js\");\n/* harmony import */ var _heading_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./heading.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/heading.js\");\n/* harmony import */ var _html_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./html.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/html.js\");\n/* harmony import */ var _image_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./image.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/image.js\");\n/* harmony import */ var _image_reference_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./image-reference.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/image-reference.js\");\n/* harmony import */ var _inline_code_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./inline-code.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/inline-code.js\");\n/* harmony import */ var _link_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./link.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/link.js\");\n/* harmony import */ var _link_reference_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./link-reference.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/link-reference.js\");\n/* harmony import */ var _list_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./list.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/list.js\");\n/* harmony import */ var _list_item_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./list-item.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/list-item.js\");\n/* harmony import */ var _paragraph_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./paragraph.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/paragraph.js\");\n/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./root.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/root.js\");\n/* harmony import */ var _strong_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./strong.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/strong.js\");\n/* harmony import */ var _text_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./text.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/text.js\");\n/* harmony import */ var _thematic_break_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./thematic-break.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Default (CommonMark) handlers.\n */\nconst handle = {\n  blockquote: _blockquote_js__WEBPACK_IMPORTED_MODULE_0__.blockquote,\n  break: _break_js__WEBPACK_IMPORTED_MODULE_1__.hardBreak,\n  code: _code_js__WEBPACK_IMPORTED_MODULE_2__.code,\n  definition: _definition_js__WEBPACK_IMPORTED_MODULE_3__.definition,\n  emphasis: _emphasis_js__WEBPACK_IMPORTED_MODULE_4__.emphasis,\n  hardBreak: _break_js__WEBPACK_IMPORTED_MODULE_1__.hardBreak,\n  heading: _heading_js__WEBPACK_IMPORTED_MODULE_5__.heading,\n  html: _html_js__WEBPACK_IMPORTED_MODULE_6__.html,\n  image: _image_js__WEBPACK_IMPORTED_MODULE_7__.image,\n  imageReference: _image_reference_js__WEBPACK_IMPORTED_MODULE_8__.imageReference,\n  inlineCode: _inline_code_js__WEBPACK_IMPORTED_MODULE_9__.inlineCode,\n  link: _link_js__WEBPACK_IMPORTED_MODULE_10__.link,\n  linkReference: _link_reference_js__WEBPACK_IMPORTED_MODULE_11__.linkReference,\n  list: _list_js__WEBPACK_IMPORTED_MODULE_12__.list,\n  listItem: _list_item_js__WEBPACK_IMPORTED_MODULE_13__.listItem,\n  paragraph: _paragraph_js__WEBPACK_IMPORTED_MODULE_14__.paragraph,\n  root: _root_js__WEBPACK_IMPORTED_MODULE_15__.root,\n  strong: _strong_js__WEBPACK_IMPORTED_MODULE_16__.strong,\n  text: _text_js__WEBPACK_IMPORTED_MODULE_17__.text,\n  thematicBreak: _thematic_break_js__WEBPACK_IMPORTED_MODULE_18__.thematicBreak\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEM7QUFDTjtBQUNOO0FBQ1k7QUFDSjtBQUNGO0FBQ047QUFDRTtBQUNtQjtBQUNSO0FBQ2I7QUFDbUI7QUFDbkI7QUFDUztBQUNDO0FBQ1Y7QUFDSTtBQUNKO0FBQ21COztBQUVqRDtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVk7QUFDWixTQUFTLGdEQUFTO0FBQ2xCLE1BQU07QUFDTixZQUFZO0FBQ1osVUFBVTtBQUNWLFdBQVc7QUFDWCxTQUFTO0FBQ1QsTUFBTTtBQUNOLE9BQU87QUFDUCxnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLE1BQU07QUFDTixlQUFlO0FBQ2YsTUFBTTtBQUNOLFVBQVU7QUFDVixXQUFXO0FBQ1gsTUFBTTtBQUNOLFFBQVE7QUFDUixNQUFNO0FBQ04sZUFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtibG9ja3F1b3RlfSBmcm9tICcuL2Jsb2NrcXVvdGUuanMnXG5pbXBvcnQge2hhcmRCcmVha30gZnJvbSAnLi9icmVhay5qcydcbmltcG9ydCB7Y29kZX0gZnJvbSAnLi9jb2RlLmpzJ1xuaW1wb3J0IHtkZWZpbml0aW9ufSBmcm9tICcuL2RlZmluaXRpb24uanMnXG5pbXBvcnQge2VtcGhhc2lzfSBmcm9tICcuL2VtcGhhc2lzLmpzJ1xuaW1wb3J0IHtoZWFkaW5nfSBmcm9tICcuL2hlYWRpbmcuanMnXG5pbXBvcnQge2h0bWx9IGZyb20gJy4vaHRtbC5qcydcbmltcG9ydCB7aW1hZ2V9IGZyb20gJy4vaW1hZ2UuanMnXG5pbXBvcnQge2ltYWdlUmVmZXJlbmNlfSBmcm9tICcuL2ltYWdlLXJlZmVyZW5jZS5qcydcbmltcG9ydCB7aW5saW5lQ29kZX0gZnJvbSAnLi9pbmxpbmUtY29kZS5qcydcbmltcG9ydCB7bGlua30gZnJvbSAnLi9saW5rLmpzJ1xuaW1wb3J0IHtsaW5rUmVmZXJlbmNlfSBmcm9tICcuL2xpbmstcmVmZXJlbmNlLmpzJ1xuaW1wb3J0IHtsaXN0fSBmcm9tICcuL2xpc3QuanMnXG5pbXBvcnQge2xpc3RJdGVtfSBmcm9tICcuL2xpc3QtaXRlbS5qcydcbmltcG9ydCB7cGFyYWdyYXBofSBmcm9tICcuL3BhcmFncmFwaC5qcydcbmltcG9ydCB7cm9vdH0gZnJvbSAnLi9yb290LmpzJ1xuaW1wb3J0IHtzdHJvbmd9IGZyb20gJy4vc3Ryb25nLmpzJ1xuaW1wb3J0IHt0ZXh0fSBmcm9tICcuL3RleHQuanMnXG5pbXBvcnQge3RoZW1hdGljQnJlYWt9IGZyb20gJy4vdGhlbWF0aWMtYnJlYWsuanMnXG5cbi8qKlxuICogRGVmYXVsdCAoQ29tbW9uTWFyaykgaGFuZGxlcnMuXG4gKi9cbmV4cG9ydCBjb25zdCBoYW5kbGUgPSB7XG4gIGJsb2NrcXVvdGUsXG4gIGJyZWFrOiBoYXJkQnJlYWssXG4gIGNvZGUsXG4gIGRlZmluaXRpb24sXG4gIGVtcGhhc2lzLFxuICBoYXJkQnJlYWssXG4gIGhlYWRpbmcsXG4gIGh0bWwsXG4gIGltYWdlLFxuICBpbWFnZVJlZmVyZW5jZSxcbiAgaW5saW5lQ29kZSxcbiAgbGluayxcbiAgbGlua1JlZmVyZW5jZSxcbiAgbGlzdCxcbiAgbGlzdEl0ZW0sXG4gIHBhcmFncmFwaCxcbiAgcm9vdCxcbiAgc3Ryb25nLFxuICB0ZXh0LFxuICB0aGVtYXRpY0JyZWFrXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/inline-code.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/inline-code.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   inlineCode: () => (/* binding */ inlineCode)\n/* harmony export */ });\n/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {InlineCode, Parents} from 'mdast'\n */\n\ninlineCode.peek = inlineCodePeek\n\n/**\n * @param {InlineCode} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction inlineCode(node, _, state) {\n  let value = node.value || ''\n  let sequence = '`'\n  let index = -1\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs dont count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) || /^`|`$/.test(value))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We cant escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    while ((match = expression.exec(value))) {\n      let position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\n/**\n * @returns {string}\n */\nfunction inlineCodePeek() {\n  return '`'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvaW5saW5lLWNvZGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVkscUJBQXFCO0FBQ2pDOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL2hhbmRsZS9pbmxpbmUtY29kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge1N0YXRlfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duJ1xuICogQGltcG9ydCB7SW5saW5lQ29kZSwgUGFyZW50c30gZnJvbSAnbWRhc3QnXG4gKi9cblxuaW5saW5lQ29kZS5wZWVrID0gaW5saW5lQ29kZVBlZWtcblxuLyoqXG4gKiBAcGFyYW0ge0lubGluZUNvZGV9IG5vZGVcbiAqIEBwYXJhbSB7UGFyZW50cyB8IHVuZGVmaW5lZH0gX1xuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmxpbmVDb2RlKG5vZGUsIF8sIHN0YXRlKSB7XG4gIGxldCB2YWx1ZSA9IG5vZGUudmFsdWUgfHwgJydcbiAgbGV0IHNlcXVlbmNlID0gJ2AnXG4gIGxldCBpbmRleCA9IC0xXG5cbiAgLy8gSWYgdGhlcmUgaXMgYSBzaW5nbGUgZ3JhdmUgYWNjZW50IG9uIGl0cyBvd24gaW4gdGhlIGNvZGUsIHVzZSBhIGZlbmNlIG9mXG4gIC8vIHR3by5cbiAgLy8gSWYgdGhlcmUgYXJlIHR3byBpbiBhIHJvdywgdXNlIG9uZS5cbiAgd2hpbGUgKG5ldyBSZWdFeHAoJyhefFteYF0pJyArIHNlcXVlbmNlICsgJyhbXmBdfCQpJykudGVzdCh2YWx1ZSkpIHtcbiAgICBzZXF1ZW5jZSArPSAnYCdcbiAgfVxuXG4gIC8vIElmIHRoaXMgaXMgbm90IGp1c3Qgc3BhY2VzIG9yIGVvbHMgKHRhYnMgZG9u4oCZdCBjb3VudCksIGFuZCBlaXRoZXIgdGhlXG4gIC8vIGZpcnN0IG9yIGxhc3QgY2hhcmFjdGVyIGFyZSBhIHNwYWNlLCBlb2wsIG9yIHRpY2ssIHRoZW4gcGFkIHdpdGggc3BhY2VzLlxuICBpZiAoXG4gICAgL1teIFxcclxcbl0vLnRlc3QodmFsdWUpICYmXG4gICAgKCgvXlsgXFxyXFxuXS8udGVzdCh2YWx1ZSkgJiYgL1sgXFxyXFxuXSQvLnRlc3QodmFsdWUpKSB8fCAvXmB8YCQvLnRlc3QodmFsdWUpKVxuICApIHtcbiAgICB2YWx1ZSA9ICcgJyArIHZhbHVlICsgJyAnXG4gIH1cblxuICAvLyBXZSBoYXZlIGEgcG90ZW50aWFsIHByb2JsZW06IGNlcnRhaW4gY2hhcmFjdGVycyBhZnRlciBlb2xzIGNvdWxkIHJlc3VsdCBpblxuICAvLyBibG9ja3MgYmVpbmcgc2Vlbi5cbiAgLy8gRm9yIGV4YW1wbGUsIGlmIHNvbWVvbmUgaW5qZWN0ZWQgdGhlIHN0cmluZyBgJ1xcbiMgYidgLCB0aGVuIHRoYXQgd291bGRcbiAgLy8gcmVzdWx0IGluIGFuIEFUWCBoZWFkaW5nLlxuICAvLyBXZSBjYW7igJl0IGVzY2FwZSBjaGFyYWN0ZXJzIGluIGBpbmxpbmVDb2RlYCwgYnV0IGJlY2F1c2UgZW9scyBhcmVcbiAgLy8gdHJhbnNmb3JtZWQgdG8gc3BhY2VzIHdoZW4gZ29pbmcgZnJvbSBtYXJrZG93biB0byBIVE1MIGFueXdheSwgd2UgY2FuIHN3YXBcbiAgLy8gdGhlbSBvdXQuXG4gIHdoaWxlICgrK2luZGV4IDwgc3RhdGUudW5zYWZlLmxlbmd0aCkge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBzdGF0ZS51bnNhZmVbaW5kZXhdXG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IHN0YXRlLmNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pXG4gICAgLyoqIEB0eXBlIHtSZWdFeHBFeGVjQXJyYXkgfCBudWxsfSAqL1xuICAgIGxldCBtYXRjaFxuXG4gICAgLy8gT25seSBsb29rIGZvciBgYXRCcmVha2BzLlxuICAgIC8vIEJ0dzogbm90ZSB0aGF0IGBhdEJyZWFrYCBwYXR0ZXJucyB3aWxsIGFsd2F5cyBzdGFydCB0aGUgcmVnZXggYXQgTEYgb3JcbiAgICAvLyBDUi5cbiAgICBpZiAoIXBhdHRlcm4uYXRCcmVhaykgY29udGludWVcblxuICAgIHdoaWxlICgobWF0Y2ggPSBleHByZXNzaW9uLmV4ZWModmFsdWUpKSkge1xuICAgICAgbGV0IHBvc2l0aW9uID0gbWF0Y2guaW5kZXhcblxuICAgICAgLy8gU3VwcG9ydCBDUkxGIChwYXR0ZXJucyBvbmx5IGxvb2sgZm9yIG9uZSBvZiB0aGUgY2hhcmFjdGVycykuXG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlLmNoYXJDb2RlQXQocG9zaXRpb24pID09PSAxMCAvKiBgXFxuYCAqLyAmJlxuICAgICAgICB2YWx1ZS5jaGFyQ29kZUF0KHBvc2l0aW9uIC0gMSkgPT09IDEzIC8qIGBcXHJgICovXG4gICAgICApIHtcbiAgICAgICAgcG9zaXRpb24tLVxuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIHBvc2l0aW9uKSArICcgJyArIHZhbHVlLnNsaWNlKG1hdGNoLmluZGV4ICsgMSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VxdWVuY2UgKyB2YWx1ZSArIHNlcXVlbmNlXG59XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaW5saW5lQ29kZVBlZWsoKSB7XG4gIHJldHVybiAnYCdcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/inline-code.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/link-reference.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/link-reference.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   linkReference: () => (/* binding */ linkReference)\n/* harmony export */ });\n/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {LinkReference, Parents} from 'mdast'\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nfunction linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that were in phrasing, because escapes dont work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesnt matter that\n  // weve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvbGluay1yZWZlcmVuY2UuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVksd0JBQXdCO0FBQ3BDOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL2hhbmRsZS9saW5rLXJlZmVyZW5jZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge0luZm8sIFN0YXRlfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duJ1xuICogQGltcG9ydCB7TGlua1JlZmVyZW5jZSwgUGFyZW50c30gZnJvbSAnbWRhc3QnXG4gKi9cblxubGlua1JlZmVyZW5jZS5wZWVrID0gbGlua1JlZmVyZW5jZVBlZWtcblxuLyoqXG4gKiBAcGFyYW0ge0xpbmtSZWZlcmVuY2V9IG5vZGVcbiAqIEBwYXJhbSB7UGFyZW50cyB8IHVuZGVmaW5lZH0gX1xuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7SW5mb30gaW5mb1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmtSZWZlcmVuY2Uobm9kZSwgXywgc3RhdGUsIGluZm8pIHtcbiAgY29uc3QgdHlwZSA9IG5vZGUucmVmZXJlbmNlVHlwZVxuICBjb25zdCBleGl0ID0gc3RhdGUuZW50ZXIoJ2xpbmtSZWZlcmVuY2UnKVxuICBsZXQgc3ViZXhpdCA9IHN0YXRlLmVudGVyKCdsYWJlbCcpXG4gIGNvbnN0IHRyYWNrZXIgPSBzdGF0ZS5jcmVhdGVUcmFja2VyKGluZm8pXG4gIGxldCB2YWx1ZSA9IHRyYWNrZXIubW92ZSgnWycpXG4gIGNvbnN0IHRleHQgPSBzdGF0ZS5jb250YWluZXJQaHJhc2luZyhub2RlLCB7XG4gICAgYmVmb3JlOiB2YWx1ZSxcbiAgICBhZnRlcjogJ10nLFxuICAgIC4uLnRyYWNrZXIuY3VycmVudCgpXG4gIH0pXG4gIHZhbHVlICs9IHRyYWNrZXIubW92ZSh0ZXh0ICsgJ11bJylcblxuICBzdWJleGl0KClcbiAgLy8gSGlkZSB0aGUgZmFjdCB0aGF0IHdl4oCZcmUgaW4gcGhyYXNpbmcsIGJlY2F1c2UgZXNjYXBlcyBkb27igJl0IHdvcmsuXG4gIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2tcbiAgc3RhdGUuc3RhY2sgPSBbXVxuICBzdWJleGl0ID0gc3RhdGUuZW50ZXIoJ3JlZmVyZW5jZScpXG4gIC8vIE5vdGU6IGZvciBwcm9wZXIgdHJhY2tpbmcsIHdlIHNob3VsZCByZXNldCB0aGUgb3V0cHV0IHBvc2l0aW9ucyB3aGVuIHdlIGVuZFxuICAvLyB1cCBtYWtpbmcgYSBgc2hvcnRjdXRgIHJlZmVyZW5jZSwgYmVjYXVzZSB0aGVuIHRoZXJlIGlzIG5vIGJyYWNlIG91dHB1dC5cbiAgLy8gUHJhY3RpY2FsbHksIGluIHRoYXQgY2FzZSwgdGhlcmUgaXMgbm8gY29udGVudCwgc28gaXQgZG9lc27igJl0IG1hdHRlciB0aGF0XG4gIC8vIHdl4oCZdmUgdHJhY2tlZCBvbmUgdG9vIG1hbnkgY2hhcmFjdGVycy5cbiAgY29uc3QgcmVmZXJlbmNlID0gc3RhdGUuc2FmZShzdGF0ZS5hc3NvY2lhdGlvbklkKG5vZGUpLCB7XG4gICAgYmVmb3JlOiB2YWx1ZSxcbiAgICBhZnRlcjogJ10nLFxuICAgIC4uLnRyYWNrZXIuY3VycmVudCgpXG4gIH0pXG4gIHN1YmV4aXQoKVxuICBzdGF0ZS5zdGFjayA9IHN0YWNrXG4gIGV4aXQoKVxuXG4gIGlmICh0eXBlID09PSAnZnVsbCcgfHwgIXRleHQgfHwgdGV4dCAhPT0gcmVmZXJlbmNlKSB7XG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKHJlZmVyZW5jZSArICddJylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc2hvcnRjdXQnKSB7XG4gICAgLy8gUmVtb3ZlIHRoZSB1bndhbnRlZCBgW2AuXG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCAtMSlcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJ10nKVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbGlua1JlZmVyZW5jZVBlZWsoKSB7XG4gIHJldHVybiAnWydcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/link-reference.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/link.js":
/*!****************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/link.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   link: () => (/* binding */ link)\n/* harmony export */ });\n/* harmony import */ var _util_check_quote_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/check-quote.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-quote.js\");\n/* harmony import */ var _util_format_link_as_autolink_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/format-link-as-autolink.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js\");\n/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Link, Parents} from 'mdast'\n * @import {Exit} from '../types.js'\n */\n\n\n\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nfunction link(node, _, state, info) {\n  const quote = (0,_util_check_quote_js__WEBPACK_IMPORTED_MODULE_0__.checkQuote)(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if ((0,_util_format_link_as_autolink_js__WEBPACK_IMPORTED_MODULE_1__.formatLinkAsAutolink)(node, state)) {\n    // Hide the fact that were in phrasing, because escapes dont work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If theres no url but there is a title\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return (0,_util_format_link_as_autolink_js__WEBPACK_IMPORTED_MODULE_1__.formatLinkAsAutolink)(node, state) ? '<' : '['\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvbGluay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLGVBQWU7QUFDM0IsWUFBWSxNQUFNO0FBQ2xCOztBQUVpRDtBQUNzQjs7QUFFdkU7O0FBRUE7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixhQUFhO0FBQ2I7QUFDTztBQUNQLGdCQUFnQixnRUFBVTtBQUMxQjtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsYUFBYSxNQUFNO0FBQ25COztBQUVBLE1BQU0sc0ZBQW9CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQWdEO0FBQzVFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUyxzRkFBb0I7QUFDN0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL2hhbmRsZS9saW5rLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7SW5mbywgU3RhdGV9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nXG4gKiBAaW1wb3J0IHtMaW5rLCBQYXJlbnRzfSBmcm9tICdtZGFzdCdcbiAqIEBpbXBvcnQge0V4aXR9IGZyb20gJy4uL3R5cGVzLmpzJ1xuICovXG5cbmltcG9ydCB7Y2hlY2tRdW90ZX0gZnJvbSAnLi4vdXRpbC9jaGVjay1xdW90ZS5qcydcbmltcG9ydCB7Zm9ybWF0TGlua0FzQXV0b2xpbmt9IGZyb20gJy4uL3V0aWwvZm9ybWF0LWxpbmstYXMtYXV0b2xpbmsuanMnXG5cbmxpbmsucGVlayA9IGxpbmtQZWVrXG5cbi8qKlxuICogQHBhcmFtIHtMaW5rfSBub2RlXG4gKiBAcGFyYW0ge1BhcmVudHMgfCB1bmRlZmluZWR9IF9cbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge0luZm99IGluZm9cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5rKG5vZGUsIF8sIHN0YXRlLCBpbmZvKSB7XG4gIGNvbnN0IHF1b3RlID0gY2hlY2tRdW90ZShzdGF0ZSlcbiAgY29uc3Qgc3VmZml4ID0gcXVvdGUgPT09ICdcIicgPyAnUXVvdGUnIDogJ0Fwb3N0cm9waGUnXG4gIGNvbnN0IHRyYWNrZXIgPSBzdGF0ZS5jcmVhdGVUcmFja2VyKGluZm8pXG4gIC8qKiBAdHlwZSB7RXhpdH0gKi9cbiAgbGV0IGV4aXRcbiAgLyoqIEB0eXBlIHtFeGl0fSAqL1xuICBsZXQgc3ViZXhpdFxuXG4gIGlmIChmb3JtYXRMaW5rQXNBdXRvbGluayhub2RlLCBzdGF0ZSkpIHtcbiAgICAvLyBIaWRlIHRoZSBmYWN0IHRoYXQgd2XigJlyZSBpbiBwaHJhc2luZywgYmVjYXVzZSBlc2NhcGVzIGRvbuKAmXQgd29yay5cbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrXG4gICAgc3RhdGUuc3RhY2sgPSBbXVxuICAgIGV4aXQgPSBzdGF0ZS5lbnRlcignYXV0b2xpbmsnKVxuICAgIGxldCB2YWx1ZSA9IHRyYWNrZXIubW92ZSgnPCcpXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKFxuICAgICAgc3RhdGUuY29udGFpbmVyUGhyYXNpbmcobm9kZSwge1xuICAgICAgICBiZWZvcmU6IHZhbHVlLFxuICAgICAgICBhZnRlcjogJz4nLFxuICAgICAgICAuLi50cmFja2VyLmN1cnJlbnQoKVxuICAgICAgfSlcbiAgICApXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKCc+JylcbiAgICBleGl0KClcbiAgICBzdGF0ZS5zdGFjayA9IHN0YWNrXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBleGl0ID0gc3RhdGUuZW50ZXIoJ2xpbmsnKVxuICBzdWJleGl0ID0gc3RhdGUuZW50ZXIoJ2xhYmVsJylcbiAgbGV0IHZhbHVlID0gdHJhY2tlci5tb3ZlKCdbJylcbiAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKFxuICAgIHN0YXRlLmNvbnRhaW5lclBocmFzaW5nKG5vZGUsIHtcbiAgICAgIGJlZm9yZTogdmFsdWUsXG4gICAgICBhZnRlcjogJ10oJyxcbiAgICAgIC4uLnRyYWNrZXIuY3VycmVudCgpXG4gICAgfSlcbiAgKVxuICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJ10oJylcbiAgc3ViZXhpdCgpXG5cbiAgaWYgKFxuICAgIC8vIElmIHRoZXJl4oCZcyBubyB1cmwgYnV0IHRoZXJlIGlzIGEgdGl0bGXigKZcbiAgICAoIW5vZGUudXJsICYmIG5vZGUudGl0bGUpIHx8XG4gICAgLy8gSWYgdGhlcmUgYXJlIGNvbnRyb2wgY2hhcmFjdGVycyBvciB3aGl0ZXNwYWNlLlxuICAgIC9bXFwwLSBcXHUwMDdGXS8udGVzdChub2RlLnVybClcbiAgKSB7XG4gICAgc3ViZXhpdCA9IHN0YXRlLmVudGVyKCdkZXN0aW5hdGlvbkxpdGVyYWwnKVxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZSgnPCcpXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKFxuICAgICAgc3RhdGUuc2FmZShub2RlLnVybCwge2JlZm9yZTogdmFsdWUsIGFmdGVyOiAnPicsIC4uLnRyYWNrZXIuY3VycmVudCgpfSlcbiAgICApXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKCc+JylcbiAgfSBlbHNlIHtcbiAgICAvLyBObyB3aGl0ZXNwYWNlLCByYXcgaXMgcHJldHRpZXIuXG4gICAgc3ViZXhpdCA9IHN0YXRlLmVudGVyKCdkZXN0aW5hdGlvblJhdycpXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKFxuICAgICAgc3RhdGUuc2FmZShub2RlLnVybCwge1xuICAgICAgICBiZWZvcmU6IHZhbHVlLFxuICAgICAgICBhZnRlcjogbm9kZS50aXRsZSA/ICcgJyA6ICcpJyxcbiAgICAgICAgLi4udHJhY2tlci5jdXJyZW50KClcbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgc3ViZXhpdCgpXG5cbiAgaWYgKG5vZGUudGl0bGUpIHtcbiAgICBzdWJleGl0ID0gc3RhdGUuZW50ZXIoYHRpdGxlJHtzdWZmaXh9YClcbiAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJyAnICsgcXVvdGUpXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKFxuICAgICAgc3RhdGUuc2FmZShub2RlLnRpdGxlLCB7XG4gICAgICAgIGJlZm9yZTogdmFsdWUsXG4gICAgICAgIGFmdGVyOiBxdW90ZSxcbiAgICAgICAgLi4udHJhY2tlci5jdXJyZW50KClcbiAgICAgIH0pXG4gICAgKVxuICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZShxdW90ZSlcbiAgICBzdWJleGl0KClcbiAgfVxuXG4gIHZhbHVlICs9IHRyYWNrZXIubW92ZSgnKScpXG5cbiAgZXhpdCgpXG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TGlua30gbm9kZVxuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBfXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbGlua1BlZWsobm9kZSwgXywgc3RhdGUpIHtcbiAgcmV0dXJuIGZvcm1hdExpbmtBc0F1dG9saW5rKG5vZGUsIHN0YXRlKSA/ICc8JyA6ICdbJ1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/list-item.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/list-item.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   listItem: () => (/* binding */ listItem)\n/* harmony export */ });\n/* harmony import */ var _util_check_bullet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/check-bullet.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-bullet.js\");\n/* harmony import */ var _util_check_list_item_indent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/check-list-item-indent.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js\");\n/**\n * @import {Info, Map, State} from 'mdast-util-to-markdown'\n * @import {ListItem, Parents} from 'mdast'\n */\n\n\n\n\n/**\n * @param {ListItem} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nfunction listItem(node, parent, state, info) {\n  const listItemIndent = (0,_util_check_list_item_indent_js__WEBPACK_IMPORTED_MODULE_0__.checkListItemIndent)(state)\n  let bullet = state.bulletCurrent || (0,_util_check_bullet_js__WEBPACK_IMPORTED_MODULE_1__.checkBullet)(state)\n\n  // Add the marker value for ordered lists.\n  if (parent && parent.type === 'list' && parent.ordered) {\n    bullet =\n      (typeof parent.start === 'number' && parent.start > -1\n        ? parent.start\n        : 1) +\n      (state.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      bullet\n  }\n\n  let size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' &&\n      ((parent && parent.type === 'list' && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  const tracker = state.createTracker(info)\n  tracker.move(bullet + ' '.repeat(size - bullet.length))\n  tracker.shift(size)\n  const exit = state.enter('listItem')\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n\n  return value\n\n  /** @type {Map} */\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : ' '.repeat(size)) + line\n    }\n\n    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvbGlzdC1pdGVtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUIsWUFBWSxtQkFBbUI7QUFDL0I7O0FBRW1EO0FBQ2tCOztBQUVyRTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLGFBQWE7QUFDYjtBQUNPO0FBQ1AseUJBQXlCLG9GQUFtQjtBQUM1QyxzQ0FBc0Msa0VBQVc7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL2hhbmRsZS9saXN0LWl0ZW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtJbmZvLCBNYXAsIFN0YXRlfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duJ1xuICogQGltcG9ydCB7TGlzdEl0ZW0sIFBhcmVudHN9IGZyb20gJ21kYXN0J1xuICovXG5cbmltcG9ydCB7Y2hlY2tCdWxsZXR9IGZyb20gJy4uL3V0aWwvY2hlY2stYnVsbGV0LmpzJ1xuaW1wb3J0IHtjaGVja0xpc3RJdGVtSW5kZW50fSBmcm9tICcuLi91dGlsL2NoZWNrLWxpc3QtaXRlbS1pbmRlbnQuanMnXG5cbi8qKlxuICogQHBhcmFtIHtMaXN0SXRlbX0gbm9kZVxuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBwYXJlbnRcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge0luZm99IGluZm9cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0SXRlbShub2RlLCBwYXJlbnQsIHN0YXRlLCBpbmZvKSB7XG4gIGNvbnN0IGxpc3RJdGVtSW5kZW50ID0gY2hlY2tMaXN0SXRlbUluZGVudChzdGF0ZSlcbiAgbGV0IGJ1bGxldCA9IHN0YXRlLmJ1bGxldEN1cnJlbnQgfHwgY2hlY2tCdWxsZXQoc3RhdGUpXG5cbiAgLy8gQWRkIHRoZSBtYXJrZXIgdmFsdWUgZm9yIG9yZGVyZWQgbGlzdHMuXG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09ICdsaXN0JyAmJiBwYXJlbnQub3JkZXJlZCkge1xuICAgIGJ1bGxldCA9XG4gICAgICAodHlwZW9mIHBhcmVudC5zdGFydCA9PT0gJ251bWJlcicgJiYgcGFyZW50LnN0YXJ0ID4gLTFcbiAgICAgICAgPyBwYXJlbnQuc3RhcnRcbiAgICAgICAgOiAxKSArXG4gICAgICAoc3RhdGUub3B0aW9ucy5pbmNyZW1lbnRMaXN0TWFya2VyID09PSBmYWxzZVxuICAgICAgICA/IDBcbiAgICAgICAgOiBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihub2RlKSkgK1xuICAgICAgYnVsbGV0XG4gIH1cblxuICBsZXQgc2l6ZSA9IGJ1bGxldC5sZW5ndGggKyAxXG5cbiAgaWYgKFxuICAgIGxpc3RJdGVtSW5kZW50ID09PSAndGFiJyB8fFxuICAgIChsaXN0SXRlbUluZGVudCA9PT0gJ21peGVkJyAmJlxuICAgICAgKChwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09ICdsaXN0JyAmJiBwYXJlbnQuc3ByZWFkKSB8fCBub2RlLnNwcmVhZCkpXG4gICkge1xuICAgIHNpemUgPSBNYXRoLmNlaWwoc2l6ZSAvIDQpICogNFxuICB9XG5cbiAgY29uc3QgdHJhY2tlciA9IHN0YXRlLmNyZWF0ZVRyYWNrZXIoaW5mbylcbiAgdHJhY2tlci5tb3ZlKGJ1bGxldCArICcgJy5yZXBlYXQoc2l6ZSAtIGJ1bGxldC5sZW5ndGgpKVxuICB0cmFja2VyLnNoaWZ0KHNpemUpXG4gIGNvbnN0IGV4aXQgPSBzdGF0ZS5lbnRlcignbGlzdEl0ZW0nKVxuICBjb25zdCB2YWx1ZSA9IHN0YXRlLmluZGVudExpbmVzKFxuICAgIHN0YXRlLmNvbnRhaW5lckZsb3cobm9kZSwgdHJhY2tlci5jdXJyZW50KCkpLFxuICAgIG1hcFxuICApXG4gIGV4aXQoKVxuXG4gIHJldHVybiB2YWx1ZVxuXG4gIC8qKiBAdHlwZSB7TWFwfSAqL1xuICBmdW5jdGlvbiBtYXAobGluZSwgaW5kZXgsIGJsYW5rKSB7XG4gICAgaWYgKGluZGV4KSB7XG4gICAgICByZXR1cm4gKGJsYW5rID8gJycgOiAnICcucmVwZWF0KHNpemUpKSArIGxpbmVcbiAgICB9XG5cbiAgICByZXR1cm4gKGJsYW5rID8gYnVsbGV0IDogYnVsbGV0ICsgJyAnLnJlcGVhdChzaXplIC0gYnVsbGV0Lmxlbmd0aCkpICsgbGluZVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/list-item.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/list.js":
/*!****************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/list.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   list: () => (/* binding */ list)\n/* harmony export */ });\n/* harmony import */ var _util_check_bullet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/check-bullet.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-bullet.js\");\n/* harmony import */ var _util_check_bullet_other_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/check-bullet-other.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js\");\n/* harmony import */ var _util_check_bullet_ordered_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/check-bullet-ordered.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js\");\n/* harmony import */ var _util_check_rule_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/check-rule.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-rule.js\");\n/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {List, Parents} from 'mdast'\n */\n\n\n\n\n\n\n/**\n * @param {List} node\n * @param {Parents | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nfunction list(node, parent, state, info) {\n  const exit = state.enter('list')\n  const bulletCurrent = state.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? (0,_util_check_bullet_ordered_js__WEBPACK_IMPORTED_MODULE_0__.checkBulletOrdered)(state) : (0,_util_check_bullet_js__WEBPACK_IMPORTED_MODULE_1__.checkBullet)(state)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? bullet === '.'\n      ? ')'\n      : '.'\n    : (0,_util_check_bullet_other_js__WEBPACK_IMPORTED_MODULE_2__.checkBulletOther)(state)\n  let useDifferentMarker =\n    parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If theres an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      state.stack[state.stack.length - 1] === 'list' &&\n      state.stack[state.stack.length - 2] === 'listItem' &&\n      state.stack[state.stack.length - 3] === 'list' &&\n      state.stack[state.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 &&\n      state.indexStack[state.indexStack.length - 2] === 0 &&\n      state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If theres a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // because otherwise it would become one big thematic break.\n    if ((0,_util_check_rule_js__WEBPACK_IMPORTED_MODULE_3__.checkRule)(state) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  state.bulletCurrent = bullet\n  const value = state.containerFlow(node, info)\n  state.bulletLastUsed = bullet\n  state.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvbGlzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVksZUFBZTtBQUMzQjs7QUFFbUQ7QUFDVztBQUNJO0FBQ25COztBQUUvQztBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQiw4QkFBOEIsaUZBQWtCLFVBQVUsa0VBQVc7QUFDckUsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw2RUFBZ0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOERBQVM7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL2hhbmRsZS9saXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7SW5mbywgU3RhdGV9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nXG4gKiBAaW1wb3J0IHtMaXN0LCBQYXJlbnRzfSBmcm9tICdtZGFzdCdcbiAqL1xuXG5pbXBvcnQge2NoZWNrQnVsbGV0fSBmcm9tICcuLi91dGlsL2NoZWNrLWJ1bGxldC5qcydcbmltcG9ydCB7Y2hlY2tCdWxsZXRPdGhlcn0gZnJvbSAnLi4vdXRpbC9jaGVjay1idWxsZXQtb3RoZXIuanMnXG5pbXBvcnQge2NoZWNrQnVsbGV0T3JkZXJlZH0gZnJvbSAnLi4vdXRpbC9jaGVjay1idWxsZXQtb3JkZXJlZC5qcydcbmltcG9ydCB7Y2hlY2tSdWxlfSBmcm9tICcuLi91dGlsL2NoZWNrLXJ1bGUuanMnXG5cbi8qKlxuICogQHBhcmFtIHtMaXN0fSBub2RlXG4gKiBAcGFyYW0ge1BhcmVudHMgfCB1bmRlZmluZWR9IHBhcmVudFxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7SW5mb30gaW5mb1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3Qobm9kZSwgcGFyZW50LCBzdGF0ZSwgaW5mbykge1xuICBjb25zdCBleGl0ID0gc3RhdGUuZW50ZXIoJ2xpc3QnKVxuICBjb25zdCBidWxsZXRDdXJyZW50ID0gc3RhdGUuYnVsbGV0Q3VycmVudFxuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgbGV0IGJ1bGxldCA9IG5vZGUub3JkZXJlZCA/IGNoZWNrQnVsbGV0T3JkZXJlZChzdGF0ZSkgOiBjaGVja0J1bGxldChzdGF0ZSlcbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIGNvbnN0IGJ1bGxldE90aGVyID0gbm9kZS5vcmRlcmVkXG4gICAgPyBidWxsZXQgPT09ICcuJ1xuICAgICAgPyAnKSdcbiAgICAgIDogJy4nXG4gICAgOiBjaGVja0J1bGxldE90aGVyKHN0YXRlKVxuICBsZXQgdXNlRGlmZmVyZW50TWFya2VyID1cbiAgICBwYXJlbnQgJiYgc3RhdGUuYnVsbGV0TGFzdFVzZWQgPyBidWxsZXQgPT09IHN0YXRlLmJ1bGxldExhc3RVc2VkIDogZmFsc2VcblxuICBpZiAoIW5vZGUub3JkZXJlZCkge1xuICAgIGNvbnN0IGZpcnN0TGlzdEl0ZW0gPSBub2RlLmNoaWxkcmVuID8gbm9kZS5jaGlsZHJlblswXSA6IHVuZGVmaW5lZFxuXG4gICAgLy8gSWYgdGhlcmXigJlzIGFuIGVtcHR5IGZpcnN0IGxpc3QgaXRlbSBkaXJlY3RseSBpbiB0d28gbGlzdCBpdGVtcyxcbiAgICAvLyB3ZSBoYXZlIHRvIHVzZSBhIGRpZmZlcmVudCBidWxsZXQ6XG4gICAgLy9cbiAgICAvLyBgYGBtYXJrZG93blxuICAgIC8vICogLSAqXG4gICAgLy8gYGBgXG4gICAgLy9cbiAgICAvLyDigKZiZWNhdXNlIG90aGVyd2lzZSBpdCB3b3VsZCBiZWNvbWUgb25lIGJpZyB0aGVtYXRpYyBicmVhay5cbiAgICBpZiAoXG4gICAgICAvLyBCdWxsZXQgY291bGQgYmUgdXNlZCBhcyBhIHRoZW1hdGljIGJyZWFrIG1hcmtlcjpcbiAgICAgIChidWxsZXQgPT09ICcqJyB8fCBidWxsZXQgPT09ICctJykgJiZcbiAgICAgIC8vIEVtcHR5IGZpcnN0IGxpc3QgaXRlbTpcbiAgICAgIGZpcnN0TGlzdEl0ZW0gJiZcbiAgICAgICghZmlyc3RMaXN0SXRlbS5jaGlsZHJlbiB8fCAhZmlyc3RMaXN0SXRlbS5jaGlsZHJlblswXSkgJiZcbiAgICAgIC8vIERpcmVjdGx5IGluIHR3byBvdGhlciBsaXN0IGl0ZW1zOlxuICAgICAgc3RhdGUuc3RhY2tbc3RhdGUuc3RhY2subGVuZ3RoIC0gMV0gPT09ICdsaXN0JyAmJlxuICAgICAgc3RhdGUuc3RhY2tbc3RhdGUuc3RhY2subGVuZ3RoIC0gMl0gPT09ICdsaXN0SXRlbScgJiZcbiAgICAgIHN0YXRlLnN0YWNrW3N0YXRlLnN0YWNrLmxlbmd0aCAtIDNdID09PSAnbGlzdCcgJiZcbiAgICAgIHN0YXRlLnN0YWNrW3N0YXRlLnN0YWNrLmxlbmd0aCAtIDRdID09PSAnbGlzdEl0ZW0nICYmXG4gICAgICAvLyBUaGF0IGFyZSBlYWNoIHRoZSBmaXJzdCBjaGlsZC5cbiAgICAgIHN0YXRlLmluZGV4U3RhY2tbc3RhdGUuaW5kZXhTdGFjay5sZW5ndGggLSAxXSA9PT0gMCAmJlxuICAgICAgc3RhdGUuaW5kZXhTdGFja1tzdGF0ZS5pbmRleFN0YWNrLmxlbmd0aCAtIDJdID09PSAwICYmXG4gICAgICBzdGF0ZS5pbmRleFN0YWNrW3N0YXRlLmluZGV4U3RhY2subGVuZ3RoIC0gM10gPT09IDBcbiAgICApIHtcbiAgICAgIHVzZURpZmZlcmVudE1hcmtlciA9IHRydWVcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZeKAmXMgYSB0aGVtYXRpYyBicmVhayBhdCB0aGUgc3RhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbSxcbiAgICAvLyB3ZSBoYXZlIHRvIHVzZSBhIGRpZmZlcmVudCBidWxsZXQ6XG4gICAgLy9cbiAgICAvLyBgYGBtYXJrZG93blxuICAgIC8vICogLS0tXG4gICAgLy8gYGBgXG4gICAgLy9cbiAgICAvLyDigKZiZWNhdXNlIG90aGVyd2lzZSBpdCB3b3VsZCBiZWNvbWUgb25lIGJpZyB0aGVtYXRpYyBicmVhay5cbiAgICBpZiAoY2hlY2tSdWxlKHN0YXRlKSA9PT0gYnVsbGV0ICYmIGZpcnN0TGlzdEl0ZW0pIHtcbiAgICAgIGxldCBpbmRleCA9IC0xXG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IG5vZGUuY2hpbGRyZW5baW5kZXhdXG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGl0ZW0gJiZcbiAgICAgICAgICBpdGVtLnR5cGUgPT09ICdsaXN0SXRlbScgJiZcbiAgICAgICAgICBpdGVtLmNoaWxkcmVuICYmXG4gICAgICAgICAgaXRlbS5jaGlsZHJlblswXSAmJlxuICAgICAgICAgIGl0ZW0uY2hpbGRyZW5bMF0udHlwZSA9PT0gJ3RoZW1hdGljQnJlYWsnXG4gICAgICAgICkge1xuICAgICAgICAgIHVzZURpZmZlcmVudE1hcmtlciA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHVzZURpZmZlcmVudE1hcmtlcikge1xuICAgIGJ1bGxldCA9IGJ1bGxldE90aGVyXG4gIH1cblxuICBzdGF0ZS5idWxsZXRDdXJyZW50ID0gYnVsbGV0XG4gIGNvbnN0IHZhbHVlID0gc3RhdGUuY29udGFpbmVyRmxvdyhub2RlLCBpbmZvKVxuICBzdGF0ZS5idWxsZXRMYXN0VXNlZCA9IGJ1bGxldFxuICBzdGF0ZS5idWxsZXRDdXJyZW50ID0gYnVsbGV0Q3VycmVudFxuICBleGl0KClcbiAgcmV0dXJuIHZhbHVlXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/list.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/paragraph.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/paragraph.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   paragraph: () => (/* binding */ paragraph)\n/* harmony export */ });\n/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Paragraph, Parents} from 'mdast'\n */\n\n/**\n * @param {Paragraph} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nfunction paragraph(node, _, state, info) {\n  const exit = state.enter('paragraph')\n  const subexit = state.enter('phrasing')\n  const value = state.containerPhrasing(node, info)\n  subexit()\n  exit()\n  return value\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvcGFyYWdyYXBoLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLG9CQUFvQjtBQUNoQzs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL2hhbmRsZS9wYXJhZ3JhcGguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtJbmZvLCBTdGF0ZX0gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bidcbiAqIEBpbXBvcnQge1BhcmFncmFwaCwgUGFyZW50c30gZnJvbSAnbWRhc3QnXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge1BhcmFncmFwaH0gbm9kZVxuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBfXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtJbmZvfSBpbmZvXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyYWdyYXBoKG5vZGUsIF8sIHN0YXRlLCBpbmZvKSB7XG4gIGNvbnN0IGV4aXQgPSBzdGF0ZS5lbnRlcigncGFyYWdyYXBoJylcbiAgY29uc3Qgc3ViZXhpdCA9IHN0YXRlLmVudGVyKCdwaHJhc2luZycpXG4gIGNvbnN0IHZhbHVlID0gc3RhdGUuY29udGFpbmVyUGhyYXNpbmcobm9kZSwgaW5mbylcbiAgc3ViZXhpdCgpXG4gIGV4aXQoKVxuICByZXR1cm4gdmFsdWVcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/paragraph.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/root.js":
/*!****************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/root.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   root: () => (/* binding */ root)\n/* harmony export */ });\n/* harmony import */ var mdast_util_phrasing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mdast-util-phrasing */ \"(app-pages-browser)/./node_modules/mdast-util-phrasing/lib/index.js\");\n/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Root} from 'mdast'\n */\n\n\n\n/**\n * @param {Root} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nfunction root(node, _, state, info) {\n  // Note: `html` nodes are ambiguous.\n  const hasPhrasing = node.children.some(function (d) {\n    return (0,mdast_util_phrasing__WEBPACK_IMPORTED_MODULE_0__.phrasing)(d)\n  })\n\n  const container = hasPhrasing ? state.containerPhrasing : state.containerFlow\n  return container.call(state, node, info)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvcm9vdC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVksZUFBZTtBQUMzQjs7QUFFNEM7O0FBRTVDO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0EsV0FBVyw2REFBUTtBQUNuQixHQUFHOztBQUVIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvaGFuZGxlL3Jvb3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtJbmZvLCBTdGF0ZX0gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bidcbiAqIEBpbXBvcnQge1BhcmVudHMsIFJvb3R9IGZyb20gJ21kYXN0J1xuICovXG5cbmltcG9ydCB7cGhyYXNpbmd9IGZyb20gJ21kYXN0LXV0aWwtcGhyYXNpbmcnXG5cbi8qKlxuICogQHBhcmFtIHtSb290fSBub2RlXG4gKiBAcGFyYW0ge1BhcmVudHMgfCB1bmRlZmluZWR9IF9cbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge0luZm99IGluZm9cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb290KG5vZGUsIF8sIHN0YXRlLCBpbmZvKSB7XG4gIC8vIE5vdGU6IGBodG1sYCBub2RlcyBhcmUgYW1iaWd1b3VzLlxuICBjb25zdCBoYXNQaHJhc2luZyA9IG5vZGUuY2hpbGRyZW4uc29tZShmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBwaHJhc2luZyhkKVxuICB9KVxuXG4gIGNvbnN0IGNvbnRhaW5lciA9IGhhc1BocmFzaW5nID8gc3RhdGUuY29udGFpbmVyUGhyYXNpbmcgOiBzdGF0ZS5jb250YWluZXJGbG93XG4gIHJldHVybiBjb250YWluZXIuY2FsbChzdGF0ZSwgbm9kZSwgaW5mbylcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/root.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/strong.js":
/*!******************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/strong.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   strong: () => (/* binding */ strong)\n/* harmony export */ });\n/* harmony import */ var _util_check_strong_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/check-strong.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-strong.js\");\n/* harmony import */ var _util_encode_character_reference_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/encode-character-reference.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js\");\n/* harmony import */ var _util_encode_info_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/encode-info.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/encode-info.js\");\n/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Strong} from 'mdast'\n */\n\n\n\n\n\nstrong.peek = strongPeek\n\n/**\n * @param {Strong} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nfunction strong(node, _, state, info) {\n  const marker = (0,_util_check_strong_js__WEBPACK_IMPORTED_MODULE_0__.checkStrong)(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  const before = tracker.move(marker + marker)\n\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  )\n  const betweenHead = between.charCodeAt(0)\n  const open = (0,_util_encode_info_js__WEBPACK_IMPORTED_MODULE_1__.encodeInfo)(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  )\n\n  if (open.inside) {\n    between = (0,_util_encode_character_reference_js__WEBPACK_IMPORTED_MODULE_2__.encodeCharacterReference)(betweenHead) + between.slice(1)\n  }\n\n  const betweenTail = between.charCodeAt(between.length - 1)\n  const close = (0,_util_encode_info_js__WEBPACK_IMPORTED_MODULE_1__.encodeInfo)(info.after.charCodeAt(0), betweenTail, marker)\n\n  if (close.inside) {\n    between = between.slice(0, -1) + (0,_util_encode_character_reference_js__WEBPACK_IMPORTED_MODULE_2__.encodeCharacterReference)(betweenTail)\n  }\n\n  const after = tracker.move(marker + marker)\n\n  exit()\n\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  }\n  return before + between + after\n}\n\n/**\n * @param {Strong} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvc3Ryb25nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBLFlBQVksYUFBYTtBQUN6QixZQUFZLGlCQUFpQjtBQUM3Qjs7QUFFbUQ7QUFDMkI7QUFDN0I7O0FBRWpEOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsYUFBYTtBQUNiO0FBQ087QUFDUCxpQkFBaUIsa0VBQVc7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWUsZ0VBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDZGQUF3QjtBQUN0Qzs7QUFFQTtBQUNBLGdCQUFnQixnRUFBVTs7QUFFMUI7QUFDQSxxQ0FBcUMsNkZBQXdCO0FBQzdEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvc3Ryb25nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7SW5mbywgU3RhdGV9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nXG4gKiBAaW1wb3J0IHtQYXJlbnRzLCBTdHJvbmd9IGZyb20gJ21kYXN0J1xuICovXG5cbmltcG9ydCB7Y2hlY2tTdHJvbmd9IGZyb20gJy4uL3V0aWwvY2hlY2stc3Ryb25nLmpzJ1xuaW1wb3J0IHtlbmNvZGVDaGFyYWN0ZXJSZWZlcmVuY2V9IGZyb20gJy4uL3V0aWwvZW5jb2RlLWNoYXJhY3Rlci1yZWZlcmVuY2UuanMnXG5pbXBvcnQge2VuY29kZUluZm99IGZyb20gJy4uL3V0aWwvZW5jb2RlLWluZm8uanMnXG5cbnN0cm9uZy5wZWVrID0gc3Ryb25nUGVla1xuXG4vKipcbiAqIEBwYXJhbSB7U3Ryb25nfSBub2RlXG4gKiBAcGFyYW0ge1BhcmVudHMgfCB1bmRlZmluZWR9IF9cbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge0luZm99IGluZm9cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJvbmcobm9kZSwgXywgc3RhdGUsIGluZm8pIHtcbiAgY29uc3QgbWFya2VyID0gY2hlY2tTdHJvbmcoc3RhdGUpXG4gIGNvbnN0IGV4aXQgPSBzdGF0ZS5lbnRlcignc3Ryb25nJylcbiAgY29uc3QgdHJhY2tlciA9IHN0YXRlLmNyZWF0ZVRyYWNrZXIoaW5mbylcbiAgY29uc3QgYmVmb3JlID0gdHJhY2tlci5tb3ZlKG1hcmtlciArIG1hcmtlcilcblxuICBsZXQgYmV0d2VlbiA9IHRyYWNrZXIubW92ZShcbiAgICBzdGF0ZS5jb250YWluZXJQaHJhc2luZyhub2RlLCB7XG4gICAgICBhZnRlcjogbWFya2VyLFxuICAgICAgYmVmb3JlLFxuICAgICAgLi4udHJhY2tlci5jdXJyZW50KClcbiAgICB9KVxuICApXG4gIGNvbnN0IGJldHdlZW5IZWFkID0gYmV0d2Vlbi5jaGFyQ29kZUF0KDApXG4gIGNvbnN0IG9wZW4gPSBlbmNvZGVJbmZvKFxuICAgIGluZm8uYmVmb3JlLmNoYXJDb2RlQXQoaW5mby5iZWZvcmUubGVuZ3RoIC0gMSksXG4gICAgYmV0d2VlbkhlYWQsXG4gICAgbWFya2VyXG4gIClcblxuICBpZiAob3Blbi5pbnNpZGUpIHtcbiAgICBiZXR3ZWVuID0gZW5jb2RlQ2hhcmFjdGVyUmVmZXJlbmNlKGJldHdlZW5IZWFkKSArIGJldHdlZW4uc2xpY2UoMSlcbiAgfVxuXG4gIGNvbnN0IGJldHdlZW5UYWlsID0gYmV0d2Vlbi5jaGFyQ29kZUF0KGJldHdlZW4ubGVuZ3RoIC0gMSlcbiAgY29uc3QgY2xvc2UgPSBlbmNvZGVJbmZvKGluZm8uYWZ0ZXIuY2hhckNvZGVBdCgwKSwgYmV0d2VlblRhaWwsIG1hcmtlcilcblxuICBpZiAoY2xvc2UuaW5zaWRlKSB7XG4gICAgYmV0d2VlbiA9IGJldHdlZW4uc2xpY2UoMCwgLTEpICsgZW5jb2RlQ2hhcmFjdGVyUmVmZXJlbmNlKGJldHdlZW5UYWlsKVxuICB9XG5cbiAgY29uc3QgYWZ0ZXIgPSB0cmFja2VyLm1vdmUobWFya2VyICsgbWFya2VyKVxuXG4gIGV4aXQoKVxuXG4gIHN0YXRlLmF0dGVudGlvbkVuY29kZVN1cnJvdW5kaW5nSW5mbyA9IHtcbiAgICBhZnRlcjogY2xvc2Uub3V0c2lkZSxcbiAgICBiZWZvcmU6IG9wZW4ub3V0c2lkZVxuICB9XG4gIHJldHVybiBiZWZvcmUgKyBiZXR3ZWVuICsgYWZ0ZXJcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0cm9uZ30gX1xuICogQHBhcmFtIHtQYXJlbnRzIHwgdW5kZWZpbmVkfSBfMVxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHN0cm9uZ1BlZWsoXywgXzEsIHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5vcHRpb25zLnN0cm9uZyB8fCAnKidcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/strong.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/text.js":
/*!****************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/text.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   text: () => (/* binding */ text)\n/* harmony export */ });\n/**\n * @import {Info, State} from 'mdast-util-to-markdown'\n * @import {Parents, Text} from 'mdast'\n */\n\n/**\n * @param {Text} node\n * @param {Parents | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nfunction text(node, _, state, info) {\n  return state.safe(node.value, info)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvdGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSxZQUFZLGFBQWE7QUFDekIsWUFBWSxlQUFlO0FBQzNCOztBQUVBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvdGV4dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge0luZm8sIFN0YXRlfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duJ1xuICogQGltcG9ydCB7UGFyZW50cywgVGV4dH0gZnJvbSAnbWRhc3QnXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge1RleHR9IG5vZGVcbiAqIEBwYXJhbSB7UGFyZW50cyB8IHVuZGVmaW5lZH0gX1xuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7SW5mb30gaW5mb1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHQobm9kZSwgXywgc3RhdGUsIGluZm8pIHtcbiAgcmV0dXJuIHN0YXRlLnNhZmUobm9kZS52YWx1ZSwgaW5mbylcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/text.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   thematicBreak: () => (/* binding */ thematicBreak)\n/* harmony export */ });\n/* harmony import */ var _util_check_rule_repetition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/check-rule-repetition.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js\");\n/* harmony import */ var _util_check_rule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/check-rule.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-rule.js\");\n/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Parents, ThematicBreak} from 'mdast'\n */\n\n\n\n\n/**\n * @param {ThematicBreak} _\n * @param {Parents | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction thematicBreak(_, _1, state) {\n  const value = (\n    (0,_util_check_rule_js__WEBPACK_IMPORTED_MODULE_0__.checkRule)(state) + (state.options.ruleSpaces ? ' ' : '')\n  ).repeat((0,_util_check_rule_repetition_js__WEBPACK_IMPORTED_MODULE_1__.checkRuleRepetition)(state))\n\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi9oYW5kbGUvdGhlbWF0aWMtYnJlYWsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSx3QkFBd0I7QUFDcEM7O0FBRW9FO0FBQ3JCOztBQUUvQztBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBLElBQUksOERBQVM7QUFDYixXQUFXLG1GQUFtQjs7QUFFOUI7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvaGFuZGxlL3RoZW1hdGljLWJyZWFrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7U3RhdGV9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nXG4gKiBAaW1wb3J0IHtQYXJlbnRzLCBUaGVtYXRpY0JyZWFrfSBmcm9tICdtZGFzdCdcbiAqL1xuXG5pbXBvcnQge2NoZWNrUnVsZVJlcGV0aXRpb259IGZyb20gJy4uL3V0aWwvY2hlY2stcnVsZS1yZXBldGl0aW9uLmpzJ1xuaW1wb3J0IHtjaGVja1J1bGV9IGZyb20gJy4uL3V0aWwvY2hlY2stcnVsZS5qcydcblxuLyoqXG4gKiBAcGFyYW0ge1RoZW1hdGljQnJlYWt9IF9cbiAqIEBwYXJhbSB7UGFyZW50cyB8IHVuZGVmaW5lZH0gXzFcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhlbWF0aWNCcmVhayhfLCBfMSwgc3RhdGUpIHtcbiAgY29uc3QgdmFsdWUgPSAoXG4gICAgY2hlY2tSdWxlKHN0YXRlKSArIChzdGF0ZS5vcHRpb25zLnJ1bGVTcGFjZXMgPyAnICcgOiAnJylcbiAgKS5yZXBlYXQoY2hlY2tSdWxlUmVwZXRpdGlvbihzdGF0ZSkpXG5cbiAgcmV0dXJuIHN0YXRlLm9wdGlvbnMucnVsZVNwYWNlcyA/IHZhbHVlLnNsaWNlKDAsIC0xKSA6IHZhbHVlXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkBulletOrdered: () => (/* binding */ checkBulletOrdered)\n/* harmony export */ });\n/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nfunction checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2NoZWNrLWJ1bGxldC1vcmRlcmVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC9jaGVjay1idWxsZXQtb3JkZXJlZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge09wdGlvbnMsIFN0YXRlfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duJ1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEByZXR1cm5zIHtFeGNsdWRlPE9wdGlvbnNbJ2J1bGxldE9yZGVyZWQnXSwgbnVsbCB8IHVuZGVmaW5lZD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0J1bGxldE9yZGVyZWQoc3RhdGUpIHtcbiAgY29uc3QgbWFya2VyID0gc3RhdGUub3B0aW9ucy5idWxsZXRPcmRlcmVkIHx8ICcuJ1xuXG4gIGlmIChtYXJrZXIgIT09ICcuJyAmJiBtYXJrZXIgIT09ICcpJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDYW5ub3Qgc2VyaWFsaXplIGl0ZW1zIHdpdGggYCcgK1xuICAgICAgICBtYXJrZXIgK1xuICAgICAgICAnYCBmb3IgYG9wdGlvbnMuYnVsbGV0T3JkZXJlZGAsIGV4cGVjdGVkIGAuYCBvciBgKWAnXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIG1hcmtlclxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkBulletOther: () => (/* binding */ checkBulletOther)\n/* harmony export */ });\n/* harmony import */ var _check_bullet_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./check-bullet.js */ \"(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-bullet.js\");\n/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nfunction checkBulletOther(state) {\n  const bullet = (0,_check_bullet_js__WEBPACK_IMPORTED_MODULE_0__.checkBullet)(state)\n  const bulletOther = state.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2NoZWNrLWJ1bGxldC1vdGhlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7O0FBRTZDOztBQUU3QztBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDTztBQUNQLGlCQUFpQiw2REFBVztBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvY2hlY2stYnVsbGV0LW90aGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7T3B0aW9ucywgU3RhdGV9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nXG4gKi9cblxuaW1wb3J0IHtjaGVja0J1bGxldH0gZnJvbSAnLi9jaGVjay1idWxsZXQuanMnXG5cbi8qKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEByZXR1cm5zIHtFeGNsdWRlPE9wdGlvbnNbJ2J1bGxldCddLCBudWxsIHwgdW5kZWZpbmVkPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrQnVsbGV0T3RoZXIoc3RhdGUpIHtcbiAgY29uc3QgYnVsbGV0ID0gY2hlY2tCdWxsZXQoc3RhdGUpXG4gIGNvbnN0IGJ1bGxldE90aGVyID0gc3RhdGUub3B0aW9ucy5idWxsZXRPdGhlclxuXG4gIGlmICghYnVsbGV0T3RoZXIpIHtcbiAgICByZXR1cm4gYnVsbGV0ID09PSAnKicgPyAnLScgOiAnKidcbiAgfVxuXG4gIGlmIChidWxsZXRPdGhlciAhPT0gJyonICYmIGJ1bGxldE90aGVyICE9PSAnKycgJiYgYnVsbGV0T3RoZXIgIT09ICctJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDYW5ub3Qgc2VyaWFsaXplIGl0ZW1zIHdpdGggYCcgK1xuICAgICAgICBidWxsZXRPdGhlciArXG4gICAgICAgICdgIGZvciBgb3B0aW9ucy5idWxsZXRPdGhlcmAsIGV4cGVjdGVkIGAqYCwgYCtgLCBvciBgLWAnXG4gICAgKVxuICB9XG5cbiAgaWYgKGJ1bGxldE90aGVyID09PSBidWxsZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRXhwZWN0ZWQgYGJ1bGxldGAgKGAnICtcbiAgICAgICAgYnVsbGV0ICtcbiAgICAgICAgJ2ApIGFuZCBgYnVsbGV0T3RoZXJgIChgJyArXG4gICAgICAgIGJ1bGxldE90aGVyICtcbiAgICAgICAgJ2ApIHRvIGJlIGRpZmZlcmVudCdcbiAgICApXG4gIH1cblxuICByZXR1cm4gYnVsbGV0T3RoZXJcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-bullet.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/util/check-bullet.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkBullet: () => (/* binding */ checkBullet)\n/* harmony export */ });\n/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nfunction checkBullet(state) {\n  const marker = state.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2NoZWNrLWJ1bGxldC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSxZQUFZLGdCQUFnQjtBQUM1Qjs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvY2hlY2stYnVsbGV0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7T3B0aW9ucywgU3RhdGV9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHJldHVybnMge0V4Y2x1ZGU8T3B0aW9uc1snYnVsbGV0J10sIG51bGwgfCB1bmRlZmluZWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tCdWxsZXQoc3RhdGUpIHtcbiAgY29uc3QgbWFya2VyID0gc3RhdGUub3B0aW9ucy5idWxsZXQgfHwgJyonXG5cbiAgaWYgKG1hcmtlciAhPT0gJyonICYmIG1hcmtlciAhPT0gJysnICYmIG1hcmtlciAhPT0gJy0nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0Nhbm5vdCBzZXJpYWxpemUgaXRlbXMgd2l0aCBgJyArXG4gICAgICAgIG1hcmtlciArXG4gICAgICAgICdgIGZvciBgb3B0aW9ucy5idWxsZXRgLCBleHBlY3RlZCBgKmAsIGArYCwgb3IgYC1gJ1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBtYXJrZXJcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-bullet.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js":
/*!************************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkEmphasis: () => (/* binding */ checkEmphasis)\n/* harmony export */ });\n/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nfunction checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2NoZWNrLWVtcGhhc2lzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC9jaGVjay1lbXBoYXNpcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge09wdGlvbnMsIFN0YXRlfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duJ1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEByZXR1cm5zIHtFeGNsdWRlPE9wdGlvbnNbJ2VtcGhhc2lzJ10sIG51bGwgfCB1bmRlZmluZWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tFbXBoYXNpcyhzdGF0ZSkge1xuICBjb25zdCBtYXJrZXIgPSBzdGF0ZS5vcHRpb25zLmVtcGhhc2lzIHx8ICcqJ1xuXG4gIGlmIChtYXJrZXIgIT09ICcqJyAmJiBtYXJrZXIgIT09ICdfJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDYW5ub3Qgc2VyaWFsaXplIGVtcGhhc2lzIHdpdGggYCcgK1xuICAgICAgICBtYXJrZXIgK1xuICAgICAgICAnYCBmb3IgYG9wdGlvbnMuZW1waGFzaXNgLCBleHBlY3RlZCBgKmAsIG9yIGBfYCdcbiAgICApXG4gIH1cblxuICByZXR1cm4gbWFya2VyXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-fence.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/util/check-fence.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkFence: () => (/* binding */ checkFence)\n/* harmony export */ });\n/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['fence'], null | undefined>}\n */\nfunction checkFence(state) {\n  const marker = state.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2NoZWNrLWZlbmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC9jaGVjay1mZW5jZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge09wdGlvbnMsIFN0YXRlfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duJ1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEByZXR1cm5zIHtFeGNsdWRlPE9wdGlvbnNbJ2ZlbmNlJ10sIG51bGwgfCB1bmRlZmluZWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tGZW5jZShzdGF0ZSkge1xuICBjb25zdCBtYXJrZXIgPSBzdGF0ZS5vcHRpb25zLmZlbmNlIHx8ICdgJ1xuXG4gIGlmIChtYXJrZXIgIT09ICdgJyAmJiBtYXJrZXIgIT09ICd+Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDYW5ub3Qgc2VyaWFsaXplIGNvZGUgd2l0aCBgJyArXG4gICAgICAgIG1hcmtlciArXG4gICAgICAgICdgIGZvciBgb3B0aW9ucy5mZW5jZWAsIGV4cGVjdGVkIGBgIGAgYGAgb3IgYH5gJ1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBtYXJrZXJcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-fence.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkListItemIndent: () => (/* binding */ checkListItemIndent)\n/* harmony export */ });\n/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['listItemIndent'], null | undefined>}\n */\nfunction checkListItemIndent(state) {\n  const style = state.options.listItemIndent || 'one'\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2NoZWNrLWxpc3QtaXRlbS1pbmRlbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2NoZWNrLWxpc3QtaXRlbS1pbmRlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtPcHRpb25zLCBTdGF0ZX0gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bidcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcmV0dXJucyB7RXhjbHVkZTxPcHRpb25zWydsaXN0SXRlbUluZGVudCddLCBudWxsIHwgdW5kZWZpbmVkPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrTGlzdEl0ZW1JbmRlbnQoc3RhdGUpIHtcbiAgY29uc3Qgc3R5bGUgPSBzdGF0ZS5vcHRpb25zLmxpc3RJdGVtSW5kZW50IHx8ICdvbmUnXG5cbiAgaWYgKHN0eWxlICE9PSAndGFiJyAmJiBzdHlsZSAhPT0gJ29uZScgJiYgc3R5bGUgIT09ICdtaXhlZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQ2Fubm90IHNlcmlhbGl6ZSBpdGVtcyB3aXRoIGAnICtcbiAgICAgICAgc3R5bGUgK1xuICAgICAgICAnYCBmb3IgYG9wdGlvbnMubGlzdEl0ZW1JbmRlbnRgLCBleHBlY3RlZCBgdGFiYCwgYG9uZWAsIG9yIGBtaXhlZGAnXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHN0eWxlXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-quote.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/util/check-quote.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkQuote: () => (/* binding */ checkQuote)\n/* harmony export */ });\n/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nfunction checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2NoZWNrLXF1b3RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC9jaGVjay1xdW90ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge09wdGlvbnMsIFN0YXRlfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duJ1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEByZXR1cm5zIHtFeGNsdWRlPE9wdGlvbnNbJ3F1b3RlJ10sIG51bGwgfCB1bmRlZmluZWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tRdW90ZShzdGF0ZSkge1xuICBjb25zdCBtYXJrZXIgPSBzdGF0ZS5vcHRpb25zLnF1b3RlIHx8ICdcIidcblxuICBpZiAobWFya2VyICE9PSAnXCInICYmIG1hcmtlciAhPT0gXCInXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQ2Fubm90IHNlcmlhbGl6ZSB0aXRsZSB3aXRoIGAnICtcbiAgICAgICAgbWFya2VyICtcbiAgICAgICAgJ2AgZm9yIGBvcHRpb25zLnF1b3RlYCwgZXhwZWN0ZWQgYFwiYCwgb3IgYFxcJ2AnXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIG1hcmtlclxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-quote.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkRuleRepetition: () => (/* binding */ checkRuleRepetition)\n/* harmony export */ });\n/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\n */\nfunction checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2NoZWNrLXJ1bGUtcmVwZXRpdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSxZQUFZLGdCQUFnQjtBQUM1Qjs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvY2hlY2stcnVsZS1yZXBldGl0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7T3B0aW9ucywgU3RhdGV9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHJldHVybnMge0V4Y2x1ZGU8T3B0aW9uc1sncnVsZVJlcGV0aXRpb24nXSwgbnVsbCB8IHVuZGVmaW5lZD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1J1bGVSZXBldGl0aW9uKHN0YXRlKSB7XG4gIGNvbnN0IHJlcGV0aXRpb24gPSBzdGF0ZS5vcHRpb25zLnJ1bGVSZXBldGl0aW9uIHx8IDNcblxuICBpZiAocmVwZXRpdGlvbiA8IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQ2Fubm90IHNlcmlhbGl6ZSBydWxlcyB3aXRoIHJlcGV0aXRpb24gYCcgK1xuICAgICAgICByZXBldGl0aW9uICtcbiAgICAgICAgJ2AgZm9yIGBvcHRpb25zLnJ1bGVSZXBldGl0aW9uYCwgZXhwZWN0ZWQgYDNgIG9yIG1vcmUnXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHJlcGV0aXRpb25cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-rule.js":
/*!********************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/util/check-rule.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkRule: () => (/* binding */ checkRule)\n/* harmony export */ });\n/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['rule'], null | undefined>}\n */\nfunction checkRule(state) {\n  const marker = state.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2NoZWNrLXJ1bGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2NoZWNrLXJ1bGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtPcHRpb25zLCBTdGF0ZX0gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bidcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcmV0dXJucyB7RXhjbHVkZTxPcHRpb25zWydydWxlJ10sIG51bGwgfCB1bmRlZmluZWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSdWxlKHN0YXRlKSB7XG4gIGNvbnN0IG1hcmtlciA9IHN0YXRlLm9wdGlvbnMucnVsZSB8fCAnKidcblxuICBpZiAobWFya2VyICE9PSAnKicgJiYgbWFya2VyICE9PSAnLScgJiYgbWFya2VyICE9PSAnXycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQ2Fubm90IHNlcmlhbGl6ZSBydWxlcyB3aXRoIGAnICtcbiAgICAgICAgbWFya2VyICtcbiAgICAgICAgJ2AgZm9yIGBvcHRpb25zLnJ1bGVgLCBleHBlY3RlZCBgKmAsIGAtYCwgb3IgYF9gJ1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBtYXJrZXJcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-rule.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-strong.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/util/check-strong.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkStrong: () => (/* binding */ checkStrong)\n/* harmony export */ });\n/**\n * @import {Options, State} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nfunction checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2NoZWNrLXN0cm9uZy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSxZQUFZLGdCQUFnQjtBQUM1Qjs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvY2hlY2stc3Ryb25nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7T3B0aW9ucywgU3RhdGV9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogQHJldHVybnMge0V4Y2x1ZGU8T3B0aW9uc1snc3Ryb25nJ10sIG51bGwgfCB1bmRlZmluZWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tTdHJvbmcoc3RhdGUpIHtcbiAgY29uc3QgbWFya2VyID0gc3RhdGUub3B0aW9ucy5zdHJvbmcgfHwgJyonXG5cbiAgaWYgKG1hcmtlciAhPT0gJyonICYmIG1hcmtlciAhPT0gJ18nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0Nhbm5vdCBzZXJpYWxpemUgc3Ryb25nIHdpdGggYCcgK1xuICAgICAgICBtYXJrZXIgK1xuICAgICAgICAnYCBmb3IgYG9wdGlvbnMuc3Ryb25nYCwgZXhwZWN0ZWQgYCpgLCBvciBgX2AnXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIG1hcmtlclxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/check-strong.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js":
/*!************************************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeCharacterReference: () => (/* binding */ encodeCharacterReference)\n/* harmony export */ });\n/**\n * Encode a code point as a character reference.\n *\n * @param {number} code\n *   Code point to encode.\n * @returns {string}\n *   Encoded character reference.\n */\nfunction encodeCharacterReference(code) {\n  return '&#x' + code.toString(16).toUpperCase() + ';'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2VuY29kZS1jaGFyYWN0ZXItcmVmZXJlbmNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1AscURBQXFEO0FBQ3JEIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2VuY29kZS1jaGFyYWN0ZXItcmVmZXJlbmNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRW5jb2RlIGEgY29kZSBwb2ludCBhcyBhIGNoYXJhY3RlciByZWZlcmVuY2UuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqICAgQ29kZSBwb2ludCB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogICBFbmNvZGVkIGNoYXJhY3RlciByZWZlcmVuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVDaGFyYWN0ZXJSZWZlcmVuY2UoY29kZSkge1xuICByZXR1cm4gJyYjeCcgKyBjb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgJzsnXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/encode-info.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/util/encode-info.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeInfo: () => (/* binding */ encodeInfo)\n/* harmony export */ });\n/* harmony import */ var micromark_util_classify_character__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-classify-character */ \"(app-pages-browser)/./node_modules/micromark-util-classify-character/dev/index.js\");\n/**\n * @import {EncodeSides} from '../types.js'\n */\n\n\n\n/**\n * Check whether to encode (as a character reference) the characters\n * surrounding an attention run.\n *\n * Which characters are around an attention run influence whether it works or\n * not.\n *\n * See <https://github.com/orgs/syntax-tree/discussions/60> for more info.\n * See this markdown in a particular renderer to see what works:\n *\n * ```markdown\n * |                         | A (letter inside) | B (punctuation inside) | C (whitespace inside) | D (nothing inside) |\n * | ----------------------- | ----------------- | ---------------------- | --------------------- | ------------------ |\n * | 1 (letter outside)      | x*y*z             | x*.*z                  | x* *z                 | x**z               |\n * | 2 (punctuation outside) | .*y*.             | .*.*.                  | .* *.                 | .**.               |\n * | 3 (whitespace outside)  | x *y* z           | x *.* z                | x * * z               | x ** z             |\n * | 4 (nothing outside)     | *x*               | *.*                    | * *                   | **                 |\n * ```\n *\n * @param {number} outside\n *   Code point on the outer side of the run.\n * @param {number} inside\n *   Code point on the inner side of the run.\n * @param {'*' | '_'} marker\n *   Marker of the run.\n *   Underscores are handled more strictly (they form less often) than\n *   asterisks.\n * @returns {EncodeSides}\n *   Whether to encode characters.\n */\n// Important: punctuation must never be encoded.\n// Punctuation is solely used by markdown constructs.\n// And by encoding itself.\n// Encoding them will break constructs or double encode things.\nfunction encodeInfo(outside, inside, marker) {\n  const outsideKind = (0,micromark_util_classify_character__WEBPACK_IMPORTED_MODULE_0__.classifyCharacter)(outside)\n  const insideKind = (0,micromark_util_classify_character__WEBPACK_IMPORTED_MODULE_0__.classifyCharacter)(inside)\n\n  // Letter outside:\n  if (outsideKind === undefined) {\n    return insideKind === undefined\n      ? // Letter inside:\n        // we have to encode *both* letters for `_` as it is looser.\n        // it already forms for `*` (and GFMs `~`).\n        marker === '_'\n        ? {inside: true, outside: true}\n        : {inside: false, outside: false}\n      : insideKind === 1\n        ? // Whitespace inside: encode both (letter, whitespace).\n          {inside: true, outside: true}\n        : // Punctuation inside: encode outer (letter)\n          {inside: false, outside: true}\n  }\n\n  // Whitespace outside:\n  if (outsideKind === 1) {\n    return insideKind === undefined\n      ? // Letter inside: already forms.\n        {inside: false, outside: false}\n      : insideKind === 1\n        ? // Whitespace inside: encode both (whitespace).\n          {inside: true, outside: true}\n        : // Punctuation inside: already forms.\n          {inside: false, outside: false}\n  }\n\n  // Punctuation outside:\n  return insideKind === undefined\n    ? // Letter inside: already forms.\n      {inside: false, outside: false}\n    : insideKind === 1\n      ? // Whitespace inside: encode inner (whitespace).\n        {inside: true, outside: false}\n      : // Punctuation inside: already forms.\n        {inside: false, outside: false}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2VuY29kZS1pbmZvLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQSxZQUFZLGFBQWE7QUFDekI7O0FBRW1FOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxzQkFBc0Isb0ZBQWlCO0FBQ3ZDLHFCQUFxQixvRkFBaUI7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvZW5jb2RlLWluZm8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtFbmNvZGVTaWRlc30gZnJvbSAnLi4vdHlwZXMuanMnXG4gKi9cblxuaW1wb3J0IHtjbGFzc2lmeUNoYXJhY3Rlcn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2xhc3NpZnktY2hhcmFjdGVyJ1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdG8gZW5jb2RlIChhcyBhIGNoYXJhY3RlciByZWZlcmVuY2UpIHRoZSBjaGFyYWN0ZXJzXG4gKiBzdXJyb3VuZGluZyBhbiBhdHRlbnRpb24gcnVuLlxuICpcbiAqIFdoaWNoIGNoYXJhY3RlcnMgYXJlIGFyb3VuZCBhbiBhdHRlbnRpb24gcnVuIGluZmx1ZW5jZSB3aGV0aGVyIGl0IHdvcmtzIG9yXG4gKiBub3QuXG4gKlxuICogU2VlIDxodHRwczovL2dpdGh1Yi5jb20vb3Jncy9zeW50YXgtdHJlZS9kaXNjdXNzaW9ucy82MD4gZm9yIG1vcmUgaW5mby5cbiAqIFNlZSB0aGlzIG1hcmtkb3duIGluIGEgcGFydGljdWxhciByZW5kZXJlciB0byBzZWUgd2hhdCB3b3JrczpcbiAqXG4gKiBgYGBtYXJrZG93blxuICogfCAgICAgICAgICAgICAgICAgICAgICAgICB8IEEgKGxldHRlciBpbnNpZGUpIHwgQiAocHVuY3R1YXRpb24gaW5zaWRlKSB8IEMgKHdoaXRlc3BhY2UgaW5zaWRlKSB8IEQgKG5vdGhpbmcgaW5zaWRlKSB8XG4gKiB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tIHxcbiAqIHwgMSAobGV0dGVyIG91dHNpZGUpICAgICAgfCB4KnkqeiAgICAgICAgICAgICB8IHgqLip6ICAgICAgICAgICAgICAgICAgfCB4KiAqeiAgICAgICAgICAgICAgICAgfCB4Kip6ICAgICAgICAgICAgICAgfFxuICogfCAyIChwdW5jdHVhdGlvbiBvdXRzaWRlKSB8IC4qeSouICAgICAgICAgICAgIHwgLiouKi4gICAgICAgICAgICAgICAgICB8IC4qICouICAgICAgICAgICAgICAgICB8IC4qKi4gICAgICAgICAgICAgICB8XG4gKiB8IDMgKHdoaXRlc3BhY2Ugb3V0c2lkZSkgIHwgeCAqeSogeiAgICAgICAgICAgfCB4ICouKiB6ICAgICAgICAgICAgICAgIHwgeCAqICogeiAgICAgICAgICAgICAgIHwgeCAqKiB6ICAgICAgICAgICAgIHxcbiAqIHwgNCAobm90aGluZyBvdXRzaWRlKSAgICAgfCAqeCogICAgICAgICAgICAgICB8ICouKiAgICAgICAgICAgICAgICAgICAgfCAqICogICAgICAgICAgICAgICAgICAgfCAqKiAgICAgICAgICAgICAgICAgfFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG91dHNpZGVcbiAqICAgQ29kZSBwb2ludCBvbiB0aGUgb3V0ZXIgc2lkZSBvZiB0aGUgcnVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGluc2lkZVxuICogICBDb2RlIHBvaW50IG9uIHRoZSBpbm5lciBzaWRlIG9mIHRoZSBydW4uXG4gKiBAcGFyYW0geycqJyB8ICdfJ30gbWFya2VyXG4gKiAgIE1hcmtlciBvZiB0aGUgcnVuLlxuICogICBVbmRlcnNjb3JlcyBhcmUgaGFuZGxlZCBtb3JlIHN0cmljdGx5ICh0aGV5IGZvcm0gbGVzcyBvZnRlbikgdGhhblxuICogICBhc3Rlcmlza3MuXG4gKiBAcmV0dXJucyB7RW5jb2RlU2lkZXN9XG4gKiAgIFdoZXRoZXIgdG8gZW5jb2RlIGNoYXJhY3RlcnMuXG4gKi9cbi8vIEltcG9ydGFudDogcHVuY3R1YXRpb24gbXVzdCBuZXZlciBiZSBlbmNvZGVkLlxuLy8gUHVuY3R1YXRpb24gaXMgc29sZWx5IHVzZWQgYnkgbWFya2Rvd24gY29uc3RydWN0cy5cbi8vIEFuZCBieSBlbmNvZGluZyBpdHNlbGYuXG4vLyBFbmNvZGluZyB0aGVtIHdpbGwgYnJlYWsgY29uc3RydWN0cyBvciBkb3VibGUgZW5jb2RlIHRoaW5ncy5cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVJbmZvKG91dHNpZGUsIGluc2lkZSwgbWFya2VyKSB7XG4gIGNvbnN0IG91dHNpZGVLaW5kID0gY2xhc3NpZnlDaGFyYWN0ZXIob3V0c2lkZSlcbiAgY29uc3QgaW5zaWRlS2luZCA9IGNsYXNzaWZ5Q2hhcmFjdGVyKGluc2lkZSlcblxuICAvLyBMZXR0ZXIgb3V0c2lkZTpcbiAgaWYgKG91dHNpZGVLaW5kID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaW5zaWRlS2luZCA9PT0gdW5kZWZpbmVkXG4gICAgICA/IC8vIExldHRlciBpbnNpZGU6XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gZW5jb2RlICpib3RoKiBsZXR0ZXJzIGZvciBgX2AgYXMgaXQgaXMgbG9vc2VyLlxuICAgICAgICAvLyBpdCBhbHJlYWR5IGZvcm1zIGZvciBgKmAgKGFuZCBHRk1zIGB+YCkuXG4gICAgICAgIG1hcmtlciA9PT0gJ18nXG4gICAgICAgID8ge2luc2lkZTogdHJ1ZSwgb3V0c2lkZTogdHJ1ZX1cbiAgICAgICAgOiB7aW5zaWRlOiBmYWxzZSwgb3V0c2lkZTogZmFsc2V9XG4gICAgICA6IGluc2lkZUtpbmQgPT09IDFcbiAgICAgICAgPyAvLyBXaGl0ZXNwYWNlIGluc2lkZTogZW5jb2RlIGJvdGggKGxldHRlciwgd2hpdGVzcGFjZSkuXG4gICAgICAgICAge2luc2lkZTogdHJ1ZSwgb3V0c2lkZTogdHJ1ZX1cbiAgICAgICAgOiAvLyBQdW5jdHVhdGlvbiBpbnNpZGU6IGVuY29kZSBvdXRlciAobGV0dGVyKVxuICAgICAgICAgIHtpbnNpZGU6IGZhbHNlLCBvdXRzaWRlOiB0cnVlfVxuICB9XG5cbiAgLy8gV2hpdGVzcGFjZSBvdXRzaWRlOlxuICBpZiAob3V0c2lkZUtpbmQgPT09IDEpIHtcbiAgICByZXR1cm4gaW5zaWRlS2luZCA9PT0gdW5kZWZpbmVkXG4gICAgICA/IC8vIExldHRlciBpbnNpZGU6IGFscmVhZHkgZm9ybXMuXG4gICAgICAgIHtpbnNpZGU6IGZhbHNlLCBvdXRzaWRlOiBmYWxzZX1cbiAgICAgIDogaW5zaWRlS2luZCA9PT0gMVxuICAgICAgICA/IC8vIFdoaXRlc3BhY2UgaW5zaWRlOiBlbmNvZGUgYm90aCAod2hpdGVzcGFjZSkuXG4gICAgICAgICAge2luc2lkZTogdHJ1ZSwgb3V0c2lkZTogdHJ1ZX1cbiAgICAgICAgOiAvLyBQdW5jdHVhdGlvbiBpbnNpZGU6IGFscmVhZHkgZm9ybXMuXG4gICAgICAgICAge2luc2lkZTogZmFsc2UsIG91dHNpZGU6IGZhbHNlfVxuICB9XG5cbiAgLy8gUHVuY3R1YXRpb24gb3V0c2lkZTpcbiAgcmV0dXJuIGluc2lkZUtpbmQgPT09IHVuZGVmaW5lZFxuICAgID8gLy8gTGV0dGVyIGluc2lkZTogYWxyZWFkeSBmb3Jtcy5cbiAgICAgIHtpbnNpZGU6IGZhbHNlLCBvdXRzaWRlOiBmYWxzZX1cbiAgICA6IGluc2lkZUtpbmQgPT09IDFcbiAgICAgID8gLy8gV2hpdGVzcGFjZSBpbnNpZGU6IGVuY29kZSBpbm5lciAod2hpdGVzcGFjZSkuXG4gICAgICAgIHtpbnNpZGU6IHRydWUsIG91dHNpZGU6IGZhbHNlfVxuICAgICAgOiAvLyBQdW5jdHVhdGlvbiBpbnNpZGU6IGFscmVhZHkgZm9ybXMuXG4gICAgICAgIHtpbnNpZGU6IGZhbHNlLCBvdXRzaWRlOiBmYWxzZX1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/encode-info.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatCodeAsIndented: () => (/* binding */ formatCodeAsIndented)\n/* harmony export */ });\n/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Code} from 'mdast'\n */\n\n/**\n * @param {Code} node\n * @param {State} state\n * @returns {boolean}\n */\nfunction formatCodeAsIndented(node, state) {\n  return Boolean(\n    state.options.fences === false &&\n      node.value &&\n      // If theres no info\n      !node.lang &&\n      // And theres a non-whitespace character\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesnt start or end in a blank\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2Zvcm1hdC1jb2RlLWFzLWluZGVudGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE1BQU07QUFDbEI7O0FBRUE7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC9mb3JtYXQtY29kZS1hcy1pbmRlbnRlZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge1N0YXRlfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duJ1xuICogQGltcG9ydCB7Q29kZX0gZnJvbSAnbWRhc3QnXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0NvZGV9IG5vZGVcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdENvZGVBc0luZGVudGVkKG5vZGUsIHN0YXRlKSB7XG4gIHJldHVybiBCb29sZWFuKFxuICAgIHN0YXRlLm9wdGlvbnMuZmVuY2VzID09PSBmYWxzZSAmJlxuICAgICAgbm9kZS52YWx1ZSAmJlxuICAgICAgLy8gSWYgdGhlcmXigJlzIG5vIGluZm/igKZcbiAgICAgICFub2RlLmxhbmcgJiZcbiAgICAgIC8vIEFuZCB0aGVyZeKAmXMgYSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXLigKZcbiAgICAgIC9bXiBcXHJcXG5dLy50ZXN0KG5vZGUudmFsdWUpICYmXG4gICAgICAvLyBBbmQgdGhlIHZhbHVlIGRvZXNu4oCZdCBzdGFydCBvciBlbmQgaW4gYSBibGFua+KAplxuICAgICAgIS9eW1xcdCBdKig/OltcXHJcXG5dfCQpfCg/Ol58W1xcclxcbl0pW1xcdCBdKiQvLnRlc3Qobm9kZS52YWx1ZSlcbiAgKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatHeadingAsSetext: () => (/* binding */ formatHeadingAsSetext)\n/* harmony export */ });\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-visit */ \"(app-pages-browser)/./node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unist-util-visit */ \"(app-pages-browser)/./node_modules/unist-util-visit-parents/lib/index.js\");\n/* harmony import */ var mdast_util_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mdast-util-to-string */ \"(app-pages-browser)/./node_modules/mdast-util-to-string/lib/index.js\");\n/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Heading} from 'mdast'\n */\n\n\n\n\n/**\n * @param {Heading} node\n * @param {State} state\n * @returns {boolean}\n */\nfunction formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  ;(0,unist_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(node, function (node) {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return unist_util_visit__WEBPACK_IMPORTED_MODULE_1__.EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      (0,mdast_util_to_string__WEBPACK_IMPORTED_MODULE_2__.toString)(node) &&\n      (state.options.setext || literalWithBreak)\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2Zvcm1hdC1oZWFkaW5nLWFzLXNldGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCOztBQUU0QztBQUNDOztBQUU3QztBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0EsRUFBRSx3REFBSztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtEQUFJO0FBQ2pCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsTUFBTSw4REFBUTtBQUNkO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1tYXJrZG93bi9saWIvdXRpbC9mb3JtYXQtaGVhZGluZy1hcy1zZXRleHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtTdGF0ZX0gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bidcbiAqIEBpbXBvcnQge0hlYWRpbmd9IGZyb20gJ21kYXN0J1xuICovXG5cbmltcG9ydCB7RVhJVCwgdmlzaXR9IGZyb20gJ3VuaXN0LXV0aWwtdmlzaXQnXG5pbXBvcnQge3RvU3RyaW5nfSBmcm9tICdtZGFzdC11dGlsLXRvLXN0cmluZydcblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRpbmd9IG5vZGVcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEhlYWRpbmdBc1NldGV4dChub2RlLCBzdGF0ZSkge1xuICBsZXQgbGl0ZXJhbFdpdGhCcmVhayA9IGZhbHNlXG5cbiAgLy8gTG9vayBmb3IgbGl0ZXJhbHMgd2l0aCBhIGxpbmUgYnJlYWsuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIGFsc29cbiAgdmlzaXQobm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAoXG4gICAgICAoJ3ZhbHVlJyBpbiBub2RlICYmIC9cXHI/XFxufFxcci8udGVzdChub2RlLnZhbHVlKSkgfHxcbiAgICAgIG5vZGUudHlwZSA9PT0gJ2JyZWFrJ1xuICAgICkge1xuICAgICAgbGl0ZXJhbFdpdGhCcmVhayA9IHRydWVcbiAgICAgIHJldHVybiBFWElUXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBCb29sZWFuKFxuICAgICghbm9kZS5kZXB0aCB8fCBub2RlLmRlcHRoIDwgMykgJiZcbiAgICAgIHRvU3RyaW5nKG5vZGUpICYmXG4gICAgICAoc3RhdGUub3B0aW9ucy5zZXRleHQgfHwgbGl0ZXJhbFdpdGhCcmVhaylcbiAgKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatLinkAsAutolink: () => (/* binding */ formatLinkAsAutolink)\n/* harmony export */ });\n/* harmony import */ var mdast_util_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mdast-util-to-string */ \"(app-pages-browser)/./node_modules/mdast-util-to-string/lib/index.js\");\n/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {Link} from 'mdast'\n */\n\n\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nfunction formatLinkAsAutolink(node, state) {\n  const raw = (0,mdast_util_to_string__WEBPACK_IMPORTED_MODULE_0__.toString)(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If theres a url\n      node.url &&\n      // And theres a no title\n      !node.title &&\n      // And the content of `node` is a single text node\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesnt contain ASCII control codes (character escapes and\n      // references dont work), space, or angle brackets\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL2Zvcm1hdC1saW5rLWFzLWF1dG9saW5rLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxNQUFNO0FBQ2xCOztBQUU2Qzs7QUFFN0M7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNPO0FBQ1AsY0FBYyw4REFBUTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvZm9ybWF0LWxpbmstYXMtYXV0b2xpbmsuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtTdGF0ZX0gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bidcbiAqIEBpbXBvcnQge0xpbmt9IGZyb20gJ21kYXN0J1xuICovXG5cbmltcG9ydCB7dG9TdHJpbmd9IGZyb20gJ21kYXN0LXV0aWwtdG8tc3RyaW5nJ1xuXG4vKipcbiAqIEBwYXJhbSB7TGlua30gbm9kZVxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TGlua0FzQXV0b2xpbmsobm9kZSwgc3RhdGUpIHtcbiAgY29uc3QgcmF3ID0gdG9TdHJpbmcobm9kZSlcblxuICByZXR1cm4gQm9vbGVhbihcbiAgICAhc3RhdGUub3B0aW9ucy5yZXNvdXJjZUxpbmsgJiZcbiAgICAgIC8vIElmIHRoZXJl4oCZcyBhIHVybOKAplxuICAgICAgbm9kZS51cmwgJiZcbiAgICAgIC8vIEFuZCB0aGVyZeKAmXMgYSBubyB0aXRsZeKAplxuICAgICAgIW5vZGUudGl0bGUgJiZcbiAgICAgIC8vIEFuZCB0aGUgY29udGVudCBvZiBgbm9kZWAgaXMgYSBzaW5nbGUgdGV4dCBub2Rl4oCmXG4gICAgICBub2RlLmNoaWxkcmVuICYmXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgIC8vIEFuZCBpZiB0aGUgdXJsIGlzIHRoZSBzYW1lIGFzIHRoZSBjb250ZW504oCmXG4gICAgICAocmF3ID09PSBub2RlLnVybCB8fCAnbWFpbHRvOicgKyByYXcgPT09IG5vZGUudXJsKSAmJlxuICAgICAgLy8gQW5kIHRoYXQgc3RhcnRzIHcvIGEgcHJvdG9jb2zigKZcbiAgICAgIC9eW2Etel1bYS16Ky4tXSs6L2kudGVzdChub2RlLnVybCkgJiZcbiAgICAgIC8vIEFuZCB0aGF0IGRvZXNu4oCZdCBjb250YWluIEFTQ0lJIGNvbnRyb2wgY29kZXMgKGNoYXJhY3RlciBlc2NhcGVzIGFuZFxuICAgICAgLy8gcmVmZXJlbmNlcyBkb27igJl0IHdvcmspLCBzcGFjZSwgb3IgYW5nbGUgYnJhY2tldHPigKZcbiAgICAgICEvW1xcMC0gPD5cXHUwMDdGXS8udGVzdChub2RlLnVybClcbiAgKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   patternInScope: () => (/* binding */ patternInScope)\n/* harmony export */ });\n/**\n * @import {ConstructName, Unsafe} from 'mdast-util-to-markdown'\n */\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nfunction patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array<ConstructName>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  if (!list || list.length === 0) {\n    return none\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2xpYi91dGlsL3BhdHRlcm4taW4tc2NvcGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7O0FBRUE7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8tbWFya2Rvd24vbGliL3V0aWwvcGF0dGVybi1pbi1zY29wZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge0NvbnN0cnVjdE5hbWUsIFVuc2FmZX0gZnJvbSAnbWRhc3QtdXRpbC10by1tYXJrZG93bidcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8Q29uc3RydWN0TmFtZT59IHN0YWNrXG4gKiBAcGFyYW0ge1Vuc2FmZX0gcGF0dGVyblxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXR0ZXJuSW5TY29wZShzdGFjaywgcGF0dGVybikge1xuICByZXR1cm4gKFxuICAgIGxpc3RJblNjb3BlKHN0YWNrLCBwYXR0ZXJuLmluQ29uc3RydWN0LCB0cnVlKSAmJlxuICAgICFsaXN0SW5TY29wZShzdGFjaywgcGF0dGVybi5ub3RJbkNvbnN0cnVjdCwgZmFsc2UpXG4gIClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PENvbnN0cnVjdE5hbWU+fSBzdGFja1xuICogQHBhcmFtIHtVbnNhZmVbJ2luQ29uc3RydWN0J119IGxpc3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbm9uZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGxpc3RJblNjb3BlKHN0YWNrLCBsaXN0LCBub25lKSB7XG4gIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICBsaXN0ID0gW2xpc3RdXG4gIH1cblxuICBpZiAoIWxpc3QgfHwgbGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbm9uZVxuICB9XG5cbiAgbGV0IGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgaWYgKHN0YWNrLmluY2x1ZGVzKGxpc3RbaW5kZXhdKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/micromark-extension-gfm-autolink-literal/dev/lib/html.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-autolink-literal/dev/lib/html.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmAutolinkLiteralHtml: () => (/* binding */ gfmAutolinkLiteralHtml)\n/* harmony export */ });\n/* harmony import */ var micromark_util_sanitize_uri__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-sanitize-uri */ \"(app-pages-browser)/./node_modules/micromark-util-sanitize-uri/dev/index.js\");\n/**\n * @import {CompileContext, Handle, HtmlExtension, Token} from 'micromark-util-types'\n */\n\n\n\n/**\n * Create an HTML extension for `micromark` to support GitHub autolink literal\n * when serializing to HTML.\n *\n * @returns {HtmlExtension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GitHub autolink literal when serializing to HTML.\n */\nfunction gfmAutolinkLiteralHtml() {\n  return {\n    exit: {literalAutolinkEmail, literalAutolinkHttp, literalAutolinkWww}\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {Handle}\n */\nfunction literalAutolinkWww(token) {\n  anchorFromToken.call(this, token, 'http://')\n}\n\n/**\n * @this {CompileContext}\n * @type {Handle}\n */\nfunction literalAutolinkEmail(token) {\n  anchorFromToken.call(this, token, 'mailto:')\n}\n\n/**\n * @this {CompileContext}\n * @type {Handle}\n */\nfunction literalAutolinkHttp(token) {\n  anchorFromToken.call(this, token)\n}\n\n/**\n * @this CompileContext\n * @param {Token} token\n * @param {string | null | undefined} [protocol]\n * @returns {undefined}\n */\nfunction anchorFromToken(token, protocol) {\n  const url = this.sliceSerialize(token)\n  this.tag('<a href=\"' + (0,micromark_util_sanitize_uri__WEBPACK_IMPORTED_MODULE_0__.sanitizeUri)((protocol || '') + url) + '\">')\n  this.raw(this.encode(url))\n  this.tag('</a>')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS1hdXRvbGluay1saXRlcmFsL2Rldi9saWIvaHRtbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsWUFBWSw4Q0FBOEM7QUFDMUQ7O0FBRXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLDJCQUEyQjtBQUN0QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdFQUFXO0FBQ3BDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tYXV0b2xpbmstbGl0ZXJhbC9kZXYvbGliL2h0bWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtDb21waWxlQ29udGV4dCwgSGFuZGxlLCBIdG1sRXh0ZW5zaW9uLCBUb2tlbn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtdHlwZXMnXG4gKi9cblxuaW1wb3J0IHtzYW5pdGl6ZVVyaX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtc2FuaXRpemUtdXJpJ1xuXG4vKipcbiAqIENyZWF0ZSBhbiBIVE1MIGV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdG8gc3VwcG9ydCBHaXRIdWIgYXV0b2xpbmsgbGl0ZXJhbFxuICogd2hlbiBzZXJpYWxpemluZyB0byBIVE1MLlxuICpcbiAqIEByZXR1cm5zIHtIdG1sRXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtaWNyb21hcmtgIHRoYXQgY2FuIGJlIHBhc3NlZCBpbiBgaHRtbEV4dGVuc2lvbnNgIHRvXG4gKiAgIHN1cHBvcnQgR2l0SHViIGF1dG9saW5rIGxpdGVyYWwgd2hlbiBzZXJpYWxpemluZyB0byBIVE1MLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtQXV0b2xpbmtMaXRlcmFsSHRtbCgpIHtcbiAgcmV0dXJuIHtcbiAgICBleGl0OiB7bGl0ZXJhbEF1dG9saW5rRW1haWwsIGxpdGVyYWxBdXRvbGlua0h0dHAsIGxpdGVyYWxBdXRvbGlua1d3d31cbiAgfVxufVxuXG4vKipcbiAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAqIEB0eXBlIHtIYW5kbGV9XG4gKi9cbmZ1bmN0aW9uIGxpdGVyYWxBdXRvbGlua1d3dyh0b2tlbikge1xuICBhbmNob3JGcm9tVG9rZW4uY2FsbCh0aGlzLCB0b2tlbiwgJ2h0dHA6Ly8nKVxufVxuXG4vKipcbiAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAqIEB0eXBlIHtIYW5kbGV9XG4gKi9cbmZ1bmN0aW9uIGxpdGVyYWxBdXRvbGlua0VtYWlsKHRva2VuKSB7XG4gIGFuY2hvckZyb21Ub2tlbi5jYWxsKHRoaXMsIHRva2VuLCAnbWFpbHRvOicpXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0hhbmRsZX1cbiAqL1xuZnVuY3Rpb24gbGl0ZXJhbEF1dG9saW5rSHR0cCh0b2tlbikge1xuICBhbmNob3JGcm9tVG9rZW4uY2FsbCh0aGlzLCB0b2tlbilcbn1cblxuLyoqXG4gKiBAdGhpcyBDb21waWxlQ29udGV4dFxuICogQHBhcmFtIHtUb2tlbn0gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Byb3RvY29sXVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gYW5jaG9yRnJvbVRva2VuKHRva2VuLCBwcm90b2NvbCkge1xuICBjb25zdCB1cmwgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuICB0aGlzLnRhZygnPGEgaHJlZj1cIicgKyBzYW5pdGl6ZVVyaSgocHJvdG9jb2wgfHwgJycpICsgdXJsKSArICdcIj4nKVxuICB0aGlzLnJhdyh0aGlzLmVuY29kZSh1cmwpKVxuICB0aGlzLnRhZygnPC9hPicpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/micromark-extension-gfm-autolink-literal/dev/lib/html.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmAutolinkLiteral: () => (/* binding */ gfmAutolinkLiteral)\n/* harmony export */ });\n/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-character */ \"(app-pages-browser)/./node_modules/micromark-util-character/dev/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/codes.js\");\n/**\n * @import {Code, ConstructRecord, Event, Extension, Previous, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\n\n\n\nconst wwwPrefix = {tokenize: tokenizeWwwPrefix, partial: true}\nconst domain = {tokenize: tokenizeDomain, partial: true}\nconst path = {tokenize: tokenizePath, partial: true}\nconst trail = {tokenize: tokenizeTrail, partial: true}\nconst emailDomainDotTrail = {\n  tokenize: tokenizeEmailDomainDotTrail,\n  partial: true\n}\n\nconst wwwAutolink = {\n  name: 'wwwAutolink',\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n}\n\nconst protocolAutolink = {\n  name: 'protocolAutolink',\n  tokenize: tokenizeProtocolAutolink,\n  previous: previousProtocol\n}\n\nconst emailAutolink = {\n  name: 'emailAutolink',\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n}\n\n/** @type {ConstructRecord} */\nconst text = {}\n\n/**\n * Create an extension for `micromark` to support GitHub autolink literal\n * syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to enable GFM\n *   autolink literal syntax.\n */\nfunction gfmAutolinkLiteral() {\n  return {text}\n}\n\n/** @type {Code} */\nlet code = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.digit0\n\n// Add alphanumerics.\nwhile (code < micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftCurlyBrace) {\n  text[code] = emailAutolink\n  code++\n  if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.colon) code = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.uppercaseA\n  else if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket) code = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lowercaseA\n}\n\ntext[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.plusSign] = emailAutolink\ntext[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dash] = emailAutolink\ntext[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dot] = emailAutolink\ntext[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.underscore] = emailAutolink\ntext[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.uppercaseH] = [emailAutolink, protocolAutolink]\ntext[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lowercaseH] = [emailAutolink, protocolAutolink]\ntext[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.uppercaseW] = [emailAutolink, wwwAutolink]\ntext[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lowercaseW] = [emailAutolink, wwwAutolink]\n\n// To do: perform email autolink literals on events, afterwards.\n// Thats where `markdown-rs` and `cmark-gfm` perform it.\n// It should look for `@`, then for atext backwards, and then for a label\n// forwards.\n// To do: `mailto:`, `xmpp:` protocol as prefix.\n\n/**\n * Email autolink literal.\n *\n * ```markdown\n * > | a contact@example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  const self = this\n  /** @type {boolean | undefined} */\n  let dot\n  /** @type {boolean} */\n  let data\n\n  return start\n\n  /**\n   * Start of email autolink literal.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (\n      !gfmAtext(code) ||\n      !previousEmail.call(self, self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkEmail')\n    return atext(code)\n  }\n\n  /**\n   * In email atext.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code)\n      return atext\n    }\n\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.atSign) {\n      effects.consume(code)\n      return emailDomain\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In email domain.\n   *\n   * The reference code is a bit overly complex as it handles the `@`, of which\n   * there may be just one.\n   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomain(code) {\n    // Dot followed by alphanumerical (not `-` or `_`).\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dot) {\n      return effects.check(\n        emailDomainDotTrail,\n        emailDomainAfter,\n        emailDomainDot\n      )(code)\n    }\n\n    // Alphanumerical, `-`, and `_`.\n    if (\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dash ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.underscore ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlphanumeric)(code)\n    ) {\n      data = true\n      effects.consume(code)\n      return emailDomain\n    }\n\n    // To do: `/` if xmpp.\n\n    // Note: normally wed truncate trailing punctuation from the link.\n    // However, email autolink literals cannot contain any of those markers,\n    // except for `.`, but that can only occur if it isnt trailing.\n    // So we can ignore truncating!\n    return emailDomainAfter(code)\n  }\n\n  /**\n   * In email domain, on dot that is not a trail.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainDot(code) {\n    effects.consume(code)\n    dot = true\n    return emailDomain\n  }\n\n  /**\n   * After email domain.\n   *\n   * ```markdown\n   * > | a contact@example.org b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function emailDomainAfter(code) {\n    // Domain must not be empty, must include a dot, and must end in alphabetical.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.\n    if (data && dot && (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlpha)(self.previous)) {\n      effects.exit('literalAutolinkEmail')\n      effects.exit('literalAutolink')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\n/**\n * `www` autolink literal.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  const self = this\n\n  return wwwStart\n\n  /**\n   * Start of www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwStart(code) {\n    if (\n      (code !== micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.uppercaseW && code !== micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lowercaseW) ||\n      !previousWww.call(self, self.previous) ||\n      previousUnbalanced(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkWww')\n    // Note: we *check*, so we can discard the `www.` we parsed.\n    // If it worked, we consider it as a part of the domain.\n    return effects.check(\n      wwwPrefix,\n      effects.attempt(domain, effects.attempt(path, wwwAfter), nok),\n      nok\n    )(code)\n  }\n\n  /**\n   * After a www autolink literal.\n   *\n   * ```markdown\n   * > | www.example.com/a?b#c\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwAfter(code) {\n    effects.exit('literalAutolinkWww')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n\n/**\n * Protocol autolink literal.\n *\n * ```markdown\n * > | a https://example.org b\n *       ^^^^^^^^^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeProtocolAutolink(effects, ok, nok) {\n  const self = this\n  let buffer = ''\n  let seen = false\n\n  return protocolStart\n\n  /**\n   * Start of protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolStart(code) {\n    if (\n      (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.uppercaseH || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lowercaseH) &&\n      previousProtocol.call(self, self.previous) &&\n      !previousUnbalanced(self.events)\n    ) {\n      effects.enter('literalAutolink')\n      effects.enter('literalAutolinkHttp')\n      buffer += String.fromCodePoint(code)\n      effects.consume(code)\n      return protocolPrefixInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In protocol.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *     ^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolPrefixInside(code) {\n    // `5` is size of `https`\n    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlpha)(code) && buffer.length < 5) {\n      // @ts-expect-error: definitely number.\n      buffer += String.fromCodePoint(code)\n      effects.consume(code)\n      return protocolPrefixInside\n    }\n\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.colon) {\n      const protocol = buffer.toLowerCase()\n\n      if (protocol === 'http' || protocol === 'https') {\n        effects.consume(code)\n        return protocolSlashesInside\n      }\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In slashes.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *           ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolSlashesInside(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.slash) {\n      effects.consume(code)\n\n      if (seen) {\n        return afterProtocol\n      }\n\n      seen = true\n      return protocolSlashesInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After protocol, before domain.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterProtocol(code) {\n    // To do: this is different from `markdown-rs`:\n    // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182\n    return code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiControl)(code) ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEndingOrSpace)(code) ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.unicodeWhitespace)(code) ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.unicodePunctuation)(code)\n      ? nok(code)\n      : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code)\n  }\n\n  /**\n   * After a protocol autolink literal.\n   *\n   * ```markdown\n   * > | https://example.com/a?b#c\n   *                              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function protocolAfter(code) {\n    effects.exit('literalAutolinkHttp')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n\n/**\n * `www` prefix.\n *\n * ```markdown\n * > | a www.example.org b\n *       ^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeWwwPrefix(effects, ok, nok) {\n  let size = 0\n\n  return wwwPrefixInside\n\n  /**\n   * In www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *     ^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixInside(code) {\n    if ((code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.uppercaseW || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lowercaseW) && size < 3) {\n      size++\n      effects.consume(code)\n      return wwwPrefixInside\n    }\n\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dot && size === 3) {\n      effects.consume(code)\n      return wwwPrefixAfter\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After www prefix.\n   *\n   * ```markdown\n   * > | www.example.com\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function wwwPrefixAfter(code) {\n    // If there is *anything*, we can link.\n    return code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof ? nok(code) : ok(code)\n  }\n}\n\n/**\n * Domain.\n *\n * ```markdown\n * > | a https://example.org b\n *               ^^^^^^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDomain(effects, ok, nok) {\n  /** @type {boolean | undefined} */\n  let underscoreInLastSegment\n  /** @type {boolean | undefined} */\n  let underscoreInLastLastSegment\n  /** @type {boolean | undefined} */\n  let seen\n\n  return domainInside\n\n  /**\n   * In domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *             ^^^^^^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainInside(code) {\n    // Check whether this marker, which is a trailing punctuation\n    // marker, optionally followed by more trailing markers, and then\n    // followed by an end.\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dot || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.underscore) {\n      return effects.check(trail, domainAfter, domainAtPunctuation)(code)\n    }\n\n    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www..com`,\n    // so thats Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.\n    if (\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEndingOrSpace)(code) ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.unicodeWhitespace)(code) ||\n      (code !== micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dash && (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.unicodePunctuation)(code))\n    ) {\n      return domainAfter(code)\n    }\n\n    seen = true\n    effects.consume(code)\n    return domainInside\n  }\n\n  /**\n   * In domain, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function domainAtPunctuation(code) {\n    // There is an underscore in the last segment of the domain\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.underscore) {\n      underscoreInLastSegment = true\n    }\n    // Otherwise, its a `.`: save the last segment underscore in the\n    // penultimate segment slot.\n    else {\n      underscoreInLastLastSegment = underscoreInLastSegment\n      underscoreInLastSegment = undefined\n    }\n\n    effects.consume(code)\n    return domainInside\n  }\n\n  /**\n   * After domain.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^\n   * ```\n   *\n   * @type {State} */\n  function domainAfter(code) {\n    // Note: thats GH says a dot is needed, but its not true:\n    // <https://github.com/github/cmark-gfm/issues/279>\n    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {\n      return nok(code)\n    }\n\n    return ok(code)\n  }\n}\n\n/**\n * Path.\n *\n * ```markdown\n * > | a https://example.org/stuff b\n *                          ^^^^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePath(effects, ok) {\n  let sizeOpen = 0\n  let sizeClose = 0\n\n  return pathInside\n\n  /**\n   * In path.\n   *\n   * ```markdown\n   * > | https://example.com/a\n   *                        ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathInside(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftParenthesis) {\n      sizeOpen++\n      effects.consume(code)\n      return pathInside\n    }\n\n    // To do: `markdown-rs` also needs this.\n    // If this is a paren, and there are less closings than openings,\n    // we dont check for a trail.\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightParenthesis && sizeClose < sizeOpen) {\n      return pathAtPunctuation(code)\n    }\n\n    // Check whether this trailing punctuation marker is optionally\n    // followed by more trailing markers, and then followed\n    // by an end.\n    if (\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.exclamationMark ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.quotationMark ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.ampersand ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.apostrophe ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightParenthesis ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.asterisk ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.comma ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dot ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.colon ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.semicolon ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lessThan ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.questionMark ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightSquareBracket ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.underscore ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.tilde\n    ) {\n      return effects.check(trail, ok, pathAtPunctuation)(code)\n    }\n\n    if (\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEndingOrSpace)(code) ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.unicodeWhitespace)(code)\n    ) {\n      return ok(code)\n    }\n\n    effects.consume(code)\n    return pathInside\n  }\n\n  /**\n   * In path, at potential trailing punctuation, that was not trailing.\n   *\n   * ```markdown\n   * > | https://example.com/a\"b\n   *                          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function pathAtPunctuation(code) {\n    // Count closing parens.\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightParenthesis) {\n      sizeClose++\n    }\n\n    effects.consume(code)\n    return pathInside\n  }\n}\n\n/**\n * Trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the entire trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | https://example.com\").\n *                        ^^^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTrail(effects, ok, nok) {\n  return trail\n\n  /**\n   * In trail of domain or path.\n   *\n   * ```markdown\n   * > | https://example.com\").\n   *                        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trail(code) {\n    // Regular trailing punctuation.\n    if (\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.exclamationMark ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.quotationMark ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.apostrophe ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightParenthesis ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.asterisk ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.comma ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dot ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.colon ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.semicolon ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.questionMark ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.underscore ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.tilde\n    ) {\n      effects.consume(code)\n      return trail\n    }\n\n    // `&` followed by one or more alphabeticals and then a `;`, is\n    // as a whole considered as trailing punctuation.\n    // In all other cases, it is considered as continuation of the URL.\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.ampersand) {\n      effects.consume(code)\n      return trailCharacterReferenceStart\n    }\n\n    // Needed because we allow literals after `[`, as we fix:\n    // <https://github.com/github/cmark-gfm/issues/278>.\n    // Check that it is not followed by `(` or `[`.\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightSquareBracket) {\n      effects.consume(code)\n      return trailBracketAfter\n    }\n\n    if (\n      // `<` is an end.\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lessThan ||\n      // So is whitespace.\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEndingOrSpace)(code) ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.unicodeWhitespace)(code)\n    ) {\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In trail, after `]`.\n   *\n   * >  **Note**: this deviates from `cmark-gfm` to fix a bug.\n   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.\n   *\n   * ```markdown\n   * > | https://example.com](\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailBracketAfter(code) {\n    // Whitespace or something that could start a resource or reference is the end.\n    // Switch back to trail otherwise.\n    if (\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftParenthesis ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEndingOrSpace)(code) ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.unicodeWhitespace)(code)\n    ) {\n      return ok(code)\n    }\n\n    return trail(code)\n  }\n\n  /**\n   * In character-reference like trail, after `&`.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharacterReferenceStart(code) {\n    // When non-alpha, its not a trail.\n    return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlpha)(code) ? trailCharacterReferenceInside(code) : nok(code)\n  }\n\n  /**\n   * In character-reference like trail.\n   *\n   * ```markdown\n   * > | https://example.com&amp;).\n   *                         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function trailCharacterReferenceInside(code) {\n    // Switch back to trail if this is well-formed.\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.semicolon) {\n      effects.consume(code)\n      return trail\n    }\n\n    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlpha)(code)) {\n      effects.consume(code)\n      return trailCharacterReferenceInside\n    }\n\n    // Its not a trail.\n    return nok(code)\n  }\n}\n\n/**\n * Dot in email domain trail.\n *\n * This calls `ok` if this *is* the trail, followed by an end, which means\n * the trail is not part of the link.\n * It calls `nok` if this *is* part of the link.\n *\n * ```markdown\n * > | contact@example.org.\n *                        ^\n * ```\n *\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeEmailDomainDotTrail(effects, ok, nok) {\n  return start\n\n  /**\n   * Dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                    ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // Must be dot.\n    effects.consume(code)\n    return after\n  }\n\n  /**\n   * After dot.\n   *\n   * ```markdown\n   * > | contact@example.org.\n   *                     ^   ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Not a trail if alphanumeric.\n    return (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlphanumeric)(code) ? nok(code) : ok(code)\n  }\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.\n *\n * @type {Previous}\n */\nfunction previousWww(code) {\n  return (\n    code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof ||\n    code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftParenthesis ||\n    code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.asterisk ||\n    code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.underscore ||\n    code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket ||\n    code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightSquareBracket ||\n    code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.tilde ||\n    (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.markdownLineEndingOrSpace)(code)\n  )\n}\n\n/**\n * See:\n * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.\n *\n * @type {Previous}\n */\nfunction previousProtocol(code) {\n  return !(0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlpha)(code)\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previousEmail(code) {\n  // Do not allow a slash inside atext.\n  // The reference code is a bit weird, but thats what it results in.\n  // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.\n  // Other than slash, every preceding character is allowed.\n  return !(code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.slash || gfmAtext(code))\n}\n\n/**\n * @param {Code} code\n * @returns {boolean}\n */\nfunction gfmAtext(code) {\n  return (\n    code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.plusSign ||\n    code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dash ||\n    code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dot ||\n    code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.underscore ||\n    (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_1__.asciiAlphanumeric)(code)\n  )\n}\n\n/**\n * @param {Array<Event>} events\n * @returns {boolean}\n */\nfunction previousUnbalanced(events) {\n  let index = events.length\n  let result = false\n\n  while (index--) {\n    const token = events[index][1]\n\n    if (\n      (token.type === 'labelLink' || token.type === 'labelImage') &&\n      !token._balanced\n    ) {\n      result = true\n      break\n    }\n\n    // If weve seen this token, and it was marked as not having any unbalanced\n    // bracket before it, we can exit.\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false\n      break\n    }\n  }\n\n  if (events.length > 0 && !result) {\n    // Mark the last token as walked into w/o finding\n    // anything.\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true\n  }\n\n  return result\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS1hdXRvbGluay1saXRlcmFsL2Rldi9saWIvc3ludGF4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0EsWUFBWSxzRkFBc0Y7QUFDbEc7O0FBU2lDO0FBQ1U7O0FBRTNDLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGlCQUFpQjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDTztBQUNQLFVBQVU7QUFDVjs7QUFFQSxXQUFXLE1BQU07QUFDakIsV0FBVyx3REFBSzs7QUFFaEI7QUFDQSxjQUFjLHdEQUFLO0FBQ25CO0FBQ0E7QUFDQSxlQUFlLHdEQUFLLGVBQWUsd0RBQUs7QUFDeEMsb0JBQW9CLHdEQUFLLDJCQUEyQix3REFBSztBQUN6RDs7QUFFQSxLQUFLLHdEQUFLO0FBQ1YsS0FBSyx3REFBSztBQUNWLEtBQUssd0RBQUs7QUFDVixLQUFLLHdEQUFLO0FBQ1YsS0FBSyx3REFBSztBQUNWLEtBQUssd0RBQUs7QUFDVixLQUFLLHdEQUFLO0FBQ1YsS0FBSyx3REFBSzs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix3REFBSztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFLO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx3REFBSztBQUNwQixlQUFlLHdEQUFLO0FBQ3BCLE1BQU0sMkVBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0VBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3REFBSyx3QkFBd0Isd0RBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQUssd0JBQXdCLHdEQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvRUFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix3REFBSztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFLO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdEQUFLO0FBQ3pCLE1BQU0sc0VBQVk7QUFDbEIsTUFBTSxtRkFBeUI7QUFDL0IsTUFBTSwyRUFBaUI7QUFDdkIsTUFBTSw0RUFBa0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGtCQUFrQix3REFBSyx3QkFBd0Isd0RBQUs7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHdEQUFLO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdEQUFLO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQUssaUJBQWlCLHdEQUFLO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdEQUFLO0FBQ3BCLE1BQU0sbUZBQXlCO0FBQy9CLE1BQU0sMkVBQWlCO0FBQ3ZCLGdCQUFnQix3REFBSyxTQUFTLDRFQUFrQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGlCQUFpQix3REFBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQUs7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQUs7QUFDcEIsZUFBZSx3REFBSztBQUNwQixlQUFlLHdEQUFLO0FBQ3BCLGVBQWUsd0RBQUs7QUFDcEIsZUFBZSx3REFBSztBQUNwQixlQUFlLHdEQUFLO0FBQ3BCLGVBQWUsd0RBQUs7QUFDcEIsZUFBZSx3REFBSztBQUNwQixlQUFlLHdEQUFLO0FBQ3BCLGVBQWUsd0RBQUs7QUFDcEIsZUFBZSx3REFBSztBQUNwQixlQUFlLHdEQUFLO0FBQ3BCLGVBQWUsd0RBQUs7QUFDcEIsZUFBZSx3REFBSztBQUNwQixlQUFlLHdEQUFLO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsd0RBQUs7QUFDcEIsTUFBTSxtRkFBeUI7QUFDL0IsTUFBTSwyRUFBaUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBSztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdEQUFLO0FBQ3BCLGVBQWUsd0RBQUs7QUFDcEIsZUFBZSx3REFBSztBQUNwQixlQUFlLHdEQUFLO0FBQ3BCLGVBQWUsd0RBQUs7QUFDcEIsZUFBZSx3REFBSztBQUNwQixlQUFlLHdEQUFLO0FBQ3BCLGVBQWUsd0RBQUs7QUFDcEIsZUFBZSx3REFBSztBQUNwQixlQUFlLHdEQUFLO0FBQ3BCLGVBQWUsd0RBQUs7QUFDcEIsZUFBZSx3REFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBLGlCQUFpQix3REFBSztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFLO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx3REFBSztBQUNwQjtBQUNBLGVBQWUsd0RBQUs7QUFDcEIsTUFBTSxtRkFBeUI7QUFDL0IsTUFBTSwyRUFBaUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBSztBQUNwQixlQUFlLHdEQUFLO0FBQ3BCLGVBQWUsd0RBQUs7QUFDcEIsTUFBTSxtRkFBeUI7QUFDL0IsTUFBTSwyRUFBaUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0VBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBSztBQUN0QjtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxvRUFBVTtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJFQUFpQjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0RBQUs7QUFDbEIsYUFBYSx3REFBSztBQUNsQixhQUFhLHdEQUFLO0FBQ2xCLGFBQWEsd0RBQUs7QUFDbEIsYUFBYSx3REFBSztBQUNsQixhQUFhLHdEQUFLO0FBQ2xCLGFBQWEsd0RBQUs7QUFDbEIsSUFBSSxtRkFBeUI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVSxvRUFBVTtBQUNwQjs7QUFFQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdEQUFLO0FBQ3pCOztBQUVBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdEQUFLO0FBQ2xCLGFBQWEsd0RBQUs7QUFDbEIsYUFBYSx3REFBSztBQUNsQixhQUFhLHdEQUFLO0FBQ2xCLElBQUksMkVBQWlCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS1hdXRvbGluay1saXRlcmFsL2Rldi9saWIvc3ludGF4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7Q29kZSwgQ29uc3RydWN0UmVjb3JkLCBFdmVudCwgRXh0ZW5zaW9uLCBQcmV2aW91cywgU3RhdGUsIFRva2VuaXplQ29udGV4dCwgVG9rZW5pemVyfSBmcm9tICdtaWNyb21hcmstdXRpbC10eXBlcydcbiAqL1xuXG5pbXBvcnQge1xuICBhc2NpaUFscGhhLFxuICBhc2NpaUFscGhhbnVtZXJpYyxcbiAgYXNjaWlDb250cm9sLFxuICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlLFxuICB1bmljb2RlUHVuY3R1YXRpb24sXG4gIHVuaWNvZGVXaGl0ZXNwYWNlXG59IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcbmltcG9ydCB7Y29kZXN9IGZyb20gJ21pY3JvbWFyay11dGlsLXN5bWJvbCdcblxuY29uc3Qgd3d3UHJlZml4ID0ge3Rva2VuaXplOiB0b2tlbml6ZVd3d1ByZWZpeCwgcGFydGlhbDogdHJ1ZX1cbmNvbnN0IGRvbWFpbiA9IHt0b2tlbml6ZTogdG9rZW5pemVEb21haW4sIHBhcnRpYWw6IHRydWV9XG5jb25zdCBwYXRoID0ge3Rva2VuaXplOiB0b2tlbml6ZVBhdGgsIHBhcnRpYWw6IHRydWV9XG5jb25zdCB0cmFpbCA9IHt0b2tlbml6ZTogdG9rZW5pemVUcmFpbCwgcGFydGlhbDogdHJ1ZX1cbmNvbnN0IGVtYWlsRG9tYWluRG90VHJhaWwgPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZUVtYWlsRG9tYWluRG90VHJhaWwsXG4gIHBhcnRpYWw6IHRydWVcbn1cblxuY29uc3Qgd3d3QXV0b2xpbmsgPSB7XG4gIG5hbWU6ICd3d3dBdXRvbGluaycsXG4gIHRva2VuaXplOiB0b2tlbml6ZVd3d0F1dG9saW5rLFxuICBwcmV2aW91czogcHJldmlvdXNXd3dcbn1cblxuY29uc3QgcHJvdG9jb2xBdXRvbGluayA9IHtcbiAgbmFtZTogJ3Byb3RvY29sQXV0b2xpbmsnLFxuICB0b2tlbml6ZTogdG9rZW5pemVQcm90b2NvbEF1dG9saW5rLFxuICBwcmV2aW91czogcHJldmlvdXNQcm90b2NvbFxufVxuXG5jb25zdCBlbWFpbEF1dG9saW5rID0ge1xuICBuYW1lOiAnZW1haWxBdXRvbGluaycsXG4gIHRva2VuaXplOiB0b2tlbml6ZUVtYWlsQXV0b2xpbmssXG4gIHByZXZpb3VzOiBwcmV2aW91c0VtYWlsXG59XG5cbi8qKiBAdHlwZSB7Q29uc3RydWN0UmVjb3JkfSAqL1xuY29uc3QgdGV4dCA9IHt9XG5cbi8qKlxuICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdG8gc3VwcG9ydCBHaXRIdWIgYXV0b2xpbmsgbGl0ZXJhbFxuICogc3ludGF4LlxuICpcbiAqIEByZXR1cm5zIHtFeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdGhhdCBjYW4gYmUgcGFzc2VkIGluIGBleHRlbnNpb25zYCB0byBlbmFibGUgR0ZNXG4gKiAgIGF1dG9saW5rIGxpdGVyYWwgc3ludGF4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtQXV0b2xpbmtMaXRlcmFsKCkge1xuICByZXR1cm4ge3RleHR9XG59XG5cbi8qKiBAdHlwZSB7Q29kZX0gKi9cbmxldCBjb2RlID0gY29kZXMuZGlnaXQwXG5cbi8vIEFkZCBhbHBoYW51bWVyaWNzLlxud2hpbGUgKGNvZGUgPCBjb2Rlcy5sZWZ0Q3VybHlCcmFjZSkge1xuICB0ZXh0W2NvZGVdID0gZW1haWxBdXRvbGlua1xuICBjb2RlKytcbiAgaWYgKGNvZGUgPT09IGNvZGVzLmNvbG9uKSBjb2RlID0gY29kZXMudXBwZXJjYXNlQVxuICBlbHNlIGlmIChjb2RlID09PSBjb2Rlcy5sZWZ0U3F1YXJlQnJhY2tldCkgY29kZSA9IGNvZGVzLmxvd2VyY2FzZUFcbn1cblxudGV4dFtjb2Rlcy5wbHVzU2lnbl0gPSBlbWFpbEF1dG9saW5rXG50ZXh0W2NvZGVzLmRhc2hdID0gZW1haWxBdXRvbGlua1xudGV4dFtjb2Rlcy5kb3RdID0gZW1haWxBdXRvbGlua1xudGV4dFtjb2Rlcy51bmRlcnNjb3JlXSA9IGVtYWlsQXV0b2xpbmtcbnRleHRbY29kZXMudXBwZXJjYXNlSF0gPSBbZW1haWxBdXRvbGluaywgcHJvdG9jb2xBdXRvbGlua11cbnRleHRbY29kZXMubG93ZXJjYXNlSF0gPSBbZW1haWxBdXRvbGluaywgcHJvdG9jb2xBdXRvbGlua11cbnRleHRbY29kZXMudXBwZXJjYXNlV10gPSBbZW1haWxBdXRvbGluaywgd3d3QXV0b2xpbmtdXG50ZXh0W2NvZGVzLmxvd2VyY2FzZVddID0gW2VtYWlsQXV0b2xpbmssIHd3d0F1dG9saW5rXVxuXG4vLyBUbyBkbzogcGVyZm9ybSBlbWFpbCBhdXRvbGluayBsaXRlcmFscyBvbiBldmVudHMsIGFmdGVyd2FyZHMuXG4vLyBUaGF04oCZcyB3aGVyZSBgbWFya2Rvd24tcnNgIGFuZCBgY21hcmstZ2ZtYCBwZXJmb3JtIGl0LlxuLy8gSXQgc2hvdWxkIGxvb2sgZm9yIGBAYCwgdGhlbiBmb3IgYXRleHQgYmFja3dhcmRzLCBhbmQgdGhlbiBmb3IgYSBsYWJlbFxuLy8gZm9yd2FyZHMuXG4vLyBUbyBkbzogYG1haWx0bzpgLCBgeG1wcDpgIHByb3RvY29sIGFzIHByZWZpeC5cblxuLyoqXG4gKiBFbWFpbCBhdXRvbGluayBsaXRlcmFsLlxuICpcbiAqIGBgYG1hcmtkb3duXG4gKiA+IHwgYSBjb250YWN0QGV4YW1wbGUub3JnIGJcbiAqICAgICAgIF5eXl5eXl5eXl5eXl5eXl5eXl5cbiAqIGBgYFxuICpcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAdHlwZSB7VG9rZW5pemVyfVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZUVtYWlsQXV0b2xpbmsoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICAvKiogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9ICovXG4gIGxldCBkb3RcbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICBsZXQgZGF0YVxuXG4gIHJldHVybiBzdGFydFxuXG4gIC8qKlxuICAgKiBTdGFydCBvZiBlbWFpbCBhdXRvbGluayBsaXRlcmFsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgYSBjb250YWN0QGV4YW1wbGUub3JnIGJcbiAgICogICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGlmIChcbiAgICAgICFnZm1BdGV4dChjb2RlKSB8fFxuICAgICAgIXByZXZpb3VzRW1haWwuY2FsbChzZWxmLCBzZWxmLnByZXZpb3VzKSB8fFxuICAgICAgcHJldmlvdXNVbmJhbGFuY2VkKHNlbGYuZXZlbnRzKVxuICAgICkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ2xpdGVyYWxBdXRvbGluaycpXG4gICAgZWZmZWN0cy5lbnRlcignbGl0ZXJhbEF1dG9saW5rRW1haWwnKVxuICAgIHJldHVybiBhdGV4dChjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEluIGVtYWlsIGF0ZXh0LlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgYSBjb250YWN0QGV4YW1wbGUub3JnIGJcbiAgICogICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gYXRleHQoY29kZSkge1xuICAgIGlmIChnZm1BdGV4dChjb2RlKSkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gYXRleHRcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMuYXRTaWduKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBlbWFpbERvbWFpblxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBlbWFpbCBkb21haW4uXG4gICAqXG4gICAqIFRoZSByZWZlcmVuY2UgY29kZSBpcyBhIGJpdCBvdmVybHkgY29tcGxleCBhcyBpdCBoYW5kbGVzIHRoZSBgQGAsIG9mIHdoaWNoXG4gICAqIHRoZXJlIG1heSBiZSBqdXN0IG9uZS5cbiAgICogU291cmNlOiA8aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9jbWFyay1nZm0vYmxvYi9lZjFjZmNiL2V4dGVuc2lvbnMvYXV0b2xpbmsuYyNMMzE4PlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgYSBjb250YWN0QGV4YW1wbGUub3JnIGJcbiAgICogICAgICAgICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBlbWFpbERvbWFpbihjb2RlKSB7XG4gICAgLy8gRG90IGZvbGxvd2VkIGJ5IGFscGhhbnVtZXJpY2FsIChub3QgYC1gIG9yIGBfYCkuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmRvdCkge1xuICAgICAgcmV0dXJuIGVmZmVjdHMuY2hlY2soXG4gICAgICAgIGVtYWlsRG9tYWluRG90VHJhaWwsXG4gICAgICAgIGVtYWlsRG9tYWluQWZ0ZXIsXG4gICAgICAgIGVtYWlsRG9tYWluRG90XG4gICAgICApKGNvZGUpXG4gICAgfVxuXG4gICAgLy8gQWxwaGFudW1lcmljYWwsIGAtYCwgYW5kIGBfYC5cbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBjb2Rlcy5kYXNoIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy51bmRlcnNjb3JlIHx8XG4gICAgICBhc2NpaUFscGhhbnVtZXJpYyhjb2RlKVxuICAgICkge1xuICAgICAgZGF0YSA9IHRydWVcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGVtYWlsRG9tYWluXG4gICAgfVxuXG4gICAgLy8gVG8gZG86IGAvYCBpZiB4bXBwLlxuXG4gICAgLy8gTm90ZTogbm9ybWFsbHkgd2XigJlkIHRydW5jYXRlIHRyYWlsaW5nIHB1bmN0dWF0aW9uIGZyb20gdGhlIGxpbmsuXG4gICAgLy8gSG93ZXZlciwgZW1haWwgYXV0b2xpbmsgbGl0ZXJhbHMgY2Fubm90IGNvbnRhaW4gYW55IG9mIHRob3NlIG1hcmtlcnMsXG4gICAgLy8gZXhjZXB0IGZvciBgLmAsIGJ1dCB0aGF0IGNhbiBvbmx5IG9jY3VyIGlmIGl0IGlzbuKAmXQgdHJhaWxpbmcuXG4gICAgLy8gU28gd2UgY2FuIGlnbm9yZSB0cnVuY2F0aW5nIVxuICAgIHJldHVybiBlbWFpbERvbWFpbkFmdGVyKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogSW4gZW1haWwgZG9tYWluLCBvbiBkb3QgdGhhdCBpcyBub3QgYSB0cmFpbC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGEgY29udGFjdEBleGFtcGxlLm9yZyBiXG4gICAqICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGVtYWlsRG9tYWluRG90KGNvZGUpIHtcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBkb3QgPSB0cnVlXG4gICAgcmV0dXJuIGVtYWlsRG9tYWluXG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgZW1haWwgZG9tYWluLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgYSBjb250YWN0QGV4YW1wbGUub3JnIGJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGVtYWlsRG9tYWluQWZ0ZXIoY29kZSkge1xuICAgIC8vIERvbWFpbiBtdXN0IG5vdCBiZSBlbXB0eSwgbXVzdCBpbmNsdWRlIGEgZG90LCBhbmQgbXVzdCBlbmQgaW4gYWxwaGFiZXRpY2FsLlxuICAgIC8vIFNvdXJjZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvY21hcmstZ2ZtL2Jsb2IvZWYxY2ZjYi9leHRlbnNpb25zL2F1dG9saW5rLmMjTDMzMj4uXG4gICAgaWYgKGRhdGEgJiYgZG90ICYmIGFzY2lpQWxwaGEoc2VsZi5wcmV2aW91cykpIHtcbiAgICAgIGVmZmVjdHMuZXhpdCgnbGl0ZXJhbEF1dG9saW5rRW1haWwnKVxuICAgICAgZWZmZWN0cy5leGl0KCdsaXRlcmFsQXV0b2xpbmsnKVxuICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG59XG5cbi8qKlxuICogYHd3d2AgYXV0b2xpbmsgbGl0ZXJhbC5cbiAqXG4gKiBgYGBtYXJrZG93blxuICogPiB8IGEgd3d3LmV4YW1wbGUub3JnIGJcbiAqICAgICAgIF5eXl5eXl5eXl5eXl5eXlxuICogYGBgXG4gKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplV3d3QXV0b2xpbmsoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuXG4gIHJldHVybiB3d3dTdGFydFxuXG4gIC8qKlxuICAgKiBTdGFydCBvZiB3d3cgYXV0b2xpbmsgbGl0ZXJhbC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IHd3dy5leGFtcGxlLmNvbS9hP2IjY1xuICAgKiAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gd3d3U3RhcnQoY29kZSkge1xuICAgIGlmIChcbiAgICAgIChjb2RlICE9PSBjb2Rlcy51cHBlcmNhc2VXICYmIGNvZGUgIT09IGNvZGVzLmxvd2VyY2FzZVcpIHx8XG4gICAgICAhcHJldmlvdXNXd3cuY2FsbChzZWxmLCBzZWxmLnByZXZpb3VzKSB8fFxuICAgICAgcHJldmlvdXNVbmJhbGFuY2VkKHNlbGYuZXZlbnRzKVxuICAgICkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ2xpdGVyYWxBdXRvbGluaycpXG4gICAgZWZmZWN0cy5lbnRlcignbGl0ZXJhbEF1dG9saW5rV3d3JylcbiAgICAvLyBOb3RlOiB3ZSAqY2hlY2sqLCBzbyB3ZSBjYW4gZGlzY2FyZCB0aGUgYHd3dy5gIHdlIHBhcnNlZC5cbiAgICAvLyBJZiBpdCB3b3JrZWQsIHdlIGNvbnNpZGVyIGl0IGFzIGEgcGFydCBvZiB0aGUgZG9tYWluLlxuICAgIHJldHVybiBlZmZlY3RzLmNoZWNrKFxuICAgICAgd3d3UHJlZml4LFxuICAgICAgZWZmZWN0cy5hdHRlbXB0KGRvbWFpbiwgZWZmZWN0cy5hdHRlbXB0KHBhdGgsIHd3d0FmdGVyKSwgbm9rKSxcbiAgICAgIG5va1xuICAgICkoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBhIHd3dyBhdXRvbGluayBsaXRlcmFsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgd3d3LmV4YW1wbGUuY29tL2E/YiNjXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiB3d3dBZnRlcihjb2RlKSB7XG4gICAgZWZmZWN0cy5leGl0KCdsaXRlcmFsQXV0b2xpbmtXd3cnKVxuICAgIGVmZmVjdHMuZXhpdCgnbGl0ZXJhbEF1dG9saW5rJylcbiAgICByZXR1cm4gb2soY29kZSlcbiAgfVxufVxuXG4vKipcbiAqIFByb3RvY29sIGF1dG9saW5rIGxpdGVyYWwuXG4gKlxuICogYGBgbWFya2Rvd25cbiAqID4gfCBhIGh0dHBzOi8vZXhhbXBsZS5vcmcgYlxuICogICAgICAgXl5eXl5eXl5eXl5eXl5eXl5eXlxuICogYGBgXG4gKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplUHJvdG9jb2xBdXRvbGluayhlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGxldCBidWZmZXIgPSAnJ1xuICBsZXQgc2VlbiA9IGZhbHNlXG5cbiAgcmV0dXJuIHByb3RvY29sU3RhcnRcblxuICAvKipcbiAgICogU3RhcnQgb2YgcHJvdG9jb2wgYXV0b2xpbmsgbGl0ZXJhbC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGh0dHBzOi8vZXhhbXBsZS5jb20vYT9iI2NcbiAgICogICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHByb3RvY29sU3RhcnQoY29kZSkge1xuICAgIGlmIChcbiAgICAgIChjb2RlID09PSBjb2Rlcy51cHBlcmNhc2VIIHx8IGNvZGUgPT09IGNvZGVzLmxvd2VyY2FzZUgpICYmXG4gICAgICBwcmV2aW91c1Byb3RvY29sLmNhbGwoc2VsZiwgc2VsZi5wcmV2aW91cykgJiZcbiAgICAgICFwcmV2aW91c1VuYmFsYW5jZWQoc2VsZi5ldmVudHMpXG4gICAgKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCdsaXRlcmFsQXV0b2xpbmsnKVxuICAgICAgZWZmZWN0cy5lbnRlcignbGl0ZXJhbEF1dG9saW5rSHR0cCcpXG4gICAgICBidWZmZXIgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZSlcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHByb3RvY29sUHJlZml4SW5zaWRlXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHByb3RvY29sLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgaHR0cHM6Ly9leGFtcGxlLmNvbS9hP2IjY1xuICAgKiAgICAgXl5eXl5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHByb3RvY29sUHJlZml4SW5zaWRlKGNvZGUpIHtcbiAgICAvLyBgNWAgaXMgc2l6ZSBvZiBgaHR0cHNgXG4gICAgaWYgKGFzY2lpQWxwaGEoY29kZSkgJiYgYnVmZmVyLmxlbmd0aCA8IDUpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGRlZmluaXRlbHkgbnVtYmVyLlxuICAgICAgYnVmZmVyICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiBwcm90b2NvbFByZWZpeEluc2lkZVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5jb2xvbikge1xuICAgICAgY29uc3QgcHJvdG9jb2wgPSBidWZmZXIudG9Mb3dlckNhc2UoKVxuXG4gICAgICBpZiAocHJvdG9jb2wgPT09ICdodHRwJyB8fCBwcm90b2NvbCA9PT0gJ2h0dHBzJykge1xuICAgICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgICAgcmV0dXJuIHByb3RvY29sU2xhc2hlc0luc2lkZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBzbGFzaGVzLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgaHR0cHM6Ly9leGFtcGxlLmNvbS9hP2IjY1xuICAgKiAgICAgICAgICAgXl5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHByb3RvY29sU2xhc2hlc0luc2lkZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLnNsYXNoKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcblxuICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgcmV0dXJuIGFmdGVyUHJvdG9jb2xcbiAgICAgIH1cblxuICAgICAgc2VlbiA9IHRydWVcbiAgICAgIHJldHVybiBwcm90b2NvbFNsYXNoZXNJbnNpZGVcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgcHJvdG9jb2wsIGJlZm9yZSBkb21haW4uXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBodHRwczovL2V4YW1wbGUuY29tL2E/YiNjXG4gICAqICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGFmdGVyUHJvdG9jb2woY29kZSkge1xuICAgIC8vIFRvIGRvOiB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIGBtYXJrZG93bi1yc2A6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dvb29ybS9tYXJrZG93bi1ycy9ibG9iL2IzYTkyMWM3NjEzMDlhZTAwYTUxZmUzNDhkOGE0M2FkYmM1NGI1MTgvc3JjL2NvbnN0cnVjdC9nZm1fYXV0b2xpbmtfbGl0ZXJhbC5ycyNMMTcyLUwxODJcbiAgICByZXR1cm4gY29kZSA9PT0gY29kZXMuZW9mIHx8XG4gICAgICBhc2NpaUNvbnRyb2woY29kZSkgfHxcbiAgICAgIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSkgfHxcbiAgICAgIHVuaWNvZGVXaGl0ZXNwYWNlKGNvZGUpIHx8XG4gICAgICB1bmljb2RlUHVuY3R1YXRpb24oY29kZSlcbiAgICAgID8gbm9rKGNvZGUpXG4gICAgICA6IGVmZmVjdHMuYXR0ZW1wdChkb21haW4sIGVmZmVjdHMuYXR0ZW1wdChwYXRoLCBwcm90b2NvbEFmdGVyKSwgbm9rKShjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIGEgcHJvdG9jb2wgYXV0b2xpbmsgbGl0ZXJhbC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGh0dHBzOi8vZXhhbXBsZS5jb20vYT9iI2NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBwcm90b2NvbEFmdGVyKGNvZGUpIHtcbiAgICBlZmZlY3RzLmV4aXQoJ2xpdGVyYWxBdXRvbGlua0h0dHAnKVxuICAgIGVmZmVjdHMuZXhpdCgnbGl0ZXJhbEF1dG9saW5rJylcbiAgICByZXR1cm4gb2soY29kZSlcbiAgfVxufVxuXG4vKipcbiAqIGB3d3dgIHByZWZpeC5cbiAqXG4gKiBgYGBtYXJrZG93blxuICogPiB8IGEgd3d3LmV4YW1wbGUub3JnIGJcbiAqICAgICAgIF5eXl5cbiAqIGBgYFxuICpcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAdHlwZSB7VG9rZW5pemVyfVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZVd3d1ByZWZpeChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGxldCBzaXplID0gMFxuXG4gIHJldHVybiB3d3dQcmVmaXhJbnNpZGVcblxuICAvKipcbiAgICogSW4gd3d3IHByZWZpeC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IHd3dy5leGFtcGxlLmNvbVxuICAgKiAgICAgXl5eXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gd3d3UHJlZml4SW5zaWRlKGNvZGUpIHtcbiAgICBpZiAoKGNvZGUgPT09IGNvZGVzLnVwcGVyY2FzZVcgfHwgY29kZSA9PT0gY29kZXMubG93ZXJjYXNlVykgJiYgc2l6ZSA8IDMpIHtcbiAgICAgIHNpemUrK1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gd3d3UHJlZml4SW5zaWRlXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmRvdCAmJiBzaXplID09PSAzKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB3d3dQcmVmaXhBZnRlclxuICAgIH1cblxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciB3d3cgcHJlZml4LlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgd3d3LmV4YW1wbGUuY29tXG4gICAqICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gd3d3UHJlZml4QWZ0ZXIoY29kZSkge1xuICAgIC8vIElmIHRoZXJlIGlzICphbnl0aGluZyosIHdlIGNhbiBsaW5rLlxuICAgIHJldHVybiBjb2RlID09PSBjb2Rlcy5lb2YgPyBub2soY29kZSkgOiBvayhjb2RlKVxuICB9XG59XG5cbi8qKlxuICogRG9tYWluLlxuICpcbiAqIGBgYG1hcmtkb3duXG4gKiA+IHwgYSBodHRwczovL2V4YW1wbGUub3JnIGJcbiAqICAgICAgICAgICAgICAgXl5eXl5eXl5eXl5cbiAqIGBgYFxuICpcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAdHlwZSB7VG9rZW5pemVyfVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZURvbWFpbihlZmZlY3RzLCBvaywgbm9rKSB7XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IHVuZGVyc2NvcmVJbkxhc3RTZWdtZW50XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IHVuZGVyc2NvcmVJbkxhc3RMYXN0U2VnbWVudFxuICAvKiogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9ICovXG4gIGxldCBzZWVuXG5cbiAgcmV0dXJuIGRvbWFpbkluc2lkZVxuXG4gIC8qKlxuICAgKiBJbiBkb21haW4uXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBodHRwczovL2V4YW1wbGUuY29tL2FcbiAgICogICAgICAgICAgICAgXl5eXl5eXl5eXl5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGRvbWFpbkluc2lkZShjb2RlKSB7XG4gICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIG1hcmtlciwgd2hpY2ggaXMgYSB0cmFpbGluZyBwdW5jdHVhdGlvblxuICAgIC8vIG1hcmtlciwgb3B0aW9uYWxseSBmb2xsb3dlZCBieSBtb3JlIHRyYWlsaW5nIG1hcmtlcnMsIGFuZCB0aGVuXG4gICAgLy8gZm9sbG93ZWQgYnkgYW4gZW5kLlxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5kb3QgfHwgY29kZSA9PT0gY29kZXMudW5kZXJzY29yZSkge1xuICAgICAgcmV0dXJuIGVmZmVjdHMuY2hlY2sodHJhaWwsIGRvbWFpbkFmdGVyLCBkb21haW5BdFB1bmN0dWF0aW9uKShjb2RlKVxuICAgIH1cblxuICAgIC8vIEdIIGRvY3VtZW50cyB0aGF0IG9ubHkgYWxwaGFudW1lcmljcyAob3RoZXIgdGhhbiBgLWAsIGAuYCwgYW5kIGBfYCkgY2FuXG4gICAgLy8gb2NjdXIsIHdoaWNoIHNvdW5kcyBsaWtlIEFTQ0lJIG9ubHksIGJ1dCB0aGV5IGFsc28gc3VwcG9ydCBgd3d3Lum7nueciy5jb21gLFxuICAgIC8vIHNvIHRoYXTigJlzIFVuaWNvZGUuXG4gICAgLy8gSW5zdGVhZCBvZiBzb21lIG5ldyBwcm9kdWN0aW9uIGZvciBVbmljb2RlIGFscGhhbnVtZXJpY3MsIG1hcmtkb3duXG4gICAgLy8gYWxyZWFkeSBoYXMgdGhhdCBmb3IgVW5pY29kZSBwdW5jdHVhdGlvbiBhbmQgd2hpdGVzcGFjZSwgc28gdXNlIHRob3NlLlxuICAgIC8vIFNvdXJjZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvY21hcmstZ2ZtL2Jsb2IvZWYxY2ZjYi9leHRlbnNpb25zL2F1dG9saW5rLmMjTDEyPi5cbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBjb2Rlcy5lb2YgfHxcbiAgICAgIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSkgfHxcbiAgICAgIHVuaWNvZGVXaGl0ZXNwYWNlKGNvZGUpIHx8XG4gICAgICAoY29kZSAhPT0gY29kZXMuZGFzaCAmJiB1bmljb2RlUHVuY3R1YXRpb24oY29kZSkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZG9tYWluQWZ0ZXIoY29kZSlcbiAgICB9XG5cbiAgICBzZWVuID0gdHJ1ZVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIHJldHVybiBkb21haW5JbnNpZGVcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBkb21haW4sIGF0IHBvdGVudGlhbCB0cmFpbGluZyBwdW5jdHVhdGlvbiwgdGhhdCB3YXMgbm90IHRyYWlsaW5nLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgaHR0cHM6Ly9leGFtcGxlLmNvbVxuICAgKiAgICAgICAgICAgICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gZG9tYWluQXRQdW5jdHVhdGlvbihjb2RlKSB7XG4gICAgLy8gVGhlcmUgaXMgYW4gdW5kZXJzY29yZSBpbiB0aGUgbGFzdCBzZWdtZW50IG9mIHRoZSBkb21haW5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMudW5kZXJzY29yZSkge1xuICAgICAgdW5kZXJzY29yZUluTGFzdFNlZ21lbnQgPSB0cnVlXG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgaXTigJlzIGEgYC5gOiBzYXZlIHRoZSBsYXN0IHNlZ21lbnQgdW5kZXJzY29yZSBpbiB0aGVcbiAgICAvLyBwZW51bHRpbWF0ZSBzZWdtZW50IHNsb3QuXG4gICAgZWxzZSB7XG4gICAgICB1bmRlcnNjb3JlSW5MYXN0TGFzdFNlZ21lbnQgPSB1bmRlcnNjb3JlSW5MYXN0U2VnbWVudFxuICAgICAgdW5kZXJzY29yZUluTGFzdFNlZ21lbnQgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gZG9tYWluSW5zaWRlXG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgZG9tYWluLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgaHR0cHM6Ly9leGFtcGxlLmNvbS9hXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfSAqL1xuICBmdW5jdGlvbiBkb21haW5BZnRlcihjb2RlKSB7XG4gICAgLy8gTm90ZTogdGhhdOKAmXMgR0ggc2F5cyBhIGRvdCBpcyBuZWVkZWQsIGJ1dCBpdOKAmXMgbm90IHRydWU6XG4gICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvY21hcmstZ2ZtL2lzc3Vlcy8yNzk+XG4gICAgaWYgKHVuZGVyc2NvcmVJbkxhc3RMYXN0U2VnbWVudCB8fCB1bmRlcnNjb3JlSW5MYXN0U2VnbWVudCB8fCAhc2Vlbikge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBvayhjb2RlKVxuICB9XG59XG5cbi8qKlxuICogUGF0aC5cbiAqXG4gKiBgYGBtYXJrZG93blxuICogPiB8IGEgaHR0cHM6Ly9leGFtcGxlLm9yZy9zdHVmZiBiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXG4gKiBgYGBcbiAqXG4gKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0fVxuICogQHR5cGUge1Rva2VuaXplcn1cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemVQYXRoKGVmZmVjdHMsIG9rKSB7XG4gIGxldCBzaXplT3BlbiA9IDBcbiAgbGV0IHNpemVDbG9zZSA9IDBcblxuICByZXR1cm4gcGF0aEluc2lkZVxuXG4gIC8qKlxuICAgKiBJbiBwYXRoLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgaHR0cHM6Ly9leGFtcGxlLmNvbS9hXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgXl5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHBhdGhJbnNpZGUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBjb2Rlcy5sZWZ0UGFyZW50aGVzaXMpIHtcbiAgICAgIHNpemVPcGVuKytcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHBhdGhJbnNpZGVcbiAgICB9XG5cbiAgICAvLyBUbyBkbzogYG1hcmtkb3duLXJzYCBhbHNvIG5lZWRzIHRoaXMuXG4gICAgLy8gSWYgdGhpcyBpcyBhIHBhcmVuLCBhbmQgdGhlcmUgYXJlIGxlc3MgY2xvc2luZ3MgdGhhbiBvcGVuaW5ncyxcbiAgICAvLyB3ZSBkb27igJl0IGNoZWNrIGZvciBhIHRyYWlsLlxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5yaWdodFBhcmVudGhlc2lzICYmIHNpemVDbG9zZSA8IHNpemVPcGVuKSB7XG4gICAgICByZXR1cm4gcGF0aEF0UHVuY3R1YXRpb24oY29kZSlcbiAgICB9XG5cbiAgICAvLyBDaGVjayB3aGV0aGVyIHRoaXMgdHJhaWxpbmcgcHVuY3R1YXRpb24gbWFya2VyIGlzIG9wdGlvbmFsbHlcbiAgICAvLyBmb2xsb3dlZCBieSBtb3JlIHRyYWlsaW5nIG1hcmtlcnMsIGFuZCB0aGVuIGZvbGxvd2VkXG4gICAgLy8gYnkgYW4gZW5kLlxuICAgIGlmIChcbiAgICAgIGNvZGUgPT09IGNvZGVzLmV4Y2xhbWF0aW9uTWFyayB8fFxuICAgICAgY29kZSA9PT0gY29kZXMucXVvdGF0aW9uTWFyayB8fFxuICAgICAgY29kZSA9PT0gY29kZXMuYW1wZXJzYW5kIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy5hcG9zdHJvcGhlIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy5yaWdodFBhcmVudGhlc2lzIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy5hc3RlcmlzayB8fFxuICAgICAgY29kZSA9PT0gY29kZXMuY29tbWEgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLmRvdCB8fFxuICAgICAgY29kZSA9PT0gY29kZXMuY29sb24gfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLnNlbWljb2xvbiB8fFxuICAgICAgY29kZSA9PT0gY29kZXMubGVzc1RoYW4gfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLnF1ZXN0aW9uTWFyayB8fFxuICAgICAgY29kZSA9PT0gY29kZXMucmlnaHRTcXVhcmVCcmFja2V0IHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy51bmRlcnNjb3JlIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy50aWxkZVxuICAgICkge1xuICAgICAgcmV0dXJuIGVmZmVjdHMuY2hlY2sodHJhaWwsIG9rLCBwYXRoQXRQdW5jdHVhdGlvbikoY29kZSlcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBjb2Rlcy5lb2YgfHxcbiAgICAgIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSkgfHxcbiAgICAgIHVuaWNvZGVXaGl0ZXNwYWNlKGNvZGUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gcGF0aEluc2lkZVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHBhdGgsIGF0IHBvdGVudGlhbCB0cmFpbGluZyBwdW5jdHVhdGlvbiwgdGhhdCB3YXMgbm90IHRyYWlsaW5nLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgaHR0cHM6Ly9leGFtcGxlLmNvbS9hXCJiXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBwYXRoQXRQdW5jdHVhdGlvbihjb2RlKSB7XG4gICAgLy8gQ291bnQgY2xvc2luZyBwYXJlbnMuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLnJpZ2h0UGFyZW50aGVzaXMpIHtcbiAgICAgIHNpemVDbG9zZSsrXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIHBhdGhJbnNpZGVcbiAgfVxufVxuXG4vKipcbiAqIFRyYWlsLlxuICpcbiAqIFRoaXMgY2FsbHMgYG9rYCBpZiB0aGlzICppcyogdGhlIHRyYWlsLCBmb2xsb3dlZCBieSBhbiBlbmQsIHdoaWNoIG1lYW5zXG4gKiB0aGUgZW50aXJlIHRyYWlsIGlzIG5vdCBwYXJ0IG9mIHRoZSBsaW5rLlxuICogSXQgY2FsbHMgYG5va2AgaWYgdGhpcyAqaXMqIHBhcnQgb2YgdGhlIGxpbmsuXG4gKlxuICogYGBgbWFya2Rvd25cbiAqID4gfCBodHRwczovL2V4YW1wbGUuY29tXCIpLlxuICogICAgICAgICAgICAgICAgICAgICAgICBeXl5cbiAqIGBgYFxuICpcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAdHlwZSB7VG9rZW5pemVyfVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZVRyYWlsKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgcmV0dXJuIHRyYWlsXG5cbiAgLyoqXG4gICAqIEluIHRyYWlsIG9mIGRvbWFpbiBvciBwYXRoLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgaHR0cHM6Ly9leGFtcGxlLmNvbVwiKS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiB0cmFpbChjb2RlKSB7XG4gICAgLy8gUmVndWxhciB0cmFpbGluZyBwdW5jdHVhdGlvbi5cbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBjb2Rlcy5leGNsYW1hdGlvbk1hcmsgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLnF1b3RhdGlvbk1hcmsgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLmFwb3N0cm9waGUgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLnJpZ2h0UGFyZW50aGVzaXMgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLmFzdGVyaXNrIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy5jb21tYSB8fFxuICAgICAgY29kZSA9PT0gY29kZXMuZG90IHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy5jb2xvbiB8fFxuICAgICAgY29kZSA9PT0gY29kZXMuc2VtaWNvbG9uIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy5xdWVzdGlvbk1hcmsgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLnVuZGVyc2NvcmUgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLnRpbGRlXG4gICAgKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHJldHVybiB0cmFpbFxuICAgIH1cblxuICAgIC8vIGAmYCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBhbHBoYWJldGljYWxzIGFuZCB0aGVuIGEgYDtgLCBpc1xuICAgIC8vIGFzIGEgd2hvbGUgY29uc2lkZXJlZCBhcyB0cmFpbGluZyBwdW5jdHVhdGlvbi5cbiAgICAvLyBJbiBhbGwgb3RoZXIgY2FzZXMsIGl0IGlzIGNvbnNpZGVyZWQgYXMgY29udGludWF0aW9uIG9mIHRoZSBVUkwuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmFtcGVyc2FuZCkge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gdHJhaWxDaGFyYWN0ZXJSZWZlcmVuY2VTdGFydFxuICAgIH1cblxuICAgIC8vIE5lZWRlZCBiZWNhdXNlIHdlIGFsbG93IGxpdGVyYWxzIGFmdGVyIGBbYCwgYXMgd2UgZml4OlxuICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2NtYXJrLWdmbS9pc3N1ZXMvMjc4Pi5cbiAgICAvLyBDaGVjayB0aGF0IGl0IGlzIG5vdCBmb2xsb3dlZCBieSBgKGAgb3IgYFtgLlxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5yaWdodFNxdWFyZUJyYWNrZXQpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRyYWlsQnJhY2tldEFmdGVyXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgLy8gYDxgIGlzIGFuIGVuZC5cbiAgICAgIGNvZGUgPT09IGNvZGVzLmxlc3NUaGFuIHx8XG4gICAgICAvLyBTbyBpcyB3aGl0ZXNwYWNlLlxuICAgICAgY29kZSA9PT0gY29kZXMuZW9mIHx8XG4gICAgICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpIHx8XG4gICAgICB1bmljb2RlV2hpdGVzcGFjZShjb2RlKVxuICAgICkge1xuICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHRyYWlsLCBhZnRlciBgXWAuXG4gICAqXG4gICAqID4g8J+RiSAqKk5vdGUqKjogdGhpcyBkZXZpYXRlcyBmcm9tIGBjbWFyay1nZm1gIHRvIGZpeCBhIGJ1Zy5cbiAgICogPiBTZWUgZW5kIG9mIDxodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2NtYXJrLWdmbS9pc3N1ZXMvMjc4PiBmb3IgbW9yZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGh0dHBzOi8vZXhhbXBsZS5jb21dKFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiB0cmFpbEJyYWNrZXRBZnRlcihjb2RlKSB7XG4gICAgLy8gV2hpdGVzcGFjZSBvciBzb21ldGhpbmcgdGhhdCBjb3VsZCBzdGFydCBhIHJlc291cmNlIG9yIHJlZmVyZW5jZSBpcyB0aGUgZW5kLlxuICAgIC8vIFN3aXRjaCBiYWNrIHRvIHRyYWlsIG90aGVyd2lzZS5cbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBjb2Rlcy5lb2YgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLmxlZnRQYXJlbnRoZXNpcyB8fFxuICAgICAgY29kZSA9PT0gY29kZXMubGVmdFNxdWFyZUJyYWNrZXQgfHxcbiAgICAgIG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSkgfHxcbiAgICAgIHVuaWNvZGVXaGl0ZXNwYWNlKGNvZGUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gb2soY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJhaWwoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBjaGFyYWN0ZXItcmVmZXJlbmNlIGxpa2UgdHJhaWwsIGFmdGVyIGAmYC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGh0dHBzOi8vZXhhbXBsZS5jb20mYW1wOykuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHRyYWlsQ2hhcmFjdGVyUmVmZXJlbmNlU3RhcnQoY29kZSkge1xuICAgIC8vIFdoZW4gbm9uLWFscGhhLCBpdOKAmXMgbm90IGEgdHJhaWwuXG4gICAgcmV0dXJuIGFzY2lpQWxwaGEoY29kZSkgPyB0cmFpbENoYXJhY3RlclJlZmVyZW5jZUluc2lkZShjb2RlKSA6IG5vayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEluIGNoYXJhY3Rlci1yZWZlcmVuY2UgbGlrZSB0cmFpbC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IGh0dHBzOi8vZXhhbXBsZS5jb20mYW1wOykuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHRyYWlsQ2hhcmFjdGVyUmVmZXJlbmNlSW5zaWRlKGNvZGUpIHtcbiAgICAvLyBTd2l0Y2ggYmFjayB0byB0cmFpbCBpZiB0aGlzIGlzIHdlbGwtZm9ybWVkLlxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5zZW1pY29sb24pIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRyYWlsXG4gICAgfVxuXG4gICAgaWYgKGFzY2lpQWxwaGEoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIHRyYWlsQ2hhcmFjdGVyUmVmZXJlbmNlSW5zaWRlXG4gICAgfVxuXG4gICAgLy8gSXTigJlzIG5vdCBhIHRyYWlsLlxuICAgIHJldHVybiBub2soY29kZSlcbiAgfVxufVxuXG4vKipcbiAqIERvdCBpbiBlbWFpbCBkb21haW4gdHJhaWwuXG4gKlxuICogVGhpcyBjYWxscyBgb2tgIGlmIHRoaXMgKmlzKiB0aGUgdHJhaWwsIGZvbGxvd2VkIGJ5IGFuIGVuZCwgd2hpY2ggbWVhbnNcbiAqIHRoZSB0cmFpbCBpcyBub3QgcGFydCBvZiB0aGUgbGluay5cbiAqIEl0IGNhbGxzIGBub2tgIGlmIHRoaXMgKmlzKiBwYXJ0IG9mIHRoZSBsaW5rLlxuICpcbiAqIGBgYG1hcmtkb3duXG4gKiA+IHwgY29udGFjdEBleGFtcGxlLm9yZy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgXlxuICogYGBgXG4gKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplRW1haWxEb21haW5Eb3RUcmFpbChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIHJldHVybiBzdGFydFxuXG4gIC8qKlxuICAgKiBEb3QuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBjb250YWN0QGV4YW1wbGUub3JnLlxuICAgKiAgICAgICAgICAgICAgICAgICAgXiAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICAvLyBNdXN0IGJlIGRvdC5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gYWZ0ZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBkb3QuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBjb250YWN0QGV4YW1wbGUub3JnLlxuICAgKiAgICAgICAgICAgICAgICAgICAgIF4gICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBhZnRlcihjb2RlKSB7XG4gICAgLy8gTm90IGEgdHJhaWwgaWYgYWxwaGFudW1lcmljLlxuICAgIHJldHVybiBhc2NpaUFscGhhbnVtZXJpYyhjb2RlKSA/IG5vayhjb2RlKSA6IG9rKGNvZGUpXG4gIH1cbn1cblxuLyoqXG4gKiBTZWU6XG4gKiA8aHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9jbWFyay1nZm0vYmxvYi9lZjFjZmNiL2V4dGVuc2lvbnMvYXV0b2xpbmsuYyNMMTU2Pi5cbiAqXG4gKiBAdHlwZSB7UHJldmlvdXN9XG4gKi9cbmZ1bmN0aW9uIHByZXZpb3VzV3d3KGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICBjb2RlID09PSBjb2Rlcy5lb2YgfHxcbiAgICBjb2RlID09PSBjb2Rlcy5sZWZ0UGFyZW50aGVzaXMgfHxcbiAgICBjb2RlID09PSBjb2Rlcy5hc3RlcmlzayB8fFxuICAgIGNvZGUgPT09IGNvZGVzLnVuZGVyc2NvcmUgfHxcbiAgICBjb2RlID09PSBjb2Rlcy5sZWZ0U3F1YXJlQnJhY2tldCB8fFxuICAgIGNvZGUgPT09IGNvZGVzLnJpZ2h0U3F1YXJlQnJhY2tldCB8fFxuICAgIGNvZGUgPT09IGNvZGVzLnRpbGRlIHx8XG4gICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKVxuICApXG59XG5cbi8qKlxuICogU2VlOlxuICogPGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvY21hcmstZ2ZtL2Jsb2IvZWYxY2ZjYi9leHRlbnNpb25zL2F1dG9saW5rLmMjTDIxND4uXG4gKlxuICogQHR5cGUge1ByZXZpb3VzfVxuICovXG5mdW5jdGlvbiBwcmV2aW91c1Byb3RvY29sKGNvZGUpIHtcbiAgcmV0dXJuICFhc2NpaUFscGhhKGNvZGUpXG59XG5cbi8qKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtQcmV2aW91c31cbiAqL1xuZnVuY3Rpb24gcHJldmlvdXNFbWFpbChjb2RlKSB7XG4gIC8vIERvIG5vdCBhbGxvdyBhIHNsYXNoIOKAnGluc2lkZeKAnSBhdGV4dC5cbiAgLy8gVGhlIHJlZmVyZW5jZSBjb2RlIGlzIGEgYml0IHdlaXJkLCBidXQgdGhhdOKAmXMgd2hhdCBpdCByZXN1bHRzIGluLlxuICAvLyBTb3VyY2U6IDxodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2NtYXJrLWdmbS9ibG9iL2VmMWNmY2IvZXh0ZW5zaW9ucy9hdXRvbGluay5jI0wzMDc+LlxuICAvLyBPdGhlciB0aGFuIHNsYXNoLCBldmVyeSBwcmVjZWRpbmcgY2hhcmFjdGVyIGlzIGFsbG93ZWQuXG4gIHJldHVybiAhKGNvZGUgPT09IGNvZGVzLnNsYXNoIHx8IGdmbUF0ZXh0KGNvZGUpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q29kZX0gY29kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGdmbUF0ZXh0KGNvZGUpIHtcbiAgcmV0dXJuIChcbiAgICBjb2RlID09PSBjb2Rlcy5wbHVzU2lnbiB8fFxuICAgIGNvZGUgPT09IGNvZGVzLmRhc2ggfHxcbiAgICBjb2RlID09PSBjb2Rlcy5kb3QgfHxcbiAgICBjb2RlID09PSBjb2Rlcy51bmRlcnNjb3JlIHx8XG4gICAgYXNjaWlBbHBoYW51bWVyaWMoY29kZSlcbiAgKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBldmVudHNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBwcmV2aW91c1VuYmFsYW5jZWQoZXZlbnRzKSB7XG4gIGxldCBpbmRleCA9IGV2ZW50cy5sZW5ndGhcbiAgbGV0IHJlc3VsdCA9IGZhbHNlXG5cbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICBjb25zdCB0b2tlbiA9IGV2ZW50c1tpbmRleF1bMV1cblxuICAgIGlmIChcbiAgICAgICh0b2tlbi50eXBlID09PSAnbGFiZWxMaW5rJyB8fCB0b2tlbi50eXBlID09PSAnbGFiZWxJbWFnZScpICYmXG4gICAgICAhdG9rZW4uX2JhbGFuY2VkXG4gICAgKSB7XG4gICAgICByZXN1bHQgPSB0cnVlXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIC8vIElmIHdl4oCZdmUgc2VlbiB0aGlzIHRva2VuLCBhbmQgaXQgd2FzIG1hcmtlZCBhcyBub3QgaGF2aW5nIGFueSB1bmJhbGFuY2VkXG4gICAgLy8gYnJhY2tldCBiZWZvcmUgaXQsIHdlIGNhbiBleGl0LlxuICAgIGlmICh0b2tlbi5fZ2ZtQXV0b2xpbmtMaXRlcmFsV2Fsa2VkSW50bykge1xuICAgICAgcmVzdWx0ID0gZmFsc2VcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKGV2ZW50cy5sZW5ndGggPiAwICYmICFyZXN1bHQpIHtcbiAgICAvLyBNYXJrIHRoZSBsYXN0IHRva2VuIGFzIOKAnHdhbGtlZCBpbnRv4oCdIHcvbyBmaW5kaW5nXG4gICAgLy8gYW55dGhpbmcuXG4gICAgZXZlbnRzW2V2ZW50cy5sZW5ndGggLSAxXVsxXS5fZ2ZtQXV0b2xpbmtMaXRlcmFsV2Fsa2VkSW50byA9IHRydWVcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/micromark-extension-gfm-footnote/dev/lib/html.js":
/*!***********************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-footnote/dev/lib/html.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultBackLabel: () => (/* binding */ defaultBackLabel),\n/* harmony export */   gfmFootnoteHtml: () => (/* binding */ gfmFootnoteHtml)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devlop */ \"(app-pages-browser)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-normalize-identifier */ \"(app-pages-browser)/./node_modules/micromark-util-normalize-identifier/dev/index.js\");\n/* harmony import */ var micromark_util_sanitize_uri__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-sanitize-uri */ \"(app-pages-browser)/./node_modules/micromark-util-sanitize-uri/dev/index.js\");\n/**\n * @import {HtmlOptions as Options} from 'micromark-extension-gfm-footnote'\n * @import {HtmlExtension} from 'micromark-util-types'\n */\n\n\n\n\n\nconst own = {}.hasOwnProperty\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Generate the default label that GitHub uses on backreferences.\n *\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {string}\n *   Default label.\n */\nfunction defaultBackLabel(referenceIndex, rereferenceIndex) {\n  return (\n    'Back to reference ' +\n    (referenceIndex + 1) +\n    (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n  )\n}\n\n/**\n * Create an extension for `micromark` to support GFM footnotes when\n * serializing to HTML.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration (optional).\n * @returns {HtmlExtension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GFM footnotes when serializing to HTML.\n */\nfunction gfmFootnoteHtml(options) {\n  const config = options || emptyOptions\n  const label = config.label || 'Footnotes'\n  const labelTagName = config.labelTagName || 'h2'\n  const labelAttributes =\n    config.labelAttributes === null || config.labelAttributes === undefined\n      ? 'class=\"sr-only\"'\n      : config.labelAttributes\n  const backLabel = config.backLabel || defaultBackLabel\n  const clobberPrefix =\n    config.clobberPrefix === null || config.clobberPrefix === undefined\n      ? 'user-content-'\n      : config.clobberPrefix\n  return {\n    enter: {\n      gfmFootnoteDefinition() {\n        const stack = this.getData('tightStack')\n        stack.push(false)\n      },\n      gfmFootnoteDefinitionLabelString() {\n        this.buffer()\n      },\n      gfmFootnoteCallString() {\n        this.buffer()\n      }\n    },\n    exit: {\n      gfmFootnoteDefinition() {\n        let definitions = this.getData('gfmFootnoteDefinitions')\n        const footnoteStack = this.getData('gfmFootnoteDefinitionStack')\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(footnoteStack, 'expected `footnoteStack`')\n        const tightStack = this.getData('tightStack')\n        const current = footnoteStack.pop()\n        const value = this.resume()\n\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(current, 'expected to be in a footnote')\n\n        if (!definitions) {\n          this.setData('gfmFootnoteDefinitions', (definitions = {}))\n        }\n\n        if (!own.call(definitions, current)) definitions[current] = value\n\n        tightStack.pop()\n        this.setData('slurpOneLineEnding', true)\n        // Hack to prevent a line ending from showing up if were in a definition in\n        // an empty list item.\n        this.setData('lastWasTag')\n      },\n      gfmFootnoteDefinitionLabelString(token) {\n        let footnoteStack = this.getData('gfmFootnoteDefinitionStack')\n\n        if (!footnoteStack) {\n          this.setData('gfmFootnoteDefinitionStack', (footnoteStack = []))\n        }\n\n        footnoteStack.push((0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_1__.normalizeIdentifier)(this.sliceSerialize(token)))\n        this.resume() // Drop the label.\n        this.buffer() // Get ready for a value.\n      },\n      gfmFootnoteCallString(token) {\n        let calls = this.getData('gfmFootnoteCallOrder')\n        let counts = this.getData('gfmFootnoteCallCounts')\n        const id = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_1__.normalizeIdentifier)(this.sliceSerialize(token))\n        /** @type {number} */\n        let counter\n\n        this.resume()\n\n        if (!calls) this.setData('gfmFootnoteCallOrder', (calls = []))\n        if (!counts) this.setData('gfmFootnoteCallCounts', (counts = {}))\n\n        const index = calls.indexOf(id)\n        const safeId = (0,micromark_util_sanitize_uri__WEBPACK_IMPORTED_MODULE_2__.sanitizeUri)(id.toLowerCase())\n\n        if (index === -1) {\n          calls.push(id)\n          counts[id] = 1\n          counter = calls.length\n        } else {\n          counts[id]++\n          counter = index + 1\n        }\n\n        const reuseCounter = counts[id]\n\n        this.tag(\n          '<sup><a href=\"#' +\n            clobberPrefix +\n            'fn-' +\n            safeId +\n            '\" id=\"' +\n            clobberPrefix +\n            'fnref-' +\n            safeId +\n            (reuseCounter > 1 ? '-' + reuseCounter : '') +\n            '\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">' +\n            String(counter) +\n            '</a></sup>'\n        )\n      },\n      null() {\n        const calls = this.getData('gfmFootnoteCallOrder') || []\n        const counts = this.getData('gfmFootnoteCallCounts') || {}\n        const definitions = this.getData('gfmFootnoteDefinitions') || {}\n        let index = -1\n\n        if (calls.length > 0) {\n          this.lineEndingIfNeeded()\n          this.tag(\n            '<section data-footnotes=\"\" class=\"footnotes\"><' +\n              labelTagName +\n              ' id=\"footnote-label\"' +\n              (labelAttributes ? ' ' + labelAttributes : '') +\n              '>'\n          )\n          this.raw(this.encode(label))\n          this.tag('</' + labelTagName + '>')\n          this.lineEndingIfNeeded()\n          this.tag('<ol>')\n        }\n\n        while (++index < calls.length) {\n          // Called definitions are always defined.\n          const id = calls[index]\n          const safeId = (0,micromark_util_sanitize_uri__WEBPACK_IMPORTED_MODULE_2__.sanitizeUri)(id.toLowerCase())\n          let referenceIndex = 0\n          /** @type {Array<string>} */\n          const references = []\n\n          while (++referenceIndex <= counts[id]) {\n            references.push(\n              '<a href=\"#' +\n                clobberPrefix +\n                'fnref-' +\n                safeId +\n                (referenceIndex > 1 ? '-' + referenceIndex : '') +\n                '\" data-footnote-backref=\"\" aria-label=\"' +\n                this.encode(\n                  typeof backLabel === 'string'\n                    ? backLabel\n                    : backLabel(index, referenceIndex)\n                ) +\n                '\" class=\"data-footnote-backref\">' +\n                (referenceIndex > 1\n                  ? '<sup>' + referenceIndex + '</sup>'\n                  : '') +\n                '</a>'\n            )\n          }\n\n          const reference = references.join(' ')\n          let injected = false\n\n          this.lineEndingIfNeeded()\n          this.tag('<li id=\"' + clobberPrefix + 'fn-' + safeId + '\">')\n          this.lineEndingIfNeeded()\n          this.tag(\n            definitions[id].replace(/<\\/p>(?:\\r?\\n|\\r)?$/, function ($0) {\n              injected = true\n              return ' ' + reference + $0\n            })\n          )\n\n          if (!injected) {\n            this.lineEndingIfNeeded()\n            this.tag(reference)\n          }\n\n          this.lineEndingIfNeeded()\n          this.tag('</li>')\n        }\n\n        if (calls.length > 0) {\n          this.lineEndingIfNeeded()\n          this.tag('</ol>')\n          this.lineEndingIfNeeded()\n          this.tag('</section>')\n        }\n      }\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS1mb290bm90ZS9kZXYvbGliL2h0bWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDLFlBQVksZUFBZTtBQUMzQjs7QUFFbUM7QUFDb0M7QUFDaEI7O0FBRXZELGNBQWM7O0FBRWQsV0FBVyxTQUFTO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCLFdBQVc7QUFDbEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBTTtBQUNkO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLDJDQUFNOztBQUVkO0FBQ0Esa0VBQWtFO0FBQ2xFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHdGQUFtQjtBQUM5QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3RkFBbUI7QUFDdEMsbUJBQW1CLFFBQVE7QUFDM0I7O0FBRUE7O0FBRUE7QUFDQSx1RUFBdUU7O0FBRXZFO0FBQ0EsdUJBQXVCLHdFQUFXOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdFQUFXO0FBQ3BDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tZm9vdG5vdGUvZGV2L2xpYi9odG1sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7SHRtbE9wdGlvbnMgYXMgT3B0aW9uc30gZnJvbSAnbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tZm9vdG5vdGUnXG4gKiBAaW1wb3J0IHtIdG1sRXh0ZW5zaW9ufSBmcm9tICdtaWNyb21hcmstdXRpbC10eXBlcydcbiAqL1xuXG5pbXBvcnQge29rIGFzIGFzc2VydH0gZnJvbSAnZGV2bG9wJ1xuaW1wb3J0IHtub3JtYWxpemVJZGVudGlmaWVyfSBmcm9tICdtaWNyb21hcmstdXRpbC1ub3JtYWxpemUtaWRlbnRpZmllcidcbmltcG9ydCB7c2FuaXRpemVVcml9IGZyb20gJ21pY3JvbWFyay11dGlsLXNhbml0aXplLXVyaSdcblxuY29uc3Qgb3duID0ge30uaGFzT3duUHJvcGVydHlcblxuLyoqIEB0eXBlIHtPcHRpb25zfSAqL1xuY29uc3QgZW1wdHlPcHRpb25zID0ge31cblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgZGVmYXVsdCBsYWJlbCB0aGF0IEdpdEh1YiB1c2VzIG9uIGJhY2tyZWZlcmVuY2VzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWZlcmVuY2VJbmRleFxuICogICBJbmRleCBvZiB0aGUgZGVmaW5pdGlvbiBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGFyZSBmaXJzdCByZWZlcmVuY2VkLFxuICogICAwLWluZGV4ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVyZWZlcmVuY2VJbmRleFxuICogICBJbmRleCBvZiBjYWxscyB0byB0aGUgc2FtZSBkZWZpbml0aW9uLCAwLWluZGV4ZWQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogICBEZWZhdWx0IGxhYmVsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdEJhY2tMYWJlbChyZWZlcmVuY2VJbmRleCwgcmVyZWZlcmVuY2VJbmRleCkge1xuICByZXR1cm4gKFxuICAgICdCYWNrIHRvIHJlZmVyZW5jZSAnICtcbiAgICAocmVmZXJlbmNlSW5kZXggKyAxKSArXG4gICAgKHJlcmVmZXJlbmNlSW5kZXggPiAxID8gJy0nICsgcmVyZWZlcmVuY2VJbmRleCA6ICcnKVxuICApXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdG8gc3VwcG9ydCBHRk0gZm9vdG5vdGVzIHdoZW5cbiAqIHNlcmlhbGl6aW5nIHRvIEhUTUwuXG4gKlxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnM9e31dXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHtIdG1sRXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtaWNyb21hcmtgIHRoYXQgY2FuIGJlIHBhc3NlZCBpbiBgaHRtbEV4dGVuc2lvbnNgIHRvXG4gKiAgIHN1cHBvcnQgR0ZNIGZvb3Rub3RlcyB3aGVuIHNlcmlhbGl6aW5nIHRvIEhUTUwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZm1Gb290bm90ZUh0bWwob3B0aW9ucykge1xuICBjb25zdCBjb25maWcgPSBvcHRpb25zIHx8IGVtcHR5T3B0aW9uc1xuICBjb25zdCBsYWJlbCA9IGNvbmZpZy5sYWJlbCB8fCAnRm9vdG5vdGVzJ1xuICBjb25zdCBsYWJlbFRhZ05hbWUgPSBjb25maWcubGFiZWxUYWdOYW1lIHx8ICdoMidcbiAgY29uc3QgbGFiZWxBdHRyaWJ1dGVzID1cbiAgICBjb25maWcubGFiZWxBdHRyaWJ1dGVzID09PSBudWxsIHx8IGNvbmZpZy5sYWJlbEF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZFxuICAgICAgPyAnY2xhc3M9XCJzci1vbmx5XCInXG4gICAgICA6IGNvbmZpZy5sYWJlbEF0dHJpYnV0ZXNcbiAgY29uc3QgYmFja0xhYmVsID0gY29uZmlnLmJhY2tMYWJlbCB8fCBkZWZhdWx0QmFja0xhYmVsXG4gIGNvbnN0IGNsb2JiZXJQcmVmaXggPVxuICAgIGNvbmZpZy5jbG9iYmVyUHJlZml4ID09PSBudWxsIHx8IGNvbmZpZy5jbG9iYmVyUHJlZml4ID09PSB1bmRlZmluZWRcbiAgICAgID8gJ3VzZXItY29udGVudC0nXG4gICAgICA6IGNvbmZpZy5jbG9iYmVyUHJlZml4XG4gIHJldHVybiB7XG4gICAgZW50ZXI6IHtcbiAgICAgIGdmbUZvb3Rub3RlRGVmaW5pdGlvbigpIHtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLmdldERhdGEoJ3RpZ2h0U3RhY2snKVxuICAgICAgICBzdGFjay5wdXNoKGZhbHNlKVxuICAgICAgfSxcbiAgICAgIGdmbUZvb3Rub3RlRGVmaW5pdGlvbkxhYmVsU3RyaW5nKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlcigpXG4gICAgICB9LFxuICAgICAgZ2ZtRm9vdG5vdGVDYWxsU3RyaW5nKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlcigpXG4gICAgICB9XG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICBnZm1Gb290bm90ZURlZmluaXRpb24oKSB7XG4gICAgICAgIGxldCBkZWZpbml0aW9ucyA9IHRoaXMuZ2V0RGF0YSgnZ2ZtRm9vdG5vdGVEZWZpbml0aW9ucycpXG4gICAgICAgIGNvbnN0IGZvb3Rub3RlU3RhY2sgPSB0aGlzLmdldERhdGEoJ2dmbUZvb3Rub3RlRGVmaW5pdGlvblN0YWNrJylcbiAgICAgICAgYXNzZXJ0KGZvb3Rub3RlU3RhY2ssICdleHBlY3RlZCBgZm9vdG5vdGVTdGFja2AnKVxuICAgICAgICBjb25zdCB0aWdodFN0YWNrID0gdGhpcy5nZXREYXRhKCd0aWdodFN0YWNrJylcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGZvb3Rub3RlU3RhY2sucG9wKClcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlc3VtZSgpXG5cbiAgICAgICAgYXNzZXJ0KGN1cnJlbnQsICdleHBlY3RlZCB0byBiZSBpbiBhIGZvb3Rub3RlJylcblxuICAgICAgICBpZiAoIWRlZmluaXRpb25zKSB7XG4gICAgICAgICAgdGhpcy5zZXREYXRhKCdnZm1Gb290bm90ZURlZmluaXRpb25zJywgKGRlZmluaXRpb25zID0ge30pKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvd24uY2FsbChkZWZpbml0aW9ucywgY3VycmVudCkpIGRlZmluaXRpb25zW2N1cnJlbnRdID0gdmFsdWVcblxuICAgICAgICB0aWdodFN0YWNrLnBvcCgpXG4gICAgICAgIHRoaXMuc2V0RGF0YSgnc2x1cnBPbmVMaW5lRW5kaW5nJywgdHJ1ZSlcbiAgICAgICAgLy8g4oCcSGFja+KAnSB0byBwcmV2ZW50IGEgbGluZSBlbmRpbmcgZnJvbSBzaG93aW5nIHVwIGlmIHdl4oCZcmUgaW4gYSBkZWZpbml0aW9uIGluXG4gICAgICAgIC8vIGFuIGVtcHR5IGxpc3QgaXRlbS5cbiAgICAgICAgdGhpcy5zZXREYXRhKCdsYXN0V2FzVGFnJylcbiAgICAgIH0sXG4gICAgICBnZm1Gb290bm90ZURlZmluaXRpb25MYWJlbFN0cmluZyh0b2tlbikge1xuICAgICAgICBsZXQgZm9vdG5vdGVTdGFjayA9IHRoaXMuZ2V0RGF0YSgnZ2ZtRm9vdG5vdGVEZWZpbml0aW9uU3RhY2snKVxuXG4gICAgICAgIGlmICghZm9vdG5vdGVTdGFjaykge1xuICAgICAgICAgIHRoaXMuc2V0RGF0YSgnZ2ZtRm9vdG5vdGVEZWZpbml0aW9uU3RhY2snLCAoZm9vdG5vdGVTdGFjayA9IFtdKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGZvb3Rub3RlU3RhY2sucHVzaChub3JtYWxpemVJZGVudGlmaWVyKHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pKSlcbiAgICAgICAgdGhpcy5yZXN1bWUoKSAvLyBEcm9wIHRoZSBsYWJlbC5cbiAgICAgICAgdGhpcy5idWZmZXIoKSAvLyBHZXQgcmVhZHkgZm9yIGEgdmFsdWUuXG4gICAgICB9LFxuICAgICAgZ2ZtRm9vdG5vdGVDYWxsU3RyaW5nKHRva2VuKSB7XG4gICAgICAgIGxldCBjYWxscyA9IHRoaXMuZ2V0RGF0YSgnZ2ZtRm9vdG5vdGVDYWxsT3JkZXInKVxuICAgICAgICBsZXQgY291bnRzID0gdGhpcy5nZXREYXRhKCdnZm1Gb290bm90ZUNhbGxDb3VudHMnKVxuICAgICAgICBjb25zdCBpZCA9IG5vcm1hbGl6ZUlkZW50aWZpZXIodGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbikpXG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICBsZXQgY291bnRlclxuXG4gICAgICAgIHRoaXMucmVzdW1lKClcblxuICAgICAgICBpZiAoIWNhbGxzKSB0aGlzLnNldERhdGEoJ2dmbUZvb3Rub3RlQ2FsbE9yZGVyJywgKGNhbGxzID0gW10pKVxuICAgICAgICBpZiAoIWNvdW50cykgdGhpcy5zZXREYXRhKCdnZm1Gb290bm90ZUNhbGxDb3VudHMnLCAoY291bnRzID0ge30pKVxuXG4gICAgICAgIGNvbnN0IGluZGV4ID0gY2FsbHMuaW5kZXhPZihpZClcbiAgICAgICAgY29uc3Qgc2FmZUlkID0gc2FuaXRpemVVcmkoaWQudG9Mb3dlckNhc2UoKSlcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgY2FsbHMucHVzaChpZClcbiAgICAgICAgICBjb3VudHNbaWRdID0gMVxuICAgICAgICAgIGNvdW50ZXIgPSBjYWxscy5sZW5ndGhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudHNbaWRdKytcbiAgICAgICAgICBjb3VudGVyID0gaW5kZXggKyAxXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXVzZUNvdW50ZXIgPSBjb3VudHNbaWRdXG5cbiAgICAgICAgdGhpcy50YWcoXG4gICAgICAgICAgJzxzdXA+PGEgaHJlZj1cIiMnICtcbiAgICAgICAgICAgIGNsb2JiZXJQcmVmaXggK1xuICAgICAgICAgICAgJ2ZuLScgK1xuICAgICAgICAgICAgc2FmZUlkICtcbiAgICAgICAgICAgICdcIiBpZD1cIicgK1xuICAgICAgICAgICAgY2xvYmJlclByZWZpeCArXG4gICAgICAgICAgICAnZm5yZWYtJyArXG4gICAgICAgICAgICBzYWZlSWQgK1xuICAgICAgICAgICAgKHJldXNlQ291bnRlciA+IDEgPyAnLScgKyByZXVzZUNvdW50ZXIgOiAnJykgK1xuICAgICAgICAgICAgJ1wiIGRhdGEtZm9vdG5vdGUtcmVmPVwiXCIgYXJpYS1kZXNjcmliZWRieT1cImZvb3Rub3RlLWxhYmVsXCI+JyArXG4gICAgICAgICAgICBTdHJpbmcoY291bnRlcikgK1xuICAgICAgICAgICAgJzwvYT48L3N1cD4nXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBudWxsKCkge1xuICAgICAgICBjb25zdCBjYWxscyA9IHRoaXMuZ2V0RGF0YSgnZ2ZtRm9vdG5vdGVDYWxsT3JkZXInKSB8fCBbXVxuICAgICAgICBjb25zdCBjb3VudHMgPSB0aGlzLmdldERhdGEoJ2dmbUZvb3Rub3RlQ2FsbENvdW50cycpIHx8IHt9XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb25zID0gdGhpcy5nZXREYXRhKCdnZm1Gb290bm90ZURlZmluaXRpb25zJykgfHwge31cbiAgICAgICAgbGV0IGluZGV4ID0gLTFcblxuICAgICAgICBpZiAoY2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMubGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICAgICAgICB0aGlzLnRhZyhcbiAgICAgICAgICAgICc8c2VjdGlvbiBkYXRhLWZvb3Rub3Rlcz1cIlwiIGNsYXNzPVwiZm9vdG5vdGVzXCI+PCcgK1xuICAgICAgICAgICAgICBsYWJlbFRhZ05hbWUgK1xuICAgICAgICAgICAgICAnIGlkPVwiZm9vdG5vdGUtbGFiZWxcIicgK1xuICAgICAgICAgICAgICAobGFiZWxBdHRyaWJ1dGVzID8gJyAnICsgbGFiZWxBdHRyaWJ1dGVzIDogJycpICtcbiAgICAgICAgICAgICAgJz4nXG4gICAgICAgICAgKVxuICAgICAgICAgIHRoaXMucmF3KHRoaXMuZW5jb2RlKGxhYmVsKSlcbiAgICAgICAgICB0aGlzLnRhZygnPC8nICsgbGFiZWxUYWdOYW1lICsgJz4nKVxuICAgICAgICAgIHRoaXMubGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICAgICAgICB0aGlzLnRhZygnPG9sPicpXG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGNhbGxzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIENhbGxlZCBkZWZpbml0aW9ucyBhcmUgYWx3YXlzIGRlZmluZWQuXG4gICAgICAgICAgY29uc3QgaWQgPSBjYWxsc1tpbmRleF1cbiAgICAgICAgICBjb25zdCBzYWZlSWQgPSBzYW5pdGl6ZVVyaShpZC50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgIGxldCByZWZlcmVuY2VJbmRleCA9IDBcbiAgICAgICAgICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlcyA9IFtdXG5cbiAgICAgICAgICB3aGlsZSAoKytyZWZlcmVuY2VJbmRleCA8PSBjb3VudHNbaWRdKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goXG4gICAgICAgICAgICAgICc8YSBocmVmPVwiIycgK1xuICAgICAgICAgICAgICAgIGNsb2JiZXJQcmVmaXggK1xuICAgICAgICAgICAgICAgICdmbnJlZi0nICtcbiAgICAgICAgICAgICAgICBzYWZlSWQgK1xuICAgICAgICAgICAgICAgIChyZWZlcmVuY2VJbmRleCA+IDEgPyAnLScgKyByZWZlcmVuY2VJbmRleCA6ICcnKSArXG4gICAgICAgICAgICAgICAgJ1wiIGRhdGEtZm9vdG5vdGUtYmFja3JlZj1cIlwiIGFyaWEtbGFiZWw9XCInICtcbiAgICAgICAgICAgICAgICB0aGlzLmVuY29kZShcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiBiYWNrTGFiZWwgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gYmFja0xhYmVsXG4gICAgICAgICAgICAgICAgICAgIDogYmFja0xhYmVsKGluZGV4LCByZWZlcmVuY2VJbmRleClcbiAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAnXCIgY2xhc3M9XCJkYXRhLWZvb3Rub3RlLWJhY2tyZWZcIj7ihqknICtcbiAgICAgICAgICAgICAgICAocmVmZXJlbmNlSW5kZXggPiAxXG4gICAgICAgICAgICAgICAgICA/ICc8c3VwPicgKyByZWZlcmVuY2VJbmRleCArICc8L3N1cD4nXG4gICAgICAgICAgICAgICAgICA6ICcnKSArXG4gICAgICAgICAgICAgICAgJzwvYT4nXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gcmVmZXJlbmNlcy5qb2luKCcgJylcbiAgICAgICAgICBsZXQgaW5qZWN0ZWQgPSBmYWxzZVxuXG4gICAgICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgICAgIHRoaXMudGFnKCc8bGkgaWQ9XCInICsgY2xvYmJlclByZWZpeCArICdmbi0nICsgc2FmZUlkICsgJ1wiPicpXG4gICAgICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgICAgIHRoaXMudGFnKFxuICAgICAgICAgICAgZGVmaW5pdGlvbnNbaWRdLnJlcGxhY2UoLzxcXC9wPig/Olxccj9cXG58XFxyKT8kLywgZnVuY3Rpb24gKCQwKSB7XG4gICAgICAgICAgICAgIGluamVjdGVkID0gdHJ1ZVxuICAgICAgICAgICAgICByZXR1cm4gJyAnICsgcmVmZXJlbmNlICsgJDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgaWYgKCFpbmplY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgICAgICAgdGhpcy50YWcocmVmZXJlbmNlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICAgICAgICB0aGlzLnRhZygnPC9saT4nKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICAgICAgdGhpcy50YWcoJzwvb2w+JylcbiAgICAgICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICAgICAgdGhpcy50YWcoJzwvc2VjdGlvbj4nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/micromark-extension-gfm-footnote/dev/lib/html.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/micromark-extension-gfm-footnote/dev/lib/syntax.js":
/*!*************************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-footnote/dev/lib/syntax.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmFootnote: () => (/* binding */ gfmFootnote)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! devlop */ \"(app-pages-browser)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! micromark-core-commonmark */ \"(app-pages-browser)/./node_modules/micromark-core-commonmark/dev/lib/blank-line.js\");\n/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! micromark-factory-space */ \"(app-pages-browser)/./node_modules/micromark-factory-space/dev/index.js\");\n/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-character */ \"(app-pages-browser)/./node_modules/micromark-util-character/dev/index.js\");\n/* harmony import */ var micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-normalize-identifier */ \"(app-pages-browser)/./node_modules/micromark-util-normalize-identifier/dev/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/types.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/constants.js\");\n/**\n * @import {Event, Exiter, Extension, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\n\n\n\n\n\n\n\nconst indent = {tokenize: tokenizeIndent, partial: true}\n\n// To do: micromark should support a `_hiddenGfmFootnoteSupport`, which only\n// affects label start (image).\n// That will let us drop `tokenizePotentialGfmFootnote*`.\n// It currently has a `_hiddenFootnoteSupport`, which affects that and more.\n// That can be removed when `micromark-extension-footnote` is archived.\n\n/**\n * Create an extension for `micromark` to enable GFM footnote syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to\n *   enable GFM footnote syntax.\n */\nfunction gfmFootnote() {\n  /** @type {Extension} */\n  return {\n    document: {\n      [micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket]: {\n        name: 'gfmFootnoteDefinition',\n        tokenize: tokenizeDefinitionStart,\n        continuation: {tokenize: tokenizeDefinitionContinuation},\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket]: {\n        name: 'gfmFootnoteCall',\n        tokenize: tokenizeGfmFootnoteCall\n      },\n      [micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightSquareBracket]: {\n        name: 'gfmPotentialFootnoteCall',\n        add: 'after',\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  }\n}\n\n// To do: remove after micromark update.\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {Token} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    const token = self.events[index][1]\n\n    if (token.type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.labelImage) {\n      labelStart = token\n      break\n    }\n\n    // Exit if weve walked far enough.\n    if (\n      token.type === 'gfmFootnoteCall' ||\n      token.type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.labelLink ||\n      token.type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.label ||\n      token.type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.image ||\n      token.type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.link\n    ) {\n      break\n    }\n  }\n\n  return start\n\n  /**\n   * @type {State}\n   */\n  function start(code) {\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightSquareBracket, 'expected `]`')\n\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code)\n    }\n\n    const id = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_3__.normalizeIdentifier)(\n      self.sliceSerialize({start: labelStart.end, end: self.now()})\n    )\n\n    if (id.codePointAt(0) !== micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.caret || !defined.includes(id.slice(1))) {\n      return nok(code)\n    }\n\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return ok(code)\n  }\n}\n\n// To do: remove after micromark update.\n/** @type {Resolver} */\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length\n  /** @type {Token | undefined} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    if (\n      events[index][1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.labelImage &&\n      events[index][0] === 'enter'\n    ) {\n      labelStart = events[index][1]\n      break\n    }\n  }\n\n  (0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(labelStart, 'expected `labelStart` to resolve')\n\n  // Change the `labelImageMarker` to a `data`.\n  events[index + 1][1].type = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.data\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'\n\n  // The whole (without `!`):\n  /** @type {Token} */\n  const call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  // The `^` marker\n  /** @type {Token} */\n  const marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  }\n  // Increment the end 1 character.\n  marker.end.column++\n  marker.end.offset++\n  marker.end._bufferIndex++\n  /** @type {Token} */\n  const string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  }\n  /** @type {Token} */\n  const chunk = {\n    type: micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.types.chunkString,\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  }\n\n  /** @type {Array<Event>} */\n  const replacement = [\n    // Take the `labelImageMarker` (now `data`, the `!`)\n    events[index + 1],\n    events[index + 2],\n    ['enter', call, context],\n    // The `[`\n    events[index + 3],\n    events[index + 4],\n    // The `^`.\n    ['enter', marker, context],\n    ['exit', marker, context],\n    // Everything in between.\n    ['enter', string, context],\n    ['enter', chunk, context],\n    ['exit', chunk, context],\n    ['exit', string, context],\n    // The ending (`]`, properly parsed and labelled).\n    events[events.length - 2],\n    events[events.length - 1],\n    ['exit', call, context]\n  ]\n\n  events.splice(index, events.length - index + 1, ...replacement)\n\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  let size = 0\n  /** @type {boolean} */\n  let data\n\n  // Note: the implementation of `markdown-rs` is different, because it houses\n  // core *and* extensions in one project.\n  // Therefore, it can include footnote logic inside `label-end`.\n  // We cant do that, but luckily, we can parse footnotes in a simpler way than\n  // needed for labels.\n  return start\n\n  /**\n   * Start of footnote label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket, 'expected `[`')\n    effects.enter('gfmFootnoteCall')\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return callStart\n  }\n\n  /**\n   * After `[`, at `^`.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callStart(code) {\n    if (code !== micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.caret) return nok(code)\n\n    effects.enter('gfmFootnoteCallMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallMarker')\n    effects.enter('gfmFootnoteCallString')\n    effects.enter('chunkString').contentType = 'string'\n    return callData\n  }\n\n  /**\n   * In label.\n   *\n   * ```markdown\n   * > | a [^b] c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callData(code) {\n    if (\n      // Too long.\n      size > micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.constants.linkReferenceSizeMax ||\n      // Closing brace with nothing.\n      (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightSquareBracket && !data) ||\n      // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_5__.markdownLineEndingOrSpace)(code)\n    ) {\n      return nok(code)\n    }\n\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightSquareBracket) {\n      effects.exit('chunkString')\n      const token = effects.exit('gfmFootnoteCallString')\n\n      if (!defined.includes((0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_3__.normalizeIdentifier)(self.sliceSerialize(token)))) {\n        return nok(code)\n      }\n\n      effects.enter('gfmFootnoteCallLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteCallLabelMarker')\n      effects.exit('gfmFootnoteCall')\n      return ok\n    }\n\n    if (!(0,micromark_util_character__WEBPACK_IMPORTED_MODULE_5__.markdownLineEndingOrSpace)(code)) {\n      data = true\n    }\n\n    size++\n    effects.consume(code)\n    return code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.backslash ? callEscape : callData\n  }\n\n  /**\n   * On character after escape.\n   *\n   * ```markdown\n   * > | a [^b\\c] d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function callEscape(code) {\n    if (\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.backslash ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightSquareBracket\n    ) {\n      effects.consume(code)\n      size++\n      return callData\n    }\n\n    return callData(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  const self = this\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {string} */\n  let identifier\n  let size = 0\n  /** @type {boolean | undefined} */\n  let data\n\n  return start\n\n  /**\n   * Start of GFM footnote definition.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket, 'expected `[`')\n    effects.enter('gfmFootnoteDefinition')._container = true\n    effects.enter('gfmFootnoteDefinitionLabel')\n    effects.enter('gfmFootnoteDefinitionLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteDefinitionLabelMarker')\n    return labelAtMarker\n  }\n\n  /**\n   * In label, at caret.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAtMarker(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.caret) {\n      effects.enter('gfmFootnoteDefinitionMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionMarker')\n      effects.enter('gfmFootnoteDefinitionLabelString')\n      effects.enter('chunkString').contentType = 'string'\n      return labelInside\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * In label.\n   *\n   * >  **Note**: `cmark-gfm` prevents whitespace from occurring in footnote\n   * > definition labels.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelInside(code) {\n    if (\n      // Too long.\n      size > micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.constants.linkReferenceSizeMax ||\n      // Closing brace with nothing.\n      (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightSquareBracket && !data) ||\n      // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_5__.markdownLineEndingOrSpace)(code)\n    ) {\n      return nok(code)\n    }\n\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightSquareBracket) {\n      effects.exit('chunkString')\n      const token = effects.exit('gfmFootnoteDefinitionLabelString')\n      identifier = (0,micromark_util_normalize_identifier__WEBPACK_IMPORTED_MODULE_3__.normalizeIdentifier)(self.sliceSerialize(token))\n      effects.enter('gfmFootnoteDefinitionLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionLabelMarker')\n      effects.exit('gfmFootnoteDefinitionLabel')\n      return labelAfter\n    }\n\n    if (!(0,micromark_util_character__WEBPACK_IMPORTED_MODULE_5__.markdownLineEndingOrSpace)(code)) {\n      data = true\n    }\n\n    size++\n    effects.consume(code)\n    return code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.backslash ? labelEscape : labelInside\n  }\n\n  /**\n   * After `\\`, at a special character.\n   *\n   * >  **Note**: `cmark-gfm` currently does not support escaped brackets:\n   * > <https://github.com/github/cmark-gfm/issues/240>\n   *\n   * ```markdown\n   * > | [^a\\*b]: c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEscape(code) {\n    if (\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.backslash ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightSquareBracket\n    ) {\n      effects.consume(code)\n      size++\n      return labelInside\n    }\n\n    return labelInside(code)\n  }\n\n  /**\n   * After definition label.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAfter(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.colon) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker')\n\n      if (!defined.includes(identifier)) {\n        defined.push(identifier)\n      }\n\n      // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n      return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_6__.factorySpace)(\n        effects,\n        whitespaceAfter,\n        'gfmFootnoteDefinitionWhitespace'\n      )\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * After definition prefix.\n   *\n   * ```markdown\n   * > | [^a]: b\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function whitespaceAfter(code) {\n    // `markdown-rs` has a wrapping token for the prefix that is closed here.\n    return ok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  /// Start of footnote definition continuation.\n  ///\n  /// ```markdown\n  ///   | [^a]: b\n  /// > |     c\n  ///     ^\n  /// ```\n  //\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(micromark_core_commonmark__WEBPACK_IMPORTED_MODULE_7__.blankLine, ok, effects.attempt(indent, ok, nok))\n}\n\n/** @type {Exiter} */\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition')\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n\n  return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_6__.factorySpace)(\n    effects,\n    afterPrefix,\n    'gfmFootnoteDefinitionIndent',\n    micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.constants.tabSize + 1\n  )\n\n  /**\n   * @type {State}\n   */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'gfmFootnoteDefinitionIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.constants.tabSize\n      ? ok(code)\n      : nok(code)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS1mb290bm90ZS9kZXYvbGliL3N5bnRheC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLFlBQVksOEVBQThFO0FBQzFGOztBQUVtQztBQUNnQjtBQUNDO0FBQ2M7QUFDSztBQUNWOztBQUU3RCxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQSxPQUFPLHdEQUFLO0FBQ1o7QUFDQTtBQUNBLHVCQUF1Qix5Q0FBeUM7QUFDaEU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLE9BQU8sd0RBQUs7QUFDWjtBQUNBO0FBQ0EsT0FBTztBQUNQLE9BQU8sd0RBQUs7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qix3REFBSztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFLO0FBQzFCLHFCQUFxQix3REFBSztBQUMxQixxQkFBcUIsd0RBQUs7QUFDMUIscUJBQXFCLHdEQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxJQUFJLDJDQUFNLFVBQVUsd0RBQUs7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHdGQUFtQjtBQUNsQywyQkFBMkIsdUNBQXVDO0FBQ2xFOztBQUVBLDhCQUE4Qix3REFBSztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxxRUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFTO0FBQ2I7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw0REFBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tZm9vdG5vdGUvZGV2L2xpYi9zeW50YXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtFdmVudCwgRXhpdGVyLCBFeHRlbnNpb24sIFJlc29sdmVyLCBTdGF0ZSwgVG9rZW4sIFRva2VuaXplQ29udGV4dCwgVG9rZW5pemVyfSBmcm9tICdtaWNyb21hcmstdXRpbC10eXBlcydcbiAqL1xuXG5pbXBvcnQge29rIGFzIGFzc2VydH0gZnJvbSAnZGV2bG9wJ1xuaW1wb3J0IHtibGFua0xpbmV9IGZyb20gJ21pY3JvbWFyay1jb3JlLWNvbW1vbm1hcmsnXG5pbXBvcnQge2ZhY3RvcnlTcGFjZX0gZnJvbSAnbWljcm9tYXJrLWZhY3Rvcnktc3BhY2UnXG5pbXBvcnQge21hcmtkb3duTGluZUVuZGluZ09yU3BhY2V9IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcbmltcG9ydCB7bm9ybWFsaXplSWRlbnRpZmllcn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtbm9ybWFsaXplLWlkZW50aWZpZXInXG5pbXBvcnQge2NvZGVzLCBjb25zdGFudHMsIHR5cGVzfSBmcm9tICdtaWNyb21hcmstdXRpbC1zeW1ib2wnXG5cbmNvbnN0IGluZGVudCA9IHt0b2tlbml6ZTogdG9rZW5pemVJbmRlbnQsIHBhcnRpYWw6IHRydWV9XG5cbi8vIFRvIGRvOiBtaWNyb21hcmsgc2hvdWxkIHN1cHBvcnQgYSBgX2hpZGRlbkdmbUZvb3Rub3RlU3VwcG9ydGAsIHdoaWNoIG9ubHlcbi8vIGFmZmVjdHMgbGFiZWwgc3RhcnQgKGltYWdlKS5cbi8vIFRoYXQgd2lsbCBsZXQgdXMgZHJvcCBgdG9rZW5pemVQb3RlbnRpYWxHZm1Gb290bm90ZSpgLlxuLy8gSXQgY3VycmVudGx5IGhhcyBhIGBfaGlkZGVuRm9vdG5vdGVTdXBwb3J0YCwgd2hpY2ggYWZmZWN0cyB0aGF0IGFuZCBtb3JlLlxuLy8gVGhhdCBjYW4gYmUgcmVtb3ZlZCB3aGVuIGBtaWNyb21hcmstZXh0ZW5zaW9uLWZvb3Rub3RlYCBpcyBhcmNoaXZlZC5cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIGZvciBgbWljcm9tYXJrYCB0byBlbmFibGUgR0ZNIGZvb3Rub3RlIHN5bnRheC5cbiAqXG4gKiBAcmV0dXJucyB7RXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtaWNyb21hcmtgIHRoYXQgY2FuIGJlIHBhc3NlZCBpbiBgZXh0ZW5zaW9uc2AgdG9cbiAqICAgZW5hYmxlIEdGTSBmb290bm90ZSBzeW50YXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZm1Gb290bm90ZSgpIHtcbiAgLyoqIEB0eXBlIHtFeHRlbnNpb259ICovXG4gIHJldHVybiB7XG4gICAgZG9jdW1lbnQ6IHtcbiAgICAgIFtjb2Rlcy5sZWZ0U3F1YXJlQnJhY2tldF06IHtcbiAgICAgICAgbmFtZTogJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbicsXG4gICAgICAgIHRva2VuaXplOiB0b2tlbml6ZURlZmluaXRpb25TdGFydCxcbiAgICAgICAgY29udGludWF0aW9uOiB7dG9rZW5pemU6IHRva2VuaXplRGVmaW5pdGlvbkNvbnRpbnVhdGlvbn0sXG4gICAgICAgIGV4aXQ6IGdmbUZvb3Rub3RlRGVmaW5pdGlvbkVuZFxuICAgICAgfVxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgW2NvZGVzLmxlZnRTcXVhcmVCcmFja2V0XToge1xuICAgICAgICBuYW1lOiAnZ2ZtRm9vdG5vdGVDYWxsJyxcbiAgICAgICAgdG9rZW5pemU6IHRva2VuaXplR2ZtRm9vdG5vdGVDYWxsXG4gICAgICB9LFxuICAgICAgW2NvZGVzLnJpZ2h0U3F1YXJlQnJhY2tldF06IHtcbiAgICAgICAgbmFtZTogJ2dmbVBvdGVudGlhbEZvb3Rub3RlQ2FsbCcsXG4gICAgICAgIGFkZDogJ2FmdGVyJyxcbiAgICAgICAgdG9rZW5pemU6IHRva2VuaXplUG90ZW50aWFsR2ZtRm9vdG5vdGVDYWxsLFxuICAgICAgICByZXNvbHZlVG86IHJlc29sdmVUb1BvdGVudGlhbEdmbUZvb3Rub3RlQ2FsbFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBUbyBkbzogcmVtb3ZlIGFmdGVyIG1pY3JvbWFyayB1cGRhdGUuXG4vKipcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAdHlwZSB7VG9rZW5pemVyfVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZVBvdGVudGlhbEdmbUZvb3Rub3RlQ2FsbChlZmZlY3RzLCBvaywgbm9rKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGxldCBpbmRleCA9IHNlbGYuZXZlbnRzLmxlbmd0aFxuICBjb25zdCBkZWZpbmVkID0gc2VsZi5wYXJzZXIuZ2ZtRm9vdG5vdGVzIHx8IChzZWxmLnBhcnNlci5nZm1Gb290bm90ZXMgPSBbXSlcbiAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cbiAgbGV0IGxhYmVsU3RhcnRcblxuICAvLyBGaW5kIGFuIG9wZW5pbmcuXG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgY29uc3QgdG9rZW4gPSBzZWxmLmV2ZW50c1tpbmRleF1bMV1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSB0eXBlcy5sYWJlbEltYWdlKSB7XG4gICAgICBsYWJlbFN0YXJ0ID0gdG9rZW5cbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgLy8gRXhpdCBpZiB3ZeKAmXZlIHdhbGtlZCBmYXIgZW5vdWdoLlxuICAgIGlmIChcbiAgICAgIHRva2VuLnR5cGUgPT09ICdnZm1Gb290bm90ZUNhbGwnIHx8XG4gICAgICB0b2tlbi50eXBlID09PSB0eXBlcy5sYWJlbExpbmsgfHxcbiAgICAgIHRva2VuLnR5cGUgPT09IHR5cGVzLmxhYmVsIHx8XG4gICAgICB0b2tlbi50eXBlID09PSB0eXBlcy5pbWFnZSB8fFxuICAgICAgdG9rZW4udHlwZSA9PT0gdHlwZXMubGlua1xuICAgICkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RhcnRcblxuICAvKipcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGFzc2VydChjb2RlID09PSBjb2Rlcy5yaWdodFNxdWFyZUJyYWNrZXQsICdleHBlY3RlZCBgXWAnKVxuXG4gICAgaWYgKCFsYWJlbFN0YXJ0IHx8ICFsYWJlbFN0YXJ0Ll9iYWxhbmNlZCkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGNvbnN0IGlkID0gbm9ybWFsaXplSWRlbnRpZmllcihcbiAgICAgIHNlbGYuc2xpY2VTZXJpYWxpemUoe3N0YXJ0OiBsYWJlbFN0YXJ0LmVuZCwgZW5kOiBzZWxmLm5vdygpfSlcbiAgICApXG5cbiAgICBpZiAoaWQuY29kZVBvaW50QXQoMCkgIT09IGNvZGVzLmNhcmV0IHx8ICFkZWZpbmVkLmluY2x1ZGVzKGlkLnNsaWNlKDEpKSkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ2dmbUZvb3Rub3RlQ2FsbExhYmVsTWFya2VyJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2dmbUZvb3Rub3RlQ2FsbExhYmVsTWFya2VyJylcbiAgICByZXR1cm4gb2soY29kZSlcbiAgfVxufVxuXG4vLyBUbyBkbzogcmVtb3ZlIGFmdGVyIG1pY3JvbWFyayB1cGRhdGUuXG4vKiogQHR5cGUge1Jlc29sdmVyfSAqL1xuZnVuY3Rpb24gcmVzb2x2ZVRvUG90ZW50aWFsR2ZtRm9vdG5vdGVDYWxsKGV2ZW50cywgY29udGV4dCkge1xuICBsZXQgaW5kZXggPSBldmVudHMubGVuZ3RoXG4gIC8qKiBAdHlwZSB7VG9rZW4gfCB1bmRlZmluZWR9ICovXG4gIGxldCBsYWJlbFN0YXJ0XG5cbiAgLy8gRmluZCBhbiBvcGVuaW5nLlxuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIGlmIChcbiAgICAgIGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gdHlwZXMubGFiZWxJbWFnZSAmJlxuICAgICAgZXZlbnRzW2luZGV4XVswXSA9PT0gJ2VudGVyJ1xuICAgICkge1xuICAgICAgbGFiZWxTdGFydCA9IGV2ZW50c1tpbmRleF1bMV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgYXNzZXJ0KGxhYmVsU3RhcnQsICdleHBlY3RlZCBgbGFiZWxTdGFydGAgdG8gcmVzb2x2ZScpXG5cbiAgLy8gQ2hhbmdlIHRoZSBgbGFiZWxJbWFnZU1hcmtlcmAgdG8gYSBgZGF0YWAuXG4gIGV2ZW50c1tpbmRleCArIDFdWzFdLnR5cGUgPSB0eXBlcy5kYXRhXG4gIGV2ZW50c1tpbmRleCArIDNdWzFdLnR5cGUgPSAnZ2ZtRm9vdG5vdGVDYWxsTGFiZWxNYXJrZXInXG5cbiAgLy8gVGhlIHdob2xlICh3aXRob3V0IGAhYCk6XG4gIC8qKiBAdHlwZSB7VG9rZW59ICovXG4gIGNvbnN0IGNhbGwgPSB7XG4gICAgdHlwZTogJ2dmbUZvb3Rub3RlQ2FsbCcsXG4gICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tpbmRleCArIDNdWzFdLnN0YXJ0KSxcbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV1bMV0uZW5kKVxuICB9XG4gIC8vIFRoZSBgXmAgbWFya2VyXG4gIC8qKiBAdHlwZSB7VG9rZW59ICovXG4gIGNvbnN0IG1hcmtlciA9IHtcbiAgICB0eXBlOiAnZ2ZtRm9vdG5vdGVDYWxsTWFya2VyJyxcbiAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW2luZGV4ICsgM11bMV0uZW5kKSxcbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tpbmRleCArIDNdWzFdLmVuZClcbiAgfVxuICAvLyBJbmNyZW1lbnQgdGhlIGVuZCAxIGNoYXJhY3Rlci5cbiAgbWFya2VyLmVuZC5jb2x1bW4rK1xuICBtYXJrZXIuZW5kLm9mZnNldCsrXG4gIG1hcmtlci5lbmQuX2J1ZmZlckluZGV4KytcbiAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cbiAgY29uc3Qgc3RyaW5nID0ge1xuICAgIHR5cGU6ICdnZm1Gb290bm90ZUNhbGxTdHJpbmcnLFxuICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBtYXJrZXIuZW5kKSxcbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV1bMV0uc3RhcnQpXG4gIH1cbiAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cbiAgY29uc3QgY2h1bmsgPSB7XG4gICAgdHlwZTogdHlwZXMuY2h1bmtTdHJpbmcsXG4gICAgY29udGVudFR5cGU6ICdzdHJpbmcnLFxuICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBzdHJpbmcuc3RhcnQpLFxuICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgc3RyaW5nLmVuZClcbiAgfVxuXG4gIC8qKiBAdHlwZSB7QXJyYXk8RXZlbnQ+fSAqL1xuICBjb25zdCByZXBsYWNlbWVudCA9IFtcbiAgICAvLyBUYWtlIHRoZSBgbGFiZWxJbWFnZU1hcmtlcmAgKG5vdyBgZGF0YWAsIHRoZSBgIWApXG4gICAgZXZlbnRzW2luZGV4ICsgMV0sXG4gICAgZXZlbnRzW2luZGV4ICsgMl0sXG4gICAgWydlbnRlcicsIGNhbGwsIGNvbnRleHRdLFxuICAgIC8vIFRoZSBgW2BcbiAgICBldmVudHNbaW5kZXggKyAzXSxcbiAgICBldmVudHNbaW5kZXggKyA0XSxcbiAgICAvLyBUaGUgYF5gLlxuICAgIFsnZW50ZXInLCBtYXJrZXIsIGNvbnRleHRdLFxuICAgIFsnZXhpdCcsIG1hcmtlciwgY29udGV4dF0sXG4gICAgLy8gRXZlcnl0aGluZyBpbiBiZXR3ZWVuLlxuICAgIFsnZW50ZXInLCBzdHJpbmcsIGNvbnRleHRdLFxuICAgIFsnZW50ZXInLCBjaHVuaywgY29udGV4dF0sXG4gICAgWydleGl0JywgY2h1bmssIGNvbnRleHRdLFxuICAgIFsnZXhpdCcsIHN0cmluZywgY29udGV4dF0sXG4gICAgLy8gVGhlIGVuZGluZyAoYF1gLCBwcm9wZXJseSBwYXJzZWQgYW5kIGxhYmVsbGVkKS5cbiAgICBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDJdLFxuICAgIGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV0sXG4gICAgWydleGl0JywgY2FsbCwgY29udGV4dF1cbiAgXVxuXG4gIGV2ZW50cy5zcGxpY2UoaW5kZXgsIGV2ZW50cy5sZW5ndGggLSBpbmRleCArIDEsIC4uLnJlcGxhY2VtZW50KVxuXG4gIHJldHVybiBldmVudHNcbn1cblxuLyoqXG4gKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0fVxuICogQHR5cGUge1Rva2VuaXplcn1cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemVHZm1Gb290bm90ZUNhbGwoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBjb25zdCBkZWZpbmVkID0gc2VsZi5wYXJzZXIuZ2ZtRm9vdG5vdGVzIHx8IChzZWxmLnBhcnNlci5nZm1Gb290bm90ZXMgPSBbXSlcbiAgbGV0IHNpemUgPSAwXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgbGV0IGRhdGFcblxuICAvLyBOb3RlOiB0aGUgaW1wbGVtZW50YXRpb24gb2YgYG1hcmtkb3duLXJzYCBpcyBkaWZmZXJlbnQsIGJlY2F1c2UgaXQgaG91c2VzXG4gIC8vIGNvcmUgKmFuZCogZXh0ZW5zaW9ucyBpbiBvbmUgcHJvamVjdC5cbiAgLy8gVGhlcmVmb3JlLCBpdCBjYW4gaW5jbHVkZSBmb290bm90ZSBsb2dpYyBpbnNpZGUgYGxhYmVsLWVuZGAuXG4gIC8vIFdlIGNhbuKAmXQgZG8gdGhhdCwgYnV0IGx1Y2tpbHksIHdlIGNhbiBwYXJzZSBmb290bm90ZXMgaW4gYSBzaW1wbGVyIHdheSB0aGFuXG4gIC8vIG5lZWRlZCBmb3IgbGFiZWxzLlxuICByZXR1cm4gc3RhcnRcblxuICAvKipcbiAgICogU3RhcnQgb2YgZm9vdG5vdGUgbGFiZWwuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBhIFteYl0gY1xuICAgKiAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgYXNzZXJ0KGNvZGUgPT09IGNvZGVzLmxlZnRTcXVhcmVCcmFja2V0LCAnZXhwZWN0ZWQgYFtgJylcbiAgICBlZmZlY3RzLmVudGVyKCdnZm1Gb290bm90ZUNhbGwnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2dmbUZvb3Rub3RlQ2FsbExhYmVsTWFya2VyJylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQoJ2dmbUZvb3Rub3RlQ2FsbExhYmVsTWFya2VyJylcbiAgICByZXR1cm4gY2FsbFN0YXJ0XG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgYFtgLCBhdCBgXmAuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBhIFteYl0gY1xuICAgKiAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gY2FsbFN0YXJ0KGNvZGUpIHtcbiAgICBpZiAoY29kZSAhPT0gY29kZXMuY2FyZXQpIHJldHVybiBub2soY29kZSlcblxuICAgIGVmZmVjdHMuZW50ZXIoJ2dmbUZvb3Rub3RlQ2FsbE1hcmtlcicpXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgZWZmZWN0cy5leGl0KCdnZm1Gb290bm90ZUNhbGxNYXJrZXInKVxuICAgIGVmZmVjdHMuZW50ZXIoJ2dmbUZvb3Rub3RlQ2FsbFN0cmluZycpXG4gICAgZWZmZWN0cy5lbnRlcignY2h1bmtTdHJpbmcnKS5jb250ZW50VHlwZSA9ICdzdHJpbmcnXG4gICAgcmV0dXJuIGNhbGxEYXRhXG4gIH1cblxuICAvKipcbiAgICogSW4gbGFiZWwuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBhIFteYl0gY1xuICAgKiAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGNhbGxEYXRhKGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICAvLyBUb28gbG9uZy5cbiAgICAgIHNpemUgPiBjb25zdGFudHMubGlua1JlZmVyZW5jZVNpemVNYXggfHxcbiAgICAgIC8vIENsb3NpbmcgYnJhY2Ugd2l0aCBub3RoaW5nLlxuICAgICAgKGNvZGUgPT09IGNvZGVzLnJpZ2h0U3F1YXJlQnJhY2tldCAmJiAhZGF0YSkgfHxcbiAgICAgIC8vIFNwYWNlIG9yIHRhYiBpcyBub3Qgc3VwcG9ydGVkIGJ5IEdGTSBmb3Igc29tZSByZWFzb24uXG4gICAgICAvLyBgXFxuYCBhbmQgYFtgIG5vdCBiZWluZyBzdXBwb3J0ZWQgbWFrZXMgc2Vuc2UuXG4gICAgICBjb2RlID09PSBjb2Rlcy5lb2YgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLmxlZnRTcXVhcmVCcmFja2V0IHx8XG4gICAgICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlKGNvZGUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLnJpZ2h0U3F1YXJlQnJhY2tldCkge1xuICAgICAgZWZmZWN0cy5leGl0KCdjaHVua1N0cmluZycpXG4gICAgICBjb25zdCB0b2tlbiA9IGVmZmVjdHMuZXhpdCgnZ2ZtRm9vdG5vdGVDYWxsU3RyaW5nJylcblxuICAgICAgaWYgKCFkZWZpbmVkLmluY2x1ZGVzKG5vcm1hbGl6ZUlkZW50aWZpZXIoc2VsZi5zbGljZVNlcmlhbGl6ZSh0b2tlbikpKSkge1xuICAgICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIGVmZmVjdHMuZW50ZXIoJ2dmbUZvb3Rub3RlQ2FsbExhYmVsTWFya2VyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdnZm1Gb290bm90ZUNhbGxMYWJlbE1hcmtlcicpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2dmbUZvb3Rub3RlQ2FsbCcpXG4gICAgICByZXR1cm4gb2tcbiAgICB9XG5cbiAgICBpZiAoIW1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSkpIHtcbiAgICAgIGRhdGEgPSB0cnVlXG4gICAgfVxuXG4gICAgc2l6ZSsrXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvZGUgPT09IGNvZGVzLmJhY2tzbGFzaCA/IGNhbGxFc2NhcGUgOiBjYWxsRGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGNoYXJhY3RlciBhZnRlciBlc2NhcGUuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBhIFteYlxcY10gZFxuICAgKiAgICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gY2FsbEVzY2FwZShjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gY29kZXMubGVmdFNxdWFyZUJyYWNrZXQgfHxcbiAgICAgIGNvZGUgPT09IGNvZGVzLmJhY2tzbGFzaCB8fFxuICAgICAgY29kZSA9PT0gY29kZXMucmlnaHRTcXVhcmVCcmFja2V0XG4gICAgKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHNpemUrK1xuICAgICAgcmV0dXJuIGNhbGxEYXRhXG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGxEYXRhKGNvZGUpXG4gIH1cbn1cblxuLyoqXG4gKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0fVxuICogQHR5cGUge1Rva2VuaXplcn1cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemVEZWZpbml0aW9uU3RhcnQoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBjb25zdCBkZWZpbmVkID0gc2VsZi5wYXJzZXIuZ2ZtRm9vdG5vdGVzIHx8IChzZWxmLnBhcnNlci5nZm1Gb290bm90ZXMgPSBbXSlcbiAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gIGxldCBpZGVudGlmaWVyXG4gIGxldCBzaXplID0gMFxuICAvKiogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9ICovXG4gIGxldCBkYXRhXG5cbiAgcmV0dXJuIHN0YXJ0XG5cbiAgLyoqXG4gICAqIFN0YXJ0IG9mIEdGTSBmb290bm90ZSBkZWZpbml0aW9uLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgW15hXTogYlxuICAgKiAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gc3RhcnQoY29kZSkge1xuICAgIGFzc2VydChjb2RlID09PSBjb2Rlcy5sZWZ0U3F1YXJlQnJhY2tldCwgJ2V4cGVjdGVkIGBbYCcpXG4gICAgZWZmZWN0cy5lbnRlcignZ2ZtRm9vdG5vdGVEZWZpbml0aW9uJykuX2NvbnRhaW5lciA9IHRydWVcbiAgICBlZmZlY3RzLmVudGVyKCdnZm1Gb290bm90ZURlZmluaXRpb25MYWJlbCcpXG4gICAgZWZmZWN0cy5lbnRlcignZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTGFiZWxNYXJrZXInKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgnZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTGFiZWxNYXJrZXInKVxuICAgIHJldHVybiBsYWJlbEF0TWFya2VyXG4gIH1cblxuICAvKipcbiAgICogSW4gbGFiZWwsIGF0IGNhcmV0LlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgW15hXTogYlxuICAgKiAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGxhYmVsQXRNYXJrZXIoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBjb2Rlcy5jYXJldCkge1xuICAgICAgZWZmZWN0cy5lbnRlcignZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTWFya2VyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCdnZm1Gb290bm90ZURlZmluaXRpb25NYXJrZXInKVxuICAgICAgZWZmZWN0cy5lbnRlcignZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTGFiZWxTdHJpbmcnKVxuICAgICAgZWZmZWN0cy5lbnRlcignY2h1bmtTdHJpbmcnKS5jb250ZW50VHlwZSA9ICdzdHJpbmcnXG4gICAgICByZXR1cm4gbGFiZWxJbnNpZGVcbiAgICB9XG5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogSW4gbGFiZWwuXG4gICAqXG4gICAqID4g8J+RiSAqKk5vdGUqKjogYGNtYXJrLWdmbWAgcHJldmVudHMgd2hpdGVzcGFjZSBmcm9tIG9jY3VycmluZyBpbiBmb290bm90ZVxuICAgKiA+IGRlZmluaXRpb24gbGFiZWxzLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgW15hXTogYlxuICAgKiAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBsYWJlbEluc2lkZShjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgLy8gVG9vIGxvbmcuXG4gICAgICBzaXplID4gY29uc3RhbnRzLmxpbmtSZWZlcmVuY2VTaXplTWF4IHx8XG4gICAgICAvLyBDbG9zaW5nIGJyYWNlIHdpdGggbm90aGluZy5cbiAgICAgIChjb2RlID09PSBjb2Rlcy5yaWdodFNxdWFyZUJyYWNrZXQgJiYgIWRhdGEpIHx8XG4gICAgICAvLyBTcGFjZSBvciB0YWIgaXMgbm90IHN1cHBvcnRlZCBieSBHRk0gZm9yIHNvbWUgcmVhc29uLlxuICAgICAgLy8gYFxcbmAgYW5kIGBbYCBub3QgYmVpbmcgc3VwcG9ydGVkIG1ha2VzIHNlbnNlLlxuICAgICAgY29kZSA9PT0gY29kZXMuZW9mIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy5sZWZ0U3F1YXJlQnJhY2tldCB8fFxuICAgICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKVxuICAgICkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5yaWdodFNxdWFyZUJyYWNrZXQpIHtcbiAgICAgIGVmZmVjdHMuZXhpdCgnY2h1bmtTdHJpbmcnKVxuICAgICAgY29uc3QgdG9rZW4gPSBlZmZlY3RzLmV4aXQoJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbkxhYmVsU3RyaW5nJylcbiAgICAgIGlkZW50aWZpZXIgPSBub3JtYWxpemVJZGVudGlmaWVyKHNlbGYuc2xpY2VTZXJpYWxpemUodG9rZW4pKVxuICAgICAgZWZmZWN0cy5lbnRlcignZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTGFiZWxNYXJrZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbkxhYmVsTWFya2VyJylcbiAgICAgIGVmZmVjdHMuZXhpdCgnZ2ZtRm9vdG5vdGVEZWZpbml0aW9uTGFiZWwnKVxuICAgICAgcmV0dXJuIGxhYmVsQWZ0ZXJcbiAgICB9XG5cbiAgICBpZiAoIW1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSkpIHtcbiAgICAgIGRhdGEgPSB0cnVlXG4gICAgfVxuXG4gICAgc2l6ZSsrXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvZGUgPT09IGNvZGVzLmJhY2tzbGFzaCA/IGxhYmVsRXNjYXBlIDogbGFiZWxJbnNpZGVcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBgXFxgLCBhdCBhIHNwZWNpYWwgY2hhcmFjdGVyLlxuICAgKlxuICAgKiA+IPCfkYkgKipOb3RlKio6IGBjbWFyay1nZm1gIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IGVzY2FwZWQgYnJhY2tldHM6XG4gICAqID4gPGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvY21hcmstZ2ZtL2lzc3Vlcy8yNDA+XG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCBbXmFcXCpiXTogY1xuICAgKiAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGxhYmVsRXNjYXBlKGNvZGUpIHtcbiAgICBpZiAoXG4gICAgICBjb2RlID09PSBjb2Rlcy5sZWZ0U3F1YXJlQnJhY2tldCB8fFxuICAgICAgY29kZSA9PT0gY29kZXMuYmFja3NsYXNoIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy5yaWdodFNxdWFyZUJyYWNrZXRcbiAgICApIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgc2l6ZSsrXG4gICAgICByZXR1cm4gbGFiZWxJbnNpZGVcbiAgICB9XG5cbiAgICByZXR1cm4gbGFiZWxJbnNpZGUoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBkZWZpbml0aW9uIGxhYmVsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgW15hXTogYlxuICAgKiAgICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGxhYmVsQWZ0ZXIoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBjb2Rlcy5jb2xvbikge1xuICAgICAgZWZmZWN0cy5lbnRlcignZGVmaW5pdGlvbk1hcmtlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgnZGVmaW5pdGlvbk1hcmtlcicpXG5cbiAgICAgIGlmICghZGVmaW5lZC5pbmNsdWRlcyhpZGVudGlmaWVyKSkge1xuICAgICAgICBkZWZpbmVkLnB1c2goaWRlbnRpZmllcilcbiAgICAgIH1cblxuICAgICAgLy8gQW55IHdoaXRlc3BhY2UgYWZ0ZXIgdGhlIG1hcmtlciBpcyBlYXRlbiwgZm9ybWluZyBpbmRlbnRlZCBjb2RlXG4gICAgICAvLyBpcyBub3QgcG9zc2libGUuXG4gICAgICAvLyBObyBzcGFjZSBpcyBhbHNvIGZpbmUsIGp1c3QgbGlrZSBhIGJsb2NrIHF1b3RlIG1hcmtlci5cbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIHdoaXRlc3BhY2VBZnRlcixcbiAgICAgICAgJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbldoaXRlc3BhY2UnXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIGRlZmluaXRpb24gcHJlZml4LlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgW15hXTogYlxuICAgKiAgICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gd2hpdGVzcGFjZUFmdGVyKGNvZGUpIHtcbiAgICAvLyBgbWFya2Rvd24tcnNgIGhhcyBhIHdyYXBwaW5nIHRva2VuIGZvciB0aGUgcHJlZml4IHRoYXQgaXMgY2xvc2VkIGhlcmUuXG4gICAgcmV0dXJuIG9rKGNvZGUpXG4gIH1cbn1cblxuLyoqXG4gKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0fVxuICogQHR5cGUge1Rva2VuaXplcn1cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemVEZWZpbml0aW9uQ29udGludWF0aW9uKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgLy8vIFN0YXJ0IG9mIGZvb3Rub3RlIGRlZmluaXRpb24gY29udGludWF0aW9uLlxuICAvLy9cbiAgLy8vIGBgYG1hcmtkb3duXG4gIC8vLyAgIHwgW15hXTogYlxuICAvLy8gPiB8ICAgICBjXG4gIC8vLyAgICAgXlxuICAvLy8gYGBgXG4gIC8vXG4gIC8vIEVpdGhlciBhIGJsYW5rIGxpbmUsIHdoaWNoIGlzIG9rYXksIG9yIGFuIGluZGVudGVkIHRoaW5nLlxuICByZXR1cm4gZWZmZWN0cy5jaGVjayhibGFua0xpbmUsIG9rLCBlZmZlY3RzLmF0dGVtcHQoaW5kZW50LCBvaywgbm9rKSlcbn1cblxuLyoqIEB0eXBlIHtFeGl0ZXJ9ICovXG5mdW5jdGlvbiBnZm1Gb290bm90ZURlZmluaXRpb25FbmQoZWZmZWN0cykge1xuICBlZmZlY3RzLmV4aXQoJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbicpXG59XG5cbi8qKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplSW5kZW50KGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcblxuICByZXR1cm4gZmFjdG9yeVNwYWNlKFxuICAgIGVmZmVjdHMsXG4gICAgYWZ0ZXJQcmVmaXgsXG4gICAgJ2dmbUZvb3Rub3RlRGVmaW5pdGlvbkluZGVudCcsXG4gICAgY29uc3RhbnRzLnRhYlNpemUgKyAxXG4gIClcblxuICAvKipcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gYWZ0ZXJQcmVmaXgoY29kZSkge1xuICAgIGNvbnN0IHRhaWwgPSBzZWxmLmV2ZW50c1tzZWxmLmV2ZW50cy5sZW5ndGggLSAxXVxuICAgIHJldHVybiB0YWlsICYmXG4gICAgICB0YWlsWzFdLnR5cGUgPT09ICdnZm1Gb290bm90ZURlZmluaXRpb25JbmRlbnQnICYmXG4gICAgICB0YWlsWzJdLnNsaWNlU2VyaWFsaXplKHRhaWxbMV0sIHRydWUpLmxlbmd0aCA9PT0gY29uc3RhbnRzLnRhYlNpemVcbiAgICAgID8gb2soY29kZSlcbiAgICAgIDogbm9rKGNvZGUpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/micromark-extension-gfm-footnote/dev/lib/syntax.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/micromark-extension-gfm-strikethrough/dev/lib/html.js":
/*!****************************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-strikethrough/dev/lib/html.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmStrikethroughHtml: () => (/* binding */ gfmStrikethroughHtml)\n/* harmony export */ });\n/**\n * @import {HtmlExtension} from 'micromark-util-types'\n */\n\n/**\n * Create an HTML extension for `micromark` to support GFM strikethrough when\n * serializing to HTML.\n *\n * @returns {HtmlExtension}\n *   Extension for `micromark` that can be passed in `htmlExtensions`, to\n *   support GFM strikethrough when serializing to HTML.\n */\nfunction gfmStrikethroughHtml() {\n  return {\n    enter: {\n      strikethrough() {\n        this.tag('<del>')\n      }\n    },\n    exit: {\n      strikethrough() {\n        this.tag('</del>')\n      }\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS1zdHJpa2V0aHJvdWdoL2Rldi9saWIvaHRtbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSxZQUFZLGVBQWU7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS1zdHJpa2V0aHJvdWdoL2Rldi9saWIvaHRtbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge0h0bWxFeHRlbnNpb259IGZyb20gJ21pY3JvbWFyay11dGlsLXR5cGVzJ1xuICovXG5cbi8qKlxuICogQ3JlYXRlIGFuIEhUTUwgZXh0ZW5zaW9uIGZvciBgbWljcm9tYXJrYCB0byBzdXBwb3J0IEdGTSBzdHJpa2V0aHJvdWdoIHdoZW5cbiAqIHNlcmlhbGl6aW5nIHRvIEhUTUwuXG4gKlxuICogQHJldHVybnMge0h0bWxFeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdGhhdCBjYW4gYmUgcGFzc2VkIGluIGBodG1sRXh0ZW5zaW9uc2AsIHRvXG4gKiAgIHN1cHBvcnQgR0ZNIHN0cmlrZXRocm91Z2ggd2hlbiBzZXJpYWxpemluZyB0byBIVE1MLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtU3RyaWtldGhyb3VnaEh0bWwoKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXI6IHtcbiAgICAgIHN0cmlrZXRocm91Z2goKSB7XG4gICAgICAgIHRoaXMudGFnKCc8ZGVsPicpXG4gICAgICB9XG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICBzdHJpa2V0aHJvdWdoKCkge1xuICAgICAgICB0aGlzLnRhZygnPC9kZWw+JylcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/micromark-extension-gfm-strikethrough/dev/lib/html.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/micromark-extension-gfm-strikethrough/dev/lib/syntax.js":
/*!******************************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-strikethrough/dev/lib/syntax.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmStrikethrough: () => (/* binding */ gfmStrikethrough)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! devlop */ \"(app-pages-browser)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var micromark_util_chunked__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-chunked */ \"(app-pages-browser)/./node_modules/micromark-util-chunked/dev/index.js\");\n/* harmony import */ var micromark_util_classify_character__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-classify-character */ \"(app-pages-browser)/./node_modules/micromark-util-classify-character/dev/index.js\");\n/* harmony import */ var micromark_util_resolve_all__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-resolve-all */ \"(app-pages-browser)/./node_modules/micromark-util-resolve-all/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/types.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/constants.js\");\n/**\n * @import {Options} from 'micromark-extension-gfm-strikethrough'\n * @import {Event, Extension, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\n\n\n\n\n\n\n/**\n * Create an extension for `micromark` to enable GFM strikethrough syntax.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable GFM strikethrough syntax.\n */\nfunction gfmStrikethrough(options) {\n  const options_ = options || {}\n  let single = options_.singleTilde\n  const tokenizer = {\n    name: 'strikethrough',\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  }\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  return {\n    text: {[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.tilde]: tokenizer},\n    insideSpan: {null: [tokenizer]},\n    attentionMarkers: {null: [micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.tilde]}\n  }\n\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n  function resolveAllStrikethrough(events, context) {\n    let index = -1\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (\n        events[index][0] === 'enter' &&\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\n        events[index][1]._close\n      ) {\n        let open = index\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (\n            events[open][0] === 'exit' &&\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\n            events[open][1]._open &&\n            // If the sizes are the same:\n            events[index][1].end.offset - events[index][1].start.offset ===\n              events[open][1].end.offset - events[open][1].start.offset\n          ) {\n            events[index][1].type = 'strikethroughSequence'\n            events[open][1].type = 'strikethroughSequence'\n\n            /** @type {Token} */\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            }\n\n            /** @type {Token} */\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            }\n\n            // Opening.\n            /** @type {Array<Event>} */\n            const nextEvents = [\n              ['enter', strikethrough, context],\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context],\n              ['enter', text, context]\n            ]\n\n            const insideSpan = context.parser.constructs.insideSpan.null\n\n            if (insideSpan) {\n              // Between.\n              (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_1__.splice)(\n                nextEvents,\n                nextEvents.length,\n                0,\n                (0,micromark_util_resolve_all__WEBPACK_IMPORTED_MODULE_2__.resolveAll)(insideSpan, events.slice(open + 1, index), context)\n              )\n            }\n\n            // Closing.\n            (0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_1__.splice)(nextEvents, nextEvents.length, 0, [\n              ['exit', text, context],\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context],\n              ['exit', strikethrough, context]\n            ])\n\n            ;(0,micromark_util_chunked__WEBPACK_IMPORTED_MODULE_1__.splice)(events, open - 1, index - open + 3, nextEvents)\n\n            index = open + nextEvents.length - 2\n            break\n          }\n        }\n      }\n    }\n\n    index = -1\n\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.data\n      }\n    }\n\n    return events\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous\n    const events = this.events\n    let size = 0\n\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.tilde, 'expected `~`')\n\n      if (\n        previous === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.tilde &&\n        events[events.length - 1][1].type !== micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.characterEscape\n      ) {\n        return nok(code)\n      }\n\n      effects.enter('strikethroughSequenceTemporary')\n      return more(code)\n    }\n\n    /** @type {State} */\n    function more(code) {\n      const before = (0,micromark_util_classify_character__WEBPACK_IMPORTED_MODULE_5__.classifyCharacter)(previous)\n\n      if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.tilde) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code)\n        effects.consume(code)\n        size++\n        return more\n      }\n\n      if (size < 2 && !single) return nok(code)\n      const token = effects.exit('strikethroughSequenceTemporary')\n      const after = (0,micromark_util_classify_character__WEBPACK_IMPORTED_MODULE_5__.classifyCharacter)(code)\n      token._open =\n        !after || (after === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_6__.constants.attentionSideAfter && Boolean(before))\n      token._close =\n        !before || (before === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_6__.constants.attentionSideAfter && Boolean(after))\n      return ok(code)\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS1zdHJpa2V0aHJvdWdoL2Rldi9saWIvc3ludGF4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxzRUFBc0U7QUFDbEY7O0FBRW1DO0FBQ1U7QUFDc0I7QUFDZDtBQUNROztBQUU3RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QixXQUFXO0FBQ2xEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxDQUFDLHdEQUFLLG1CQUFtQjtBQUNwQyxpQkFBaUIsa0JBQWtCO0FBQ25DLHVCQUF1QixPQUFPLHdEQUFLO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsbUNBQW1DO0FBQ25DOztBQUVBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLDhEQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzRUFBVTtBQUMxQjtBQUNBOztBQUVBO0FBQ0EsWUFBWSw4REFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksK0RBQU07O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLHdEQUFLO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxNQUFNLDJDQUFNLFVBQVUsd0RBQUs7O0FBRTNCO0FBQ0EscUJBQXFCLHdEQUFLO0FBQzFCLDhDQUE4Qyx3REFBSztBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsT0FBTztBQUN0QjtBQUNBLHFCQUFxQixvRkFBaUI7O0FBRXRDLG1CQUFtQix3REFBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixvRkFBaUI7QUFDckM7QUFDQSw2QkFBNkIsNERBQVM7QUFDdEM7QUFDQSwrQkFBK0IsNERBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLXN0cmlrZXRocm91Z2gvZGV2L2xpYi9zeW50YXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtPcHRpb25zfSBmcm9tICdtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS1zdHJpa2V0aHJvdWdoJ1xuICogQGltcG9ydCB7RXZlbnQsIEV4dGVuc2lvbiwgUmVzb2x2ZXIsIFN0YXRlLCBUb2tlbiwgVG9rZW5pemVDb250ZXh0LCBUb2tlbml6ZXJ9IGZyb20gJ21pY3JvbWFyay11dGlsLXR5cGVzJ1xuICovXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5pbXBvcnQge3NwbGljZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtY2h1bmtlZCdcbmltcG9ydCB7Y2xhc3NpZnlDaGFyYWN0ZXJ9IGZyb20gJ21pY3JvbWFyay11dGlsLWNsYXNzaWZ5LWNoYXJhY3RlcidcbmltcG9ydCB7cmVzb2x2ZUFsbH0gZnJvbSAnbWljcm9tYXJrLXV0aWwtcmVzb2x2ZS1hbGwnXG5pbXBvcnQge2NvZGVzLCBjb25zdGFudHMsIHR5cGVzfSBmcm9tICdtaWNyb21hcmstdXRpbC1zeW1ib2wnXG5cbi8qKlxuICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdG8gZW5hYmxlIEdGTSBzdHJpa2V0aHJvdWdoIHN5bnRheC5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9ucz17fV1cbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm5zIHtFeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdGhhdCBjYW4gYmUgcGFzc2VkIGluIGBleHRlbnNpb25zYCwgdG9cbiAqICAgZW5hYmxlIEdGTSBzdHJpa2V0aHJvdWdoIHN5bnRheC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbVN0cmlrZXRocm91Z2gob3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zXyA9IG9wdGlvbnMgfHwge31cbiAgbGV0IHNpbmdsZSA9IG9wdGlvbnNfLnNpbmdsZVRpbGRlXG4gIGNvbnN0IHRva2VuaXplciA9IHtcbiAgICBuYW1lOiAnc3RyaWtldGhyb3VnaCcsXG4gICAgdG9rZW5pemU6IHRva2VuaXplU3RyaWtldGhyb3VnaCxcbiAgICByZXNvbHZlQWxsOiByZXNvbHZlQWxsU3RyaWtldGhyb3VnaFxuICB9XG5cbiAgaWYgKHNpbmdsZSA9PT0gbnVsbCB8fCBzaW5nbGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHNpbmdsZSA9IHRydWVcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGV4dDoge1tjb2Rlcy50aWxkZV06IHRva2VuaXplcn0sXG4gICAgaW5zaWRlU3Bhbjoge251bGw6IFt0b2tlbml6ZXJdfSxcbiAgICBhdHRlbnRpb25NYXJrZXJzOiB7bnVsbDogW2NvZGVzLnRpbGRlXX1cbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlIGV2ZW50cyBhbmQgcmVzb2x2ZSBzdHJpa2V0aHJvdWdoLlxuICAgKlxuICAgKiBAdHlwZSB7UmVzb2x2ZXJ9XG4gICAqL1xuICBmdW5jdGlvbiByZXNvbHZlQWxsU3RyaWtldGhyb3VnaChldmVudHMsIGNvbnRleHQpIHtcbiAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgLy8gV2FsayB0aHJvdWdoIGFsbCBldmVudHMuXG4gICAgd2hpbGUgKCsraW5kZXggPCBldmVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBGaW5kIGEgdG9rZW4gdGhhdCBjYW4gY2xvc2UuXG4gICAgICBpZiAoXG4gICAgICAgIGV2ZW50c1tpbmRleF1bMF0gPT09ICdlbnRlcicgJiZcbiAgICAgICAgZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAnc3RyaWtldGhyb3VnaFNlcXVlbmNlVGVtcG9yYXJ5JyAmJlxuICAgICAgICBldmVudHNbaW5kZXhdWzFdLl9jbG9zZVxuICAgICAgKSB7XG4gICAgICAgIGxldCBvcGVuID0gaW5kZXhcblxuICAgICAgICAvLyBOb3cgd2FsayBiYWNrIHRvIGZpbmQgYW4gb3BlbmVyLlxuICAgICAgICB3aGlsZSAob3Blbi0tKSB7XG4gICAgICAgICAgLy8gRmluZCBhIHRva2VuIHRoYXQgY2FuIG9wZW4gdGhlIGNsb3Nlci5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBldmVudHNbb3Blbl1bMF0gPT09ICdleGl0JyAmJlxuICAgICAgICAgICAgZXZlbnRzW29wZW5dWzFdLnR5cGUgPT09ICdzdHJpa2V0aHJvdWdoU2VxdWVuY2VUZW1wb3JhcnknICYmXG4gICAgICAgICAgICBldmVudHNbb3Blbl1bMV0uX29wZW4gJiZcbiAgICAgICAgICAgIC8vIElmIHRoZSBzaXplcyBhcmUgdGhlIHNhbWU6XG4gICAgICAgICAgICBldmVudHNbaW5kZXhdWzFdLmVuZC5vZmZzZXQgLSBldmVudHNbaW5kZXhdWzFdLnN0YXJ0Lm9mZnNldCA9PT1cbiAgICAgICAgICAgICAgZXZlbnRzW29wZW5dWzFdLmVuZC5vZmZzZXQgLSBldmVudHNbb3Blbl1bMV0uc3RhcnQub2Zmc2V0XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBldmVudHNbaW5kZXhdWzFdLnR5cGUgPSAnc3RyaWtldGhyb3VnaFNlcXVlbmNlJ1xuICAgICAgICAgICAgZXZlbnRzW29wZW5dWzFdLnR5cGUgPSAnc3RyaWtldGhyb3VnaFNlcXVlbmNlJ1xuXG4gICAgICAgICAgICAvKiogQHR5cGUge1Rva2VufSAqL1xuICAgICAgICAgICAgY29uc3Qgc3RyaWtldGhyb3VnaCA9IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmlrZXRocm91Z2gnLFxuICAgICAgICAgICAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRzW29wZW5dWzFdLnN0YXJ0KSxcbiAgICAgICAgICAgICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbaW5kZXhdWzFdLmVuZClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdHJpa2V0aHJvdWdoVGV4dCcsXG4gICAgICAgICAgICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbb3Blbl1bMV0uZW5kKSxcbiAgICAgICAgICAgICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBldmVudHNbaW5kZXhdWzFdLnN0YXJ0KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPcGVuaW5nLlxuICAgICAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxFdmVudD59ICovXG4gICAgICAgICAgICBjb25zdCBuZXh0RXZlbnRzID0gW1xuICAgICAgICAgICAgICBbJ2VudGVyJywgc3RyaWtldGhyb3VnaCwgY29udGV4dF0sXG4gICAgICAgICAgICAgIFsnZW50ZXInLCBldmVudHNbb3Blbl1bMV0sIGNvbnRleHRdLFxuICAgICAgICAgICAgICBbJ2V4aXQnLCBldmVudHNbb3Blbl1bMV0sIGNvbnRleHRdLFxuICAgICAgICAgICAgICBbJ2VudGVyJywgdGV4dCwgY29udGV4dF1cbiAgICAgICAgICAgIF1cblxuICAgICAgICAgICAgY29uc3QgaW5zaWRlU3BhbiA9IGNvbnRleHQucGFyc2VyLmNvbnN0cnVjdHMuaW5zaWRlU3Bhbi5udWxsXG5cbiAgICAgICAgICAgIGlmIChpbnNpZGVTcGFuKSB7XG4gICAgICAgICAgICAgIC8vIEJldHdlZW4uXG4gICAgICAgICAgICAgIHNwbGljZShcbiAgICAgICAgICAgICAgICBuZXh0RXZlbnRzLFxuICAgICAgICAgICAgICAgIG5leHRFdmVudHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZUFsbChpbnNpZGVTcGFuLCBldmVudHMuc2xpY2Uob3BlbiArIDEsIGluZGV4KSwgY29udGV4dClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDbG9zaW5nLlxuICAgICAgICAgICAgc3BsaWNlKG5leHRFdmVudHMsIG5leHRFdmVudHMubGVuZ3RoLCAwLCBbXG4gICAgICAgICAgICAgIFsnZXhpdCcsIHRleHQsIGNvbnRleHRdLFxuICAgICAgICAgICAgICBbJ2VudGVyJywgZXZlbnRzW2luZGV4XVsxXSwgY29udGV4dF0sXG4gICAgICAgICAgICAgIFsnZXhpdCcsIGV2ZW50c1tpbmRleF1bMV0sIGNvbnRleHRdLFxuICAgICAgICAgICAgICBbJ2V4aXQnLCBzdHJpa2V0aHJvdWdoLCBjb250ZXh0XVxuICAgICAgICAgICAgXSlcblxuICAgICAgICAgICAgc3BsaWNlKGV2ZW50cywgb3BlbiAtIDEsIGluZGV4IC0gb3BlbiArIDMsIG5leHRFdmVudHMpXG5cbiAgICAgICAgICAgIGluZGV4ID0gb3BlbiArIG5leHRFdmVudHMubGVuZ3RoIC0gMlxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRleCA9IC0xXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmIChldmVudHNbaW5kZXhdWzFdLnR5cGUgPT09ICdzdHJpa2V0aHJvdWdoU2VxdWVuY2VUZW1wb3JhcnknKSB7XG4gICAgICAgIGV2ZW50c1tpbmRleF1bMV0udHlwZSA9IHR5cGVzLmRhdGFcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnRzXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAgICogQHR5cGUge1Rva2VuaXplcn1cbiAgICovXG4gIGZ1bmN0aW9uIHRva2VuaXplU3RyaWtldGhyb3VnaChlZmZlY3RzLCBvaywgbm9rKSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLnByZXZpb3VzXG4gICAgY29uc3QgZXZlbnRzID0gdGhpcy5ldmVudHNcbiAgICBsZXQgc2l6ZSA9IDBcblxuICAgIHJldHVybiBzdGFydFxuXG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cbiAgICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgICBhc3NlcnQoY29kZSA9PT0gY29kZXMudGlsZGUsICdleHBlY3RlZCBgfmAnKVxuXG4gICAgICBpZiAoXG4gICAgICAgIHByZXZpb3VzID09PSBjb2Rlcy50aWxkZSAmJlxuICAgICAgICBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdWzFdLnR5cGUgIT09IHR5cGVzLmNoYXJhY3RlckVzY2FwZVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBub2soY29kZSlcbiAgICAgIH1cblxuICAgICAgZWZmZWN0cy5lbnRlcignc3RyaWtldGhyb3VnaFNlcXVlbmNlVGVtcG9yYXJ5JylcbiAgICAgIHJldHVybiBtb3JlKGNvZGUpXG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cbiAgICBmdW5jdGlvbiBtb3JlKGNvZGUpIHtcbiAgICAgIGNvbnN0IGJlZm9yZSA9IGNsYXNzaWZ5Q2hhcmFjdGVyKHByZXZpb3VzKVxuXG4gICAgICBpZiAoY29kZSA9PT0gY29kZXMudGlsZGUpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgdGhpcmQgbWFya2VyLCBleGl0LlxuICAgICAgICBpZiAoc2l6ZSA+IDEpIHJldHVybiBub2soY29kZSlcbiAgICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICAgIHNpemUrK1xuICAgICAgICByZXR1cm4gbW9yZVxuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZSA8IDIgJiYgIXNpbmdsZSkgcmV0dXJuIG5vayhjb2RlKVxuICAgICAgY29uc3QgdG9rZW4gPSBlZmZlY3RzLmV4aXQoJ3N0cmlrZXRocm91Z2hTZXF1ZW5jZVRlbXBvcmFyeScpXG4gICAgICBjb25zdCBhZnRlciA9IGNsYXNzaWZ5Q2hhcmFjdGVyKGNvZGUpXG4gICAgICB0b2tlbi5fb3BlbiA9XG4gICAgICAgICFhZnRlciB8fCAoYWZ0ZXIgPT09IGNvbnN0YW50cy5hdHRlbnRpb25TaWRlQWZ0ZXIgJiYgQm9vbGVhbihiZWZvcmUpKVxuICAgICAgdG9rZW4uX2Nsb3NlID1cbiAgICAgICAgIWJlZm9yZSB8fCAoYmVmb3JlID09PSBjb25zdGFudHMuYXR0ZW50aW9uU2lkZUFmdGVyICYmIEJvb2xlYW4oYWZ0ZXIpKVxuICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/micromark-extension-gfm-strikethrough/dev/lib/syntax.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js":
/*!************************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditMap: () => (/* binding */ EditMap)\n/* harmony export */ });\n/**\n * @import {Event} from 'micromark-util-types'\n */\n\n// Port of `edit_map.rs` from `markdown-rs`.\n// This should move to `markdown-js` later.\n\n// Deal with several changes in events, batching them together.\n//\n// Preferably, changes should be kept to a minimum.\n// Sometimes, its needed to change the list of events, because parsing can be\n// messy, and it helps to expose a cleaner interface of events to the compiler\n// and other users.\n// It can also help to merge many adjacent similar events.\n// And, in other cases, its needed to parse subcontent: pass some events\n// through another tokenizer and inject the result.\n\n/**\n * @typedef {[number, number, Array<Event>]} Change\n * @typedef {[number, number, number]} Jump\n */\n\n/**\n * Tracks a bunch of edits.\n */\nclass EditMap {\n  /**\n   * Create a new edit map.\n   */\n  constructor() {\n    /**\n     * Record of changes.\n     *\n     * @type {Array<Change>}\n     */\n    this.map = []\n  }\n\n  /**\n   * Create an edit: a remove and/or add at a certain place.\n   *\n   * @param {number} index\n   * @param {number} remove\n   * @param {Array<Event>} add\n   * @returns {undefined}\n   */\n  add(index, remove, add) {\n    addImplementation(this, index, remove, add)\n  }\n\n  // To do: add this when moving to `micromark`.\n  // /**\n  //  * Create an edit: but insert `add` before existing additions.\n  //  *\n  //  * @param {number} index\n  //  * @param {number} remove\n  //  * @param {Array<Event>} add\n  //  * @returns {undefined}\n  //  */\n  // addBefore(index, remove, add) {\n  //   addImplementation(this, index, remove, add, true)\n  // }\n\n  /**\n   * Done, change the events.\n   *\n   * @param {Array<Event>} events\n   * @returns {undefined}\n   */\n  consume(events) {\n    this.map.sort(function (a, b) {\n      return a[0] - b[0]\n    })\n\n    /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\n    if (this.map.length === 0) {\n      return\n    }\n\n    // To do: if links are added in events, like they are in `markdown-rs`,\n    // this is needed.\n    // // Calculate jumps: where items in the current list move to.\n    // /** @type {Array<Jump>} */\n    // const jumps = []\n    // let index = 0\n    // let addAcc = 0\n    // let removeAcc = 0\n    // while (index < this.map.length) {\n    //   const [at, remove, add] = this.map[index]\n    //   removeAcc += remove\n    //   addAcc += add.length\n    //   jumps.push([at, removeAcc, addAcc])\n    //   index += 1\n    // }\n    //\n    // . shiftLinks(events, jumps)\n\n    let index = this.map.length\n    /** @type {Array<Array<Event>>} */\n    const vecs = []\n    while (index > 0) {\n      index -= 1\n      vecs.push(\n        events.slice(this.map[index][0] + this.map[index][1]),\n        this.map[index][2]\n      )\n\n      // Truncate rest.\n      events.length = this.map[index][0]\n    }\n\n    vecs.push(events.slice())\n    events.length = 0\n\n    let slice = vecs.pop()\n\n    while (slice) {\n      for (const element of slice) {\n        events.push(element)\n      }\n\n      slice = vecs.pop()\n    }\n\n    // Truncate everything.\n    this.map.length = 0\n  }\n}\n\n/**\n * Create an edit.\n *\n * @param {EditMap} editMap\n * @param {number} at\n * @param {number} remove\n * @param {Array<Event>} add\n * @returns {undefined}\n */\nfunction addImplementation(editMap, at, remove, add) {\n  let index = 0\n\n  /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\n  if (remove === 0 && add.length === 0) {\n    return\n  }\n\n  while (index < editMap.map.length) {\n    if (editMap.map[index][0] === at) {\n      editMap.map[index][1] += remove\n\n      // To do: before not used by tables, use when moving to micromark.\n      // if (before) {\n      //   add.push(...editMap.map[index][2])\n      //   editMap.map[index][2] = add\n      // } else {\n      editMap.map[index][2].push(...add)\n      // }\n\n      return\n    }\n\n    index += 1\n  }\n\n  editMap.map.push([at, remove, add])\n}\n\n// /**\n//  * Shift `previous` and `next` links according to `jumps`.\n//  *\n//  * This fixes links in case there are events removed or added between them.\n//  *\n//  * @param {Array<Event>} events\n//  * @param {Array<Jump>} jumps\n//  */\n// function shiftLinks(events, jumps) {\n//   let jumpIndex = 0\n//   let index = 0\n//   let add = 0\n//   let rm = 0\n\n//   while (index < events.length) {\n//     const rmCurr = rm\n\n//     while (jumpIndex < jumps.length && jumps[jumpIndex][0] <= index) {\n//       add = jumps[jumpIndex][2]\n//       rm = jumps[jumpIndex][1]\n//       jumpIndex += 1\n//     }\n\n//     // Ignore items that will be removed.\n//     if (rm > rmCurr) {\n//       index += rm - rmCurr\n//     } else {\n//       // ?\n//       // if let Some(link) = &events[index].link {\n//       //     if let Some(next) = link.next {\n//       //         events[next].link.as_mut().unwrap().previous = Some(index + add - rm);\n//       //         while jumpIndex < jumps.len() && jumps[jumpIndex].0 <= next {\n//       //             add = jumps[jumpIndex].2;\n//       //             rm = jumps[jumpIndex].1;\n//       //             jumpIndex += 1;\n//       //         }\n//       //         events[index].link.as_mut().unwrap().next = Some(next + add - rm);\n//       //         index = next;\n//       //         continue;\n//       //     }\n//       // }\n//       index += 1\n//     }\n//   }\n// }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWJsZS9kZXYvbGliL2VkaXQtbWFwLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLGFBQWEsMEJBQTBCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxjQUFjO0FBQzNCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixjQUFjO0FBQzlCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxjQUFjO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QixjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWJsZS9kZXYvbGliL2VkaXQtbWFwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7RXZlbnR9IGZyb20gJ21pY3JvbWFyay11dGlsLXR5cGVzJ1xuICovXG5cbi8vIFBvcnQgb2YgYGVkaXRfbWFwLnJzYCBmcm9tIGBtYXJrZG93bi1yc2AuXG4vLyBUaGlzIHNob3VsZCBtb3ZlIHRvIGBtYXJrZG93bi1qc2AgbGF0ZXIuXG5cbi8vIERlYWwgd2l0aCBzZXZlcmFsIGNoYW5nZXMgaW4gZXZlbnRzLCBiYXRjaGluZyB0aGVtIHRvZ2V0aGVyLlxuLy9cbi8vIFByZWZlcmFibHksIGNoYW5nZXMgc2hvdWxkIGJlIGtlcHQgdG8gYSBtaW5pbXVtLlxuLy8gU29tZXRpbWVzLCBpdOKAmXMgbmVlZGVkIHRvIGNoYW5nZSB0aGUgbGlzdCBvZiBldmVudHMsIGJlY2F1c2UgcGFyc2luZyBjYW4gYmVcbi8vIG1lc3N5LCBhbmQgaXQgaGVscHMgdG8gZXhwb3NlIGEgY2xlYW5lciBpbnRlcmZhY2Ugb2YgZXZlbnRzIHRvIHRoZSBjb21waWxlclxuLy8gYW5kIG90aGVyIHVzZXJzLlxuLy8gSXQgY2FuIGFsc28gaGVscCB0byBtZXJnZSBtYW55IGFkamFjZW50IHNpbWlsYXIgZXZlbnRzLlxuLy8gQW5kLCBpbiBvdGhlciBjYXNlcywgaXTigJlzIG5lZWRlZCB0byBwYXJzZSBzdWJjb250ZW50OiBwYXNzIHNvbWUgZXZlbnRzXG4vLyB0aHJvdWdoIGFub3RoZXIgdG9rZW5pemVyIGFuZCBpbmplY3QgdGhlIHJlc3VsdC5cblxuLyoqXG4gKiBAdHlwZWRlZiB7W251bWJlciwgbnVtYmVyLCBBcnJheTxFdmVudD5dfSBDaGFuZ2VcbiAqIEB0eXBlZGVmIHtbbnVtYmVyLCBudW1iZXIsIG51bWJlcl19IEp1bXBcbiAqL1xuXG4vKipcbiAqIFRyYWNrcyBhIGJ1bmNoIG9mIGVkaXRzLlxuICovXG5leHBvcnQgY2xhc3MgRWRpdE1hcCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZWRpdCBtYXAuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBSZWNvcmQgb2YgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTxDaGFuZ2U+fVxuICAgICAqL1xuICAgIHRoaXMubWFwID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZWRpdDogYSByZW1vdmUgYW5kL29yIGFkZCBhdCBhIGNlcnRhaW4gcGxhY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVtb3ZlXG4gICAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBhZGRcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGFkZChpbmRleCwgcmVtb3ZlLCBhZGQpIHtcbiAgICBhZGRJbXBsZW1lbnRhdGlvbih0aGlzLCBpbmRleCwgcmVtb3ZlLCBhZGQpXG4gIH1cblxuICAvLyBUbyBkbzogYWRkIHRoaXMgd2hlbiBtb3ZpbmcgdG8gYG1pY3JvbWFya2AuXG4gIC8vIC8qKlxuICAvLyAgKiBDcmVhdGUgYW4gZWRpdDogYnV0IGluc2VydCBgYWRkYCBiZWZvcmUgZXhpc3RpbmcgYWRkaXRpb25zLlxuICAvLyAgKlxuICAvLyAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgLy8gICogQHBhcmFtIHtudW1iZXJ9IHJlbW92ZVxuICAvLyAgKiBAcGFyYW0ge0FycmF5PEV2ZW50Pn0gYWRkXG4gIC8vICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gIC8vICAqL1xuICAvLyBhZGRCZWZvcmUoaW5kZXgsIHJlbW92ZSwgYWRkKSB7XG4gIC8vICAgYWRkSW1wbGVtZW50YXRpb24odGhpcywgaW5kZXgsIHJlbW92ZSwgYWRkLCB0cnVlKVxuICAvLyB9XG5cbiAgLyoqXG4gICAqIERvbmUsIGNoYW5nZSB0aGUgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PEV2ZW50Pn0gZXZlbnRzXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBjb25zdW1lKGV2ZW50cykge1xuICAgIHRoaXMubWFwLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhWzBdIC0gYlswXVxuICAgIH0pXG5cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAzIC0tIGByZXNvbHZlYCBpcyBuZXZlciBjYWxsZWQgd2l0aG91dCB0YWJsZXMsIHNvIHdpdGhvdXQgZWRpdHMuICovXG4gICAgaWYgKHRoaXMubWFwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gVG8gZG86IGlmIGxpbmtzIGFyZSBhZGRlZCBpbiBldmVudHMsIGxpa2UgdGhleSBhcmUgaW4gYG1hcmtkb3duLXJzYCxcbiAgICAvLyB0aGlzIGlzIG5lZWRlZC5cbiAgICAvLyAvLyBDYWxjdWxhdGUganVtcHM6IHdoZXJlIGl0ZW1zIGluIHRoZSBjdXJyZW50IGxpc3QgbW92ZSB0by5cbiAgICAvLyAvKiogQHR5cGUge0FycmF5PEp1bXA+fSAqL1xuICAgIC8vIGNvbnN0IGp1bXBzID0gW11cbiAgICAvLyBsZXQgaW5kZXggPSAwXG4gICAgLy8gbGV0IGFkZEFjYyA9IDBcbiAgICAvLyBsZXQgcmVtb3ZlQWNjID0gMFxuICAgIC8vIHdoaWxlIChpbmRleCA8IHRoaXMubWFwLmxlbmd0aCkge1xuICAgIC8vICAgY29uc3QgW2F0LCByZW1vdmUsIGFkZF0gPSB0aGlzLm1hcFtpbmRleF1cbiAgICAvLyAgIHJlbW92ZUFjYyArPSByZW1vdmVcbiAgICAvLyAgIGFkZEFjYyArPSBhZGQubGVuZ3RoXG4gICAgLy8gICBqdW1wcy5wdXNoKFthdCwgcmVtb3ZlQWNjLCBhZGRBY2NdKVxuICAgIC8vICAgaW5kZXggKz0gMVxuICAgIC8vIH1cbiAgICAvL1xuICAgIC8vIC4gc2hpZnRMaW5rcyhldmVudHMsIGp1bXBzKVxuXG4gICAgbGV0IGluZGV4ID0gdGhpcy5tYXAubGVuZ3RoXG4gICAgLyoqIEB0eXBlIHtBcnJheTxBcnJheTxFdmVudD4+fSAqL1xuICAgIGNvbnN0IHZlY3MgPSBbXVxuICAgIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICAgIGluZGV4IC09IDFcbiAgICAgIHZlY3MucHVzaChcbiAgICAgICAgZXZlbnRzLnNsaWNlKHRoaXMubWFwW2luZGV4XVswXSArIHRoaXMubWFwW2luZGV4XVsxXSksXG4gICAgICAgIHRoaXMubWFwW2luZGV4XVsyXVxuICAgICAgKVxuXG4gICAgICAvLyBUcnVuY2F0ZSByZXN0LlxuICAgICAgZXZlbnRzLmxlbmd0aCA9IHRoaXMubWFwW2luZGV4XVswXVxuICAgIH1cblxuICAgIHZlY3MucHVzaChldmVudHMuc2xpY2UoKSlcbiAgICBldmVudHMubGVuZ3RoID0gMFxuXG4gICAgbGV0IHNsaWNlID0gdmVjcy5wb3AoKVxuXG4gICAgd2hpbGUgKHNsaWNlKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2Ygc2xpY2UpIHtcbiAgICAgICAgZXZlbnRzLnB1c2goZWxlbWVudClcbiAgICAgIH1cblxuICAgICAgc2xpY2UgPSB2ZWNzLnBvcCgpXG4gICAgfVxuXG4gICAgLy8gVHJ1bmNhdGUgZXZlcnl0aGluZy5cbiAgICB0aGlzLm1hcC5sZW5ndGggPSAwXG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZWRpdC5cbiAqXG4gKiBAcGFyYW0ge0VkaXRNYXB9IGVkaXRNYXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBhdFxuICogQHBhcmFtIHtudW1iZXJ9IHJlbW92ZVxuICogQHBhcmFtIHtBcnJheTxFdmVudD59IGFkZFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gYWRkSW1wbGVtZW50YXRpb24oZWRpdE1hcCwgYXQsIHJlbW92ZSwgYWRkKSB7XG4gIGxldCBpbmRleCA9IDBcblxuICAvKiBjOCBpZ25vcmUgbmV4dCAzIC0tIGByZXNvbHZlYCBpcyBuZXZlciBjYWxsZWQgd2l0aG91dCB0YWJsZXMsIHNvIHdpdGhvdXQgZWRpdHMuICovXG4gIGlmIChyZW1vdmUgPT09IDAgJiYgYWRkLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgd2hpbGUgKGluZGV4IDwgZWRpdE1hcC5tYXAubGVuZ3RoKSB7XG4gICAgaWYgKGVkaXRNYXAubWFwW2luZGV4XVswXSA9PT0gYXQpIHtcbiAgICAgIGVkaXRNYXAubWFwW2luZGV4XVsxXSArPSByZW1vdmVcblxuICAgICAgLy8gVG8gZG86IGJlZm9yZSBub3QgdXNlZCBieSB0YWJsZXMsIHVzZSB3aGVuIG1vdmluZyB0byBtaWNyb21hcmsuXG4gICAgICAvLyBpZiAoYmVmb3JlKSB7XG4gICAgICAvLyAgIGFkZC5wdXNoKC4uLmVkaXRNYXAubWFwW2luZGV4XVsyXSlcbiAgICAgIC8vICAgZWRpdE1hcC5tYXBbaW5kZXhdWzJdID0gYWRkXG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgZWRpdE1hcC5tYXBbaW5kZXhdWzJdLnB1c2goLi4uYWRkKVxuICAgICAgLy8gfVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpbmRleCArPSAxXG4gIH1cblxuICBlZGl0TWFwLm1hcC5wdXNoKFthdCwgcmVtb3ZlLCBhZGRdKVxufVxuXG4vLyAvKipcbi8vICAqIFNoaWZ0IGBwcmV2aW91c2AgYW5kIGBuZXh0YCBsaW5rcyBhY2NvcmRpbmcgdG8gYGp1bXBzYC5cbi8vICAqXG4vLyAgKiBUaGlzIGZpeGVzIGxpbmtzIGluIGNhc2UgdGhlcmUgYXJlIGV2ZW50cyByZW1vdmVkIG9yIGFkZGVkIGJldHdlZW4gdGhlbS5cbi8vICAqXG4vLyAgKiBAcGFyYW0ge0FycmF5PEV2ZW50Pn0gZXZlbnRzXG4vLyAgKiBAcGFyYW0ge0FycmF5PEp1bXA+fSBqdW1wc1xuLy8gICovXG4vLyBmdW5jdGlvbiBzaGlmdExpbmtzKGV2ZW50cywganVtcHMpIHtcbi8vICAgbGV0IGp1bXBJbmRleCA9IDBcbi8vICAgbGV0IGluZGV4ID0gMFxuLy8gICBsZXQgYWRkID0gMFxuLy8gICBsZXQgcm0gPSAwXG5cbi8vICAgd2hpbGUgKGluZGV4IDwgZXZlbnRzLmxlbmd0aCkge1xuLy8gICAgIGNvbnN0IHJtQ3VyciA9IHJtXG5cbi8vICAgICB3aGlsZSAoanVtcEluZGV4IDwganVtcHMubGVuZ3RoICYmIGp1bXBzW2p1bXBJbmRleF1bMF0gPD0gaW5kZXgpIHtcbi8vICAgICAgIGFkZCA9IGp1bXBzW2p1bXBJbmRleF1bMl1cbi8vICAgICAgIHJtID0ganVtcHNbanVtcEluZGV4XVsxXVxuLy8gICAgICAganVtcEluZGV4ICs9IDFcbi8vICAgICB9XG5cbi8vICAgICAvLyBJZ25vcmUgaXRlbXMgdGhhdCB3aWxsIGJlIHJlbW92ZWQuXG4vLyAgICAgaWYgKHJtID4gcm1DdXJyKSB7XG4vLyAgICAgICBpbmRleCArPSBybSAtIHJtQ3VyclxuLy8gICAgIH0gZWxzZSB7XG4vLyAgICAgICAvLyA/XG4vLyAgICAgICAvLyBpZiBsZXQgU29tZShsaW5rKSA9ICZldmVudHNbaW5kZXhdLmxpbmsge1xuLy8gICAgICAgLy8gICAgIGlmIGxldCBTb21lKG5leHQpID0gbGluay5uZXh0IHtcbi8vICAgICAgIC8vICAgICAgICAgZXZlbnRzW25leHRdLmxpbmsuYXNfbXV0KCkudW53cmFwKCkucHJldmlvdXMgPSBTb21lKGluZGV4ICsgYWRkIC0gcm0pO1xuLy8gICAgICAgLy8gICAgICAgICB3aGlsZSBqdW1wSW5kZXggPCBqdW1wcy5sZW4oKSAmJiBqdW1wc1tqdW1wSW5kZXhdLjAgPD0gbmV4dCB7XG4vLyAgICAgICAvLyAgICAgICAgICAgICBhZGQgPSBqdW1wc1tqdW1wSW5kZXhdLjI7XG4vLyAgICAgICAvLyAgICAgICAgICAgICBybSA9IGp1bXBzW2p1bXBJbmRleF0uMTtcbi8vICAgICAgIC8vICAgICAgICAgICAgIGp1bXBJbmRleCArPSAxO1xuLy8gICAgICAgLy8gICAgICAgICB9XG4vLyAgICAgICAvLyAgICAgICAgIGV2ZW50c1tpbmRleF0ubGluay5hc19tdXQoKS51bndyYXAoKS5uZXh0ID0gU29tZShuZXh0ICsgYWRkIC0gcm0pO1xuLy8gICAgICAgLy8gICAgICAgICBpbmRleCA9IG5leHQ7XG4vLyAgICAgICAvLyAgICAgICAgIGNvbnRpbnVlO1xuLy8gICAgICAgLy8gICAgIH1cbi8vICAgICAgIC8vIH1cbi8vICAgICAgIGluZGV4ICs9IDFcbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/micromark-extension-gfm-table/dev/lib/html.js":
/*!********************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/html.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTableHtml: () => (/* binding */ gfmTableHtml)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devlop */ \"(app-pages-browser)/./node_modules/devlop/lib/development.js\");\n/**\n * @import {HtmlExtension} from 'micromark-util-types'\n */\n\n\n\nconst alignment = {\n  none: '',\n  left: ' align=\"left\"',\n  right: ' align=\"right\"',\n  center: ' align=\"center\"'\n}\n\n// To do: micromark@5: use `infer` here, when all events are exposed.\n\n/**\n * Create an HTML extension for `micromark` to support GitHub tables when\n * serializing to HTML.\n *\n * @returns {HtmlExtension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GitHub tables when serializing to HTML.\n */\nfunction gfmTableHtml() {\n  return {\n    enter: {\n      table(token) {\n        const tableAlign = token._align\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, 'expected `_align`')\n        this.lineEndingIfNeeded()\n        this.tag('<table>')\n        this.setData('tableAlign', tableAlign)\n      },\n      tableBody() {\n        this.tag('<tbody>')\n      },\n      tableData() {\n        const tableAlign = this.getData('tableAlign')\n        const tableColumn = this.getData('tableColumn')\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, 'expected `tableAlign`')\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === 'number', 'expected `tableColumn`')\n        const align = alignment[tableAlign[tableColumn]]\n\n        if (align === undefined) {\n          // Capture results to ignore them.\n          this.buffer()\n        } else {\n          this.lineEndingIfNeeded()\n          this.tag('<td' + align + '>')\n        }\n      },\n      tableHead() {\n        this.lineEndingIfNeeded()\n        this.tag('<thead>')\n      },\n      tableHeader() {\n        const tableAlign = this.getData('tableAlign')\n        const tableColumn = this.getData('tableColumn')\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, 'expected `tableAlign`')\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === 'number', 'expected `tableColumn`')\n        const align = alignment[tableAlign[tableColumn]]\n        this.lineEndingIfNeeded()\n        this.tag('<th' + align + '>')\n      },\n      tableRow() {\n        this.setData('tableColumn', 0)\n        this.lineEndingIfNeeded()\n        this.tag('<tr>')\n      }\n    },\n    exit: {\n      // Overwrite the default code text data handler to unescape escaped pipes when\n      // they are in tables.\n      codeTextData(token) {\n        let value = this.sliceSerialize(token)\n\n        if (this.getData('tableAlign')) {\n          value = value.replace(/\\\\([\\\\|])/g, replace)\n        }\n\n        this.raw(this.encode(value))\n      },\n      table() {\n        this.setData('tableAlign')\n        // Note: we dont set `slurpAllLineEndings` anymore, in delimiter rows,\n        // but we do need to reset it to match a funky newline GH generates for\n        // list items combined with tables.\n        this.setData('slurpAllLineEndings')\n        this.lineEndingIfNeeded()\n        this.tag('</table>')\n      },\n      tableBody() {\n        this.lineEndingIfNeeded()\n        this.tag('</tbody>')\n      },\n      tableData() {\n        const tableAlign = this.getData('tableAlign')\n        const tableColumn = this.getData('tableColumn')\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, 'expected `tableAlign`')\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === 'number', 'expected `tableColumn`')\n\n        if (tableColumn in tableAlign) {\n          this.tag('</td>')\n          this.setData('tableColumn', tableColumn + 1)\n        } else {\n          // Stop capturing.\n          this.resume()\n        }\n      },\n      tableHead() {\n        this.lineEndingIfNeeded()\n        this.tag('</thead>')\n      },\n      tableHeader() {\n        const tableColumn = this.getData('tableColumn')\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === 'number', 'expected `tableColumn`')\n        this.tag('</th>')\n        this.setData('tableColumn', tableColumn + 1)\n      },\n      tableRow() {\n        const tableAlign = this.getData('tableAlign')\n        let tableColumn = this.getData('tableColumn')\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(tableAlign, 'expected `tableAlign`')\n        ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(typeof tableColumn === 'number', 'expected `tableColumn`')\n\n        while (tableColumn < tableAlign.length) {\n          this.lineEndingIfNeeded()\n          this.tag('<td' + alignment[tableAlign[tableColumn]] + '></td>')\n          tableColumn++\n        }\n\n        this.setData('tableColumn', tableColumn)\n        this.lineEndingIfNeeded()\n        this.tag('</tr>')\n      }\n    }\n  }\n}\n\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */\nfunction replace($0, $1) {\n  // Pipes work, backslashes dont (but cant escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWJsZS9kZXYvbGliL2h0bWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBLFlBQVksZUFBZTtBQUMzQjs7QUFFbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkNBQU07QUFDZCxRQUFRLDJDQUFNO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBTTtBQUNkLFFBQVEsMkNBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJDQUFNO0FBQ2QsUUFBUSwyQ0FBTTs7QUFFZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUSwyQ0FBTTtBQUNkO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBTTtBQUNkLFFBQVEsMkNBQU07O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLXRhYmxlL2Rldi9saWIvaHRtbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge0h0bWxFeHRlbnNpb259IGZyb20gJ21pY3JvbWFyay11dGlsLXR5cGVzJ1xuICovXG5cbmltcG9ydCB7b2sgYXMgYXNzZXJ0fSBmcm9tICdkZXZsb3AnXG5cbmNvbnN0IGFsaWdubWVudCA9IHtcbiAgbm9uZTogJycsXG4gIGxlZnQ6ICcgYWxpZ249XCJsZWZ0XCInLFxuICByaWdodDogJyBhbGlnbj1cInJpZ2h0XCInLFxuICBjZW50ZXI6ICcgYWxpZ249XCJjZW50ZXJcIidcbn1cblxuLy8gVG8gZG86IG1pY3JvbWFya0A1OiB1c2UgYGluZmVyYCBoZXJlLCB3aGVuIGFsbCBldmVudHMgYXJlIGV4cG9zZWQuXG5cbi8qKlxuICogQ3JlYXRlIGFuIEhUTUwgZXh0ZW5zaW9uIGZvciBgbWljcm9tYXJrYCB0byBzdXBwb3J0IEdpdEh1YiB0YWJsZXMgd2hlblxuICogc2VyaWFsaXppbmcgdG8gSFRNTC5cbiAqXG4gKiBAcmV0dXJucyB7SHRtbEV4dGVuc2lvbn1cbiAqICAgRXh0ZW5zaW9uIGZvciBgbWljcm9tYXJrYCB0aGF0IGNhbiBiZSBwYXNzZWQgaW4gYGh0bWxFeHRlbnNpb25zYCB0b1xuICogICBzdXBwb3J0IEdpdEh1YiB0YWJsZXMgd2hlbiBzZXJpYWxpemluZyB0byBIVE1MLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtVGFibGVIdG1sKCkge1xuICByZXR1cm4ge1xuICAgIGVudGVyOiB7XG4gICAgICB0YWJsZSh0b2tlbikge1xuICAgICAgICBjb25zdCB0YWJsZUFsaWduID0gdG9rZW4uX2FsaWduXG4gICAgICAgIGFzc2VydCh0YWJsZUFsaWduLCAnZXhwZWN0ZWQgYF9hbGlnbmAnKVxuICAgICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICAgIHRoaXMudGFnKCc8dGFibGU+JylcbiAgICAgICAgdGhpcy5zZXREYXRhKCd0YWJsZUFsaWduJywgdGFibGVBbGlnbilcbiAgICAgIH0sXG4gICAgICB0YWJsZUJvZHkoKSB7XG4gICAgICAgIHRoaXMudGFnKCc8dGJvZHk+JylcbiAgICAgIH0sXG4gICAgICB0YWJsZURhdGEoKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlQWxpZ24gPSB0aGlzLmdldERhdGEoJ3RhYmxlQWxpZ24nKVxuICAgICAgICBjb25zdCB0YWJsZUNvbHVtbiA9IHRoaXMuZ2V0RGF0YSgndGFibGVDb2x1bW4nKVxuICAgICAgICBhc3NlcnQodGFibGVBbGlnbiwgJ2V4cGVjdGVkIGB0YWJsZUFsaWduYCcpXG4gICAgICAgIGFzc2VydCh0eXBlb2YgdGFibGVDb2x1bW4gPT09ICdudW1iZXInLCAnZXhwZWN0ZWQgYHRhYmxlQ29sdW1uYCcpXG4gICAgICAgIGNvbnN0IGFsaWduID0gYWxpZ25tZW50W3RhYmxlQWxpZ25bdGFibGVDb2x1bW5dXVxuXG4gICAgICAgIGlmIChhbGlnbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gQ2FwdHVyZSByZXN1bHRzIHRvIGlnbm9yZSB0aGVtLlxuICAgICAgICAgIHRoaXMuYnVmZmVyKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICAgICAgdGhpcy50YWcoJzx0ZCcgKyBhbGlnbiArICc+JylcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRhYmxlSGVhZCgpIHtcbiAgICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgICB0aGlzLnRhZygnPHRoZWFkPicpXG4gICAgICB9LFxuICAgICAgdGFibGVIZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlQWxpZ24gPSB0aGlzLmdldERhdGEoJ3RhYmxlQWxpZ24nKVxuICAgICAgICBjb25zdCB0YWJsZUNvbHVtbiA9IHRoaXMuZ2V0RGF0YSgndGFibGVDb2x1bW4nKVxuICAgICAgICBhc3NlcnQodGFibGVBbGlnbiwgJ2V4cGVjdGVkIGB0YWJsZUFsaWduYCcpXG4gICAgICAgIGFzc2VydCh0eXBlb2YgdGFibGVDb2x1bW4gPT09ICdudW1iZXInLCAnZXhwZWN0ZWQgYHRhYmxlQ29sdW1uYCcpXG4gICAgICAgIGNvbnN0IGFsaWduID0gYWxpZ25tZW50W3RhYmxlQWxpZ25bdGFibGVDb2x1bW5dXVxuICAgICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICAgIHRoaXMudGFnKCc8dGgnICsgYWxpZ24gKyAnPicpXG4gICAgICB9LFxuICAgICAgdGFibGVSb3coKSB7XG4gICAgICAgIHRoaXMuc2V0RGF0YSgndGFibGVDb2x1bW4nLCAwKVxuICAgICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICAgIHRoaXMudGFnKCc8dHI+JylcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIC8vIE92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBjb2RlIHRleHQgZGF0YSBoYW5kbGVyIHRvIHVuZXNjYXBlIGVzY2FwZWQgcGlwZXMgd2hlblxuICAgICAgLy8gdGhleSBhcmUgaW4gdGFibGVzLlxuICAgICAgY29kZVRleHREYXRhKHRva2VuKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0RGF0YSgndGFibGVBbGlnbicpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcKFtcXFxcfF0pL2csIHJlcGxhY2UpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJhdyh0aGlzLmVuY29kZSh2YWx1ZSkpXG4gICAgICB9LFxuICAgICAgdGFibGUoKSB7XG4gICAgICAgIHRoaXMuc2V0RGF0YSgndGFibGVBbGlnbicpXG4gICAgICAgIC8vIE5vdGU6IHdlIGRvbuKAmXQgc2V0IGBzbHVycEFsbExpbmVFbmRpbmdzYCBhbnltb3JlLCBpbiBkZWxpbWl0ZXIgcm93cyxcbiAgICAgICAgLy8gYnV0IHdlIGRvIG5lZWQgdG8gcmVzZXQgaXQgdG8gbWF0Y2ggYSBmdW5reSBuZXdsaW5lIEdIIGdlbmVyYXRlcyBmb3JcbiAgICAgICAgLy8gbGlzdCBpdGVtcyBjb21iaW5lZCB3aXRoIHRhYmxlcy5cbiAgICAgICAgdGhpcy5zZXREYXRhKCdzbHVycEFsbExpbmVFbmRpbmdzJylcbiAgICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgICB0aGlzLnRhZygnPC90YWJsZT4nKVxuICAgICAgfSxcbiAgICAgIHRhYmxlQm9keSgpIHtcbiAgICAgICAgdGhpcy5saW5lRW5kaW5nSWZOZWVkZWQoKVxuICAgICAgICB0aGlzLnRhZygnPC90Ym9keT4nKVxuICAgICAgfSxcbiAgICAgIHRhYmxlRGF0YSgpIHtcbiAgICAgICAgY29uc3QgdGFibGVBbGlnbiA9IHRoaXMuZ2V0RGF0YSgndGFibGVBbGlnbicpXG4gICAgICAgIGNvbnN0IHRhYmxlQ29sdW1uID0gdGhpcy5nZXREYXRhKCd0YWJsZUNvbHVtbicpXG4gICAgICAgIGFzc2VydCh0YWJsZUFsaWduLCAnZXhwZWN0ZWQgYHRhYmxlQWxpZ25gJylcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB0YWJsZUNvbHVtbiA9PT0gJ251bWJlcicsICdleHBlY3RlZCBgdGFibGVDb2x1bW5gJylcblxuICAgICAgICBpZiAodGFibGVDb2x1bW4gaW4gdGFibGVBbGlnbikge1xuICAgICAgICAgIHRoaXMudGFnKCc8L3RkPicpXG4gICAgICAgICAgdGhpcy5zZXREYXRhKCd0YWJsZUNvbHVtbicsIHRhYmxlQ29sdW1uICsgMSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTdG9wIGNhcHR1cmluZy5cbiAgICAgICAgICB0aGlzLnJlc3VtZSgpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0YWJsZUhlYWQoKSB7XG4gICAgICAgIHRoaXMubGluZUVuZGluZ0lmTmVlZGVkKClcbiAgICAgICAgdGhpcy50YWcoJzwvdGhlYWQ+JylcbiAgICAgIH0sXG4gICAgICB0YWJsZUhlYWRlcigpIHtcbiAgICAgICAgY29uc3QgdGFibGVDb2x1bW4gPSB0aGlzLmdldERhdGEoJ3RhYmxlQ29sdW1uJylcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB0YWJsZUNvbHVtbiA9PT0gJ251bWJlcicsICdleHBlY3RlZCBgdGFibGVDb2x1bW5gJylcbiAgICAgICAgdGhpcy50YWcoJzwvdGg+JylcbiAgICAgICAgdGhpcy5zZXREYXRhKCd0YWJsZUNvbHVtbicsIHRhYmxlQ29sdW1uICsgMSlcbiAgICAgIH0sXG4gICAgICB0YWJsZVJvdygpIHtcbiAgICAgICAgY29uc3QgdGFibGVBbGlnbiA9IHRoaXMuZ2V0RGF0YSgndGFibGVBbGlnbicpXG4gICAgICAgIGxldCB0YWJsZUNvbHVtbiA9IHRoaXMuZ2V0RGF0YSgndGFibGVDb2x1bW4nKVxuICAgICAgICBhc3NlcnQodGFibGVBbGlnbiwgJ2V4cGVjdGVkIGB0YWJsZUFsaWduYCcpXG4gICAgICAgIGFzc2VydCh0eXBlb2YgdGFibGVDb2x1bW4gPT09ICdudW1iZXInLCAnZXhwZWN0ZWQgYHRhYmxlQ29sdW1uYCcpXG5cbiAgICAgICAgd2hpbGUgKHRhYmxlQ29sdW1uIDwgdGFibGVBbGlnbi5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICAgICAgdGhpcy50YWcoJzx0ZCcgKyBhbGlnbm1lbnRbdGFibGVBbGlnblt0YWJsZUNvbHVtbl1dICsgJz48L3RkPicpXG4gICAgICAgICAgdGFibGVDb2x1bW4rK1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXREYXRhKCd0YWJsZUNvbHVtbicsIHRhYmxlQ29sdW1uKVxuICAgICAgICB0aGlzLmxpbmVFbmRpbmdJZk5lZWRlZCgpXG4gICAgICAgIHRoaXMudGFnKCc8L3RyPicpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9ICQwXG4gKiBAcGFyYW0ge3N0cmluZ30gJDFcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2UoJDAsICQxKSB7XG4gIC8vIFBpcGVzIHdvcmssIGJhY2tzbGFzaGVzIGRvbuKAmXQgKGJ1dCBjYW7igJl0IGVzY2FwZSBwaXBlcykuXG4gIHJldHVybiAkMSA9PT0gJ3wnID8gJDEgOiAkMFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/micromark-extension-gfm-table/dev/lib/html.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/micromark-extension-gfm-table/dev/lib/infer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/infer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTableAlign: () => (/* binding */ gfmTableAlign)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devlop */ \"(app-pages-browser)/./node_modules/devlop/lib/development.js\");\n/**\n * @import {Event} from 'micromark-util-types'\n */\n\n/**\n * @typedef {'center' | 'left' | 'none' | 'right'} Align\n */\n\n\n\n/**\n * Figure out the alignment of a GFM table.\n *\n * @param {Readonly<Array<Event>>} events\n *   List of events.\n * @param {number} index\n *   Table enter event.\n * @returns {Array<Align>}\n *   List of aligns.\n */\nfunction gfmTableAlign(events, index) {\n  (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(events[index][1].type === 'table', 'expected table')\n  let inDelimiterRow = false\n  /** @type {Array<Align>} */\n  const align = []\n\n  while (index < events.length) {\n    const event = events[index]\n\n    if (inDelimiterRow) {\n      if (event[0] === 'enter') {\n        // Start of alignment value: set a new column.\n        // To do: `markdown-rs` uses `tableDelimiterCellValue`.\n        if (event[1].type === 'tableContent') {\n          align.push(\n            events[index + 1][1].type === 'tableDelimiterMarker'\n              ? 'left'\n              : 'none'\n          )\n        }\n      }\n      // Exits:\n      // End of alignment value: change the column.\n      // To do: `markdown-rs` uses `tableDelimiterCellValue`.\n      else if (event[1].type === 'tableContent') {\n        if (events[index - 1][1].type === 'tableDelimiterMarker') {\n          const alignIndex = align.length - 1\n\n          align[alignIndex] = align[alignIndex] === 'left' ? 'center' : 'right'\n        }\n      }\n      // Done!\n      else if (event[1].type === 'tableDelimiterRow') {\n        break\n      }\n    } else if (event[0] === 'enter' && event[1].type === 'tableDelimiterRow') {\n      inDelimiterRow = true\n    }\n\n    index += 1\n  }\n\n  return align\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWJsZS9kZXYvbGliL2luZmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQSxZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQSxhQUFhLHNDQUFzQztBQUNuRDs7QUFFbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQLEVBQUUsMENBQU07QUFDUjtBQUNBLGFBQWEsY0FBYztBQUMzQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFibGUvZGV2L2xpYi9pbmZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge0V2ZW50fSBmcm9tICdtaWNyb21hcmstdXRpbC10eXBlcydcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnY2VudGVyJyB8ICdsZWZ0JyB8ICdub25lJyB8ICdyaWdodCd9IEFsaWduXG4gKi9cblxuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ2RldmxvcCdcblxuLyoqXG4gKiBGaWd1cmUgb3V0IHRoZSBhbGlnbm1lbnQgb2YgYSBHRk0gdGFibGUuXG4gKlxuICogQHBhcmFtIHtSZWFkb25seTxBcnJheTxFdmVudD4+fSBldmVudHNcbiAqICAgTGlzdCBvZiBldmVudHMuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqICAgVGFibGUgZW50ZXIgZXZlbnQuXG4gKiBAcmV0dXJucyB7QXJyYXk8QWxpZ24+fVxuICogICBMaXN0IG9mIGFsaWducy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbVRhYmxlQWxpZ24oZXZlbnRzLCBpbmRleCkge1xuICBhc3NlcnQoZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAndGFibGUnLCAnZXhwZWN0ZWQgdGFibGUnKVxuICBsZXQgaW5EZWxpbWl0ZXJSb3cgPSBmYWxzZVxuICAvKiogQHR5cGUge0FycmF5PEFsaWduPn0gKi9cbiAgY29uc3QgYWxpZ24gPSBbXVxuXG4gIHdoaWxlIChpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICBjb25zdCBldmVudCA9IGV2ZW50c1tpbmRleF1cblxuICAgIGlmIChpbkRlbGltaXRlclJvdykge1xuICAgICAgaWYgKGV2ZW50WzBdID09PSAnZW50ZXInKSB7XG4gICAgICAgIC8vIFN0YXJ0IG9mIGFsaWdubWVudCB2YWx1ZTogc2V0IGEgbmV3IGNvbHVtbi5cbiAgICAgICAgLy8gVG8gZG86IGBtYXJrZG93bi1yc2AgdXNlcyBgdGFibGVEZWxpbWl0ZXJDZWxsVmFsdWVgLlxuICAgICAgICBpZiAoZXZlbnRbMV0udHlwZSA9PT0gJ3RhYmxlQ29udGVudCcpIHtcbiAgICAgICAgICBhbGlnbi5wdXNoKFxuICAgICAgICAgICAgZXZlbnRzW2luZGV4ICsgMV1bMV0udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyTWFya2VyJ1xuICAgICAgICAgICAgICA/ICdsZWZ0J1xuICAgICAgICAgICAgICA6ICdub25lJ1xuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRXhpdHM6XG4gICAgICAvLyBFbmQgb2YgYWxpZ25tZW50IHZhbHVlOiBjaGFuZ2UgdGhlIGNvbHVtbi5cbiAgICAgIC8vIFRvIGRvOiBgbWFya2Rvd24tcnNgIHVzZXMgYHRhYmxlRGVsaW1pdGVyQ2VsbFZhbHVlYC5cbiAgICAgIGVsc2UgaWYgKGV2ZW50WzFdLnR5cGUgPT09ICd0YWJsZUNvbnRlbnQnKSB7XG4gICAgICAgIGlmIChldmVudHNbaW5kZXggLSAxXVsxXS50eXBlID09PSAndGFibGVEZWxpbWl0ZXJNYXJrZXInKSB7XG4gICAgICAgICAgY29uc3QgYWxpZ25JbmRleCA9IGFsaWduLmxlbmd0aCAtIDFcblxuICAgICAgICAgIGFsaWduW2FsaWduSW5kZXhdID0gYWxpZ25bYWxpZ25JbmRleF0gPT09ICdsZWZ0JyA/ICdjZW50ZXInIDogJ3JpZ2h0J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBEb25lIVxuICAgICAgZWxzZSBpZiAoZXZlbnRbMV0udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyUm93Jykge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXZlbnRbMF0gPT09ICdlbnRlcicgJiYgZXZlbnRbMV0udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyUm93Jykge1xuICAgICAgaW5EZWxpbWl0ZXJSb3cgPSB0cnVlXG4gICAgfVxuXG4gICAgaW5kZXggKz0gMVxuICB9XG5cbiAgcmV0dXJuIGFsaWduXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/micromark-extension-gfm-table/dev/lib/infer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/micromark-extension-gfm-table/dev/lib/syntax.js":
/*!**********************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-table/dev/lib/syntax.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTable: () => (/* binding */ gfmTable)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! devlop */ \"(app-pages-browser)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-factory-space */ \"(app-pages-browser)/./node_modules/micromark-factory-space/dev/index.js\");\n/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-character */ \"(app-pages-browser)/./node_modules/micromark-util-character/dev/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/types.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/constants.js\");\n/* harmony import */ var _edit_map_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./edit-map.js */ \"(app-pages-browser)/./node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js\");\n/* harmony import */ var _infer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./infer.js */ \"(app-pages-browser)/./node_modules/micromark-extension-gfm-table/dev/lib/infer.js\");\n/**\n * @import {Event, Extension, Point, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\n/**\n * @typedef {[number, number, number, number]} Range\n *   Cell info.\n *\n * @typedef {0 | 1 | 2 | 3} RowKind\n *   Where we are: `1` for head row, `2` for delimiter row, `3` for body row.\n */\n\n\n\n\n\n\n\n\n/**\n * Create an HTML extension for `micromark` to support GitHub tables syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to enable GFM\n *   table syntax.\n */\nfunction gfmTable() {\n  return {\n    flow: {\n      null: {name: 'table', tokenize: tokenizeTable, resolveAll: resolveTable}\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this\n  let size = 0\n  let sizeB = 0\n  /** @type {boolean | undefined} */\n  let seen\n\n  return start\n\n  /**\n   * Start of a GFM table.\n   *\n   * If there is a valid table row or table head before, then we try to parse\n   * another row.\n   * Otherwise, we try to parse a head.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   * @type {State}\n   */\n  function start(code) {\n    let index = self.events.length - 1\n\n    while (index > -1) {\n      const type = self.events[index][1].type\n      if (\n        type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.lineEnding ||\n        // Note: markdown-rs uses `whitespace` instead of `linePrefix`\n        type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.linePrefix\n      )\n        index--\n      else break\n    }\n\n    const tail = index > -1 ? self.events[index][1].type : null\n\n    const next =\n      tail === 'tableHead' || tail === 'tableRow' ? bodyRowStart : headRowBefore\n\n    // Dont allow lazy body rows.\n    if (next === bodyRowStart && self.parser.lazy[self.now().line]) {\n      return nok(code)\n    }\n\n    return next(code)\n  }\n\n  /**\n   * Before table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowBefore(code) {\n    effects.enter('tableHead')\n    effects.enter('tableRow')\n    return headRowStart(code)\n  }\n\n  /**\n   * Before table head row, after whitespace.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowStart(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar) {\n      return headRowBreak(code)\n    }\n\n    // To do: micromark-js should let us parse our own whitespace in extensions,\n    // like `markdown-rs`:\n    //\n    // ```js\n    // // 4+ spaces.\n    // if (markdownSpace(code)) {\n    //   return nok(code)\n    // }\n    // ```\n\n    seen = true\n    // Count the first character, that isnt a pipe, double.\n    sizeB += 1\n    return headRowBreak(code)\n  }\n\n  /**\n   * At break in table head row.\n   *\n   * ```markdown\n   * > | | a |\n   *     ^\n   *       ^\n   *         ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowBreak(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.eof) {\n      // Note: in `markdown-rs`, we need to reset, in `micromark-js` we dont.\n      return nok(code)\n    }\n\n    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownLineEnding)(code)) {\n      // If anything other than one pipe (ignoring whitespace) was used, its fine.\n      if (sizeB > 1) {\n        sizeB = 0\n        // To do: check if this works.\n        // Feel free to interrupt:\n        self.interrupt = true\n        effects.exit('tableRow')\n        effects.enter(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.lineEnding)\n        effects.consume(code)\n        effects.exit(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.lineEnding)\n        return headDelimiterStart\n      }\n\n      // Note: in `markdown-rs`, we need to reset, in `micromark-js` we dont.\n      return nok(code)\n    }\n\n    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownSpace)(code)) {\n      // To do: check if this is fine.\n      // effects.attempt(State::Next(StateName::GfmTableHeadRowBreak), State::Nok)\n      // State::Retry(space_or_tab(tokenizer))\n      return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__.factorySpace)(effects, headRowBreak, micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.whitespace)(code)\n    }\n\n    sizeB += 1\n\n    if (seen) {\n      seen = false\n      // Header cell count.\n      size += 1\n    }\n\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      // Whether a delimiter was seen.\n      seen = true\n      return headRowBreak\n    }\n\n    // Anything else is cell data.\n    effects.enter(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.data)\n    return headRowData(code)\n  }\n\n  /**\n   * In table head row data.\n   *\n   * ```markdown\n   * > | | a |\n   *       ^\n   *   | | - |\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowData(code) {\n    if (\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.eof ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownLineEndingOrSpace)(code)\n    ) {\n      effects.exit(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.data)\n      return headRowBreak(code)\n    }\n\n    effects.consume(code)\n    return code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.backslash ? headRowEscape : headRowData\n  }\n\n  /**\n   * In table head row escape.\n   *\n   * ```markdown\n   * > | | a\\-b |\n   *         ^\n   *   | | ---- |\n   *   | | c    |\n   * ```\n   *\n   * @type {State}\n   */\n  function headRowEscape(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.backslash || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar) {\n      effects.consume(code)\n      return headRowData\n    }\n\n    return headRowData(code)\n  }\n\n  /**\n   * Before delimiter row.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterStart(code) {\n    // Reset `interrupt`.\n    self.interrupt = false\n\n    // Note: in `markdown-rs`, we need to handle piercing here too.\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code)\n    }\n\n    effects.enter('tableDelimiterRow')\n    // Track if weve seen a `:` or `|`.\n    seen = false\n\n    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownSpace)(code)) {\n      (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(self.parser.constructs.disable.null, 'expected `disabled.null`')\n      return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__.factorySpace)(\n        effects,\n        headDelimiterBefore,\n        micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.linePrefix,\n        self.parser.constructs.disable.null.includes('codeIndented')\n          ? undefined\n          : micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.constants.tabSize\n      )(code)\n    }\n\n    return headDelimiterBefore(code)\n  }\n\n  /**\n   * Before delimiter row, after optional whitespace.\n   *\n   * Reused when a `|` is found later, to parse another cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *     ^\n   *   | | b |\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterBefore(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.dash || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.colon) {\n      return headDelimiterValueBefore(code)\n    }\n\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar) {\n      seen = true\n      // If we start with a pipe, we open a cell marker.\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return headDelimiterCellBefore\n    }\n\n    // More whitespace / empty row not allowed at start.\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * After `|`, before delimiter cell.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterCellBefore(code) {\n    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownSpace)(code)) {\n      return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__.factorySpace)(\n        effects,\n        headDelimiterValueBefore,\n        micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.whitespace\n      )(code)\n    }\n\n    return headDelimiterValueBefore(code)\n  }\n\n  /**\n   * Before delimiter cell value.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterValueBefore(code) {\n    // Align: left.\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.colon) {\n      sizeB += 1\n      seen = true\n\n      effects.enter('tableDelimiterMarker')\n      effects.consume(code)\n      effects.exit('tableDelimiterMarker')\n      return headDelimiterLeftAlignmentAfter\n    }\n\n    // Align: none.\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.dash) {\n      sizeB += 1\n      // To do: seems weird that this *isnt* left aligned, but that state is used?\n      return headDelimiterLeftAlignmentAfter(code)\n    }\n\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownLineEnding)(code)) {\n      return headDelimiterCellAfter(code)\n    }\n\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * After delimiter cell left alignment marker.\n   *\n   * ```markdown\n   *   | | a  |\n   * > | | :- |\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterLeftAlignmentAfter(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.dash) {\n      effects.enter('tableDelimiterFiller')\n      return headDelimiterFiller(code)\n    }\n\n    // Anything else is not ok after the left-align colon.\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * In delimiter cell filler.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | - |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterFiller(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.dash) {\n      effects.consume(code)\n      return headDelimiterFiller\n    }\n\n    // Align is `center` if it was `left`, `right` otherwise.\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.colon) {\n      seen = true\n      effects.exit('tableDelimiterFiller')\n      effects.enter('tableDelimiterMarker')\n      effects.consume(code)\n      effects.exit('tableDelimiterMarker')\n      return headDelimiterRightAlignmentAfter\n    }\n\n    effects.exit('tableDelimiterFiller')\n    return headDelimiterRightAlignmentAfter(code)\n  }\n\n  /**\n   * After delimiter cell right alignment marker.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterRightAlignmentAfter(code) {\n    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownSpace)(code)) {\n      return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__.factorySpace)(\n        effects,\n        headDelimiterCellAfter,\n        micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.whitespace\n      )(code)\n    }\n\n    return headDelimiterCellAfter(code)\n  }\n\n  /**\n   * After delimiter cell.\n   *\n   * ```markdown\n   *   | |  a |\n   * > | | -: |\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterCellAfter(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar) {\n      return headDelimiterBefore(code)\n    }\n\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownLineEnding)(code)) {\n      // Exit when:\n      // * there was no `:` or `|` at all (its a thematic break or setext\n      //   underline instead)\n      // * the header cell count is not the delimiter cell count\n      if (!seen || size !== sizeB) {\n        return headDelimiterNok(code)\n      }\n\n      // Note: in markdown-rs`, a reset is needed here.\n      effects.exit('tableDelimiterRow')\n      effects.exit('tableHead')\n      // To do: in `markdown-rs`, resolvers need to be registered manually.\n      // effects.register_resolver(ResolveName::GfmTable)\n      return ok(code)\n    }\n\n    return headDelimiterNok(code)\n  }\n\n  /**\n   * In delimiter row, at a disallowed byte.\n   *\n   * ```markdown\n   *   | | a |\n   * > | | x |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function headDelimiterNok(code) {\n    // Note: in `markdown-rs`, we need to reset, in `micromark-js` we dont.\n    return nok(code)\n  }\n\n  /**\n   * Before table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowStart(code) {\n    // Note: in `markdown-rs` we need to manually take care of a prefix,\n    // but in `micromark-js` that is done for us, so if were here, were\n    // never at whitespace.\n    effects.enter('tableRow')\n    return bodyRowBreak(code)\n  }\n\n  /**\n   * At break in table body row.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *     ^\n   *       ^\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowBreak(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return bodyRowBreak\n    }\n\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownLineEnding)(code)) {\n      effects.exit('tableRow')\n      return ok(code)\n    }\n\n    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownSpace)(code)) {\n      return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__.factorySpace)(effects, bodyRowBreak, micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.whitespace)(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.data)\n    return bodyRowData(code)\n  }\n\n  /**\n   * In table body row data.\n   *\n   * ```markdown\n   *   | | a |\n   *   | | - |\n   * > | | b |\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowData(code) {\n    if (\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.eof ||\n      code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar ||\n      (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownLineEndingOrSpace)(code)\n    ) {\n      effects.exit(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.data)\n      return bodyRowBreak(code)\n    }\n\n    effects.consume(code)\n    return code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.backslash ? bodyRowEscape : bodyRowData\n  }\n\n  /**\n   * In table body row escape.\n   *\n   * ```markdown\n   *   | | a    |\n   *   | | ---- |\n   * > | | b\\-c |\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function bodyRowEscape(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.backslash || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.verticalBar) {\n      effects.consume(code)\n      return bodyRowData\n    }\n\n    return bodyRowData(code)\n  }\n}\n\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  let index = -1\n  let inFirstCellAwaitingPipe = true\n  /** @type {RowKind} */\n  let rowKind = 0\n  /** @type {Range} */\n  let lastCell = [0, 0, 0, 0]\n  /** @type {Range} */\n  let cell = [0, 0, 0, 0]\n  let afterHeadAwaitingFirstBodyRow = false\n  let lastTableEnd = 0\n  /** @type {Token | undefined} */\n  let currentTable\n  /** @type {Token | undefined} */\n  let currentBody\n  /** @type {Token | undefined} */\n  let currentCell\n\n  const map = new _edit_map_js__WEBPACK_IMPORTED_MODULE_6__.EditMap()\n\n  while (++index < events.length) {\n    const event = events[index]\n    const token = event[1]\n\n    if (event[0] === 'enter') {\n      // Start of head.\n      if (token.type === 'tableHead') {\n        afterHeadAwaitingFirstBodyRow = false\n\n        // Inject previous (body end and) table end.\n        if (lastTableEnd !== 0) {\n          (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(currentTable, 'there should be a table opening')\n          flushTableEnd(map, context, lastTableEnd, currentTable, currentBody)\n          currentBody = undefined\n          lastTableEnd = 0\n        }\n\n        // Inject table start.\n        currentTable = {\n          type: 'table',\n          start: Object.assign({}, token.start),\n          // Note: correct end is set later.\n          end: Object.assign({}, token.end)\n        }\n        map.add(index, 0, [['enter', currentTable, context]])\n      } else if (\n        token.type === 'tableRow' ||\n        token.type === 'tableDelimiterRow'\n      ) {\n        inFirstCellAwaitingPipe = true\n        currentCell = undefined\n        lastCell = [0, 0, 0, 0]\n        cell = [0, index + 1, 0, 0]\n\n        // Inject table body start.\n        if (afterHeadAwaitingFirstBodyRow) {\n          afterHeadAwaitingFirstBodyRow = false\n          currentBody = {\n            type: 'tableBody',\n            start: Object.assign({}, token.start),\n            // Note: correct end is set later.\n            end: Object.assign({}, token.end)\n          }\n          map.add(index, 0, [['enter', currentBody, context]])\n        }\n\n        rowKind = token.type === 'tableDelimiterRow' ? 2 : currentBody ? 3 : 1\n      }\n      // Cell data.\n      else if (\n        rowKind &&\n        (token.type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.data ||\n          token.type === 'tableDelimiterMarker' ||\n          token.type === 'tableDelimiterFiller')\n      ) {\n        inFirstCellAwaitingPipe = false\n\n        // First value in cell.\n        if (cell[2] === 0) {\n          if (lastCell[1] !== 0) {\n            cell[0] = cell[1]\n            currentCell = flushCell(\n              map,\n              context,\n              lastCell,\n              rowKind,\n              undefined,\n              currentCell\n            )\n            lastCell = [0, 0, 0, 0]\n          }\n\n          cell[2] = index\n        }\n      } else if (token.type === 'tableCellDivider') {\n        if (inFirstCellAwaitingPipe) {\n          inFirstCellAwaitingPipe = false\n        } else {\n          if (lastCell[1] !== 0) {\n            cell[0] = cell[1]\n            currentCell = flushCell(\n              map,\n              context,\n              lastCell,\n              rowKind,\n              undefined,\n              currentCell\n            )\n          }\n\n          lastCell = cell\n          cell = [lastCell[1], index, 0, 0]\n        }\n      }\n    }\n    // Exit events.\n    else if (token.type === 'tableHead') {\n      afterHeadAwaitingFirstBodyRow = true\n      lastTableEnd = index\n    } else if (\n      token.type === 'tableRow' ||\n      token.type === 'tableDelimiterRow'\n    ) {\n      lastTableEnd = index\n\n      if (lastCell[1] !== 0) {\n        cell[0] = cell[1]\n        currentCell = flushCell(\n          map,\n          context,\n          lastCell,\n          rowKind,\n          index,\n          currentCell\n        )\n      } else if (cell[1] !== 0) {\n        currentCell = flushCell(map, context, cell, rowKind, index, currentCell)\n      }\n\n      rowKind = 0\n    } else if (\n      rowKind &&\n      (token.type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.data ||\n        token.type === 'tableDelimiterMarker' ||\n        token.type === 'tableDelimiterFiller')\n    ) {\n      cell[3] = index\n    }\n  }\n\n  if (lastTableEnd !== 0) {\n    (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(currentTable, 'expected table opening')\n    flushTableEnd(map, context, lastTableEnd, currentTable, currentBody)\n  }\n\n  map.consume(context.events)\n\n  // To do: move this into `html`, when events are exposed there.\n  // Thats what `markdown-rs` does.\n  // That needs updates to `mdast-util-gfm-table`.\n  index = -1\n  while (++index < context.events.length) {\n    const event = context.events[index]\n    if (event[0] === 'enter' && event[1].type === 'table') {\n      event[1]._align = (0,_infer_js__WEBPACK_IMPORTED_MODULE_7__.gfmTableAlign)(context.events, index)\n    }\n  }\n\n  return events\n}\n\n/**\n * Generate a cell.\n *\n * @param {EditMap} map\n * @param {Readonly<TokenizeContext>} context\n * @param {Readonly<Range>} range\n * @param {RowKind} rowKind\n * @param {number | undefined} rowEnd\n * @param {Token | undefined} previousCell\n * @returns {Token | undefined}\n */\n// eslint-disable-next-line max-params\nfunction flushCell(map, context, range, rowKind, rowEnd, previousCell) {\n  // `markdown-rs` uses:\n  // rowKind === 2 ? 'tableDelimiterCell' : 'tableCell'\n  const groupName =\n    rowKind === 1\n      ? 'tableHeader'\n      : rowKind === 2\n        ? 'tableDelimiter'\n        : 'tableData'\n  // `markdown-rs` uses:\n  // rowKind === 2 ? 'tableDelimiterCellValue' : 'tableCellText'\n  const valueName = 'tableContent'\n\n  // Insert an exit for the previous cell, if there is one.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //          ^-- exit\n  //           ^^^^-- this cell\n  // ```\n  if (range[0] !== 0) {\n    (0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(previousCell, 'expected previous cell enter')\n    previousCell.end = Object.assign({}, getPoint(context.events, range[0]))\n    map.add(range[0], 0, [['exit', previousCell, context]])\n  }\n\n  // Insert enter of this cell.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //           ^-- enter\n  //           ^^^^-- this cell\n  // ```\n  const now = getPoint(context.events, range[1])\n  previousCell = {\n    type: groupName,\n    start: Object.assign({}, now),\n    // Note: correct end is set later.\n    end: Object.assign({}, now)\n  }\n  map.add(range[1], 0, [['enter', previousCell, context]])\n\n  // Insert text start at first data start and end at last data end, and\n  // remove events between.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //            ^-- enter\n  //             ^-- exit\n  //           ^^^^-- this cell\n  // ```\n  if (range[2] !== 0) {\n    const relatedStart = getPoint(context.events, range[2])\n    const relatedEnd = getPoint(context.events, range[3])\n    /** @type {Token} */\n    const valueToken = {\n      type: valueName,\n      start: Object.assign({}, relatedStart),\n      end: Object.assign({}, relatedEnd)\n    }\n    map.add(range[2], 0, [['enter', valueToken, context]])\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_4__.ok)(range[3] !== 0)\n\n    if (rowKind !== 2) {\n      // Fix positional info on remaining events\n      const start = context.events[range[2]]\n      const end = context.events[range[3]]\n      start[1].end = Object.assign({}, end[1].end)\n      start[1].type = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.chunkText\n      start[1].contentType = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.constants.contentTypeText\n\n      // Remove if needed.\n      if (range[3] > range[2] + 1) {\n        const a = range[2] + 1\n        const b = range[3] - range[2] - 1\n        map.add(a, b, [])\n      }\n    }\n\n    map.add(range[3] + 1, 0, [['exit', valueToken, context]])\n  }\n\n  // Insert an exit for the last cell, if at the row end.\n  //\n  // ```markdown\n  // > | | aa | bb | cc |\n  //                    ^-- exit\n  //               ^^^^^^-- this cell (the last one contains two between parts)\n  // ```\n  if (rowEnd !== undefined) {\n    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd))\n    map.add(rowEnd, 0, [['exit', previousCell, context]])\n    previousCell = undefined\n  }\n\n  return previousCell\n}\n\n/**\n * Generate table end (and table body end).\n *\n * @param {Readonly<EditMap>} map\n * @param {Readonly<TokenizeContext>} context\n * @param {number} index\n * @param {Token} table\n * @param {Token | undefined} tableBody\n */\n// eslint-disable-next-line max-params\nfunction flushTableEnd(map, context, index, table, tableBody) {\n  /** @type {Array<Event>} */\n  const exits = []\n  const related = getPoint(context.events, index)\n\n  if (tableBody) {\n    tableBody.end = Object.assign({}, related)\n    exits.push(['exit', tableBody, context])\n  }\n\n  table.end = Object.assign({}, related)\n  exits.push(['exit', table, context])\n\n  map.add(index + 1, 0, exits)\n}\n\n/**\n * @param {Readonly<Array<Event>>} events\n * @param {number} index\n * @returns {Readonly<Point>}\n */\nfunction getPoint(events, index) {\n  const event = events[index]\n  const side = event[0] === 'enter' ? 'start' : 'end'\n  return event[1][side]\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWJsZS9kZXYvbGliL3N5bnRheC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLFlBQVksNkVBQTZFO0FBQ3pGOztBQUVBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0M7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBOztBQUVtQztBQUNpQjtBQUtuQjtBQUM0QjtBQUN4QjtBQUNHOztBQUV4QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBSztBQUN0QjtBQUNBLGlCQUFpQix3REFBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxpQkFBaUIsd0RBQUs7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QU07O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsc0JBQXNCLHdEQUFLO0FBQzNCLDZCQUE2Qiw0REFBUzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsMkJBQTJCO0FBQ3RDLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWJsZS9kZXYvbGliL3N5bnRheC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge0V2ZW50LCBFeHRlbnNpb24sIFBvaW50LCBSZXNvbHZlciwgU3RhdGUsIFRva2VuLCBUb2tlbml6ZUNvbnRleHQsIFRva2VuaXplcn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtdHlwZXMnXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7W251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl19IFJhbmdlXG4gKiAgIENlbGwgaW5mby5cbiAqXG4gKiBAdHlwZWRlZiB7MCB8IDEgfCAyIHwgM30gUm93S2luZFxuICogICBXaGVyZSB3ZSBhcmU6IGAxYCBmb3IgaGVhZCByb3csIGAyYCBmb3IgZGVsaW1pdGVyIHJvdywgYDNgIGZvciBib2R5IHJvdy5cbiAqL1xuXG5pbXBvcnQge29rIGFzIGFzc2VydH0gZnJvbSAnZGV2bG9wJ1xuaW1wb3J0IHtmYWN0b3J5U3BhY2V9IGZyb20gJ21pY3JvbWFyay1mYWN0b3J5LXNwYWNlJ1xuaW1wb3J0IHtcbiAgbWFya2Rvd25MaW5lRW5kaW5nLFxuICBtYXJrZG93bkxpbmVFbmRpbmdPclNwYWNlLFxuICBtYXJrZG93blNwYWNlXG59IGZyb20gJ21pY3JvbWFyay11dGlsLWNoYXJhY3RlcidcbmltcG9ydCB7Y29kZXMsIGNvbnN0YW50cywgdHlwZXN9IGZyb20gJ21pY3JvbWFyay11dGlsLXN5bWJvbCdcbmltcG9ydCB7RWRpdE1hcH0gZnJvbSAnLi9lZGl0LW1hcC5qcydcbmltcG9ydCB7Z2ZtVGFibGVBbGlnbn0gZnJvbSAnLi9pbmZlci5qcydcblxuLyoqXG4gKiBDcmVhdGUgYW4gSFRNTCBleHRlbnNpb24gZm9yIGBtaWNyb21hcmtgIHRvIHN1cHBvcnQgR2l0SHViIHRhYmxlcyBzeW50YXguXG4gKlxuICogQHJldHVybnMge0V4dGVuc2lvbn1cbiAqICAgRXh0ZW5zaW9uIGZvciBgbWljcm9tYXJrYCB0aGF0IGNhbiBiZSBwYXNzZWQgaW4gYGV4dGVuc2lvbnNgIHRvIGVuYWJsZSBHRk1cbiAqICAgdGFibGUgc3ludGF4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtVGFibGUoKSB7XG4gIHJldHVybiB7XG4gICAgZmxvdzoge1xuICAgICAgbnVsbDoge25hbWU6ICd0YWJsZScsIHRva2VuaXplOiB0b2tlbml6ZVRhYmxlLCByZXNvbHZlQWxsOiByZXNvbHZlVGFibGV9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplVGFibGUoZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBsZXQgc2l6ZSA9IDBcbiAgbGV0IHNpemVCID0gMFxuICAvKiogQHR5cGUge2Jvb2xlYW4gfCB1bmRlZmluZWR9ICovXG4gIGxldCBzZWVuXG5cbiAgcmV0dXJuIHN0YXJ0XG5cbiAgLyoqXG4gICAqIFN0YXJ0IG9mIGEgR0ZNIHRhYmxlLlxuICAgKlxuICAgKiBJZiB0aGVyZSBpcyBhIHZhbGlkIHRhYmxlIHJvdyBvciB0YWJsZSBoZWFkIGJlZm9yZSwgdGhlbiB3ZSB0cnkgdG8gcGFyc2VcbiAgICogYW5vdGhlciByb3cuXG4gICAqIE90aGVyd2lzZSwgd2UgdHJ5IHRvIHBhcnNlIGEgaGVhZC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IHwgYSB8XG4gICAqICAgICBeXG4gICAqICAgfCB8IC0gfFxuICAgKiA+IHwgfCBiIHxcbiAgICogICAgIF5cbiAgICogYGBgXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICBsZXQgaW5kZXggPSBzZWxmLmV2ZW50cy5sZW5ndGggLSAxXG5cbiAgICB3aGlsZSAoaW5kZXggPiAtMSkge1xuICAgICAgY29uc3QgdHlwZSA9IHNlbGYuZXZlbnRzW2luZGV4XVsxXS50eXBlXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGUgPT09IHR5cGVzLmxpbmVFbmRpbmcgfHxcbiAgICAgICAgLy8gTm90ZTogbWFya2Rvd24tcnMgdXNlcyBgd2hpdGVzcGFjZWAgaW5zdGVhZCBvZiBgbGluZVByZWZpeGBcbiAgICAgICAgdHlwZSA9PT0gdHlwZXMubGluZVByZWZpeFxuICAgICAgKVxuICAgICAgICBpbmRleC0tXG4gICAgICBlbHNlIGJyZWFrXG4gICAgfVxuXG4gICAgY29uc3QgdGFpbCA9IGluZGV4ID4gLTEgPyBzZWxmLmV2ZW50c1tpbmRleF1bMV0udHlwZSA6IG51bGxcblxuICAgIGNvbnN0IG5leHQgPVxuICAgICAgdGFpbCA9PT0gJ3RhYmxlSGVhZCcgfHwgdGFpbCA9PT0gJ3RhYmxlUm93JyA/IGJvZHlSb3dTdGFydCA6IGhlYWRSb3dCZWZvcmVcblxuICAgIC8vIERvbuKAmXQgYWxsb3cgbGF6eSBib2R5IHJvd3MuXG4gICAgaWYgKG5leHQgPT09IGJvZHlSb3dTdGFydCAmJiBzZWxmLnBhcnNlci5sYXp5W3NlbGYubm93KCkubGluZV0pIHtcbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dChjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEJlZm9yZSB0YWJsZSBoZWFkIHJvdy5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IHwgYSB8XG4gICAqICAgICBeXG4gICAqICAgfCB8IC0gfFxuICAgKiAgIHwgfCBiIHxcbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGhlYWRSb3dCZWZvcmUoY29kZSkge1xuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlSGVhZCcpXG4gICAgZWZmZWN0cy5lbnRlcigndGFibGVSb3cnKVxuICAgIHJldHVybiBoZWFkUm93U3RhcnQoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWZvcmUgdGFibGUgaGVhZCByb3csIGFmdGVyIHdoaXRlc3BhY2UuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCB8IGEgfFxuICAgKiAgICAgXlxuICAgKiAgIHwgfCAtIHxcbiAgICogICB8IHwgYiB8XG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkUm93U3RhcnQoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhcikge1xuICAgICAgcmV0dXJuIGhlYWRSb3dCcmVhayhjb2RlKVxuICAgIH1cblxuICAgIC8vIFRvIGRvOiBtaWNyb21hcmstanMgc2hvdWxkIGxldCB1cyBwYXJzZSBvdXIgb3duIHdoaXRlc3BhY2UgaW4gZXh0ZW5zaW9ucyxcbiAgICAvLyBsaWtlIGBtYXJrZG93bi1yc2A6XG4gICAgLy9cbiAgICAvLyBgYGBqc1xuICAgIC8vIC8vIDQrIHNwYWNlcy5cbiAgICAvLyBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgIC8vICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIC8vIH1cbiAgICAvLyBgYGBcblxuICAgIHNlZW4gPSB0cnVlXG4gICAgLy8gQ291bnQgdGhlIGZpcnN0IGNoYXJhY3RlciwgdGhhdCBpc27igJl0IGEgcGlwZSwgZG91YmxlLlxuICAgIHNpemVCICs9IDFcbiAgICByZXR1cm4gaGVhZFJvd0JyZWFrKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQXQgYnJlYWsgaW4gdGFibGUgaGVhZCByb3cuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCB8IGEgfFxuICAgKiAgICAgXlxuICAgKiAgICAgICBeXG4gICAqICAgICAgICAgXlxuICAgKiAgIHwgfCAtIHxcbiAgICogICB8IHwgYiB8XG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkUm93QnJlYWsoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBjb2Rlcy5lb2YpIHtcbiAgICAgIC8vIE5vdGU6IGluIGBtYXJrZG93bi1yc2AsIHdlIG5lZWQgdG8gcmVzZXQsIGluIGBtaWNyb21hcmstanNgIHdlIGRvbuKAmHQuXG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgLy8gSWYgYW55dGhpbmcgb3RoZXIgdGhhbiBvbmUgcGlwZSAoaWdub3Jpbmcgd2hpdGVzcGFjZSkgd2FzIHVzZWQsIGl04oCZcyBmaW5lLlxuICAgICAgaWYgKHNpemVCID4gMSkge1xuICAgICAgICBzaXplQiA9IDBcbiAgICAgICAgLy8gVG8gZG86IGNoZWNrIGlmIHRoaXMgd29ya3MuXG4gICAgICAgIC8vIEZlZWwgZnJlZSB0byBpbnRlcnJ1cHQ6XG4gICAgICAgIHNlbGYuaW50ZXJydXB0ID0gdHJ1ZVxuICAgICAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlUm93JylcbiAgICAgICAgZWZmZWN0cy5lbnRlcih0eXBlcy5saW5lRW5kaW5nKVxuICAgICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgICAgZWZmZWN0cy5leGl0KHR5cGVzLmxpbmVFbmRpbmcpXG4gICAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyU3RhcnRcbiAgICAgIH1cblxuICAgICAgLy8gTm90ZTogaW4gYG1hcmtkb3duLXJzYCwgd2UgbmVlZCB0byByZXNldCwgaW4gYG1pY3JvbWFyay1qc2Agd2UgZG9u4oCYdC5cbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG5cbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgLy8gVG8gZG86IGNoZWNrIGlmIHRoaXMgaXMgZmluZS5cbiAgICAgIC8vIGVmZmVjdHMuYXR0ZW1wdChTdGF0ZTo6TmV4dChTdGF0ZU5hbWU6OkdmbVRhYmxlSGVhZFJvd0JyZWFrKSwgU3RhdGU6Ok5vaylcbiAgICAgIC8vIFN0YXRlOjpSZXRyeShzcGFjZV9vcl90YWIodG9rZW5pemVyKSlcbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgaGVhZFJvd0JyZWFrLCB0eXBlcy53aGl0ZXNwYWNlKShjb2RlKVxuICAgIH1cblxuICAgIHNpemVCICs9IDFcblxuICAgIGlmIChzZWVuKSB7XG4gICAgICBzZWVuID0gZmFsc2VcbiAgICAgIC8vIEhlYWRlciBjZWxsIGNvdW50LlxuICAgICAgc2l6ZSArPSAxXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLnZlcnRpY2FsQmFyKSB7XG4gICAgICBlZmZlY3RzLmVudGVyKCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZUNlbGxEaXZpZGVyJylcbiAgICAgIC8vIFdoZXRoZXIgYSBkZWxpbWl0ZXIgd2FzIHNlZW4uXG4gICAgICBzZWVuID0gdHJ1ZVxuICAgICAgcmV0dXJuIGhlYWRSb3dCcmVha1xuICAgIH1cblxuICAgIC8vIEFueXRoaW5nIGVsc2UgaXMgY2VsbCBkYXRhLlxuICAgIGVmZmVjdHMuZW50ZXIodHlwZXMuZGF0YSlcbiAgICByZXR1cm4gaGVhZFJvd0RhdGEoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiB0YWJsZSBoZWFkIHJvdyBkYXRhLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgfCBhIHxcbiAgICogICAgICAgXlxuICAgKiAgIHwgfCAtIHxcbiAgICogICB8IHwgYiB8XG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkUm93RGF0YShjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gY29kZXMuZW9mIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhciB8fFxuICAgICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKVxuICAgICkge1xuICAgICAgZWZmZWN0cy5leGl0KHR5cGVzLmRhdGEpXG4gICAgICByZXR1cm4gaGVhZFJvd0JyZWFrKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvZGUgPT09IGNvZGVzLmJhY2tzbGFzaCA/IGhlYWRSb3dFc2NhcGUgOiBoZWFkUm93RGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHRhYmxlIGhlYWQgcm93IGVzY2FwZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8IHwgYVxcLWIgfFxuICAgKiAgICAgICAgIF5cbiAgICogICB8IHwgLS0tLSB8XG4gICAqICAgfCB8IGMgICAgfFxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZFJvd0VzY2FwZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmJhY2tzbGFzaCB8fCBjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhcikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gaGVhZFJvd0RhdGFcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZFJvd0RhdGEoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWZvcmUgZGVsaW1pdGVyIHJvdy5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8IHwgYSB8XG4gICAqID4gfCB8IC0gfFxuICAgKiAgICAgXlxuICAgKiAgIHwgfCBiIHxcbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGhlYWREZWxpbWl0ZXJTdGFydChjb2RlKSB7XG4gICAgLy8gUmVzZXQgYGludGVycnVwdGAuXG4gICAgc2VsZi5pbnRlcnJ1cHQgPSBmYWxzZVxuXG4gICAgLy8gTm90ZTogaW4gYG1hcmtkb3duLXJzYCwgd2UgbmVlZCB0byBoYW5kbGUgcGllcmNpbmcgaGVyZSB0b28uXG4gICAgaWYgKHNlbGYucGFyc2VyLmxhenlbc2VsZi5ub3coKS5saW5lXSkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlRGVsaW1pdGVyUm93JylcbiAgICAvLyBUcmFjayBpZiB3ZeKAmXZlIHNlZW4gYSBgOmAgb3IgYHxgLlxuICAgIHNlZW4gPSBmYWxzZVxuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIGFzc2VydChzZWxmLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbCwgJ2V4cGVjdGVkIGBkaXNhYmxlZC5udWxsYCcpXG4gICAgICByZXR1cm4gZmFjdG9yeVNwYWNlKFxuICAgICAgICBlZmZlY3RzLFxuICAgICAgICBoZWFkRGVsaW1pdGVyQmVmb3JlLFxuICAgICAgICB0eXBlcy5saW5lUHJlZml4LFxuICAgICAgICBzZWxmLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcygnY29kZUluZGVudGVkJylcbiAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgIDogY29uc3RhbnRzLnRhYlNpemVcbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZERlbGltaXRlckJlZm9yZShjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEJlZm9yZSBkZWxpbWl0ZXIgcm93LCBhZnRlciBvcHRpb25hbCB3aGl0ZXNwYWNlLlxuICAgKlxuICAgKiBSZXVzZWQgd2hlbiBhIGB8YCBpcyBmb3VuZCBsYXRlciwgdG8gcGFyc2UgYW5vdGhlciBjZWxsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCBhIHxcbiAgICogPiB8IHwgLSB8XG4gICAqICAgICBeXG4gICAqICAgfCB8IGIgfFxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZERlbGltaXRlckJlZm9yZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmRhc2ggfHwgY29kZSA9PT0gY29kZXMuY29sb24pIHtcbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyVmFsdWVCZWZvcmUoY29kZSlcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMudmVydGljYWxCYXIpIHtcbiAgICAgIHNlZW4gPSB0cnVlXG4gICAgICAvLyBJZiB3ZSBzdGFydCB3aXRoIGEgcGlwZSwgd2Ugb3BlbiBhIGNlbGwgbWFya2VyLlxuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICByZXR1cm4gaGVhZERlbGltaXRlckNlbGxCZWZvcmVcbiAgICB9XG5cbiAgICAvLyBNb3JlIHdoaXRlc3BhY2UgLyBlbXB0eSByb3cgbm90IGFsbG93ZWQgYXQgc3RhcnQuXG4gICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJOb2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBgfGAsIGJlZm9yZSBkZWxpbWl0ZXIgY2VsbC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8IHwgYSB8XG4gICAqID4gfCB8IC0gfFxuICAgKiAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGhlYWREZWxpbWl0ZXJDZWxsQmVmb3JlKGNvZGUpIHtcbiAgICBpZiAobWFya2Rvd25TcGFjZShjb2RlKSkge1xuICAgICAgcmV0dXJuIGZhY3RvcnlTcGFjZShcbiAgICAgICAgZWZmZWN0cyxcbiAgICAgICAgaGVhZERlbGltaXRlclZhbHVlQmVmb3JlLFxuICAgICAgICB0eXBlcy53aGl0ZXNwYWNlXG4gICAgICApKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJWYWx1ZUJlZm9yZShjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEJlZm9yZSBkZWxpbWl0ZXIgY2VsbCB2YWx1ZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8IHwgYSB8XG4gICAqID4gfCB8IC0gfFxuICAgKiAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkRGVsaW1pdGVyVmFsdWVCZWZvcmUoY29kZSkge1xuICAgIC8vIEFsaWduOiBsZWZ0LlxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5jb2xvbikge1xuICAgICAgc2l6ZUIgKz0gMVxuICAgICAgc2VlbiA9IHRydWVcblxuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVEZWxpbWl0ZXJNYXJrZXInKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlRGVsaW1pdGVyTWFya2VyJylcbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyTGVmdEFsaWdubWVudEFmdGVyXG4gICAgfVxuXG4gICAgLy8gQWxpZ246IG5vbmUuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmRhc2gpIHtcbiAgICAgIHNpemVCICs9IDFcbiAgICAgIC8vIFRvIGRvOiBzZWVtcyB3ZWlyZCB0aGF0IHRoaXMgKmlzbuKAmXQqIGxlZnQgYWxpZ25lZCwgYnV0IHRoYXQgc3RhdGUgaXMgdXNlZD9cbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyTGVmdEFsaWdubWVudEFmdGVyKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmVvZiB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyQ2VsbEFmdGVyKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJOb2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBkZWxpbWl0ZXIgY2VsbCBsZWZ0IGFsaWdubWVudCBtYXJrZXIuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCB8IGEgIHxcbiAgICogPiB8IHwgOi0gfFxuICAgKiAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZERlbGltaXRlckxlZnRBbGlnbm1lbnRBZnRlcihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmRhc2gpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlRGVsaW1pdGVyRmlsbGVyJylcbiAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyRmlsbGVyKGNvZGUpXG4gICAgfVxuXG4gICAgLy8gQW55dGhpbmcgZWxzZSBpcyBub3Qgb2sgYWZ0ZXIgdGhlIGxlZnQtYWxpZ24gY29sb24uXG4gICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJOb2soY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBkZWxpbWl0ZXIgY2VsbCBmaWxsZXIuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCB8IGEgfFxuICAgKiA+IHwgfCAtIHxcbiAgICogICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZERlbGltaXRlckZpbGxlcihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmRhc2gpIHtcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgcmV0dXJuIGhlYWREZWxpbWl0ZXJGaWxsZXJcbiAgICB9XG5cbiAgICAvLyBBbGlnbiBpcyBgY2VudGVyYCBpZiBpdCB3YXMgYGxlZnRgLCBgcmlnaHRgIG90aGVyd2lzZS5cbiAgICBpZiAoY29kZSA9PT0gY29kZXMuY29sb24pIHtcbiAgICAgIHNlZW4gPSB0cnVlXG4gICAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlRGVsaW1pdGVyRmlsbGVyJylcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlRGVsaW1pdGVyTWFya2VyJylcbiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZURlbGltaXRlck1hcmtlcicpXG4gICAgICByZXR1cm4gaGVhZERlbGltaXRlclJpZ2h0QWxpZ25tZW50QWZ0ZXJcbiAgICB9XG5cbiAgICBlZmZlY3RzLmV4aXQoJ3RhYmxlRGVsaW1pdGVyRmlsbGVyJylcbiAgICByZXR1cm4gaGVhZERlbGltaXRlclJpZ2h0QWxpZ25tZW50QWZ0ZXIoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBkZWxpbWl0ZXIgY2VsbCByaWdodCBhbGlnbm1lbnQgbWFya2VyLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCAgYSB8XG4gICAqID4gfCB8IC06IHxcbiAgICogICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBoZWFkRGVsaW1pdGVyUmlnaHRBbGlnbm1lbnRBZnRlcihjb2RlKSB7XG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoXG4gICAgICAgIGVmZmVjdHMsXG4gICAgICAgIGhlYWREZWxpbWl0ZXJDZWxsQWZ0ZXIsXG4gICAgICAgIHR5cGVzLndoaXRlc3BhY2VcbiAgICAgICkoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZERlbGltaXRlckNlbGxBZnRlcihjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIGRlbGltaXRlciBjZWxsLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCAgYSB8XG4gICAqID4gfCB8IC06IHxcbiAgICogICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZERlbGltaXRlckNlbGxBZnRlcihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLnZlcnRpY2FsQmFyKSB7XG4gICAgICByZXR1cm4gaGVhZERlbGltaXRlckJlZm9yZShjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5lb2YgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUpKSB7XG4gICAgICAvLyBFeGl0IHdoZW46XG4gICAgICAvLyAqIHRoZXJlIHdhcyBubyBgOmAgb3IgYHxgIGF0IGFsbCAoaXTigJlzIGEgdGhlbWF0aWMgYnJlYWsgb3Igc2V0ZXh0XG4gICAgICAvLyAgIHVuZGVybGluZSBpbnN0ZWFkKVxuICAgICAgLy8gKiB0aGUgaGVhZGVyIGNlbGwgY291bnQgaXMgbm90IHRoZSBkZWxpbWl0ZXIgY2VsbCBjb3VudFxuICAgICAgaWYgKCFzZWVuIHx8IHNpemUgIT09IHNpemVCKSB7XG4gICAgICAgIHJldHVybiBoZWFkRGVsaW1pdGVyTm9rKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIC8vIE5vdGU6IGluIG1hcmtkb3duLXJzYCwgYSByZXNldCBpcyBuZWVkZWQgaGVyZS5cbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVEZWxpbWl0ZXJSb3cnKVxuICAgICAgZWZmZWN0cy5leGl0KCd0YWJsZUhlYWQnKVxuICAgICAgLy8gVG8gZG86IGluIGBtYXJrZG93bi1yc2AsIHJlc29sdmVycyBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgbWFudWFsbHkuXG4gICAgICAvLyBlZmZlY3RzLnJlZ2lzdGVyX3Jlc29sdmVyKFJlc29sdmVOYW1lOjpHZm1UYWJsZSlcbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH1cblxuICAgIHJldHVybiBoZWFkRGVsaW1pdGVyTm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogSW4gZGVsaW1pdGVyIHJvdywgYXQgYSBkaXNhbGxvd2VkIGJ5dGUuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCB8IGEgfFxuICAgKiA+IHwgfCB4IHxcbiAgICogICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gaGVhZERlbGltaXRlck5vayhjb2RlKSB7XG4gICAgLy8gTm90ZTogaW4gYG1hcmtkb3duLXJzYCwgd2UgbmVlZCB0byByZXNldCwgaW4gYG1pY3JvbWFyay1qc2Agd2UgZG9u4oCYdC5cbiAgICByZXR1cm4gbm9rKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQmVmb3JlIHRhYmxlIGJvZHkgcm93LlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCBhIHxcbiAgICogICB8IHwgLSB8XG4gICAqID4gfCB8IGIgfFxuICAgKiAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gYm9keVJvd1N0YXJ0KGNvZGUpIHtcbiAgICAvLyBOb3RlOiBpbiBgbWFya2Rvd24tcnNgIHdlIG5lZWQgdG8gbWFudWFsbHkgdGFrZSBjYXJlIG9mIGEgcHJlZml4LFxuICAgIC8vIGJ1dCBpbiBgbWljcm9tYXJrLWpzYCB0aGF0IGlzIGRvbmUgZm9yIHVzLCBzbyBpZiB3ZeKAmXJlIGhlcmUsIHdl4oCZcmVcbiAgICAvLyBuZXZlciBhdCB3aGl0ZXNwYWNlLlxuICAgIGVmZmVjdHMuZW50ZXIoJ3RhYmxlUm93JylcbiAgICByZXR1cm4gYm9keVJvd0JyZWFrKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQXQgYnJlYWsgaW4gdGFibGUgYm9keSByb3cuXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqICAgfCB8IGEgfFxuICAgKiAgIHwgfCAtIHxcbiAgICogPiB8IHwgYiB8XG4gICAqICAgICBeXG4gICAqICAgICAgIF5cbiAgICogICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBib2R5Um93QnJlYWsoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhcikge1xuICAgICAgZWZmZWN0cy5lbnRlcigndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVDZWxsRGl2aWRlcicpXG4gICAgICByZXR1cm4gYm9keVJvd0JyZWFrXG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmVvZiB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFibGVSb3cnKVxuICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgfVxuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgYm9keVJvd0JyZWFrLCB0eXBlcy53aGl0ZXNwYWNlKShjb2RlKVxuICAgIH1cblxuICAgIC8vIEFueXRoaW5nIGVsc2UgaXMgY2VsbCBjb250ZW50LlxuICAgIGVmZmVjdHMuZW50ZXIodHlwZXMuZGF0YSlcbiAgICByZXR1cm4gYm9keVJvd0RhdGEoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiB0YWJsZSBib2R5IHJvdyBkYXRhLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgfCBhIHxcbiAgICogICB8IHwgLSB8XG4gICAqID4gfCB8IGIgfFxuICAgKiAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBib2R5Um93RGF0YShjb2RlKSB7XG4gICAgaWYgKFxuICAgICAgY29kZSA9PT0gY29kZXMuZW9mIHx8XG4gICAgICBjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhciB8fFxuICAgICAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZShjb2RlKVxuICAgICkge1xuICAgICAgZWZmZWN0cy5leGl0KHR5cGVzLmRhdGEpXG4gICAgICByZXR1cm4gYm9keVJvd0JyZWFrKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIGNvZGUgPT09IGNvZGVzLmJhY2tzbGFzaCA/IGJvZHlSb3dFc2NhcGUgOiBib2R5Um93RGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHRhYmxlIGJvZHkgcm93IGVzY2FwZS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8IHwgYSAgICB8XG4gICAqICAgfCB8IC0tLS0gfFxuICAgKiA+IHwgfCBiXFwtYyB8XG4gICAqICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gYm9keVJvd0VzY2FwZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmJhY2tzbGFzaCB8fCBjb2RlID09PSBjb2Rlcy52ZXJ0aWNhbEJhcikge1xuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gYm9keVJvd0RhdGFcbiAgICB9XG5cbiAgICByZXR1cm4gYm9keVJvd0RhdGEoY29kZSlcbiAgfVxufVxuXG4vKiogQHR5cGUge1Jlc29sdmVyfSAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVGFibGUoZXZlbnRzLCBjb250ZXh0KSB7XG4gIGxldCBpbmRleCA9IC0xXG4gIGxldCBpbkZpcnN0Q2VsbEF3YWl0aW5nUGlwZSA9IHRydWVcbiAgLyoqIEB0eXBlIHtSb3dLaW5kfSAqL1xuICBsZXQgcm93S2luZCA9IDBcbiAgLyoqIEB0eXBlIHtSYW5nZX0gKi9cbiAgbGV0IGxhc3RDZWxsID0gWzAsIDAsIDAsIDBdXG4gIC8qKiBAdHlwZSB7UmFuZ2V9ICovXG4gIGxldCBjZWxsID0gWzAsIDAsIDAsIDBdXG4gIGxldCBhZnRlckhlYWRBd2FpdGluZ0ZpcnN0Qm9keVJvdyA9IGZhbHNlXG4gIGxldCBsYXN0VGFibGVFbmQgPSAwXG4gIC8qKiBAdHlwZSB7VG9rZW4gfCB1bmRlZmluZWR9ICovXG4gIGxldCBjdXJyZW50VGFibGVcbiAgLyoqIEB0eXBlIHtUb2tlbiB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IGN1cnJlbnRCb2R5XG4gIC8qKiBAdHlwZSB7VG9rZW4gfCB1bmRlZmluZWR9ICovXG4gIGxldCBjdXJyZW50Q2VsbFxuXG4gIGNvbnN0IG1hcCA9IG5ldyBFZGl0TWFwKClcblxuICB3aGlsZSAoKytpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICBjb25zdCBldmVudCA9IGV2ZW50c1tpbmRleF1cbiAgICBjb25zdCB0b2tlbiA9IGV2ZW50WzFdXG5cbiAgICBpZiAoZXZlbnRbMF0gPT09ICdlbnRlcicpIHtcbiAgICAgIC8vIFN0YXJ0IG9mIGhlYWQuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RhYmxlSGVhZCcpIHtcbiAgICAgICAgYWZ0ZXJIZWFkQXdhaXRpbmdGaXJzdEJvZHlSb3cgPSBmYWxzZVxuXG4gICAgICAgIC8vIEluamVjdCBwcmV2aW91cyAoYm9keSBlbmQgYW5kKSB0YWJsZSBlbmQuXG4gICAgICAgIGlmIChsYXN0VGFibGVFbmQgIT09IDApIHtcbiAgICAgICAgICBhc3NlcnQoY3VycmVudFRhYmxlLCAndGhlcmUgc2hvdWxkIGJlIGEgdGFibGUgb3BlbmluZycpXG4gICAgICAgICAgZmx1c2hUYWJsZUVuZChtYXAsIGNvbnRleHQsIGxhc3RUYWJsZUVuZCwgY3VycmVudFRhYmxlLCBjdXJyZW50Qm9keSlcbiAgICAgICAgICBjdXJyZW50Qm9keSA9IHVuZGVmaW5lZFxuICAgICAgICAgIGxhc3RUYWJsZUVuZCA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluamVjdCB0YWJsZSBzdGFydC5cbiAgICAgICAgY3VycmVudFRhYmxlID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIHRva2VuLnN0YXJ0KSxcbiAgICAgICAgICAvLyBOb3RlOiBjb3JyZWN0IGVuZCBpcyBzZXQgbGF0ZXIuXG4gICAgICAgICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCB0b2tlbi5lbmQpXG4gICAgICAgIH1cbiAgICAgICAgbWFwLmFkZChpbmRleCwgMCwgW1snZW50ZXInLCBjdXJyZW50VGFibGUsIGNvbnRleHRdXSlcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHRva2VuLnR5cGUgPT09ICd0YWJsZVJvdycgfHxcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyUm93J1xuICAgICAgKSB7XG4gICAgICAgIGluRmlyc3RDZWxsQXdhaXRpbmdQaXBlID0gdHJ1ZVxuICAgICAgICBjdXJyZW50Q2VsbCA9IHVuZGVmaW5lZFxuICAgICAgICBsYXN0Q2VsbCA9IFswLCAwLCAwLCAwXVxuICAgICAgICBjZWxsID0gWzAsIGluZGV4ICsgMSwgMCwgMF1cblxuICAgICAgICAvLyBJbmplY3QgdGFibGUgYm9keSBzdGFydC5cbiAgICAgICAgaWYgKGFmdGVySGVhZEF3YWl0aW5nRmlyc3RCb2R5Um93KSB7XG4gICAgICAgICAgYWZ0ZXJIZWFkQXdhaXRpbmdGaXJzdEJvZHlSb3cgPSBmYWxzZVxuICAgICAgICAgIGN1cnJlbnRCb2R5ID0ge1xuICAgICAgICAgICAgdHlwZTogJ3RhYmxlQm9keScsXG4gICAgICAgICAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgdG9rZW4uc3RhcnQpLFxuICAgICAgICAgICAgLy8gTm90ZTogY29ycmVjdCBlbmQgaXMgc2V0IGxhdGVyLlxuICAgICAgICAgICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCB0b2tlbi5lbmQpXG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcC5hZGQoaW5kZXgsIDAsIFtbJ2VudGVyJywgY3VycmVudEJvZHksIGNvbnRleHRdXSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJvd0tpbmQgPSB0b2tlbi50eXBlID09PSAndGFibGVEZWxpbWl0ZXJSb3cnID8gMiA6IGN1cnJlbnRCb2R5ID8gMyA6IDFcbiAgICAgIH1cbiAgICAgIC8vIENlbGwgZGF0YS5cbiAgICAgIGVsc2UgaWYgKFxuICAgICAgICByb3dLaW5kICYmXG4gICAgICAgICh0b2tlbi50eXBlID09PSB0eXBlcy5kYXRhIHx8XG4gICAgICAgICAgdG9rZW4udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyTWFya2VyJyB8fFxuICAgICAgICAgIHRva2VuLnR5cGUgPT09ICd0YWJsZURlbGltaXRlckZpbGxlcicpXG4gICAgICApIHtcbiAgICAgICAgaW5GaXJzdENlbGxBd2FpdGluZ1BpcGUgPSBmYWxzZVxuXG4gICAgICAgIC8vIEZpcnN0IHZhbHVlIGluIGNlbGwuXG4gICAgICAgIGlmIChjZWxsWzJdID09PSAwKSB7XG4gICAgICAgICAgaWYgKGxhc3RDZWxsWzFdICE9PSAwKSB7XG4gICAgICAgICAgICBjZWxsWzBdID0gY2VsbFsxXVxuICAgICAgICAgICAgY3VycmVudENlbGwgPSBmbHVzaENlbGwoXG4gICAgICAgICAgICAgIG1hcCxcbiAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgbGFzdENlbGwsXG4gICAgICAgICAgICAgIHJvd0tpbmQsXG4gICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgY3VycmVudENlbGxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGxhc3RDZWxsID0gWzAsIDAsIDAsIDBdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2VsbFsyXSA9IGluZGV4XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gJ3RhYmxlQ2VsbERpdmlkZXInKSB7XG4gICAgICAgIGlmIChpbkZpcnN0Q2VsbEF3YWl0aW5nUGlwZSkge1xuICAgICAgICAgIGluRmlyc3RDZWxsQXdhaXRpbmdQaXBlID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobGFzdENlbGxbMV0gIT09IDApIHtcbiAgICAgICAgICAgIGNlbGxbMF0gPSBjZWxsWzFdXG4gICAgICAgICAgICBjdXJyZW50Q2VsbCA9IGZsdXNoQ2VsbChcbiAgICAgICAgICAgICAgbWFwLFxuICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICBsYXN0Q2VsbCxcbiAgICAgICAgICAgICAgcm93S2luZCxcbiAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBjdXJyZW50Q2VsbFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxhc3RDZWxsID0gY2VsbFxuICAgICAgICAgIGNlbGwgPSBbbGFzdENlbGxbMV0sIGluZGV4LCAwLCAwXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEV4aXQgZXZlbnRzLlxuICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICd0YWJsZUhlYWQnKSB7XG4gICAgICBhZnRlckhlYWRBd2FpdGluZ0ZpcnN0Qm9keVJvdyA9IHRydWVcbiAgICAgIGxhc3RUYWJsZUVuZCA9IGluZGV4XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRva2VuLnR5cGUgPT09ICd0YWJsZVJvdycgfHxcbiAgICAgIHRva2VuLnR5cGUgPT09ICd0YWJsZURlbGltaXRlclJvdydcbiAgICApIHtcbiAgICAgIGxhc3RUYWJsZUVuZCA9IGluZGV4XG5cbiAgICAgIGlmIChsYXN0Q2VsbFsxXSAhPT0gMCkge1xuICAgICAgICBjZWxsWzBdID0gY2VsbFsxXVxuICAgICAgICBjdXJyZW50Q2VsbCA9IGZsdXNoQ2VsbChcbiAgICAgICAgICBtYXAsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBsYXN0Q2VsbCxcbiAgICAgICAgICByb3dLaW5kLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIGN1cnJlbnRDZWxsXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAoY2VsbFsxXSAhPT0gMCkge1xuICAgICAgICBjdXJyZW50Q2VsbCA9IGZsdXNoQ2VsbChtYXAsIGNvbnRleHQsIGNlbGwsIHJvd0tpbmQsIGluZGV4LCBjdXJyZW50Q2VsbClcbiAgICAgIH1cblxuICAgICAgcm93S2luZCA9IDBcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgcm93S2luZCAmJlxuICAgICAgKHRva2VuLnR5cGUgPT09IHR5cGVzLmRhdGEgfHxcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ3RhYmxlRGVsaW1pdGVyTWFya2VyJyB8fFxuICAgICAgICB0b2tlbi50eXBlID09PSAndGFibGVEZWxpbWl0ZXJGaWxsZXInKVxuICAgICkge1xuICAgICAgY2VsbFszXSA9IGluZGV4XG4gICAgfVxuICB9XG5cbiAgaWYgKGxhc3RUYWJsZUVuZCAhPT0gMCkge1xuICAgIGFzc2VydChjdXJyZW50VGFibGUsICdleHBlY3RlZCB0YWJsZSBvcGVuaW5nJylcbiAgICBmbHVzaFRhYmxlRW5kKG1hcCwgY29udGV4dCwgbGFzdFRhYmxlRW5kLCBjdXJyZW50VGFibGUsIGN1cnJlbnRCb2R5KVxuICB9XG5cbiAgbWFwLmNvbnN1bWUoY29udGV4dC5ldmVudHMpXG5cbiAgLy8gVG8gZG86IG1vdmUgdGhpcyBpbnRvIGBodG1sYCwgd2hlbiBldmVudHMgYXJlIGV4cG9zZWQgdGhlcmUuXG4gIC8vIFRoYXTigJlzIHdoYXQgYG1hcmtkb3duLXJzYCBkb2VzLlxuICAvLyBUaGF0IG5lZWRzIHVwZGF0ZXMgdG8gYG1kYXN0LXV0aWwtZ2ZtLXRhYmxlYC5cbiAgaW5kZXggPSAtMVxuICB3aGlsZSAoKytpbmRleCA8IGNvbnRleHQuZXZlbnRzLmxlbmd0aCkge1xuICAgIGNvbnN0IGV2ZW50ID0gY29udGV4dC5ldmVudHNbaW5kZXhdXG4gICAgaWYgKGV2ZW50WzBdID09PSAnZW50ZXInICYmIGV2ZW50WzFdLnR5cGUgPT09ICd0YWJsZScpIHtcbiAgICAgIGV2ZW50WzFdLl9hbGlnbiA9IGdmbVRhYmxlQWxpZ24oY29udGV4dC5ldmVudHMsIGluZGV4KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBldmVudHNcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGNlbGwuXG4gKlxuICogQHBhcmFtIHtFZGl0TWFwfSBtYXBcbiAqIEBwYXJhbSB7UmVhZG9ubHk8VG9rZW5pemVDb250ZXh0Pn0gY29udGV4dFxuICogQHBhcmFtIHtSZWFkb25seTxSYW5nZT59IHJhbmdlXG4gKiBAcGFyYW0ge1Jvd0tpbmR9IHJvd0tpbmRcbiAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSByb3dFbmRcbiAqIEBwYXJhbSB7VG9rZW4gfCB1bmRlZmluZWR9IHByZXZpb3VzQ2VsbFxuICogQHJldHVybnMge1Rva2VuIHwgdW5kZWZpbmVkfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuZnVuY3Rpb24gZmx1c2hDZWxsKG1hcCwgY29udGV4dCwgcmFuZ2UsIHJvd0tpbmQsIHJvd0VuZCwgcHJldmlvdXNDZWxsKSB7XG4gIC8vIGBtYXJrZG93bi1yc2AgdXNlczpcbiAgLy8gcm93S2luZCA9PT0gMiA/ICd0YWJsZURlbGltaXRlckNlbGwnIDogJ3RhYmxlQ2VsbCdcbiAgY29uc3QgZ3JvdXBOYW1lID1cbiAgICByb3dLaW5kID09PSAxXG4gICAgICA/ICd0YWJsZUhlYWRlcidcbiAgICAgIDogcm93S2luZCA9PT0gMlxuICAgICAgICA/ICd0YWJsZURlbGltaXRlcidcbiAgICAgICAgOiAndGFibGVEYXRhJ1xuICAvLyBgbWFya2Rvd24tcnNgIHVzZXM6XG4gIC8vIHJvd0tpbmQgPT09IDIgPyAndGFibGVEZWxpbWl0ZXJDZWxsVmFsdWUnIDogJ3RhYmxlQ2VsbFRleHQnXG4gIGNvbnN0IHZhbHVlTmFtZSA9ICd0YWJsZUNvbnRlbnQnXG5cbiAgLy8gSW5zZXJ0IGFuIGV4aXQgZm9yIHRoZSBwcmV2aW91cyBjZWxsLCBpZiB0aGVyZSBpcyBvbmUuXG4gIC8vXG4gIC8vIGBgYG1hcmtkb3duXG4gIC8vID4gfCB8IGFhIHwgYmIgfCBjYyB8XG4gIC8vICAgICAgICAgIF4tLSBleGl0XG4gIC8vICAgICAgICAgICBeXl5eLS0gdGhpcyBjZWxsXG4gIC8vIGBgYFxuICBpZiAocmFuZ2VbMF0gIT09IDApIHtcbiAgICBhc3NlcnQocHJldmlvdXNDZWxsLCAnZXhwZWN0ZWQgcHJldmlvdXMgY2VsbCBlbnRlcicpXG4gICAgcHJldmlvdXNDZWxsLmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIGdldFBvaW50KGNvbnRleHQuZXZlbnRzLCByYW5nZVswXSkpXG4gICAgbWFwLmFkZChyYW5nZVswXSwgMCwgW1snZXhpdCcsIHByZXZpb3VzQ2VsbCwgY29udGV4dF1dKVxuICB9XG5cbiAgLy8gSW5zZXJ0IGVudGVyIG9mIHRoaXMgY2VsbC5cbiAgLy9cbiAgLy8gYGBgbWFya2Rvd25cbiAgLy8gPiB8IHwgYWEgfCBiYiB8IGNjIHxcbiAgLy8gICAgICAgICAgIF4tLSBlbnRlclxuICAvLyAgICAgICAgICAgXl5eXi0tIHRoaXMgY2VsbFxuICAvLyBgYGBcbiAgY29uc3Qgbm93ID0gZ2V0UG9pbnQoY29udGV4dC5ldmVudHMsIHJhbmdlWzFdKVxuICBwcmV2aW91c0NlbGwgPSB7XG4gICAgdHlwZTogZ3JvdXBOYW1lLFxuICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBub3cpLFxuICAgIC8vIE5vdGU6IGNvcnJlY3QgZW5kIGlzIHNldCBsYXRlci5cbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIG5vdylcbiAgfVxuICBtYXAuYWRkKHJhbmdlWzFdLCAwLCBbWydlbnRlcicsIHByZXZpb3VzQ2VsbCwgY29udGV4dF1dKVxuXG4gIC8vIEluc2VydCB0ZXh0IHN0YXJ0IGF0IGZpcnN0IGRhdGEgc3RhcnQgYW5kIGVuZCBhdCBsYXN0IGRhdGEgZW5kLCBhbmRcbiAgLy8gcmVtb3ZlIGV2ZW50cyBiZXR3ZWVuLlxuICAvL1xuICAvLyBgYGBtYXJrZG93blxuICAvLyA+IHwgfCBhYSB8IGJiIHwgY2MgfFxuICAvLyAgICAgICAgICAgIF4tLSBlbnRlclxuICAvLyAgICAgICAgICAgICBeLS0gZXhpdFxuICAvLyAgICAgICAgICAgXl5eXi0tIHRoaXMgY2VsbFxuICAvLyBgYGBcbiAgaWYgKHJhbmdlWzJdICE9PSAwKSB7XG4gICAgY29uc3QgcmVsYXRlZFN0YXJ0ID0gZ2V0UG9pbnQoY29udGV4dC5ldmVudHMsIHJhbmdlWzJdKVxuICAgIGNvbnN0IHJlbGF0ZWRFbmQgPSBnZXRQb2ludChjb250ZXh0LmV2ZW50cywgcmFuZ2VbM10pXG4gICAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cbiAgICBjb25zdCB2YWx1ZVRva2VuID0ge1xuICAgICAgdHlwZTogdmFsdWVOYW1lLFxuICAgICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIHJlbGF0ZWRTdGFydCksXG4gICAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIHJlbGF0ZWRFbmQpXG4gICAgfVxuICAgIG1hcC5hZGQocmFuZ2VbMl0sIDAsIFtbJ2VudGVyJywgdmFsdWVUb2tlbiwgY29udGV4dF1dKVxuICAgIGFzc2VydChyYW5nZVszXSAhPT0gMClcblxuICAgIGlmIChyb3dLaW5kICE9PSAyKSB7XG4gICAgICAvLyBGaXggcG9zaXRpb25hbCBpbmZvIG9uIHJlbWFpbmluZyBldmVudHNcbiAgICAgIGNvbnN0IHN0YXJ0ID0gY29udGV4dC5ldmVudHNbcmFuZ2VbMl1dXG4gICAgICBjb25zdCBlbmQgPSBjb250ZXh0LmV2ZW50c1tyYW5nZVszXV1cbiAgICAgIHN0YXJ0WzFdLmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIGVuZFsxXS5lbmQpXG4gICAgICBzdGFydFsxXS50eXBlID0gdHlwZXMuY2h1bmtUZXh0XG4gICAgICBzdGFydFsxXS5jb250ZW50VHlwZSA9IGNvbnN0YW50cy5jb250ZW50VHlwZVRleHRcblxuICAgICAgLy8gUmVtb3ZlIGlmIG5lZWRlZC5cbiAgICAgIGlmIChyYW5nZVszXSA+IHJhbmdlWzJdICsgMSkge1xuICAgICAgICBjb25zdCBhID0gcmFuZ2VbMl0gKyAxXG4gICAgICAgIGNvbnN0IGIgPSByYW5nZVszXSAtIHJhbmdlWzJdIC0gMVxuICAgICAgICBtYXAuYWRkKGEsIGIsIFtdKVxuICAgICAgfVxuICAgIH1cblxuICAgIG1hcC5hZGQocmFuZ2VbM10gKyAxLCAwLCBbWydleGl0JywgdmFsdWVUb2tlbiwgY29udGV4dF1dKVxuICB9XG5cbiAgLy8gSW5zZXJ0IGFuIGV4aXQgZm9yIHRoZSBsYXN0IGNlbGwsIGlmIGF0IHRoZSByb3cgZW5kLlxuICAvL1xuICAvLyBgYGBtYXJrZG93blxuICAvLyA+IHwgfCBhYSB8IGJiIHwgY2MgfFxuICAvLyAgICAgICAgICAgICAgICAgICAgXi0tIGV4aXRcbiAgLy8gICAgICAgICAgICAgICBeXl5eXl4tLSB0aGlzIGNlbGwgKHRoZSBsYXN0IG9uZSBjb250YWlucyB0d28g4oCcYmV0d2VlbuKAnSBwYXJ0cylcbiAgLy8gYGBgXG4gIGlmIChyb3dFbmQgIT09IHVuZGVmaW5lZCkge1xuICAgIHByZXZpb3VzQ2VsbC5lbmQgPSBPYmplY3QuYXNzaWduKHt9LCBnZXRQb2ludChjb250ZXh0LmV2ZW50cywgcm93RW5kKSlcbiAgICBtYXAuYWRkKHJvd0VuZCwgMCwgW1snZXhpdCcsIHByZXZpb3VzQ2VsbCwgY29udGV4dF1dKVxuICAgIHByZXZpb3VzQ2VsbCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgcmV0dXJuIHByZXZpb3VzQ2VsbFxufVxuXG4vKipcbiAqIEdlbmVyYXRlIHRhYmxlIGVuZCAoYW5kIHRhYmxlIGJvZHkgZW5kKS5cbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5PEVkaXRNYXA+fSBtYXBcbiAqIEBwYXJhbSB7UmVhZG9ubHk8VG9rZW5pemVDb250ZXh0Pn0gY29udGV4dFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge1Rva2VufSB0YWJsZVxuICogQHBhcmFtIHtUb2tlbiB8IHVuZGVmaW5lZH0gdGFibGVCb2R5XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG5mdW5jdGlvbiBmbHVzaFRhYmxlRW5kKG1hcCwgY29udGV4dCwgaW5kZXgsIHRhYmxlLCB0YWJsZUJvZHkpIHtcbiAgLyoqIEB0eXBlIHtBcnJheTxFdmVudD59ICovXG4gIGNvbnN0IGV4aXRzID0gW11cbiAgY29uc3QgcmVsYXRlZCA9IGdldFBvaW50KGNvbnRleHQuZXZlbnRzLCBpbmRleClcblxuICBpZiAodGFibGVCb2R5KSB7XG4gICAgdGFibGVCb2R5LmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIHJlbGF0ZWQpXG4gICAgZXhpdHMucHVzaChbJ2V4aXQnLCB0YWJsZUJvZHksIGNvbnRleHRdKVxuICB9XG5cbiAgdGFibGUuZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgcmVsYXRlZClcbiAgZXhpdHMucHVzaChbJ2V4aXQnLCB0YWJsZSwgY29udGV4dF0pXG5cbiAgbWFwLmFkZChpbmRleCArIDEsIDAsIGV4aXRzKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhZG9ubHk8QXJyYXk8RXZlbnQ+Pn0gZXZlbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm5zIHtSZWFkb25seTxQb2ludD59XG4gKi9cbmZ1bmN0aW9uIGdldFBvaW50KGV2ZW50cywgaW5kZXgpIHtcbiAgY29uc3QgZXZlbnQgPSBldmVudHNbaW5kZXhdXG4gIGNvbnN0IHNpZGUgPSBldmVudFswXSA9PT0gJ2VudGVyJyA/ICdzdGFydCcgOiAnZW5kJ1xuICByZXR1cm4gZXZlbnRbMV1bc2lkZV1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/micromark-extension-gfm-table/dev/lib/syntax.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/micromark-extension-gfm-tagfilter/lib/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-tagfilter/lib/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTagfilterHtml: () => (/* binding */ gfmTagfilterHtml)\n/* harmony export */ });\n/**\n * @typedef {import('micromark-util-types').CompileContext} CompileContext\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n// An opening or closing tag start, followed by a case-insensitive specific tag name,\n// followed by HTML whitespace, a greater than, or a slash.\nconst reFlow =\n  /<(\\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\\t\\n\\f\\r />])/gi\n\n// As HTML (text) parses tags separately (and very strictly), we dont need to be\n// global.\nconst reText = new RegExp('^' + reFlow.source, 'i')\n\n/**\n * Create an HTML extension for `micromark` to support GitHubs weird and\n * useless tagfilter when serializing to HTML.\n *\n * @returns {HtmlExtension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to support\n *   GitHubs weird and useless tagfilter when serializing to HTML.\n */\nfunction gfmTagfilterHtml() {\n  return {\n    exit: {\n      htmlFlowData(token) {\n        exitHtmlData.call(this, token, reFlow)\n      },\n      htmlTextData(token) {\n        exitHtmlData.call(this, token, reText)\n      }\n    }\n  }\n}\n\n/**\n * @this {CompileContext}\n * @param {Token} token\n * @param {RegExp} filter\n * @returns {undefined}\n */\nfunction exitHtmlData(token, filter) {\n  let value = this.sliceSerialize(token)\n\n  if (this.options.allowDangerousHtml) {\n    value = value.replace(filter, '&lt;$1$2')\n  }\n\n  this.raw(this.encode(value))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWdmaWx0ZXIvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBLGFBQWEsK0NBQStDO0FBQzVELGFBQWEsOENBQThDO0FBQzNELGFBQWEsc0NBQXNDO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFnZmlsdGVyL2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuQ29tcGlsZUNvbnRleHR9IENvbXBpbGVDb250ZXh0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkh0bWxFeHRlbnNpb259IEh0bWxFeHRlbnNpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay11dGlsLXR5cGVzJykuVG9rZW59IFRva2VuXG4gKi9cblxuLy8gQW4gb3BlbmluZyBvciBjbG9zaW5nIHRhZyBzdGFydCwgZm9sbG93ZWQgYnkgYSBjYXNlLWluc2Vuc2l0aXZlIHNwZWNpZmljIHRhZyBuYW1lLFxuLy8gZm9sbG93ZWQgYnkgSFRNTCB3aGl0ZXNwYWNlLCBhIGdyZWF0ZXIgdGhhbiwgb3IgYSBzbGFzaC5cbmNvbnN0IHJlRmxvdyA9XG4gIC88KFxcLz8pKGlmcmFtZXxub2VtYmVkfG5vZnJhbWVzfHBsYWludGV4dHxzY3JpcHR8c3R5bGV8dGl0bGV8dGV4dGFyZWF8eG1wKSg/PVtcXHRcXG5cXGZcXHIgLz5dKS9naVxuXG4vLyBBcyBIVE1MICh0ZXh0KSBwYXJzZXMgdGFncyBzZXBhcmF0ZWx5IChhbmQgdmVyeSBzdHJpY3RseSksIHdlIGRvbuKAmXQgbmVlZCB0byBiZVxuLy8gZ2xvYmFsLlxuY29uc3QgcmVUZXh0ID0gbmV3IFJlZ0V4cCgnXicgKyByZUZsb3cuc291cmNlLCAnaScpXG5cbi8qKlxuICogQ3JlYXRlIGFuIEhUTUwgZXh0ZW5zaW9uIGZvciBgbWljcm9tYXJrYCB0byBzdXBwb3J0IEdpdEh1YnMgd2VpcmQgYW5kXG4gKiB1c2VsZXNzIHRhZ2ZpbHRlciB3aGVuIHNlcmlhbGl6aW5nIHRvIEhUTUwuXG4gKlxuICogQHJldHVybnMge0h0bWxFeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdGhhdCBjYW4gYmUgcGFzc2VkIGluIGBodG1sRXh0ZW5zaW9uc2AgdG8gc3VwcG9ydFxuICogICBHaXRIdWJzIHdlaXJkIGFuZCB1c2VsZXNzIHRhZ2ZpbHRlciB3aGVuIHNlcmlhbGl6aW5nIHRvIEhUTUwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZm1UYWdmaWx0ZXJIdG1sKCkge1xuICByZXR1cm4ge1xuICAgIGV4aXQ6IHtcbiAgICAgIGh0bWxGbG93RGF0YSh0b2tlbikge1xuICAgICAgICBleGl0SHRtbERhdGEuY2FsbCh0aGlzLCB0b2tlbiwgcmVGbG93KVxuICAgICAgfSxcbiAgICAgIGh0bWxUZXh0RGF0YSh0b2tlbikge1xuICAgICAgICBleGl0SHRtbERhdGEuY2FsbCh0aGlzLCB0b2tlbiwgcmVUZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gZmlsdGVyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBleGl0SHRtbERhdGEodG9rZW4sIGZpbHRlcikge1xuICBsZXQgdmFsdWUgPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuYWxsb3dEYW5nZXJvdXNIdG1sKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGZpbHRlciwgJyZsdDskMSQyJylcbiAgfVxuXG4gIHRoaXMucmF3KHRoaXMuZW5jb2RlKHZhbHVlKSlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/micromark-extension-gfm-tagfilter/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/micromark-extension-gfm-task-list-item/dev/lib/html.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-task-list-item/dev/lib/html.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTaskListItemHtml: () => (/* binding */ gfmTaskListItemHtml)\n/* harmony export */ });\n/**\n * @import {HtmlExtension} from 'micromark-util-types'\n */\n\n/**\n * Create an HTML extension for `micromark` to support GFM task list items when\n * serializing to HTML.\n *\n * @returns {HtmlExtension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GFM task list items when serializing to HTML.\n */\nfunction gfmTaskListItemHtml() {\n  return {\n    enter: {\n      taskListCheck() {\n        this.tag('<input type=\"checkbox\" disabled=\"\" ')\n      }\n    },\n    exit: {\n      taskListCheck() {\n        this.tag('/>')\n      },\n      taskListCheckValueChecked() {\n        this.tag('checked=\"\" ')\n      }\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YXNrLWxpc3QtaXRlbS9kZXYvbGliL2h0bWwuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YXNrLWxpc3QtaXRlbS9kZXYvbGliL2h0bWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtIdG1sRXh0ZW5zaW9ufSBmcm9tICdtaWNyb21hcmstdXRpbC10eXBlcydcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhbiBIVE1MIGV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdG8gc3VwcG9ydCBHRk0gdGFzayBsaXN0IGl0ZW1zIHdoZW5cbiAqIHNlcmlhbGl6aW5nIHRvIEhUTUwuXG4gKlxuICogQHJldHVybnMge0h0bWxFeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdGhhdCBjYW4gYmUgcGFzc2VkIGluIGBodG1sRXh0ZW5zaW9uc2AgdG9cbiAqICAgc3VwcG9ydCBHRk0gdGFzayBsaXN0IGl0ZW1zIHdoZW4gc2VyaWFsaXppbmcgdG8gSFRNTC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbVRhc2tMaXN0SXRlbUh0bWwoKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXI6IHtcbiAgICAgIHRhc2tMaXN0Q2hlY2soKSB7XG4gICAgICAgIHRoaXMudGFnKCc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgZGlzYWJsZWQ9XCJcIiAnKVxuICAgICAgfVxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgdGFza0xpc3RDaGVjaygpIHtcbiAgICAgICAgdGhpcy50YWcoJy8+JylcbiAgICAgIH0sXG4gICAgICB0YXNrTGlzdENoZWNrVmFsdWVDaGVja2VkKCkge1xuICAgICAgICB0aGlzLnRhZygnY2hlY2tlZD1cIlwiICcpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/micromark-extension-gfm-task-list-item/dev/lib/html.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/micromark-extension-gfm-task-list-item/dev/lib/syntax.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/micromark-extension-gfm-task-list-item/dev/lib/syntax.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTaskListItem: () => (/* binding */ gfmTaskListItem)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devlop */ \"(app-pages-browser)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-factory-space */ \"(app-pages-browser)/./node_modules/micromark-factory-space/dev/index.js\");\n/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-character */ \"(app-pages-browser)/./node_modules/micromark-util-character/dev/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/types.js\");\n/**\n * @import {Extension, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\n\n\n\n\n\nconst tasklistCheck = {name: 'tasklistCheck', tokenize: tokenizeTasklistCheck}\n\n/**\n * Create an HTML extension for `micromark` to support GFM task list items\n * syntax.\n *\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GFM task list items when serializing to HTML.\n */\nfunction gfmTaskListItem() {\n  return {\n    text: {[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket]: tasklistCheck}\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this\n\n  return open\n\n  /**\n   * At start of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.leftSquareBracket, 'expected `[`')\n\n    if (\n      // Exit if theres stuff before.\n      self.previous !== micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof ||\n      // Exit if not in the first content that is the first child of a list\n      // item.\n      !self._gfmTasklistFirstContentOfListItem\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('taskListCheck')\n    effects.enter('taskListCheckMarker')\n    effects.consume(code)\n    effects.exit('taskListCheckMarker')\n    return inside\n  }\n\n  /**\n   * In task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    // Currently we match how GH works in files.\n    // To match how GH works in comments, use `markdownSpace` (`[\\t ]`) instead\n    // of `markdownLineEndingOrSpace` (`[\\t\\n\\r ]`).\n    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownLineEndingOrSpace)(code)) {\n      effects.enter('taskListCheckValueUnchecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueUnchecked')\n      return close\n    }\n\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.uppercaseX || code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.lowercaseX) {\n      effects.enter('taskListCheckValueChecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueChecked')\n      return close\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * At close of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function close(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.rightSquareBracket) {\n      effects.enter('taskListCheckMarker')\n      effects.consume(code)\n      effects.exit('taskListCheckMarker')\n      effects.exit('taskListCheck')\n      return after\n    }\n\n    return nok(code)\n  }\n\n  /**\n   * @type {State}\n   */\n  function after(code) {\n    // EOL in paragraph means there must be something else after it.\n    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownLineEnding)(code)) {\n      return ok(code)\n    }\n\n    // Space or tab?\n    // Check what comes after.\n    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownSpace)(code)) {\n      return effects.check({tokenize: spaceThenNonSpace}, ok, nok)(code)\n    }\n\n    // EOF, or non-whitespace, both wrong.\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction spaceThenNonSpace(effects, ok, nok) {\n  return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__.factorySpace)(effects, after, micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.types.whitespace)\n\n  /**\n   * After whitespace, after task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // EOF means there was nothing, so bad.\n    // EOL means theres content after it, so good.\n    // Impossible to have more spaces.\n    // Anything else is good.\n    return code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.eof ? nok(code) : ok(code)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YXNrLWxpc3QtaXRlbS9kZXYvbGliL3N5bnRheC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBLFlBQVksOENBQThDO0FBQzFEOztBQUVtQztBQUNpQjtBQUtuQjtBQUNpQjs7QUFFbEQsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsV0FBVyxDQUFDLHdEQUFLO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxJQUFJLDJDQUFNLFVBQVUsd0RBQUs7O0FBRXpCO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1GQUF5QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix3REFBSyx3QkFBd0Isd0RBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGlCQUFpQix3REFBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRFQUFrQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLHVFQUFhO0FBQ3JCLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQSxTQUFTLHFFQUFZLGlCQUFpQix3REFBSzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0RBQUs7QUFDekI7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFzay1saXN0LWl0ZW0vZGV2L2xpYi9zeW50YXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtFeHRlbnNpb24sIFN0YXRlLCBUb2tlbml6ZUNvbnRleHQsIFRva2VuaXplcn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtdHlwZXMnXG4gKi9cblxuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ2RldmxvcCdcbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7XG4gIG1hcmtkb3duTGluZUVuZGluZyxcbiAgbWFya2Rvd25MaW5lRW5kaW5nT3JTcGFjZSxcbiAgbWFya2Rvd25TcGFjZVxufSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5pbXBvcnQge2NvZGVzLCB0eXBlc30gZnJvbSAnbWljcm9tYXJrLXV0aWwtc3ltYm9sJ1xuXG5jb25zdCB0YXNrbGlzdENoZWNrID0ge25hbWU6ICd0YXNrbGlzdENoZWNrJywgdG9rZW5pemU6IHRva2VuaXplVGFza2xpc3RDaGVja31cblxuLyoqXG4gKiBDcmVhdGUgYW4gSFRNTCBleHRlbnNpb24gZm9yIGBtaWNyb21hcmtgIHRvIHN1cHBvcnQgR0ZNIHRhc2sgbGlzdCBpdGVtc1xuICogc3ludGF4LlxuICpcbiAqIEByZXR1cm5zIHtFeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdGhhdCBjYW4gYmUgcGFzc2VkIGluIGBodG1sRXh0ZW5zaW9uc2AgdG9cbiAqICAgc3VwcG9ydCBHRk0gdGFzayBsaXN0IGl0ZW1zIHdoZW4gc2VyaWFsaXppbmcgdG8gSFRNTC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbVRhc2tMaXN0SXRlbSgpIHtcbiAgcmV0dXJuIHtcbiAgICB0ZXh0OiB7W2NvZGVzLmxlZnRTcXVhcmVCcmFja2V0XTogdGFza2xpc3RDaGVja31cbiAgfVxufVxuXG4vKipcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAdHlwZSB7VG9rZW5pemVyfVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZVRhc2tsaXN0Q2hlY2soZWZmZWN0cywgb2ssIG5vaykge1xuICBjb25zdCBzZWxmID0gdGhpc1xuXG4gIHJldHVybiBvcGVuXG5cbiAgLyoqXG4gICAqIEF0IHN0YXJ0IG9mIHRhc2sgbGlzdCBpdGVtIGNoZWNrLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgKiBbeF0geS5cbiAgICogICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gb3Blbihjb2RlKSB7XG4gICAgYXNzZXJ0KGNvZGUgPT09IGNvZGVzLmxlZnRTcXVhcmVCcmFja2V0LCAnZXhwZWN0ZWQgYFtgJylcblxuICAgIGlmIChcbiAgICAgIC8vIEV4aXQgaWYgdGhlcmXigJlzIHN0dWZmIGJlZm9yZS5cbiAgICAgIHNlbGYucHJldmlvdXMgIT09IGNvZGVzLmVvZiB8fFxuICAgICAgLy8gRXhpdCBpZiBub3QgaW4gdGhlIGZpcnN0IGNvbnRlbnQgdGhhdCBpcyB0aGUgZmlyc3QgY2hpbGQgb2YgYSBsaXN0XG4gICAgICAvLyBpdGVtLlxuICAgICAgIXNlbGYuX2dmbVRhc2tsaXN0Rmlyc3RDb250ZW50T2ZMaXN0SXRlbVxuICAgICkge1xuICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ3Rhc2tMaXN0Q2hlY2snKVxuICAgIGVmZmVjdHMuZW50ZXIoJ3Rhc2tMaXN0Q2hlY2tNYXJrZXInKVxuICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgIGVmZmVjdHMuZXhpdCgndGFza0xpc3RDaGVja01hcmtlcicpXG4gICAgcmV0dXJuIGluc2lkZVxuICB9XG5cbiAgLyoqXG4gICAqIEluIHRhc2sgbGlzdCBpdGVtIGNoZWNrLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgKiBbeF0geS5cbiAgICogICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGluc2lkZShjb2RlKSB7XG4gICAgLy8gQ3VycmVudGx5IHdlIG1hdGNoIGhvdyBHSCB3b3JrcyBpbiBmaWxlcy5cbiAgICAvLyBUbyBtYXRjaCBob3cgR0ggd29ya3MgaW4gY29tbWVudHMsIHVzZSBgbWFya2Rvd25TcGFjZWAgKGBbXFx0IF1gKSBpbnN0ZWFkXG4gICAgLy8gb2YgYG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2VgIChgW1xcdFxcblxcciBdYCkuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZ09yU3BhY2UoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3Rhc2tMaXN0Q2hlY2tWYWx1ZVVuY2hlY2tlZCcpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFza0xpc3RDaGVja1ZhbHVlVW5jaGVja2VkJylcbiAgICAgIHJldHVybiBjbG9zZVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBjb2Rlcy51cHBlcmNhc2VYIHx8IGNvZGUgPT09IGNvZGVzLmxvd2VyY2FzZVgpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ3Rhc2tMaXN0Q2hlY2tWYWx1ZUNoZWNrZWQnKVxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3Rhc2tMaXN0Q2hlY2tWYWx1ZUNoZWNrZWQnKVxuICAgICAgcmV0dXJuIGNsb3NlXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEF0IGNsb3NlIG9mIHRhc2sgbGlzdCBpdGVtIGNoZWNrLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgKiBbeF0geS5cbiAgICogICAgICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBjbG9zZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLnJpZ2h0U3F1YXJlQnJhY2tldCkge1xuICAgICAgZWZmZWN0cy5lbnRlcigndGFza0xpc3RDaGVja01hcmtlcicpXG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIGVmZmVjdHMuZXhpdCgndGFza0xpc3RDaGVja01hcmtlcicpXG4gICAgICBlZmZlY3RzLmV4aXQoJ3Rhc2tMaXN0Q2hlY2snKVxuICAgICAgcmV0dXJuIGFmdGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGFmdGVyKGNvZGUpIHtcbiAgICAvLyBFT0wgaW4gcGFyYWdyYXBoIG1lYW5zIHRoZXJlIG11c3QgYmUgc29tZXRoaW5nIGVsc2UgYWZ0ZXIgaXQuXG4gICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgfVxuXG4gICAgLy8gU3BhY2Ugb3IgdGFiP1xuICAgIC8vIENoZWNrIHdoYXQgY29tZXMgYWZ0ZXIuXG4gICAgaWYgKG1hcmtkb3duU3BhY2UoY29kZSkpIHtcbiAgICAgIHJldHVybiBlZmZlY3RzLmNoZWNrKHt0b2tlbml6ZTogc3BhY2VUaGVuTm9uU3BhY2V9LCBvaywgbm9rKShjb2RlKVxuICAgIH1cblxuICAgIC8vIEVPRiwgb3Igbm9uLXdoaXRlc3BhY2UsIGJvdGggd3JvbmcuXG4gICAgcmV0dXJuIG5vayhjb2RlKVxuICB9XG59XG5cbi8qKlxuICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAqIEB0eXBlIHtUb2tlbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIHNwYWNlVGhlbk5vblNwYWNlKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgcmV0dXJuIGZhY3RvcnlTcGFjZShlZmZlY3RzLCBhZnRlciwgdHlwZXMud2hpdGVzcGFjZSlcblxuICAvKipcbiAgICogQWZ0ZXIgd2hpdGVzcGFjZSwgYWZ0ZXIgdGFzayBsaXN0IGl0ZW0gY2hlY2suXG4gICAqXG4gICAqIGBgYG1hcmtkb3duXG4gICAqID4gfCAqIFt4XSB5LlxuICAgKiAgICAgICAgICAgXlxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gYWZ0ZXIoY29kZSkge1xuICAgIC8vIEVPRiBtZWFucyB0aGVyZSB3YXMgbm90aGluZywgc28gYmFkLlxuICAgIC8vIEVPTCBtZWFucyB0aGVyZeKAmXMgY29udGVudCBhZnRlciBpdCwgc28gZ29vZC5cbiAgICAvLyBJbXBvc3NpYmxlIHRvIGhhdmUgbW9yZSBzcGFjZXMuXG4gICAgLy8gQW55dGhpbmcgZWxzZSBpcyBnb29kLlxuICAgIHJldHVybiBjb2RlID09PSBjb2Rlcy5lb2YgPyBub2soY29kZSkgOiBvayhjb2RlKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/micromark-extension-gfm-task-list-item/dev/lib/syntax.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/micromark-extension-gfm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/micromark-extension-gfm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfm: () => (/* binding */ gfm),\n/* harmony export */   gfmHtml: () => (/* binding */ gfmHtml)\n/* harmony export */ });\n/* harmony import */ var micromark_util_combine_extensions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-combine-extensions */ \"(app-pages-browser)/./node_modules/micromark-util-combine-extensions/index.js\");\n/* harmony import */ var micromark_extension_gfm_autolink_literal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-extension-gfm-autolink-literal */ \"(app-pages-browser)/./node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js\");\n/* harmony import */ var micromark_extension_gfm_autolink_literal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! micromark-extension-gfm-autolink-literal */ \"(app-pages-browser)/./node_modules/micromark-extension-gfm-autolink-literal/dev/lib/html.js\");\n/* harmony import */ var micromark_extension_gfm_footnote__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-extension-gfm-footnote */ \"(app-pages-browser)/./node_modules/micromark-extension-gfm-footnote/dev/lib/syntax.js\");\n/* harmony import */ var micromark_extension_gfm_footnote__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! micromark-extension-gfm-footnote */ \"(app-pages-browser)/./node_modules/micromark-extension-gfm-footnote/dev/lib/html.js\");\n/* harmony import */ var micromark_extension_gfm_strikethrough__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-extension-gfm-strikethrough */ \"(app-pages-browser)/./node_modules/micromark-extension-gfm-strikethrough/dev/lib/syntax.js\");\n/* harmony import */ var micromark_extension_gfm_strikethrough__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! micromark-extension-gfm-strikethrough */ \"(app-pages-browser)/./node_modules/micromark-extension-gfm-strikethrough/dev/lib/html.js\");\n/* harmony import */ var micromark_extension_gfm_table__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-extension-gfm-table */ \"(app-pages-browser)/./node_modules/micromark-extension-gfm-table/dev/lib/syntax.js\");\n/* harmony import */ var micromark_extension_gfm_table__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! micromark-extension-gfm-table */ \"(app-pages-browser)/./node_modules/micromark-extension-gfm-table/dev/lib/html.js\");\n/* harmony import */ var micromark_extension_gfm_tagfilter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! micromark-extension-gfm-tagfilter */ \"(app-pages-browser)/./node_modules/micromark-extension-gfm-tagfilter/lib/index.js\");\n/* harmony import */ var micromark_extension_gfm_task_list_item__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-extension-gfm-task-list-item */ \"(app-pages-browser)/./node_modules/micromark-extension-gfm-task-list-item/dev/lib/syntax.js\");\n/* harmony import */ var micromark_extension_gfm_task_list_item__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! micromark-extension-gfm-task-list-item */ \"(app-pages-browser)/./node_modules/micromark-extension-gfm-task-list-item/dev/lib/html.js\");\n/**\n * @typedef {import('micromark-extension-gfm-footnote').HtmlOptions} HtmlOptions\n * @typedef {import('micromark-extension-gfm-strikethrough').Options} Options\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n\n\n\n\n\n\n\n\n/**\n * Create an extension for `micromark` to enable GFM syntax.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n *\n *   Passed to `micromark-extens-gfm-strikethrough`.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions` to enable GFM\n *   syntax.\n */\nfunction gfm(options) {\n  return (0,micromark_util_combine_extensions__WEBPACK_IMPORTED_MODULE_0__.combineExtensions)([\n    (0,micromark_extension_gfm_autolink_literal__WEBPACK_IMPORTED_MODULE_1__.gfmAutolinkLiteral)(),\n    (0,micromark_extension_gfm_footnote__WEBPACK_IMPORTED_MODULE_2__.gfmFootnote)(),\n    (0,micromark_extension_gfm_strikethrough__WEBPACK_IMPORTED_MODULE_3__.gfmStrikethrough)(options),\n    (0,micromark_extension_gfm_table__WEBPACK_IMPORTED_MODULE_4__.gfmTable)(),\n    (0,micromark_extension_gfm_task_list_item__WEBPACK_IMPORTED_MODULE_5__.gfmTaskListItem)()\n  ])\n}\n\n/**\n * Create an extension for `micromark` to support GFM when serializing to HTML.\n *\n * @param {HtmlOptions | null | undefined} [options]\n *   Configuration (optional).\n *\n *   Passed to `micromark-extens-gfm-footnote`.\n * @returns {HtmlExtension}\n *   Extension for `micromark` that can be passed in `htmlExtensions` to\n *   support GFM when serializing to HTML.\n */\nfunction gfmHtml(options) {\n  return (0,micromark_util_combine_extensions__WEBPACK_IMPORTED_MODULE_0__.combineHtmlExtensions)([\n    (0,micromark_extension_gfm_autolink_literal__WEBPACK_IMPORTED_MODULE_6__.gfmAutolinkLiteralHtml)(),\n    (0,micromark_extension_gfm_footnote__WEBPACK_IMPORTED_MODULE_7__.gfmFootnoteHtml)(options),\n    (0,micromark_extension_gfm_strikethrough__WEBPACK_IMPORTED_MODULE_8__.gfmStrikethroughHtml)(),\n    (0,micromark_extension_gfm_table__WEBPACK_IMPORTED_MODULE_9__.gfmTableHtml)(),\n    (0,micromark_extension_gfm_tagfilter__WEBPACK_IMPORTED_MODULE_10__.gfmTagfilterHtml)(),\n    (0,micromark_extension_gfm_task_list_item__WEBPACK_IMPORTED_MODULE_11__.gfmTaskListItemHtml)()\n  ])\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLWdmbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsYUFBYSx3REFBd0Q7QUFDckUsYUFBYSx5REFBeUQ7QUFDdEUsYUFBYSwwQ0FBMEM7QUFDdkQsYUFBYSw4Q0FBOEM7QUFDM0Q7O0FBSzBDO0FBSU87QUFDNEI7QUFJL0I7QUFDc0I7QUFDRjtBQUluQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsU0FBUyxvRkFBaUI7QUFDMUIsSUFBSSw0RkFBa0I7QUFDdEIsSUFBSSw2RUFBVztBQUNmLElBQUksdUZBQWdCO0FBQ3BCLElBQUksdUVBQVE7QUFDWixJQUFJLHVGQUFlO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsU0FBUyx3RkFBcUI7QUFDOUIsSUFBSSxnR0FBc0I7QUFDMUIsSUFBSSxpRkFBZTtBQUNuQixJQUFJLDJGQUFvQjtBQUN4QixJQUFJLDJFQUFZO0FBQ2hCLElBQUksb0ZBQWdCO0FBQ3BCLElBQUksNEZBQW1CO0FBQ3ZCO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hcHp6by9jbGllbnQvZGVtby1hcHAvbm9kZV9tb2R1bGVzL21pY3JvbWFyay1leHRlbnNpb24tZ2ZtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tZm9vdG5vdGUnKS5IdG1sT3B0aW9uc30gSHRtbE9wdGlvbnNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLXN0cmlrZXRocm91Z2gnKS5PcHRpb25zfSBPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkV4dGVuc2lvbn0gRXh0ZW5zaW9uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtaWNyb21hcmstdXRpbC10eXBlcycpLkh0bWxFeHRlbnNpb259IEh0bWxFeHRlbnNpb25cbiAqL1xuXG5pbXBvcnQge1xuICBjb21iaW5lRXh0ZW5zaW9ucyxcbiAgY29tYmluZUh0bWxFeHRlbnNpb25zXG59IGZyb20gJ21pY3JvbWFyay11dGlsLWNvbWJpbmUtZXh0ZW5zaW9ucydcbmltcG9ydCB7XG4gIGdmbUF1dG9saW5rTGl0ZXJhbCxcbiAgZ2ZtQXV0b2xpbmtMaXRlcmFsSHRtbFxufSBmcm9tICdtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS1hdXRvbGluay1saXRlcmFsJ1xuaW1wb3J0IHtnZm1Gb290bm90ZSwgZ2ZtRm9vdG5vdGVIdG1sfSBmcm9tICdtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS1mb290bm90ZSdcbmltcG9ydCB7XG4gIGdmbVN0cmlrZXRocm91Z2gsXG4gIGdmbVN0cmlrZXRocm91Z2hIdG1sXG59IGZyb20gJ21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLXN0cmlrZXRocm91Z2gnXG5pbXBvcnQge2dmbVRhYmxlLCBnZm1UYWJsZUh0bWx9IGZyb20gJ21pY3JvbWFyay1leHRlbnNpb24tZ2ZtLXRhYmxlJ1xuaW1wb3J0IHtnZm1UYWdmaWx0ZXJIdG1sfSBmcm9tICdtaWNyb21hcmstZXh0ZW5zaW9uLWdmbS10YWdmaWx0ZXInXG5pbXBvcnQge1xuICBnZm1UYXNrTGlzdEl0ZW0sXG4gIGdmbVRhc2tMaXN0SXRlbUh0bWxcbn0gZnJvbSAnbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tdGFzay1saXN0LWl0ZW0nXG5cbi8qKlxuICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdG8gZW5hYmxlIEdGTSBzeW50YXguXG4gKlxuICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqXG4gKiAgIFBhc3NlZCB0byBgbWljcm9tYXJrLWV4dGVucy1nZm0tc3RyaWtldGhyb3VnaGAuXG4gKiBAcmV0dXJucyB7RXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtaWNyb21hcmtgIHRoYXQgY2FuIGJlIHBhc3NlZCBpbiBgZXh0ZW5zaW9uc2AgdG8gZW5hYmxlIEdGTVxuICogICBzeW50YXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZm0ob3B0aW9ucykge1xuICByZXR1cm4gY29tYmluZUV4dGVuc2lvbnMoW1xuICAgIGdmbUF1dG9saW5rTGl0ZXJhbCgpLFxuICAgIGdmbUZvb3Rub3RlKCksXG4gICAgZ2ZtU3RyaWtldGhyb3VnaChvcHRpb25zKSxcbiAgICBnZm1UYWJsZSgpLFxuICAgIGdmbVRhc2tMaXN0SXRlbSgpXG4gIF0pXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBmb3IgYG1pY3JvbWFya2AgdG8gc3VwcG9ydCBHRk0gd2hlbiBzZXJpYWxpemluZyB0byBIVE1MLlxuICpcbiAqIEBwYXJhbSB7SHRtbE9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAqICAgQ29uZmlndXJhdGlvbiAob3B0aW9uYWwpLlxuICpcbiAqICAgUGFzc2VkIHRvIGBtaWNyb21hcmstZXh0ZW5zLWdmbS1mb290bm90ZWAuXG4gKiBAcmV0dXJucyB7SHRtbEV4dGVuc2lvbn1cbiAqICAgRXh0ZW5zaW9uIGZvciBgbWljcm9tYXJrYCB0aGF0IGNhbiBiZSBwYXNzZWQgaW4gYGh0bWxFeHRlbnNpb25zYCB0b1xuICogICBzdXBwb3J0IEdGTSB3aGVuIHNlcmlhbGl6aW5nIHRvIEhUTUwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZm1IdG1sKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNvbWJpbmVIdG1sRXh0ZW5zaW9ucyhbXG4gICAgZ2ZtQXV0b2xpbmtMaXRlcmFsSHRtbCgpLFxuICAgIGdmbUZvb3Rub3RlSHRtbChvcHRpb25zKSxcbiAgICBnZm1TdHJpa2V0aHJvdWdoSHRtbCgpLFxuICAgIGdmbVRhYmxlSHRtbCgpLFxuICAgIGdmbVRhZ2ZpbHRlckh0bWwoKSxcbiAgICBnZm1UYXNrTGlzdEl0ZW1IdG1sKClcbiAgXSlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/micromark-extension-gfm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/micromark-extension-math/dev/lib/math-flow.js":
/*!********************************************************************!*\
  !*** ./node_modules/micromark-extension-math/dev/lib/math-flow.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mathFlow: () => (/* binding */ mathFlow)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devlop */ \"(app-pages-browser)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-factory-space */ \"(app-pages-browser)/./node_modules/micromark-factory-space/dev/index.js\");\n/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-character */ \"(app-pages-browser)/./node_modules/micromark-util-character/dev/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/types.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/constants.js\");\n/**\n * @import {Construct, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\n\n\n\n\n\n/** @type {Construct} */\nconst mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true,\n  name: 'mathFlow'\n}\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  const initialSize =\n    tail && tail[1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.linePrefix\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n\n  return start\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_2__.codes.dollarSign, 'expected `$`')\n    effects.enter('mathFlow')\n    effects.enter('mathFlowFence')\n    effects.enter('mathFlowFenceSequence')\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_2__.codes.dollarSign) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    if (sizeOpen < 2) {\n      return nok(code)\n    }\n\n    effects.exit('mathFlowFenceSequence')\n    return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__.factorySpace)(effects, metaBefore, micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.whitespace)(code)\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEnding)(code)) {\n      return metaAfter(code)\n    }\n\n    effects.enter('mathFlowFenceMeta')\n    effects.enter(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.chunkString, {contentType: micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.constants.contentTypeString})\n    return meta(code)\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEnding)(code)) {\n      effects.exit(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.chunkString)\n      effects.exit('mathFlowFenceMeta')\n      return metaAfter(code)\n    }\n\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_2__.codes.dollarSign) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return meta\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence')\n\n    if (self.interrupt) {\n      return ok(code)\n    }\n\n    return effects.attempt(\n      nonLazyContinuation,\n      beforeNonLazyContinuation,\n      after\n    )(code)\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt(\n      {tokenize: tokenizeClosingFence, partial: true},\n      after,\n      contentStart\n    )(code)\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (\n      initialSize\n        ? (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__.factorySpace)(\n            effects,\n            beforeContentChunk,\n            micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.linePrefix,\n            initialSize + 1\n          )\n        : beforeContentChunk\n    )(code)\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_2__.codes.eof) {\n      return after(code)\n    }\n\n    if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEnding)(code)) {\n      return effects.attempt(\n        nonLazyContinuation,\n        beforeNonLazyContinuation,\n        after\n      )(code)\n    }\n\n    effects.enter('mathFlowValue')\n    return contentChunk(code)\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEnding)(code)) {\n      effects.exit('mathFlowValue')\n      return beforeContentChunk(code)\n    }\n\n    effects.consume(code)\n    return contentChunk\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow')\n    return ok(code)\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(self.parser.constructs.disable.null, 'expected `disable.null`')\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__.factorySpace)(\n      effects,\n      beforeSequenceClose,\n      micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.linePrefix,\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.constants.tabSize\n    )\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence')\n      effects.enter('mathFlowFenceSequence')\n      return sequenceClose(code)\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_2__.codes.dollarSign) {\n        size++\n        effects.consume(code)\n        return sequenceClose\n      }\n\n      if (size < sizeOpen) {\n        return nok(code)\n      }\n\n      effects.exit('mathFlowFenceSequence')\n      return (0,micromark_factory_space__WEBPACK_IMPORTED_MODULE_3__.factorySpace)(effects, afterSequenceClose, micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.whitespace)(code)\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_2__.codes.eof || (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEnding)(code)) {\n        effects.exit('mathFlowFence')\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code)\n    }\n\n    (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_4__.markdownLineEnding)(code), 'expected eol')\n    effects.enter(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.lineEnding)\n    effects.consume(code)\n    effects.exit(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.types.lineEnding)\n    return lineStart\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLW1hdGgvZGV2L2xpYi9tYXRoLWZsb3cuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0EsWUFBWSw4Q0FBOEM7QUFDMUQ7O0FBRW1DO0FBQ2lCO0FBQ087QUFDRTs7QUFFN0QsV0FBVyxXQUFXO0FBQ2Y7QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0RBQUs7QUFDbEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLElBQUksMkNBQU0sVUFBVSx3REFBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGlCQUFpQix3REFBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHFFQUFZLHNCQUFzQix3REFBSztBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBLGlCQUFpQix3REFBSyxRQUFRLDRFQUFrQjtBQUNoRDtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHdEQUFLLGVBQWUsYUFBYSw0REFBUyxtQkFBbUI7QUFDL0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNB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YXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLW1hdGgvZGV2L2xpYi9tYXRoLWZsb3cuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtDb25zdHJ1Y3QsIFN0YXRlLCBUb2tlbml6ZUNvbnRleHQsIFRva2VuaXplcn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtdHlwZXMnXG4gKi9cblxuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ2RldmxvcCdcbmltcG9ydCB7ZmFjdG9yeVNwYWNlfSBmcm9tICdtaWNyb21hcmstZmFjdG9yeS1zcGFjZSdcbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5pbXBvcnQge2NvZGVzLCBjb25zdGFudHMsIHR5cGVzfSBmcm9tICdtaWNyb21hcmstdXRpbC1zeW1ib2wnXG5cbi8qKiBAdHlwZSB7Q29uc3RydWN0fSAqL1xuZXhwb3J0IGNvbnN0IG1hdGhGbG93ID0ge1xuICB0b2tlbml6ZTogdG9rZW5pemVNYXRoRmVuY2VkLFxuICBjb25jcmV0ZTogdHJ1ZSxcbiAgbmFtZTogJ21hdGhGbG93J1xufVxuXG4vKiogQHR5cGUge0NvbnN0cnVjdH0gKi9cbmNvbnN0IG5vbkxhenlDb250aW51YXRpb24gPSB7XG4gIHRva2VuaXplOiB0b2tlbml6ZU5vbkxhenlDb250aW51YXRpb24sXG4gIHBhcnRpYWw6IHRydWVcbn1cblxuLyoqXG4gKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0fVxuICogQHR5cGUge1Rva2VuaXplcn1cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemVNYXRoRmVuY2VkKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgY29uc3QgdGFpbCA9IHNlbGYuZXZlbnRzW3NlbGYuZXZlbnRzLmxlbmd0aCAtIDFdXG4gIGNvbnN0IGluaXRpYWxTaXplID1cbiAgICB0YWlsICYmIHRhaWxbMV0udHlwZSA9PT0gdHlwZXMubGluZVByZWZpeFxuICAgICAgPyB0YWlsWzJdLnNsaWNlU2VyaWFsaXplKHRhaWxbMV0sIHRydWUpLmxlbmd0aFxuICAgICAgOiAwXG4gIGxldCBzaXplT3BlbiA9IDBcblxuICByZXR1cm4gc3RhcnRcblxuICAvKipcbiAgICogU3RhcnQgb2YgbWF0aC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8ICQkXG4gICAqICAgICBeXG4gICAqICAgfCBcXGZyYWN7MX17Mn1cbiAgICogICB8ICQkXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgYXNzZXJ0KGNvZGUgPT09IGNvZGVzLmRvbGxhclNpZ24sICdleHBlY3RlZCBgJGAnKVxuICAgIGVmZmVjdHMuZW50ZXIoJ21hdGhGbG93JylcbiAgICBlZmZlY3RzLmVudGVyKCdtYXRoRmxvd0ZlbmNlJylcbiAgICBlZmZlY3RzLmVudGVyKCdtYXRoRmxvd0ZlbmNlU2VxdWVuY2UnKVxuICAgIHJldHVybiBzZXF1ZW5jZU9wZW4oY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBvcGVuaW5nIGZlbmNlIHNlcXVlbmNlLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgJCRcbiAgICogICAgICBeXG4gICAqICAgfCBcXGZyYWN7MX17Mn1cbiAgICogICB8ICQkXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBzZXF1ZW5jZU9wZW4oY29kZSkge1xuICAgIGlmIChjb2RlID09PSBjb2Rlcy5kb2xsYXJTaWduKSB7XG4gICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgIHNpemVPcGVuKytcbiAgICAgIHJldHVybiBzZXF1ZW5jZU9wZW5cbiAgICB9XG5cbiAgICBpZiAoc2l6ZU9wZW4gPCAyKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5leGl0KCdtYXRoRmxvd0ZlbmNlU2VxdWVuY2UnKVxuICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgbWV0YUJlZm9yZSwgdHlwZXMud2hpdGVzcGFjZSkoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBvcGVuaW5nIGZlbmNlLCBiZWZvcmUgbWV0YS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogPiB8ICQkYXNjaWltYXRoXG4gICAqICAgICAgIF5cbiAgICogICB8IHggPCB5XG4gICAqICAgfCAkJFxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cblxuICBmdW5jdGlvbiBtZXRhQmVmb3JlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gY29kZXMuZW9mIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgcmV0dXJuIG1ldGFBZnRlcihjb2RlKVxuICAgIH1cblxuICAgIGVmZmVjdHMuZW50ZXIoJ21hdGhGbG93RmVuY2VNZXRhJylcbiAgICBlZmZlY3RzLmVudGVyKHR5cGVzLmNodW5rU3RyaW5nLCB7Y29udGVudFR5cGU6IGNvbnN0YW50cy5jb250ZW50VHlwZVN0cmluZ30pXG4gICAgcmV0dXJuIG1ldGEoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBtZXRhLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgJCRhc2NpaW1hdGhcbiAgICogICAgICAgIF5cbiAgICogICB8IHggPCB5XG4gICAqICAgfCAkJFxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gbWV0YShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IGNvZGVzLmVvZiB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIGVmZmVjdHMuZXhpdCh0eXBlcy5jaHVua1N0cmluZylcbiAgICAgIGVmZmVjdHMuZXhpdCgnbWF0aEZsb3dGZW5jZU1ldGEnKVxuICAgICAgcmV0dXJuIG1ldGFBZnRlcihjb2RlKVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBjb2Rlcy5kb2xsYXJTaWduKSB7XG4gICAgICByZXR1cm4gbm9rKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgcmV0dXJuIG1ldGFcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBtZXRhLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiA+IHwgJCRcbiAgICogICAgICAgXlxuICAgKiAgIHwgXFxmcmFjezF9ezJ9XG4gICAqICAgfCAkJFxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gbWV0YUFmdGVyKGNvZGUpIHtcbiAgICAvLyBHdWFyYW50ZWVkIHRvIGJlIGVvbC9lb2YuXG4gICAgZWZmZWN0cy5leGl0KCdtYXRoRmxvd0ZlbmNlJylcblxuICAgIGlmIChzZWxmLmludGVycnVwdCkge1xuICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGVmZmVjdHMuYXR0ZW1wdChcbiAgICAgIG5vbkxhenlDb250aW51YXRpb24sXG4gICAgICBiZWZvcmVOb25MYXp5Q29udGludWF0aW9uLFxuICAgICAgYWZ0ZXJcbiAgICApKGNvZGUpXG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgZW9sL2VvZiBpbiBtYXRoLCBhdCBhIG5vbi1sYXp5IGNsb3NpbmcgZmVuY2Ugb3IgY29udGVudC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8ICQkXG4gICAqID4gfCBcXGZyYWN7MX17Mn1cbiAgICogICAgIF5cbiAgICogPiB8ICQkXG4gICAqICAgICBeXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBiZWZvcmVOb25MYXp5Q29udGludWF0aW9uKGNvZGUpIHtcbiAgICByZXR1cm4gZWZmZWN0cy5hdHRlbXB0KFxuICAgICAge3Rva2VuaXplOiB0b2tlbml6ZUNsb3NpbmdGZW5jZSwgcGFydGlhbDogdHJ1ZX0sXG4gICAgICBhZnRlcixcbiAgICAgIGNvbnRlbnRTdGFydFxuICAgICkoY29kZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWZvcmUgbWF0aCBjb250ZW50LCBkZWZpbml0ZWx5IG5vdCBiZWZvcmUgYSBjbG9zaW5nIGZlbmNlLlxuICAgKlxuICAgKiBgYGBtYXJrZG93blxuICAgKiAgIHwgJCRcbiAgICogPiB8IFxcZnJhY3sxfXsyfVxuICAgKiAgICAgXlxuICAgKiAgIHwgJCRcbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGNvbnRlbnRTdGFydChjb2RlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGluaXRpYWxTaXplXG4gICAgICAgID8gZmFjdG9yeVNwYWNlKFxuICAgICAgICAgICAgZWZmZWN0cyxcbiAgICAgICAgICAgIGJlZm9yZUNvbnRlbnRDaHVuayxcbiAgICAgICAgICAgIHR5cGVzLmxpbmVQcmVmaXgsXG4gICAgICAgICAgICBpbml0aWFsU2l6ZSArIDFcbiAgICAgICAgICApXG4gICAgICAgIDogYmVmb3JlQ29udGVudENodW5rXG4gICAgKShjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEJlZm9yZSBtYXRoIGNvbnRlbnQsIGFmdGVyIG9wdGlvbmFsIHByZWZpeC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8ICQkXG4gICAqID4gfCBcXGZyYWN7MX17Mn1cbiAgICogICAgIF5cbiAgICogICB8ICQkXG4gICAqIGBgYFxuICAgKlxuICAgKiBAdHlwZSB7U3RhdGV9XG4gICAqL1xuICBmdW5jdGlvbiBiZWZvcmVDb250ZW50Q2h1bmsoY29kZSkge1xuICAgIGlmIChjb2RlID09PSBjb2Rlcy5lb2YpIHtcbiAgICAgIHJldHVybiBhZnRlcihjb2RlKVxuICAgIH1cblxuICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgIHJldHVybiBlZmZlY3RzLmF0dGVtcHQoXG4gICAgICAgIG5vbkxhenlDb250aW51YXRpb24sXG4gICAgICAgIGJlZm9yZU5vbkxhenlDb250aW51YXRpb24sXG4gICAgICAgIGFmdGVyXG4gICAgICApKGNvZGUpXG4gICAgfVxuXG4gICAgZWZmZWN0cy5lbnRlcignbWF0aEZsb3dWYWx1ZScpXG4gICAgcmV0dXJuIGNvbnRlbnRDaHVuayhjb2RlKVxuICB9XG5cbiAgLyoqXG4gICAqIEluIG1hdGggY29udGVudC5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8ICQkXG4gICAqID4gfCBcXGZyYWN7MX17Mn1cbiAgICogICAgICBeXG4gICAqICAgfCAkJFxuICAgKiBgYGBcbiAgICpcbiAgICogQHR5cGUge1N0YXRlfVxuICAgKi9cbiAgZnVuY3Rpb24gY29udGVudENodW5rKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gY29kZXMuZW9mIHx8IG1hcmtkb3duTGluZUVuZGluZyhjb2RlKSkge1xuICAgICAgZWZmZWN0cy5leGl0KCdtYXRoRmxvd1ZhbHVlJylcbiAgICAgIHJldHVybiBiZWZvcmVDb250ZW50Q2h1bmsoY29kZSlcbiAgICB9XG5cbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICByZXR1cm4gY29udGVudENodW5rXG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgbWF0aCAoaGEhKS5cbiAgICpcbiAgICogYGBgbWFya2Rvd25cbiAgICogICB8ICQkXG4gICAqICAgfCBcXGZyYWN7MX17Mn1cbiAgICogPiB8ICQkXG4gICAqICAgICAgIF5cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtTdGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGFmdGVyKGNvZGUpIHtcbiAgICBlZmZlY3RzLmV4aXQoJ21hdGhGbG93JylcbiAgICByZXR1cm4gb2soY29kZSlcbiAgfVxuXG4gIC8qKiBAdHlwZSB7VG9rZW5pemVyfSAqL1xuICBmdW5jdGlvbiB0b2tlbml6ZUNsb3NpbmdGZW5jZShlZmZlY3RzLCBvaywgbm9rKSB7XG4gICAgbGV0IHNpemUgPSAwXG5cbiAgICBhc3NlcnQoc2VsZi5wYXJzZXIuY29uc3RydWN0cy5kaXNhYmxlLm51bGwsICdleHBlY3RlZCBgZGlzYWJsZS5udWxsYCcpXG4gICAgLyoqXG4gICAgICogQmVmb3JlIGNsb3NpbmcgZmVuY2UsIGF0IG9wdGlvbmFsIHdoaXRlc3BhY2UuXG4gICAgICpcbiAgICAgKiBgYGBtYXJrZG93blxuICAgICAqICAgfCAkJFxuICAgICAqICAgfCBcXGZyYWN7MX17Mn1cbiAgICAgKiA+IHwgJCRcbiAgICAgKiAgICAgXlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHJldHVybiBmYWN0b3J5U3BhY2UoXG4gICAgICBlZmZlY3RzLFxuICAgICAgYmVmb3JlU2VxdWVuY2VDbG9zZSxcbiAgICAgIHR5cGVzLmxpbmVQcmVmaXgsXG4gICAgICBzZWxmLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcygnY29kZUluZGVudGVkJylcbiAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgOiBjb25zdGFudHMudGFiU2l6ZVxuICAgIClcblxuICAgIC8qKlxuICAgICAqIEluIGNsb3NpbmcgZmVuY2UsIGFmdGVyIG9wdGlvbmFsIHdoaXRlc3BhY2UsIGF0IHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogYGBgbWFya2Rvd25cbiAgICAgKiAgIHwgJCRcbiAgICAgKiAgIHwgXFxmcmFjezF9ezJ9XG4gICAgICogPiB8ICQkXG4gICAgICogICAgIF5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdGF0ZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZWZvcmVTZXF1ZW5jZUNsb3NlKGNvZGUpIHtcbiAgICAgIGVmZmVjdHMuZW50ZXIoJ21hdGhGbG93RmVuY2UnKVxuICAgICAgZWZmZWN0cy5lbnRlcignbWF0aEZsb3dGZW5jZVNlcXVlbmNlJylcbiAgICAgIHJldHVybiBzZXF1ZW5jZUNsb3NlKGNvZGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW4gY2xvc2luZyBmZW5jZSBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIGBgYG1hcmtkb3duXG4gICAgICogICB8ICQkXG4gICAgICogICB8IFxcZnJhY3sxfXsyfVxuICAgICAqID4gfCAkJFxuICAgICAqICAgICAgXlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHR5cGUge1N0YXRlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlcXVlbmNlQ2xvc2UoY29kZSkge1xuICAgICAgaWYgKGNvZGUgPT09IGNvZGVzLmRvbGxhclNpZ24pIHtcbiAgICAgICAgc2l6ZSsrXG4gICAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlKVxuICAgICAgICByZXR1cm4gc2VxdWVuY2VDbG9zZVxuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZSA8IHNpemVPcGVuKSB7XG4gICAgICAgIHJldHVybiBub2soY29kZSlcbiAgICAgIH1cblxuICAgICAgZWZmZWN0cy5leGl0KCdtYXRoRmxvd0ZlbmNlU2VxdWVuY2UnKVxuICAgICAgcmV0dXJuIGZhY3RvcnlTcGFjZShlZmZlY3RzLCBhZnRlclNlcXVlbmNlQ2xvc2UsIHR5cGVzLndoaXRlc3BhY2UpKGNvZGUpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWZ0ZXIgY2xvc2luZyBmZW5jZSBzZXF1ZW5jZSwgYWZ0ZXIgb3B0aW9uYWwgd2hpdGVzcGFjZS5cbiAgICAgKlxuICAgICAqIGBgYG1hcmtkb3duXG4gICAgICogICB8ICQkXG4gICAgICogICB8IFxcZnJhY3sxfXsyfVxuICAgICAqID4gfCAkJFxuICAgICAqICAgICAgIF5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdGF0ZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlclNlcXVlbmNlQ2xvc2UoY29kZSkge1xuICAgICAgaWYgKGNvZGUgPT09IGNvZGVzLmVvZiB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgICAgZWZmZWN0cy5leGl0KCdtYXRoRmxvd0ZlbmNlJylcbiAgICAgICAgcmV0dXJuIG9rKGNvZGUpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2soY29kZSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAdGhpcyB7VG9rZW5pemVDb250ZXh0fVxuICogQHR5cGUge1Rva2VuaXplcn1cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemVOb25MYXp5Q29udGludWF0aW9uKGVmZmVjdHMsIG9rLCBub2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcblxuICByZXR1cm4gc3RhcnRcblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBmdW5jdGlvbiBzdGFydChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBvayhjb2RlKVxuICAgIH1cblxuICAgIGFzc2VydChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSksICdleHBlY3RlZCBlb2wnKVxuICAgIGVmZmVjdHMuZW50ZXIodHlwZXMubGluZUVuZGluZylcbiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICBlZmZlY3RzLmV4aXQodHlwZXMubGluZUVuZGluZylcbiAgICByZXR1cm4gbGluZVN0YXJ0XG4gIH1cblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBmdW5jdGlvbiBsaW5lU3RhcnQoY29kZSkge1xuICAgIHJldHVybiBzZWxmLnBhcnNlci5sYXp5W3NlbGYubm93KCkubGluZV0gPyBub2soY29kZSkgOiBvayhjb2RlKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/micromark-extension-math/dev/lib/math-flow.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/micromark-extension-math/dev/lib/math-text.js":
/*!********************************************************************!*\
  !*** ./node_modules/micromark-extension-math/dev/lib/math-text.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mathText: () => (/* binding */ mathText)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devlop */ \"(app-pages-browser)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var micromark_util_character__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! micromark-util-character */ \"(app-pages-browser)/./node_modules/micromark-util-character/dev/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/types.js\");\n/**\n * @import {Options} from 'micromark-extension-math'\n * @import {Construct, Previous, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\n */\n\n// To do: next major: clean spaces in HTML compiler.\n// This has to be coordinated together with `mdast-util-math`.\n\n\n\n\n\n/**\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Construct}\n *   Construct.\n */\nfunction mathText(options) {\n  const options_ = options || {}\n  let single = options_.singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous,\n    name: 'mathText'\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this\n    let sizeOpen = 0\n    /** @type {number} */\n    let size\n    /** @type {Token} */\n    let token\n\n    return start\n\n    /**\n     * Start of math (text).\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * > | \\$a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.dollarSign, 'expected `$`')\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(previous.call(self, self.previous), 'expected correct previous')\n      effects.enter('mathText')\n      effects.enter('mathTextSequence')\n      return sequenceOpen(code)\n    }\n\n    /**\n     * In opening sequence.\n     *\n     * ```markdown\n     * > | $a$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceOpen(code) {\n      if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.dollarSign) {\n        effects.consume(code)\n        sizeOpen++\n        return sequenceOpen\n      }\n\n      // Not enough markers in the sequence.\n      if (sizeOpen < 2 && !single) {\n        return nok(code)\n      }\n\n      effects.exit('mathTextSequence')\n      return between(code)\n    }\n\n    /**\n     * Between something and something else.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^^\n     * ```\n     *\n     * @type {State}\n     */\n    function between(code) {\n      if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.eof) {\n        return nok(code)\n      }\n\n      if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.dollarSign) {\n        token = effects.enter('mathTextSequence')\n        size = 0\n        return sequenceClose(code)\n      }\n\n      // Tabs dont work, and virtual spaces dont make sense.\n      if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.space) {\n        effects.enter('space')\n        effects.consume(code)\n        effects.exit('space')\n        return between\n      }\n\n      if ((0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownLineEnding)(code)) {\n        effects.enter(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding)\n        effects.consume(code)\n        effects.exit(micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding)\n        return between\n      }\n\n      // Data.\n      effects.enter('mathTextData')\n      return data(code)\n    }\n\n    /**\n     * In data.\n     *\n     * ```markdown\n     * > | $a$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function data(code) {\n      if (\n        code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.eof ||\n        code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.space ||\n        code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.dollarSign ||\n        (0,micromark_util_character__WEBPACK_IMPORTED_MODULE_2__.markdownLineEnding)(code)\n      ) {\n        effects.exit('mathTextData')\n        return between(code)\n      }\n\n      effects.consume(code)\n      return data\n    }\n\n    /**\n     * In closing sequence.\n     *\n     * ```markdown\n     * > | `a`\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n\n    function sequenceClose(code) {\n      // More.\n      if (code === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.dollarSign) {\n        effects.consume(code)\n        size++\n        return sequenceClose\n      }\n\n      // Done!\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence')\n        effects.exit('mathText')\n        return ok(code)\n      }\n\n      // More or less accents: mark as data.\n      token.type = 'mathTextData'\n      return data(code)\n    }\n  }\n}\n\n/** @type {Resolver} */\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4\n  let headEnterIndex = 3\n  /** @type {number} */\n  let index\n  /** @type {number | undefined} */\n  let enter\n\n  // If we start and end with an EOL or a space.\n  if (\n    (events[headEnterIndex][1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding'\n        events[headEnterIndex][1].type = 'mathTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1\n  tailExitIndex++\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (\n        index !== tailExitIndex &&\n        events[index][1].type !== micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding\n      ) {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding\n    ) {\n      events[enter][1].type = 'mathTextData'\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n\n      enter = undefined\n    }\n  }\n\n  return events\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== micromark_util_symbol__WEBPACK_IMPORTED_MODULE_1__.codes.dollarSign ||\n    this.events[this.events.length - 1][1].type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.characterEscape\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLW1hdGgvZGV2L2xpYi9tYXRoLXRleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLHlFQUF5RTtBQUNyRjs7QUFFQTtBQUNBOztBQUVtQztBQUN3QjtBQUNUOztBQUVsRDtBQUNBLFdBQVcsNEJBQTRCLFdBQVc7QUFDbEQsZ0NBQWdDO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxNQUFNLDJDQUFNLFVBQVUsd0RBQUs7QUFDM0IsTUFBTSwyQ0FBTTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQSxtQkFBbUIsd0RBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG1CQUFtQix3REFBSztBQUN4QjtBQUNBOztBQUVBLG1CQUFtQix3REFBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix3REFBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsNEVBQWtCO0FBQzVCLHNCQUFzQix3REFBSztBQUMzQjtBQUNBLHFCQUFxQix3REFBSztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFLO0FBQ3RCLGlCQUFpQix3REFBSztBQUN0QixpQkFBaUIsd0RBQUs7QUFDdEIsUUFBUSw0RUFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQix3REFBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLHdEQUFLO0FBQzdDO0FBQ0EsdUNBQXVDLHdEQUFLO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdEQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGdDQUFnQyx3REFBSztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdEQUFLO0FBQ2xCLG9EQUFvRCx3REFBSztBQUN6RDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLW1hdGgvZGV2L2xpYi9tYXRoLXRleHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtPcHRpb25zfSBmcm9tICdtaWNyb21hcmstZXh0ZW5zaW9uLW1hdGgnXG4gKiBAaW1wb3J0IHtDb25zdHJ1Y3QsIFByZXZpb3VzLCBSZXNvbHZlciwgU3RhdGUsIFRva2VuLCBUb2tlbml6ZUNvbnRleHQsIFRva2VuaXplcn0gZnJvbSAnbWljcm9tYXJrLXV0aWwtdHlwZXMnXG4gKi9cblxuLy8gVG8gZG86IG5leHQgbWFqb3I6IGNsZWFuIHNwYWNlcyBpbiBIVE1MIGNvbXBpbGVyLlxuLy8gVGhpcyBoYXMgdG8gYmUgY29vcmRpbmF0ZWQgdG9nZXRoZXIgd2l0aCBgbWRhc3QtdXRpbC1tYXRoYC5cblxuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ2RldmxvcCdcbmltcG9ydCB7bWFya2Rvd25MaW5lRW5kaW5nfSBmcm9tICdtaWNyb21hcmstdXRpbC1jaGFyYWN0ZXInXG5pbXBvcnQge2NvZGVzLCB0eXBlc30gZnJvbSAnbWljcm9tYXJrLXV0aWwtc3ltYm9sJ1xuXG4vKipcbiAqIEBwYXJhbSB7T3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zPXt9XVxuICogICBDb25maWd1cmF0aW9uIChkZWZhdWx0OiBge31gKS5cbiAqIEByZXR1cm5zIHtDb25zdHJ1Y3R9XG4gKiAgIENvbnN0cnVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGhUZXh0KG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9uc18gPSBvcHRpb25zIHx8IHt9XG4gIGxldCBzaW5nbGUgPSBvcHRpb25zXy5zaW5nbGVEb2xsYXJUZXh0TWF0aFxuXG4gIGlmIChzaW5nbGUgPT09IG51bGwgfHwgc2luZ2xlID09PSB1bmRlZmluZWQpIHtcbiAgICBzaW5nbGUgPSB0cnVlXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRva2VuaXplOiB0b2tlbml6ZU1hdGhUZXh0LFxuICAgIHJlc29sdmU6IHJlc29sdmVNYXRoVGV4dCxcbiAgICBwcmV2aW91cyxcbiAgICBuYW1lOiAnbWF0aFRleHQnXG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge1Rva2VuaXplQ29udGV4dH1cbiAgICogQHR5cGUge1Rva2VuaXplcn1cbiAgICovXG4gIGZ1bmN0aW9uIHRva2VuaXplTWF0aFRleHQoZWZmZWN0cywgb2ssIG5vaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgbGV0IHNpemVPcGVuID0gMFxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIGxldCBzaXplXG4gICAgLyoqIEB0eXBlIHtUb2tlbn0gKi9cbiAgICBsZXQgdG9rZW5cblxuICAgIHJldHVybiBzdGFydFxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgb2YgbWF0aCAodGV4dCkuXG4gICAgICpcbiAgICAgKiBgYGBtYXJrZG93blxuICAgICAqID4gfCAkYSRcbiAgICAgKiAgICAgXlxuICAgICAqID4gfCBcXCRhJFxuICAgICAqICAgICAgXlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHR5cGUge1N0YXRlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0KGNvZGUpIHtcbiAgICAgIGFzc2VydChjb2RlID09PSBjb2Rlcy5kb2xsYXJTaWduLCAnZXhwZWN0ZWQgYCRgJylcbiAgICAgIGFzc2VydChwcmV2aW91cy5jYWxsKHNlbGYsIHNlbGYucHJldmlvdXMpLCAnZXhwZWN0ZWQgY29ycmVjdCBwcmV2aW91cycpXG4gICAgICBlZmZlY3RzLmVudGVyKCdtYXRoVGV4dCcpXG4gICAgICBlZmZlY3RzLmVudGVyKCdtYXRoVGV4dFNlcXVlbmNlJylcbiAgICAgIHJldHVybiBzZXF1ZW5jZU9wZW4oY29kZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbiBvcGVuaW5nIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogYGBgbWFya2Rvd25cbiAgICAgKiA+IHwgJGEkXG4gICAgICogICAgIF5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdGF0ZX1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHNlcXVlbmNlT3Blbihjb2RlKSB7XG4gICAgICBpZiAoY29kZSA9PT0gY29kZXMuZG9sbGFyU2lnbikge1xuICAgICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgICAgc2l6ZU9wZW4rK1xuICAgICAgICByZXR1cm4gc2VxdWVuY2VPcGVuXG4gICAgICB9XG5cbiAgICAgIC8vIE5vdCBlbm91Z2ggbWFya2VycyBpbiB0aGUgc2VxdWVuY2UuXG4gICAgICBpZiAoc2l6ZU9wZW4gPCAyICYmICFzaW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIG5vayhjb2RlKVxuICAgICAgfVxuXG4gICAgICBlZmZlY3RzLmV4aXQoJ21hdGhUZXh0U2VxdWVuY2UnKVxuICAgICAgcmV0dXJuIGJldHdlZW4oY29kZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCZXR3ZWVuIHNvbWV0aGluZyBhbmQgc29tZXRoaW5nIGVsc2UuXG4gICAgICpcbiAgICAgKiBgYGBtYXJrZG93blxuICAgICAqID4gfCAkYSRcbiAgICAgKiAgICAgIF5eXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RhdGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYmV0d2Vlbihjb2RlKSB7XG4gICAgICBpZiAoY29kZSA9PT0gY29kZXMuZW9mKSB7XG4gICAgICAgIHJldHVybiBub2soY29kZSlcbiAgICAgIH1cblxuICAgICAgaWYgKGNvZGUgPT09IGNvZGVzLmRvbGxhclNpZ24pIHtcbiAgICAgICAgdG9rZW4gPSBlZmZlY3RzLmVudGVyKCdtYXRoVGV4dFNlcXVlbmNlJylcbiAgICAgICAgc2l6ZSA9IDBcbiAgICAgICAgcmV0dXJuIHNlcXVlbmNlQ2xvc2UoY29kZSlcbiAgICAgIH1cblxuICAgICAgLy8gVGFicyBkb27igJl0IHdvcmssIGFuZCB2aXJ0dWFsIHNwYWNlcyBkb27igJl0IG1ha2Ugc2Vuc2UuXG4gICAgICBpZiAoY29kZSA9PT0gY29kZXMuc3BhY2UpIHtcbiAgICAgICAgZWZmZWN0cy5lbnRlcignc3BhY2UnKVxuICAgICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgICAgZWZmZWN0cy5leGl0KCdzcGFjZScpXG4gICAgICAgIHJldHVybiBiZXR3ZWVuXG4gICAgICB9XG5cbiAgICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZSkpIHtcbiAgICAgICAgZWZmZWN0cy5lbnRlcih0eXBlcy5saW5lRW5kaW5nKVxuICAgICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgICAgZWZmZWN0cy5leGl0KHR5cGVzLmxpbmVFbmRpbmcpXG4gICAgICAgIHJldHVybiBiZXR3ZWVuXG4gICAgICB9XG5cbiAgICAgIC8vIERhdGEuXG4gICAgICBlZmZlY3RzLmVudGVyKCdtYXRoVGV4dERhdGEnKVxuICAgICAgcmV0dXJuIGRhdGEoY29kZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbiBkYXRhLlxuICAgICAqXG4gICAgICogYGBgbWFya2Rvd25cbiAgICAgKiA+IHwgJGEkXG4gICAgICogICAgICBeXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RhdGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGF0YShjb2RlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGNvZGUgPT09IGNvZGVzLmVvZiB8fFxuICAgICAgICBjb2RlID09PSBjb2Rlcy5zcGFjZSB8fFxuICAgICAgICBjb2RlID09PSBjb2Rlcy5kb2xsYXJTaWduIHx8XG4gICAgICAgIG1hcmtkb3duTGluZUVuZGluZyhjb2RlKVxuICAgICAgKSB7XG4gICAgICAgIGVmZmVjdHMuZXhpdCgnbWF0aFRleHREYXRhJylcbiAgICAgICAgcmV0dXJuIGJldHdlZW4oY29kZSlcbiAgICAgIH1cblxuICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUpXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluIGNsb3Npbmcgc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBgYGBtYXJrZG93blxuICAgICAqID4gfCBgYWBcbiAgICAgKiAgICAgICBeXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RhdGV9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBzZXF1ZW5jZUNsb3NlKGNvZGUpIHtcbiAgICAgIC8vIE1vcmUuXG4gICAgICBpZiAoY29kZSA9PT0gY29kZXMuZG9sbGFyU2lnbikge1xuICAgICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZSlcbiAgICAgICAgc2l6ZSsrXG4gICAgICAgIHJldHVybiBzZXF1ZW5jZUNsb3NlXG4gICAgICB9XG5cbiAgICAgIC8vIERvbmUhXG4gICAgICBpZiAoc2l6ZSA9PT0gc2l6ZU9wZW4pIHtcbiAgICAgICAgZWZmZWN0cy5leGl0KCdtYXRoVGV4dFNlcXVlbmNlJylcbiAgICAgICAgZWZmZWN0cy5leGl0KCdtYXRoVGV4dCcpXG4gICAgICAgIHJldHVybiBvayhjb2RlKVxuICAgICAgfVxuXG4gICAgICAvLyBNb3JlIG9yIGxlc3MgYWNjZW50czogbWFyayBhcyBkYXRhLlxuICAgICAgdG9rZW4udHlwZSA9ICdtYXRoVGV4dERhdGEnXG4gICAgICByZXR1cm4gZGF0YShjb2RlKVxuICAgIH1cbiAgfVxufVxuXG4vKiogQHR5cGUge1Jlc29sdmVyfSAqL1xuZnVuY3Rpb24gcmVzb2x2ZU1hdGhUZXh0KGV2ZW50cykge1xuICBsZXQgdGFpbEV4aXRJbmRleCA9IGV2ZW50cy5sZW5ndGggLSA0XG4gIGxldCBoZWFkRW50ZXJJbmRleCA9IDNcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIGxldCBpbmRleFxuICAvKiogQHR5cGUge251bWJlciB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IGVudGVyXG5cbiAgLy8gSWYgd2Ugc3RhcnQgYW5kIGVuZCB3aXRoIGFuIEVPTCBvciBhIHNwYWNlLlxuICBpZiAoXG4gICAgKGV2ZW50c1toZWFkRW50ZXJJbmRleF1bMV0udHlwZSA9PT0gdHlwZXMubGluZUVuZGluZyB8fFxuICAgICAgZXZlbnRzW2hlYWRFbnRlckluZGV4XVsxXS50eXBlID09PSAnc3BhY2UnKSAmJlxuICAgIChldmVudHNbdGFpbEV4aXRJbmRleF1bMV0udHlwZSA9PT0gdHlwZXMubGluZUVuZGluZyB8fFxuICAgICAgZXZlbnRzW3RhaWxFeGl0SW5kZXhdWzFdLnR5cGUgPT09ICdzcGFjZScpXG4gICkge1xuICAgIGluZGV4ID0gaGVhZEVudGVySW5kZXhcblxuICAgIC8vIEFuZCB3ZSBoYXZlIGRhdGEuXG4gICAgd2hpbGUgKCsraW5kZXggPCB0YWlsRXhpdEluZGV4KSB7XG4gICAgICBpZiAoZXZlbnRzW2luZGV4XVsxXS50eXBlID09PSAnbWF0aFRleHREYXRhJykge1xuICAgICAgICAvLyBUaGVuIHdlIGhhdmUgcGFkZGluZy5cbiAgICAgICAgZXZlbnRzW3RhaWxFeGl0SW5kZXhdWzFdLnR5cGUgPSAnbWF0aFRleHRQYWRkaW5nJ1xuICAgICAgICBldmVudHNbaGVhZEVudGVySW5kZXhdWzFdLnR5cGUgPSAnbWF0aFRleHRQYWRkaW5nJ1xuICAgICAgICBoZWFkRW50ZXJJbmRleCArPSAyXG4gICAgICAgIHRhaWxFeGl0SW5kZXggLT0gMlxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE1lcmdlIGFkamFjZW50IHNwYWNlcyBhbmQgZGF0YS5cbiAgaW5kZXggPSBoZWFkRW50ZXJJbmRleCAtIDFcbiAgdGFpbEV4aXRJbmRleCsrXG5cbiAgd2hpbGUgKCsraW5kZXggPD0gdGFpbEV4aXRJbmRleCkge1xuICAgIGlmIChlbnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGluZGV4ICE9PSB0YWlsRXhpdEluZGV4ICYmXG4gICAgICAgIGV2ZW50c1tpbmRleF1bMV0udHlwZSAhPT0gdHlwZXMubGluZUVuZGluZ1xuICAgICAgKSB7XG4gICAgICAgIGVudGVyID0gaW5kZXhcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaW5kZXggPT09IHRhaWxFeGl0SW5kZXggfHxcbiAgICAgIGV2ZW50c1tpbmRleF1bMV0udHlwZSA9PT0gdHlwZXMubGluZUVuZGluZ1xuICAgICkge1xuICAgICAgZXZlbnRzW2VudGVyXVsxXS50eXBlID0gJ21hdGhUZXh0RGF0YSdcblxuICAgICAgaWYgKGluZGV4ICE9PSBlbnRlciArIDIpIHtcbiAgICAgICAgZXZlbnRzW2VudGVyXVsxXS5lbmQgPSBldmVudHNbaW5kZXggLSAxXVsxXS5lbmRcbiAgICAgICAgZXZlbnRzLnNwbGljZShlbnRlciArIDIsIGluZGV4IC0gZW50ZXIgLSAyKVxuICAgICAgICB0YWlsRXhpdEluZGV4IC09IGluZGV4IC0gZW50ZXIgLSAyXG4gICAgICAgIGluZGV4ID0gZW50ZXIgKyAyXG4gICAgICB9XG5cbiAgICAgIGVudGVyID0gdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50c1xufVxuXG4vKipcbiAqIEB0aGlzIHtUb2tlbml6ZUNvbnRleHR9XG4gKiBAdHlwZSB7UHJldmlvdXN9XG4gKi9cbmZ1bmN0aW9uIHByZXZpb3VzKGNvZGUpIHtcbiAgLy8gSWYgdGhlcmUgaXMgYSBwcmV2aW91cyBjb2RlLCB0aGVyZSB3aWxsIGFsd2F5cyBiZSBhIHRhaWwuXG4gIHJldHVybiAoXG4gICAgY29kZSAhPT0gY29kZXMuZG9sbGFyU2lnbiB8fFxuICAgIHRoaXMuZXZlbnRzW3RoaXMuZXZlbnRzLmxlbmd0aCAtIDFdWzFdLnR5cGUgPT09IHR5cGVzLmNoYXJhY3RlckVzY2FwZVxuICApXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/micromark-extension-math/dev/lib/math-text.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/micromark-extension-math/dev/lib/syntax.js":
/*!*****************************************************************!*\
  !*** ./node_modules/micromark-extension-math/dev/lib/syntax.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   math: () => (/* binding */ math)\n/* harmony export */ });\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-util-symbol */ \"(app-pages-browser)/./node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var _math_flow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math-flow.js */ \"(app-pages-browser)/./node_modules/micromark-extension-math/dev/lib/math-flow.js\");\n/* harmony import */ var _math_text_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math-text.js */ \"(app-pages-browser)/./node_modules/micromark-extension-math/dev/lib/math-text.js\");\n/**\n * @import {Options} from 'micromark-extension-math'\n * @import {Extension} from 'micromark-util-types'\n */\n\n\n\n\n\n/**\n * Create an extension for `micromark` to enable math syntax.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable math syntax.\n */\nfunction math(options) {\n  return {\n    flow: {[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dollarSign]: _math_flow_js__WEBPACK_IMPORTED_MODULE_1__.mathFlow},\n    text: {[micromark_util_symbol__WEBPACK_IMPORTED_MODULE_0__.codes.dollarSign]: (0,_math_text_js__WEBPACK_IMPORTED_MODULE_2__.mathText)(options)}\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9taWNyb21hcmstZXh0ZW5zaW9uLW1hdGgvZGV2L2xpYi9zeW50YXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksV0FBVztBQUN2Qjs7QUFFMkM7QUFDSjtBQUNBOztBQUV2QztBQUNBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QixXQUFXO0FBQ2xELGdDQUFnQztBQUNoQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFdBQVcsQ0FBQyx3REFBSyxjQUFjLG1EQUFRLENBQUM7QUFDeEMsV0FBVyxDQUFDLHdEQUFLLGNBQWMsdURBQVE7QUFDdkM7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvbWljcm9tYXJrLWV4dGVuc2lvbi1tYXRoL2Rldi9saWIvc3ludGF4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGltcG9ydCB7T3B0aW9uc30gZnJvbSAnbWljcm9tYXJrLWV4dGVuc2lvbi1tYXRoJ1xuICogQGltcG9ydCB7RXh0ZW5zaW9ufSBmcm9tICdtaWNyb21hcmstdXRpbC10eXBlcydcbiAqL1xuXG5pbXBvcnQge2NvZGVzfSBmcm9tICdtaWNyb21hcmstdXRpbC1zeW1ib2wnXG5pbXBvcnQge21hdGhGbG93fSBmcm9tICcuL21hdGgtZmxvdy5qcydcbmltcG9ydCB7bWF0aFRleHR9IGZyb20gJy4vbWF0aC10ZXh0LmpzJ1xuXG4vKipcbiAqIENyZWF0ZSBhbiBleHRlbnNpb24gZm9yIGBtaWNyb21hcmtgIHRvIGVuYWJsZSBtYXRoIHN5bnRheC5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9ucz17fV1cbiAqICAgQ29uZmlndXJhdGlvbiAoZGVmYXVsdDogYHt9YCkuXG4gKiBAcmV0dXJucyB7RXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtaWNyb21hcmtgIHRoYXQgY2FuIGJlIHBhc3NlZCBpbiBgZXh0ZW5zaW9uc2AsIHRvXG4gKiAgIGVuYWJsZSBtYXRoIHN5bnRheC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGgob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGZsb3c6IHtbY29kZXMuZG9sbGFyU2lnbl06IG1hdGhGbG93fSxcbiAgICB0ZXh0OiB7W2NvZGVzLmRvbGxhclNpZ25dOiBtYXRoVGV4dChvcHRpb25zKX1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/micromark-extension-math/dev/lib/syntax.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rehype-katex/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/rehype-katex/lib/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rehypeKatex)\n/* harmony export */ });\n/* harmony import */ var hast_util_from_html_isomorphic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hast-util-from-html-isomorphic */ \"(app-pages-browser)/./node_modules/hast-util-from-html-isomorphic/lib/browser.js\");\n/* harmony import */ var hast_util_to_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-to-text */ \"(app-pages-browser)/./node_modules/hast-util-to-text/lib/index.js\");\n/* harmony import */ var katex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! katex */ \"(app-pages-browser)/./node_modules/katex/dist/katex.mjs\");\n/* harmony import */ var unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! unist-util-visit-parents */ \"(app-pages-browser)/./node_modules/unist-util-visit-parents/lib/index.js\");\n/**\n * @import {ElementContent, Root} from 'hast'\n * @import {KatexOptions} from 'katex'\n * @import {VFile} from 'vfile'\n */\n\n/**\n * @typedef {Omit<KatexOptions, 'displayMode' | 'throwOnError'>} Options\n */\n\n\n\n\n\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n/** @type {ReadonlyArray<unknown>} */\nconst emptyClasses = []\n\n/**\n * Render elements with a `language-math` (or `math-display`, `math-inline`)\n * class with KaTeX.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nfunction rehypeKatex(options) {\n  const settings = options || emptyOptions\n\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @param {VFile} file\n   *   File.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree, file) {\n    ;(0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_1__.visitParents)(tree, 'element', function (element, parents) {\n      const classes = Array.isArray(element.properties.className)\n        ? element.properties.className\n        : emptyClasses\n      // This class can be generated from markdown with ` ```math `.\n      const languageMath = classes.includes('language-math')\n      // This class is used by `remark-math` for flow math (block, `$$\\nmath\\n$$`).\n      const mathDisplay = classes.includes('math-display')\n      // This class is used by `remark-math` for text math (inline, `$math$`).\n      const mathInline = classes.includes('math-inline')\n      let displayMode = mathDisplay\n\n      // Any class is fine.\n      if (!languageMath && !mathDisplay && !mathInline) {\n        return\n      }\n\n      let parent = parents[parents.length - 1]\n      let scope = element\n\n      // If this was generated with ` ```math `, replace the `<pre>` and use\n      // display.\n      if (\n        element.tagName === 'code' &&\n        languageMath &&\n        parent &&\n        parent.type === 'element' &&\n        parent.tagName === 'pre'\n      ) {\n        scope = parent\n        parent = parents[parents.length - 2]\n        displayMode = true\n      }\n\n      /* c8 ignore next -- verbose to test. */\n      if (!parent) return\n\n      const value = (0,hast_util_to_text__WEBPACK_IMPORTED_MODULE_2__.toText)(scope, {whitespace: 'pre'})\n\n      /** @type {Array<ElementContent> | string | undefined} */\n      let result\n\n      try {\n        result = katex__WEBPACK_IMPORTED_MODULE_0__[\"default\"].renderToString(value, {\n          ...settings,\n          displayMode,\n          throwOnError: true\n        })\n      } catch (error) {\n        const cause = /** @type {Error} */ (error)\n        const ruleId = cause.name.toLowerCase()\n\n        file.message('Could not render math with KaTeX', {\n          ancestors: [...parents, element],\n          cause,\n          place: element.position,\n          ruleId,\n          source: 'rehype-katex'\n        })\n\n        // KaTeX *should* handle `ParseError` itself, but not others.\n        // it doesnt always:\n        // <https://github.com/remarkjs/react-markdown/issues/853>\n        try {\n          result = katex__WEBPACK_IMPORTED_MODULE_0__[\"default\"].renderToString(value, {\n            ...settings,\n            displayMode,\n            strict: 'ignore',\n            throwOnError: false\n          })\n        } catch {\n          // Generate similar markup if this is an other error.\n          // See: <https://github.com/KaTeX/KaTeX/blob/5dc7af0/docs/error.md>.\n          result = [\n            {\n              type: 'element',\n              tagName: 'span',\n              properties: {\n                className: ['katex-error'],\n                style: 'color:' + (settings.errorColor || '#cc0000'),\n                title: String(error)\n              },\n              children: [{type: 'text', value}]\n            }\n          ]\n        }\n      }\n\n      if (typeof result === 'string') {\n        const root = (0,hast_util_from_html_isomorphic__WEBPACK_IMPORTED_MODULE_3__.fromHtmlIsomorphic)(result, {fragment: true})\n        // Cast as we dont expect `doctypes` in KaTeX result.\n        result = /** @type {Array<ElementContent>} */ (root.children)\n      }\n\n      const index = parent.children.indexOf(scope)\n      parent.children.splice(index, 1, ...result)\n      return unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_1__.SKIP\n    })\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWh5cGUta2F0ZXgvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQyxZQUFZLGNBQWM7QUFDMUIsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0EsYUFBYSxvREFBb0Q7QUFDakU7O0FBRWlFO0FBQ3pCO0FBQ2Y7QUFDa0M7O0FBRTNELFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNDQUFzQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLElBQUksdUVBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQix5REFBTSxTQUFTLGtCQUFrQjs7QUFFckQsaUJBQWlCLDRDQUE0QztBQUM3RDs7QUFFQTtBQUNBLGlCQUFpQiw0REFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUixpQ0FBaUMsT0FBTztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDREQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixrRkFBa0IsVUFBVSxlQUFlO0FBQ2hFO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0EsYUFBYSwwREFBSTtBQUNqQixLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvcmVoeXBlLWthdGV4L2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge0VsZW1lbnRDb250ZW50LCBSb290fSBmcm9tICdoYXN0J1xuICogQGltcG9ydCB7S2F0ZXhPcHRpb25zfSBmcm9tICdrYXRleCdcbiAqIEBpbXBvcnQge1ZGaWxlfSBmcm9tICd2ZmlsZSdcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPbWl0PEthdGV4T3B0aW9ucywgJ2Rpc3BsYXlNb2RlJyB8ICd0aHJvd09uRXJyb3InPn0gT3B0aW9uc1xuICovXG5cbmltcG9ydCB7ZnJvbUh0bWxJc29tb3JwaGljfSBmcm9tICdoYXN0LXV0aWwtZnJvbS1odG1sLWlzb21vcnBoaWMnXG5pbXBvcnQge3RvVGV4dH0gZnJvbSAnaGFzdC11dGlsLXRvLXRleHQnXG5pbXBvcnQga2F0ZXggZnJvbSAna2F0ZXgnXG5pbXBvcnQge1NLSVAsIHZpc2l0UGFyZW50c30gZnJvbSAndW5pc3QtdXRpbC12aXNpdC1wYXJlbnRzJ1xuXG4vKiogQHR5cGUge1JlYWRvbmx5PE9wdGlvbnM+fSAqL1xuY29uc3QgZW1wdHlPcHRpb25zID0ge31cbi8qKiBAdHlwZSB7UmVhZG9ubHlBcnJheTx1bmtub3duPn0gKi9cbmNvbnN0IGVtcHR5Q2xhc3NlcyA9IFtdXG5cbi8qKlxuICogUmVuZGVyIGVsZW1lbnRzIHdpdGggYSBgbGFuZ3VhZ2UtbWF0aGAgKG9yIGBtYXRoLWRpc3BsYXlgLCBgbWF0aC1pbmxpbmVgKVxuICogY2xhc3Mgd2l0aCBLYVRlWC5cbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5PE9wdGlvbnM+IHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zXG4gKiAgIFRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVoeXBlS2F0ZXgob3B0aW9ucykge1xuICBjb25zdCBzZXR0aW5ncyA9IG9wdGlvbnMgfHwgZW1wdHlPcHRpb25zXG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybS5cbiAgICpcbiAgICogQHBhcmFtIHtSb290fSB0cmVlXG4gICAqICAgVHJlZS5cbiAgICogQHBhcmFtIHtWRmlsZX0gZmlsZVxuICAgKiAgIEZpbGUuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqICAgTm90aGluZy5cbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiAodHJlZSwgZmlsZSkge1xuICAgIHZpc2l0UGFyZW50cyh0cmVlLCAnZWxlbWVudCcsIGZ1bmN0aW9uIChlbGVtZW50LCBwYXJlbnRzKSB7XG4gICAgICBjb25zdCBjbGFzc2VzID0gQXJyYXkuaXNBcnJheShlbGVtZW50LnByb3BlcnRpZXMuY2xhc3NOYW1lKVxuICAgICAgICA/IGVsZW1lbnQucHJvcGVydGllcy5jbGFzc05hbWVcbiAgICAgICAgOiBlbXB0eUNsYXNzZXNcbiAgICAgIC8vIFRoaXMgY2xhc3MgY2FuIGJlIGdlbmVyYXRlZCBmcm9tIG1hcmtkb3duIHdpdGggYCBgYGBtYXRoIGAuXG4gICAgICBjb25zdCBsYW5ndWFnZU1hdGggPSBjbGFzc2VzLmluY2x1ZGVzKCdsYW5ndWFnZS1tYXRoJylcbiAgICAgIC8vIFRoaXMgY2xhc3MgaXMgdXNlZCBieSBgcmVtYXJrLW1hdGhgIGZvciBmbG93IG1hdGggKGJsb2NrLCBgJCRcXG5tYXRoXFxuJCRgKS5cbiAgICAgIGNvbnN0IG1hdGhEaXNwbGF5ID0gY2xhc3Nlcy5pbmNsdWRlcygnbWF0aC1kaXNwbGF5JylcbiAgICAgIC8vIFRoaXMgY2xhc3MgaXMgdXNlZCBieSBgcmVtYXJrLW1hdGhgIGZvciB0ZXh0IG1hdGggKGlubGluZSwgYCRtYXRoJGApLlxuICAgICAgY29uc3QgbWF0aElubGluZSA9IGNsYXNzZXMuaW5jbHVkZXMoJ21hdGgtaW5saW5lJylcbiAgICAgIGxldCBkaXNwbGF5TW9kZSA9IG1hdGhEaXNwbGF5XG5cbiAgICAgIC8vIEFueSBjbGFzcyBpcyBmaW5lLlxuICAgICAgaWYgKCFsYW5ndWFnZU1hdGggJiYgIW1hdGhEaXNwbGF5ICYmICFtYXRoSW5saW5lKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBsZXQgcGFyZW50ID0gcGFyZW50c1twYXJlbnRzLmxlbmd0aCAtIDFdXG4gICAgICBsZXQgc2NvcGUgPSBlbGVtZW50XG5cbiAgICAgIC8vIElmIHRoaXMgd2FzIGdlbmVyYXRlZCB3aXRoIGAgYGBgbWF0aCBgLCByZXBsYWNlIHRoZSBgPHByZT5gIGFuZCB1c2VcbiAgICAgIC8vIGRpc3BsYXkuXG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQudGFnTmFtZSA9PT0gJ2NvZGUnICYmXG4gICAgICAgIGxhbmd1YWdlTWF0aCAmJlxuICAgICAgICBwYXJlbnQgJiZcbiAgICAgICAgcGFyZW50LnR5cGUgPT09ICdlbGVtZW50JyAmJlxuICAgICAgICBwYXJlbnQudGFnTmFtZSA9PT0gJ3ByZSdcbiAgICAgICkge1xuICAgICAgICBzY29wZSA9IHBhcmVudFxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRzW3BhcmVudHMubGVuZ3RoIC0gMl1cbiAgICAgICAgZGlzcGxheU1vZGUgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IC0tIHZlcmJvc2UgdG8gdGVzdC4gKi9cbiAgICAgIGlmICghcGFyZW50KSByZXR1cm5cblxuICAgICAgY29uc3QgdmFsdWUgPSB0b1RleHQoc2NvcGUsIHt3aGl0ZXNwYWNlOiAncHJlJ30pXG5cbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8RWxlbWVudENvbnRlbnQ+IHwgc3RyaW5nIHwgdW5kZWZpbmVkfSAqL1xuICAgICAgbGV0IHJlc3VsdFxuXG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBrYXRleC5yZW5kZXJUb1N0cmluZyh2YWx1ZSwge1xuICAgICAgICAgIC4uLnNldHRpbmdzLFxuICAgICAgICAgIGRpc3BsYXlNb2RlLFxuICAgICAgICAgIHRocm93T25FcnJvcjogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgY2F1c2UgPSAvKiogQHR5cGUge0Vycm9yfSAqLyAoZXJyb3IpXG4gICAgICAgIGNvbnN0IHJ1bGVJZCA9IGNhdXNlLm5hbWUudG9Mb3dlckNhc2UoKVxuXG4gICAgICAgIGZpbGUubWVzc2FnZSgnQ291bGQgbm90IHJlbmRlciBtYXRoIHdpdGggS2FUZVgnLCB7XG4gICAgICAgICAgYW5jZXN0b3JzOiBbLi4ucGFyZW50cywgZWxlbWVudF0sXG4gICAgICAgICAgY2F1c2UsXG4gICAgICAgICAgcGxhY2U6IGVsZW1lbnQucG9zaXRpb24sXG4gICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgIHNvdXJjZTogJ3JlaHlwZS1rYXRleCdcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBLYVRlWCAqc2hvdWxkKiBoYW5kbGUgYFBhcnNlRXJyb3JgIGl0c2VsZiwgYnV0IG5vdCBvdGhlcnMuXG4gICAgICAgIC8vIGl0IGRvZXNu4oCZdCBhbHdheXM6XG4gICAgICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vcmVtYXJranMvcmVhY3QtbWFya2Rvd24vaXNzdWVzLzg1Mz5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBrYXRleC5yZW5kZXJUb1N0cmluZyh2YWx1ZSwge1xuICAgICAgICAgICAgLi4uc2V0dGluZ3MsXG4gICAgICAgICAgICBkaXNwbGF5TW9kZSxcbiAgICAgICAgICAgIHN0cmljdDogJ2lnbm9yZScsXG4gICAgICAgICAgICB0aHJvd09uRXJyb3I6IGZhbHNlXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgLy8gR2VuZXJhdGUgc2ltaWxhciBtYXJrdXAgaWYgdGhpcyBpcyBhbiBvdGhlciBlcnJvci5cbiAgICAgICAgICAvLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vS2FUZVgvS2FUZVgvYmxvYi81ZGM3YWYwL2RvY3MvZXJyb3IubWQ+LlxuICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2VsZW1lbnQnLFxuICAgICAgICAgICAgICB0YWdOYW1lOiAnc3BhbicsXG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFsna2F0ZXgtZXJyb3InXSxcbiAgICAgICAgICAgICAgICBzdHlsZTogJ2NvbG9yOicgKyAoc2V0dGluZ3MuZXJyb3JDb2xvciB8fCAnI2NjMDAwMCcpLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBTdHJpbmcoZXJyb3IpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbe3R5cGU6ICd0ZXh0JywgdmFsdWV9XVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IGZyb21IdG1sSXNvbW9ycGhpYyhyZXN1bHQsIHtmcmFnbWVudDogdHJ1ZX0pXG4gICAgICAgIC8vIENhc3QgYXMgd2UgZG9u4oCZdCBleHBlY3QgYGRvY3R5cGVzYCBpbiBLYVRlWCByZXN1bHQuXG4gICAgICAgIHJlc3VsdCA9IC8qKiBAdHlwZSB7QXJyYXk8RWxlbWVudENvbnRlbnQ+fSAqLyAocm9vdC5jaGlsZHJlbilcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihzY29wZSlcbiAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEsIC4uLnJlc3VsdClcbiAgICAgIHJldHVybiBTS0lQXG4gICAgfSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rehype-katex/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/remark-gfm/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/remark-gfm/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ remarkGfm)\n/* harmony export */ });\n/* harmony import */ var mdast_util_gfm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mdast-util-gfm */ \"(app-pages-browser)/./node_modules/mdast-util-gfm/lib/index.js\");\n/* harmony import */ var micromark_extension_gfm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-extension-gfm */ \"(app-pages-browser)/./node_modules/micromark-extension-gfm/index.js\");\n/**\n * @import {Root} from 'mdast'\n * @import {Options} from 'remark-gfm'\n * @import {} from 'remark-parse'\n * @import {} from 'remark-stringify'\n * @import {Processor} from 'unified'\n */\n\n\n\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Add support GFM (autolink literals, footnotes, strikethrough, tables,\n * tasklists).\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nfunction remarkGfm(options) {\n  // @ts-expect-error: TS is wrong about `this`.\n  // eslint-disable-next-line unicorn/no-this-assignment\n  const self = /** @type {Processor<Root>} */ (this)\n  const settings = options || emptyOptions\n  const data = self.data()\n\n  const micromarkExtensions =\n    data.micromarkExtensions || (data.micromarkExtensions = [])\n  const fromMarkdownExtensions =\n    data.fromMarkdownExtensions || (data.fromMarkdownExtensions = [])\n  const toMarkdownExtensions =\n    data.toMarkdownExtensions || (data.toMarkdownExtensions = [])\n\n  micromarkExtensions.push((0,micromark_extension_gfm__WEBPACK_IMPORTED_MODULE_0__.gfm)(settings))\n  fromMarkdownExtensions.push((0,mdast_util_gfm__WEBPACK_IMPORTED_MODULE_1__.gfmFromMarkdown)())\n  toMarkdownExtensions.push((0,mdast_util_gfm__WEBPACK_IMPORTED_MODULE_1__.gfmToMarkdown)(settings))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZW1hcmstZ2ZtL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBLFlBQVksTUFBTTtBQUNsQixZQUFZLFNBQVM7QUFDckIsY0FBYztBQUNkLGNBQWM7QUFDZCxZQUFZLFdBQVc7QUFDdkI7O0FBRTZEO0FBQ2xCOztBQUUzQyxXQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsNERBQUc7QUFDOUIsOEJBQThCLCtEQUFlO0FBQzdDLDRCQUE0Qiw2REFBYTtBQUN6QyIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvcmVtYXJrLWdmbS9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtSb290fSBmcm9tICdtZGFzdCdcbiAqIEBpbXBvcnQge09wdGlvbnN9IGZyb20gJ3JlbWFyay1nZm0nXG4gKiBAaW1wb3J0IHt9IGZyb20gJ3JlbWFyay1wYXJzZSdcbiAqIEBpbXBvcnQge30gZnJvbSAncmVtYXJrLXN0cmluZ2lmeSdcbiAqIEBpbXBvcnQge1Byb2Nlc3Nvcn0gZnJvbSAndW5pZmllZCdcbiAqL1xuXG5pbXBvcnQge2dmbUZyb21NYXJrZG93biwgZ2ZtVG9NYXJrZG93bn0gZnJvbSAnbWRhc3QtdXRpbC1nZm0nXG5pbXBvcnQge2dmbX0gZnJvbSAnbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0nXG5cbi8qKiBAdHlwZSB7T3B0aW9uc30gKi9cbmNvbnN0IGVtcHR5T3B0aW9ucyA9IHt9XG5cbi8qKlxuICogQWRkIHN1cHBvcnQgR0ZNIChhdXRvbGluayBsaXRlcmFscywgZm9vdG5vdGVzLCBzdHJpa2V0aHJvdWdoLCB0YWJsZXMsXG4gKiB0YXNrbGlzdHMpLlxuICpcbiAqIEBwYXJhbSB7T3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zXVxuICogICBDb25maWd1cmF0aW9uIChvcHRpb25hbCkuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZW1hcmtHZm0ob3B0aW9ucykge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBUUyBpcyB3cm9uZyBhYm91dCBgdGhpc2AuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLXRoaXMtYXNzaWdubWVudFxuICBjb25zdCBzZWxmID0gLyoqIEB0eXBlIHtQcm9jZXNzb3I8Um9vdD59ICovICh0aGlzKVxuICBjb25zdCBzZXR0aW5ncyA9IG9wdGlvbnMgfHwgZW1wdHlPcHRpb25zXG4gIGNvbnN0IGRhdGEgPSBzZWxmLmRhdGEoKVxuXG4gIGNvbnN0IG1pY3JvbWFya0V4dGVuc2lvbnMgPVxuICAgIGRhdGEubWljcm9tYXJrRXh0ZW5zaW9ucyB8fCAoZGF0YS5taWNyb21hcmtFeHRlbnNpb25zID0gW10pXG4gIGNvbnN0IGZyb21NYXJrZG93bkV4dGVuc2lvbnMgPVxuICAgIGRhdGEuZnJvbU1hcmtkb3duRXh0ZW5zaW9ucyB8fCAoZGF0YS5mcm9tTWFya2Rvd25FeHRlbnNpb25zID0gW10pXG4gIGNvbnN0IHRvTWFya2Rvd25FeHRlbnNpb25zID1cbiAgICBkYXRhLnRvTWFya2Rvd25FeHRlbnNpb25zIHx8IChkYXRhLnRvTWFya2Rvd25FeHRlbnNpb25zID0gW10pXG5cbiAgbWljcm9tYXJrRXh0ZW5zaW9ucy5wdXNoKGdmbShzZXR0aW5ncykpXG4gIGZyb21NYXJrZG93bkV4dGVuc2lvbnMucHVzaChnZm1Gcm9tTWFya2Rvd24oKSlcbiAgdG9NYXJrZG93bkV4dGVuc2lvbnMucHVzaChnZm1Ub01hcmtkb3duKHNldHRpbmdzKSlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/remark-gfm/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/remark-math/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/remark-math/lib/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ remarkMath)\n/* harmony export */ });\n/* harmony import */ var mdast_util_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mdast-util-math */ \"(app-pages-browser)/./node_modules/mdast-util-math/lib/index.js\");\n/* harmony import */ var micromark_extension_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! micromark-extension-math */ \"(app-pages-browser)/./node_modules/micromark-extension-math/dev/lib/syntax.js\");\n/// <reference types=\"mdast-util-math\" />\n/// <reference types=\"remark-parse\" />\n/// <reference types=\"remark-stringify\" />\n\n/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-math').ToOptions} Options\n * @typedef {import('unified').Processor<Root>} Processor\n */\n\n\n\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n\n/**\n * Add support for math.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nfunction remarkMath(options) {\n  // @ts-expect-error: TS is wrong about `this`.\n  // eslint-disable-next-line unicorn/no-this-assignment\n  const self = /** @type {Processor} */ (this)\n  const settings = options || emptyOptions\n  const data = self.data()\n\n  const micromarkExtensions =\n    data.micromarkExtensions || (data.micromarkExtensions = [])\n  const fromMarkdownExtensions =\n    data.fromMarkdownExtensions || (data.fromMarkdownExtensions = [])\n  const toMarkdownExtensions =\n    data.toMarkdownExtensions || (data.toMarkdownExtensions = [])\n\n  micromarkExtensions.push((0,micromark_extension_math__WEBPACK_IMPORTED_MODULE_0__.math)(settings))\n  fromMarkdownExtensions.push((0,mdast_util_math__WEBPACK_IMPORTED_MODULE_1__.mathFromMarkdown)())\n  toMarkdownExtensions.push((0,mdast_util_math__WEBPACK_IMPORTED_MODULE_1__.mathToMarkdown)(settings))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZW1hcmstbWF0aC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkMsYUFBYSxxQ0FBcUM7QUFDbEQsYUFBYSxtQ0FBbUM7QUFDaEQ7O0FBRWdFO0FBQ25COztBQUU3QyxXQUFXLG1CQUFtQjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNDQUFzQztBQUNqRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDhEQUFJO0FBQy9CLDhCQUE4QixpRUFBZ0I7QUFDOUMsNEJBQTRCLCtEQUFjO0FBQzFDIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy9yZW1hcmstbWF0aC9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJtZGFzdC11dGlsLW1hdGhcIiAvPlxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJyZW1hcmstcGFyc2VcIiAvPlxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJyZW1hcmstc3RyaW5naWZ5XCIgLz5cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlJvb3R9IFJvb3RcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtbWF0aCcpLlRvT3B0aW9uc30gT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgndW5pZmllZCcpLlByb2Nlc3NvcjxSb290Pn0gUHJvY2Vzc29yXG4gKi9cblxuaW1wb3J0IHttYXRoRnJvbU1hcmtkb3duLCBtYXRoVG9NYXJrZG93bn0gZnJvbSAnbWRhc3QtdXRpbC1tYXRoJ1xuaW1wb3J0IHttYXRofSBmcm9tICdtaWNyb21hcmstZXh0ZW5zaW9uLW1hdGgnXG5cbi8qKiBAdHlwZSB7UmVhZG9ubHk8T3B0aW9ucz59ICovXG5jb25zdCBlbXB0eU9wdGlvbnMgPSB7fVxuXG4vKipcbiAqIEFkZCBzdXBwb3J0IGZvciBtYXRoLlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHk8T3B0aW9ucz4gfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAqICAgQ29uZmlndXJhdGlvbiAob3B0aW9uYWwpLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVtYXJrTWF0aChvcHRpb25zKSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IFRTIGlzIHdyb25nIGFib3V0IGB0aGlzYC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tdGhpcy1hc3NpZ25tZW50XG4gIGNvbnN0IHNlbGYgPSAvKiogQHR5cGUge1Byb2Nlc3Nvcn0gKi8gKHRoaXMpXG4gIGNvbnN0IHNldHRpbmdzID0gb3B0aW9ucyB8fCBlbXB0eU9wdGlvbnNcbiAgY29uc3QgZGF0YSA9IHNlbGYuZGF0YSgpXG5cbiAgY29uc3QgbWljcm9tYXJrRXh0ZW5zaW9ucyA9XG4gICAgZGF0YS5taWNyb21hcmtFeHRlbnNpb25zIHx8IChkYXRhLm1pY3JvbWFya0V4dGVuc2lvbnMgPSBbXSlcbiAgY29uc3QgZnJvbU1hcmtkb3duRXh0ZW5zaW9ucyA9XG4gICAgZGF0YS5mcm9tTWFya2Rvd25FeHRlbnNpb25zIHx8IChkYXRhLmZyb21NYXJrZG93bkV4dGVuc2lvbnMgPSBbXSlcbiAgY29uc3QgdG9NYXJrZG93bkV4dGVuc2lvbnMgPVxuICAgIGRhdGEudG9NYXJrZG93bkV4dGVuc2lvbnMgfHwgKGRhdGEudG9NYXJrZG93bkV4dGVuc2lvbnMgPSBbXSlcblxuICBtaWNyb21hcmtFeHRlbnNpb25zLnB1c2gobWF0aChzZXR0aW5ncykpXG4gIGZyb21NYXJrZG93bkV4dGVuc2lvbnMucHVzaChtYXRoRnJvbU1hcmtkb3duKCkpXG4gIHRvTWFya2Rvd25FeHRlbnNpb25zLnB1c2gobWF0aFRvTWFya2Rvd24oc2V0dGluZ3MpKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/remark-math/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/unist-util-find-after/lib/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/unist-util-find-after/lib/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findAfter: () => (/* binding */ findAfter)\n/* harmony export */ });\n/* harmony import */ var unist_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-is */ \"(app-pages-browser)/./node_modules/unist-util-is/lib/index.js\");\n/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesnt work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {(\n *   Kind extends {children: Array<infer Child>}\n *   ? Child\n *   : never\n * )} Child\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Kind\n *   All node types.\n */\n\n\n\n/**\n * Find the first node in `parent` after another `node` or after an index,\n * that passes `test`.\n *\n * @param parent\n *   Parent node.\n * @param index\n *   Child node or index.\n * @param [test=undefined]\n *   Test for child to look for (optional).\n * @returns\n *   A child (matching `test`, if given) or `undefined`.\n */\nconst findAfter =\n  // Note: overloads like this are needed to support optional generics.\n  /**\n   * @type {(\n   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &\n   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)\n   * )}\n   */\n  (\n    /**\n     * @param {UnistParent} parent\n     * @param {UnistNode | number} index\n     * @param {Test} [test]\n     * @returns {UnistNode | undefined}\n     */\n    function (parent, index, test) {\n      const is = (0,unist_util_is__WEBPACK_IMPORTED_MODULE_0__.convert)(test)\n\n      if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node')\n      }\n\n      if (typeof index === 'number') {\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\n          throw new Error('Expected positive finite number as index')\n        }\n      } else {\n        index = parent.children.indexOf(index)\n\n        if (index < 0) {\n          throw new Error('Expected child node or index')\n        }\n      }\n\n      while (++index < parent.children.length) {\n        if (is(parent.children[index], index, parent)) {\n          return parent.children[index]\n        }\n      }\n\n      return undefined\n    }\n  )\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91bmlzdC11dGlsLWZpbmQtYWZ0ZXIvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLHdCQUF3QjtBQUNyQzs7QUFFQTtBQUNBLGFBQWEsOERBQThEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBLGFBQWE7QUFDYixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBOztBQUVxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsTUFBTTtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQixzREFBTzs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXB6em8vY2xpZW50L2RlbW8tYXBwL25vZGVfbW9kdWxlcy91bmlzdC11dGlsLWZpbmQtYWZ0ZXIvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5Ob2RlfSBVbmlzdE5vZGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3VuaXN0JykuUGFyZW50fSBVbmlzdFBhcmVudFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge0V4Y2x1ZGU8aW1wb3J0KCd1bmlzdC11dGlsLWlzJykuVGVzdCwgdW5kZWZpbmVkPiB8IHVuZGVmaW5lZH0gVGVzdFxuICogICBUZXN0IGZyb20gYHVuaXN0LXV0aWwtaXNgLlxuICpcbiAqICAgTm90ZTogd2UgaGF2ZSByZW1vdmUgYW5kIGFkZCBgdW5kZWZpbmVkYCwgYmVjYXVzZSBvdGhlcndpc2Ugd2hlbiBnZW5lcmF0aW5nXG4gKiAgIGF1dG9tYXRpYyBgLmQudHNgIGZpbGVzLCBUUyB0cmllcyB0byBmbGF0dGVuIHBhdGhzIGZyb20gYSBsb2NhbCBwZXJzcGVjdGl2ZSxcbiAqICAgd2hpY2ggZG9lc27igJl0IHdvcmsgd2hlbiBwdWJsaXNoaW5nIG9uIG5wbS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoXG4gKiAgIEZuIGV4dGVuZHMgKHZhbHVlOiBhbnkpID0+IHZhbHVlIGlzIGluZmVyIFRoaW5nXG4gKiAgID8gVGhpbmdcbiAqICAgOiBGYWxsYmFja1xuICogKX0gUHJlZGljYXRlXG4gKiAgIEdldCB0aGUgdmFsdWUgb2YgYSB0eXBlIGd1YXJkIGBGbmAuXG4gKiBAdGVtcGxhdGUgRm5cbiAqICAgVmFsdWU7IHR5cGljYWxseSBmdW5jdGlvbiB0aGF0IGlzIGEgdHlwZSBndWFyZCAoc3VjaCBhcyBgKHgpOiB4IGlzIFlgKS5cbiAqIEB0ZW1wbGF0ZSBGYWxsYmFja1xuICogICBWYWx1ZSB0byB5aWVsZCBpZiBgRm5gIGlzIG5vdCBhIHR5cGUgZ3VhcmQuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KFxuICogICBDaGVjayBleHRlbmRzIG51bGwgfCB1bmRlZmluZWQgLy8gTm8gdGVzdC5cbiAqICAgPyBWYWx1ZVxuICogICA6IFZhbHVlIGV4dGVuZHMge3R5cGU6IENoZWNrfSAvLyBTdHJpbmcgKHR5cGUpIHRlc3QuXG4gKiAgID8gVmFsdWVcbiAqICAgOiBWYWx1ZSBleHRlbmRzIENoZWNrIC8vIFBhcnRpYWwgdGVzdC5cbiAqICAgPyBWYWx1ZVxuICogICA6IENoZWNrIGV4dGVuZHMgRnVuY3Rpb24gLy8gRnVuY3Rpb24gdGVzdC5cbiAqICAgPyBQcmVkaWNhdGU8Q2hlY2ssIFZhbHVlPiBleHRlbmRzIFZhbHVlXG4gKiAgICAgPyBQcmVkaWNhdGU8Q2hlY2ssIFZhbHVlPlxuICogICAgIDogbmV2ZXJcbiAqICAgOiBuZXZlciAvLyBTb21lIG90aGVyIHRlc3Q/XG4gKiApfSBNYXRjaGVzT25lXG4gKiAgIENoZWNrIHdoZXRoZXIgYSBub2RlIG1hdGNoZXMgYSBwcmltaXRpdmUgY2hlY2sgaW4gdGhlIHR5cGUgc3lzdGVtLlxuICogQHRlbXBsYXRlIFZhbHVlXG4gKiAgIFZhbHVlOyB0eXBpY2FsbHkgdW5pc3QgYE5vZGVgLlxuICogQHRlbXBsYXRlIENoZWNrXG4gKiAgIFZhbHVlOyB0eXBpY2FsbHkgYHVuaXN0LXV0aWwtaXNgLWNvbXBhdGlibGUgdGVzdCwgYnV0IG5vdCBhcnJheXMuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KFxuICogICBDaGVjayBleHRlbmRzIEFycmF5PGFueT5cbiAqICAgPyBNYXRjaGVzT25lPFZhbHVlLCBDaGVja1trZXlvZiBDaGVja10+XG4gKiAgIDogTWF0Y2hlc09uZTxWYWx1ZSwgQ2hlY2s+XG4gKiApfSBNYXRjaGVzXG4gKiAgIENoZWNrIHdoZXRoZXIgYSBub2RlIG1hdGNoZXMgYSBjaGVjayBpbiB0aGUgdHlwZSBzeXN0ZW0uXG4gKiBAdGVtcGxhdGUgVmFsdWVcbiAqICAgVmFsdWU7IHR5cGljYWxseSB1bmlzdCBgTm9kZWAuXG4gKiBAdGVtcGxhdGUgQ2hlY2tcbiAqICAgVmFsdWU7IHR5cGljYWxseSBgdW5pc3QtdXRpbC1pc2AtY29tcGF0aWJsZSB0ZXN0LlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhcbiAqICAgS2luZCBleHRlbmRzIHtjaGlsZHJlbjogQXJyYXk8aW5mZXIgQ2hpbGQ+fVxuICogICA/IENoaWxkXG4gKiAgIDogbmV2ZXJcbiAqICl9IENoaWxkXG4gKiAgIENvbGxlY3Qgbm9kZXMgdGhhdCBjYW4gYmUgcGFyZW50cyBvZiBgQ2hpbGRgLlxuICogQHRlbXBsYXRlIHtVbmlzdE5vZGV9IEtpbmRcbiAqICAgQWxsIG5vZGUgdHlwZXMuXG4gKi9cblxuaW1wb3J0IHtjb252ZXJ0fSBmcm9tICd1bmlzdC11dGlsLWlzJ1xuXG4vKipcbiAqIEZpbmQgdGhlIGZpcnN0IG5vZGUgaW4gYHBhcmVudGAgYWZ0ZXIgYW5vdGhlciBgbm9kZWAgb3IgYWZ0ZXIgYW4gaW5kZXgsXG4gKiB0aGF0IHBhc3NlcyBgdGVzdGAuXG4gKlxuICogQHBhcmFtIHBhcmVudFxuICogICBQYXJlbnQgbm9kZS5cbiAqIEBwYXJhbSBpbmRleFxuICogICBDaGlsZCBub2RlIG9yIGluZGV4LlxuICogQHBhcmFtIFt0ZXN0PXVuZGVmaW5lZF1cbiAqICAgVGVzdCBmb3IgY2hpbGQgdG8gbG9vayBmb3IgKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zXG4gKiAgIEEgY2hpbGQgKG1hdGNoaW5nIGB0ZXN0YCwgaWYgZ2l2ZW4pIG9yIGB1bmRlZmluZWRgLlxuICovXG5leHBvcnQgY29uc3QgZmluZEFmdGVyID1cbiAgLy8gTm90ZTogb3ZlcmxvYWRzIGxpa2UgdGhpcyBhcmUgbmVlZGVkIHRvIHN1cHBvcnQgb3B0aW9uYWwgZ2VuZXJpY3MuXG4gIC8qKlxuICAgKiBAdHlwZSB7KFxuICAgKiAgICg8S2luZCBleHRlbmRzIFVuaXN0UGFyZW50LCBDaGVjayBleHRlbmRzIFRlc3Q+KHBhcmVudDogS2luZCwgaW5kZXg6IENoaWxkPEtpbmQ+IHwgbnVtYmVyLCB0ZXN0OiBDaGVjaykgPT4gTWF0Y2hlczxDaGlsZDxLaW5kPiwgQ2hlY2s+IHwgdW5kZWZpbmVkKSAmXG4gICAqICAgKDxLaW5kIGV4dGVuZHMgVW5pc3RQYXJlbnQ+KHBhcmVudDogS2luZCwgaW5kZXg6IENoaWxkPEtpbmQ+IHwgbnVtYmVyLCB0ZXN0PzogbnVsbCB8IHVuZGVmaW5lZCkgPT4gQ2hpbGQ8S2luZD4gfCB1bmRlZmluZWQpXG4gICAqICl9XG4gICAqL1xuICAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVbmlzdFBhcmVudH0gcGFyZW50XG4gICAgICogQHBhcmFtIHtVbmlzdE5vZGUgfCBudW1iZXJ9IGluZGV4XG4gICAgICogQHBhcmFtIHtUZXN0fSBbdGVzdF1cbiAgICAgKiBAcmV0dXJucyB7VW5pc3ROb2RlIHwgdW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIChwYXJlbnQsIGluZGV4LCB0ZXN0KSB7XG4gICAgICBjb25zdCBpcyA9IGNvbnZlcnQodGVzdClcblxuICAgICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC50eXBlIHx8ICFwYXJlbnQuY2hpbGRyZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwYXJlbnQgbm9kZScpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG9zaXRpdmUgZmluaXRlIG51bWJlciBhcyBpbmRleCcpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ID0gcGFyZW50LmNoaWxkcmVuLmluZGV4T2YoaW5kZXgpXG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgY2hpbGQgbm9kZSBvciBpbmRleCcpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGlmIChpcyhwYXJlbnQuY2hpbGRyZW5baW5kZXhdLCBpbmRleCwgcGFyZW50KSkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnQuY2hpbGRyZW5baW5kZXhdXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgKVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/unist-util-find-after/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/web-namespaces/index.js":
/*!**********************************************!*\
  !*** ./node_modules/web-namespaces/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   webNamespaces: () => (/* binding */ webNamespaces)\n/* harmony export */ });\n/**\n * Map of web namespaces.\n *\n * @type {Record<string, string>}\n */\nconst webNamespaces = {\n  html: 'http://www.w3.org/1999/xhtml',\n  mathml: 'http://www.w3.org/1998/Math/MathML',\n  svg: 'http://www.w3.org/2000/svg',\n  xlink: 'http://www.w3.org/1999/xlink',\n  xml: 'http://www.w3.org/XML/1998/namespace',\n  xmlns: 'http://www.w3.org/2000/xmlns/'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWItbmFtZXNwYWNlcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FwenpvL2NsaWVudC9kZW1vLWFwcC9ub2RlX21vZHVsZXMvd2ViLW5hbWVzcGFjZXMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNYXAgb2Ygd2ViIG5hbWVzcGFjZXMuXG4gKlxuICogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbmV4cG9ydCBjb25zdCB3ZWJOYW1lc3BhY2VzID0ge1xuICBodG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsXG4gIG1hdGhtbDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnLFxuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIHhsaW5rOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gIHhtbDogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsXG4gIHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/web-namespaces/index.js\n"));

/***/ })

});